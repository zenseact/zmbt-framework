{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#zenseact-mbt-framework","title":"Zenseact MBT Framework","text":"<p>C++ Model-based Testing Framework</p> <p>The framework conceptualizes a software test as a mathematical problem. It enables users to define test parameters and goals using a declarative modeling syntax, upon which automated verification procedures are applied.</p>"},{"location":"#quick-examples","title":"Quick examples","text":"<p>Simple tabular test: <pre><code>auto sum = [](double x, double y){ return x + y; };\n\nSignalMapping(\"Non-scalar input\")\n.OnTrigger(sum)\n    .At(sum) .Inject()\n    .At(sum) .Expect()\n.Test\n    ( { 2,   2},    4 )\n    ( { 2,  -2},    0 )\n    ( {42, 0.1}, 42.1 )\n;\n</code></pre></p> <p>Example of batch test with mock, generating function on input, and range matcher on output: <pre><code>struct Mock {\n    double produce() {\n        return InterfaceRecord(&amp;Mock::produce).Hook(); //(1)\n    }\n} mock {};\n\nauto sut = [&amp;mock]() { return mock.produce(); };\n\nSignalMapping(\"Mock input\")\n.OnTrigger(sut) .Repeat(250)\n    .At(&amp;Mock::produce) .Inject(Add(1)) //(2)\n    .At(sut)            .Expect(Slide(2) | Each(Lt)) //(3)\n;\n</code></pre></p> <ol> <li>Rerouting mock call to ZMBT environment</li> <li>Generating function <code>Add(1)</code> accept index call, producing <code>[1,2,3...]</code> for mock call series</li> <li>Sliding window matcher for increasing delta</li> </ol>"},{"location":"#model-based-testing","title":"Model-Based testing","text":"<p>Model-based testing (MBT) is an application of model-based design for software verification, potentially automating test generation and execution. This approach provides a high-level, abstract representation of the system under test, simplifying test interpretation and management.</p> <p>MBT is recognized as a high-level verification technique, typically applied during the design stage for model consistency checks or during a later development stages for system testing. The ZMBT framework implements this concept early in development, focusing primarily on unit and integration tests.</p> <p>The value of this approach in software verification includes:</p> <ul> <li>Quality: The framework enforces a model-driven approach to testing, ensuring early identification of design inconsistencies and improving overall code quality by aligning testing closely with the system\u2019s architecture from the outset.</li> <li>Traceability: Model-driven DSL connects the test script connect with specifications, enhancing the alignment between verification and design objectives.</li> <li>Readability: This is evident in the rapid creation and review of test cases, and the use of simple syntax makes the test code easily comprehensible, even for non-C++ engineers.</li> </ul> <p>Development Status</p> <p>The project is currently in active development, with core features functional in a prototype state. For the initial release, we aim to refine the implementation and address technical debt, including the development of the test runner application, enhanced logging and reporting capabilities, and comprehensive documentation and verification.</p> <p>In the long term, we plan to introduce Finite-State Automata test models that will operate on the same infrastructure as Signal Mapping models.</p> <p>The present documentation reflects the work in progress and is not yet intended for production use.</p>"},{"location":"dsl-reference/expressions/","title":"Expressions","text":""},{"location":"dsl-reference/expressions/#expression-language-reference","title":"Expression Language Reference","text":""},{"location":"dsl-reference/expressions/#constants","title":"Constants","text":""},{"location":"dsl-reference/expressions/#noop","title":"Noop","text":"<p>Signature: Const</p> <p>Aliases: _</p> <p>No operation</p> <p>Returns true without input validation. Used in place of matchers for uninteresting signals.</p>"},{"location":"dsl-reference/expressions/#null","title":"Null","text":"<p>Signature: Const</p> <p>Null value</p>"},{"location":"dsl-reference/expressions/#true","title":"True","text":"<p>Signature: Const</p> <p>Logical true</p>"},{"location":"dsl-reference/expressions/#false","title":"False","text":"<p>Signature: Const</p> <p>Logical false</p>"},{"location":"dsl-reference/expressions/#pi","title":"Pi","text":"<p>Signature: Const</p> <p>Pi constant</p>"},{"location":"dsl-reference/expressions/#e","title":"E","text":"<p>Signature: Const</p> <p>Euler's number</p>"},{"location":"dsl-reference/expressions/#inf","title":"Inf","text":"<p>Signature: Const</p> <p>Infinity</p>"},{"location":"dsl-reference/expressions/#eps","title":"Eps","text":"<p>Signature: Const</p> <p>Machine epsilon</p>"},{"location":"dsl-reference/expressions/#nan","title":"NaN","text":"<p>Signature: Const</p> <p>Not a number</p>"},{"location":"dsl-reference/expressions/#thread","title":"Thread","text":"<p>Signature: Const</p> <p>Thread id</p> <p>Not really a constant, but useful for branching the test input conditions.</p>"},{"location":"dsl-reference/expressions/#math-functions","title":"Math Functions","text":""},{"location":"dsl-reference/expressions/#sin","title":"Sin","text":"<p>Signature: Unary</p> <p>Sinus function</p>"},{"location":"dsl-reference/expressions/#cos","title":"Cos","text":"<p>Signature: Unary</p> <p>Cosinus function</p>"},{"location":"dsl-reference/expressions/#tan","title":"Tan","text":"<p>Signature: Unary</p> <p>Tangens function</p>"},{"location":"dsl-reference/expressions/#asin","title":"Asin","text":"<p>Signature: Unary</p> <p>Arcsin function</p>"},{"location":"dsl-reference/expressions/#acos","title":"Acos","text":"<p>Signature: Unary</p> <p>Arccos function</p>"},{"location":"dsl-reference/expressions/#atan","title":"Atan","text":"<p>Signature: Unary</p> <p>Arctan function</p>"},{"location":"dsl-reference/expressions/#sinh","title":"Sinh","text":"<p>Signature: Unary</p> <p>Hyperbolic sin</p>"},{"location":"dsl-reference/expressions/#cosh","title":"Cosh","text":"<p>Signature: Unary</p> <p>Hyperbolic cos</p>"},{"location":"dsl-reference/expressions/#tanh","title":"Tanh","text":"<p>Signature: Unary</p> <p>Hyperbolic tan</p>"},{"location":"dsl-reference/expressions/#asinh","title":"Asinh","text":"<p>Signature: Unary</p> <p>Hyperbolic arcsin</p>"},{"location":"dsl-reference/expressions/#acosh","title":"Acosh","text":"<p>Signature: Unary</p> <p>Hyperbolic arccos</p>"},{"location":"dsl-reference/expressions/#atanh","title":"Atanh","text":"<p>Signature: Unary</p> <p>Hyperbolic arctan</p>"},{"location":"dsl-reference/expressions/#exp","title":"Exp","text":"<p>Signature: Unary</p> <p>Exponential (e^x)</p>"},{"location":"dsl-reference/expressions/#erf","title":"Erf","text":"<p>Signature: Unary</p> <p>Error function</p>"},{"location":"dsl-reference/expressions/#erfc","title":"Erfc","text":"<p>Signature: Unary</p> <p>Error function complement</p>"},{"location":"dsl-reference/expressions/#gamma","title":"Gamma","text":"<p>Signature: Unary</p> <p>Gamma function</p>"},{"location":"dsl-reference/expressions/#abs","title":"Abs","text":"<p>Signature: Unary</p> <p>Absolute value</p>"},{"location":"dsl-reference/expressions/#ceil","title":"Ceil","text":"<p>Signature: Unary</p> <p>Ceil</p>"},{"location":"dsl-reference/expressions/#floor","title":"Floor","text":"<p>Signature: Unary</p> <p>Floor</p>"},{"location":"dsl-reference/expressions/#round","title":"Round","text":"<p>Signature: Unary</p> <p>Round to nearest integer</p> <p>Hint: To round to ndigits precision after the decimal point, use <code>Mul(ndigits) | Round | Div(ndigits)</code> combo.</p>"},{"location":"dsl-reference/expressions/#sqrt","title":"Sqrt","text":"<p>Signature: Unary</p> <p>Square root</p>"},{"location":"dsl-reference/expressions/#sign","title":"Sign","text":"<p>Signature: Unary</p> <p>Sign</p>"},{"location":"dsl-reference/expressions/#arithmetic-operators","title":"Arithmetic Operators","text":""},{"location":"dsl-reference/expressions/#neg","title":"Neg","text":"<p>Signature: Unary</p> <p>Negate</p> <p>Examples:</p> <ul> <li><code>42 | Neg</code>\\(\\mapsto\\)<code>-42</code></li> </ul>"},{"location":"dsl-reference/expressions/#add","title":"Add","text":"<p>Signature: Binary</p> <p>Addition</p> <p>Examples:</p> <ul> <li><code>[2, -1] | Add</code>\\(\\mapsto\\)<code>1</code></li> <li><code>2 | Add(-1)</code>\\(\\mapsto\\)<code>1</code></li> </ul>"},{"location":"dsl-reference/expressions/#sub","title":"Sub","text":"<p>Signature: Binary</p> <p>Subtraction</p> <p>Examples:</p> <ul> <li><code>[2, 1] | Sub</code>\\(\\mapsto\\)<code>-1</code></li> <li><code>2 | Sub(1)</code>\\(\\mapsto\\)<code>1</code></li> </ul>"},{"location":"dsl-reference/expressions/#mul","title":"Mul","text":"<p>Signature: Binary</p> <p>Multiplication</p> <p>Examples:</p> <ul> <li><code>[2, 3] | Mul</code>\\(\\mapsto\\)<code>6</code></li> <li><code>2 | Mul(3)</code>\\(\\mapsto\\)<code>6</code></li> </ul>"},{"location":"dsl-reference/expressions/#div","title":"Div","text":"<p>Signature: Binary</p> <p>Division</p> <ol> <li>\\([ ] \\mapsto [x, y] \\mapsto x / y\\)</li> <li>\\([y] \\mapsto [x]    \\mapsto x / y\\)</li> </ol> <p>Examples:</p> <ul> <li><code>[6, 3] | Div</code>\\(\\mapsto\\)<code>2</code></li> <li><code>6 | Div(3)</code>\\(\\mapsto\\)<code>2</code></li> </ul>"},{"location":"dsl-reference/expressions/#pow","title":"Pow","text":"<p>Signature: Binary</p> <p>To power</p> <p>X to power p   1. \\([ ] \\mapsto [x, p] \\mapsto x^p\\)   2. \\([p] \\mapsto [x]    \\mapsto x^p\\)</p> <p>Examples:</p> <ul> <li><code>[2, 3] | Pow</code>\\(\\mapsto\\)<code>8</code></li> <li><code>2 | Pow(3)</code>\\(\\mapsto\\)<code>8</code></li> </ul>"},{"location":"dsl-reference/expressions/#log","title":"Log","text":"<p>Signature: Binary</p> <p>Logarithm</p> <p>Logarithm with base b:   1. \\([ ] \\mapsto [x, b] \\mapsto log_b(x)\\)   2. \\([b] \\mapsto [x]    \\mapsto log_b(x)\\)</p> <p>Examples:</p> <ul> <li><code>[8, 2] | Log</code>\\(\\mapsto\\)<code>3</code></li> <li><code>8 | Log(2)</code>\\(\\mapsto\\)<code>3</code></li> </ul>"},{"location":"dsl-reference/expressions/#mod","title":"Mod","text":"<p>Signature: Binary</p> <p>Modulo</p> <p>Modulo of x:   1. \\([ ] \\mapsto [x, m] \\mapsto x % m\\)   2. \\([m] \\mapsto [x]    \\mapsto x % m\\)</p> <p>Examples:</p> <ul> <li><code>[7, 4] | Mod</code>\\(\\mapsto\\)<code>3</code></li> <li><code>7 | Mod(4)</code>\\(\\mapsto\\)<code>3</code></li> </ul>"},{"location":"dsl-reference/expressions/#quot","title":"Quot","text":"<p>Signature: Binary</p> <p>Quotient</p> <p>Quotient of x:   1. \\([ ] \\mapsto [x, d] \\mapsto x // d\\)   2. \\([d] \\mapsto [x]    \\mapsto x // d\\)</p> <p>Examples:</p> <ul> <li><code>[7, 4] | Quot</code>\\(\\mapsto\\)<code>1</code></li> <li><code>7 | Quot(4)</code>\\(\\mapsto\\)<code>1</code></li> </ul>"},{"location":"dsl-reference/expressions/#bitnot","title":"BitNot","text":"<p>Signature: Unary</p> <p>Bitwise not</p> <p>Examples:</p> <ul> <li><code>0b1010 | BitNot</code>\\(\\mapsto\\)<code>0b0101</code></li> </ul>"},{"location":"dsl-reference/expressions/#bitand","title":"BitAnd","text":"<p>Signature: Binary</p> <p>Bitwise and</p> <p>Examples:</p> <ul> <li><code>[0b1010, 0b1100] | BitAnd</code>\\(\\mapsto\\)<code>0b1000</code></li> </ul>"},{"location":"dsl-reference/expressions/#bitor","title":"BitOr","text":"<p>Signature: Binary</p> <p>Bitwise or</p> <p>Examples:</p> <ul> <li><code>[0b1010, 0b1100] | BitOr</code>\\(\\mapsto\\)<code>0b1110</code></li> </ul>"},{"location":"dsl-reference/expressions/#bitxor","title":"BitXor","text":"<p>Signature: Binary</p> <p>Bitwise xor</p> <p>Examples:</p> <ul> <li><code>[0b1010, 0b1100] | BitXor</code>\\(\\mapsto\\)<code>0b0110</code></li> </ul>"},{"location":"dsl-reference/expressions/#lshift","title":"Lshift","text":"<p>Signature: Binary</p> <p>Bitwise left shift</p> <ol> <li>\\([ ] \\mapsto [x, s] \\mapsto x \\texttt{ &lt;&lt; } s\\)</li> <li>\\([s] \\mapsto [x]    \\mapsto x \\texttt{ &lt;&lt; } s\\)</li> </ol> <p>Examples:</p> <ul> <li><code>[0b1010, 2] | Lshift</code>\\(\\mapsto\\)<code>0b101000</code></li> </ul>"},{"location":"dsl-reference/expressions/#rshift","title":"Rshift","text":"<p>Signature: Binary</p> <p>Bitwise right shift</p> <ol> <li>\\([ ] \u21a6 [x, s] \u21a6 x \\texttt{ &gt;&gt; } s\\)</li> <li>\\([s] \u21a6 [x]    \u21a6 x \\texttt{ &gt;&gt; } s\\)</li> </ol> <p>Examples:</p> <ul> <li><code>[0b1010, 2] | Rshift</code>\\(\\mapsto\\)<code>0b0010</code></li> </ul>"},{"location":"dsl-reference/expressions/#relation-operators","title":"Relation Operators","text":""},{"location":"dsl-reference/expressions/#eq","title":"Eq","text":"<p>Signature: Binary</p> <p>Is equal</p> <p>Examples:</p> <ul> <li><code>[1, 1] | Eq</code>\\(\\mapsto\\)<code>true</code></li> <li><code>41 | Eq(42)</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#ne","title":"Ne","text":"<p>Signature: Binary</p> <p>Not equal</p> <p>Examples:</p> <ul> <li><code>[1, 2] | Ne</code>\\(\\mapsto\\)<code>true</code></li> <li><code>42 | Ne(42)</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#lt","title":"Lt","text":"<p>Signature: Binary</p> <p>Lesser than</p> <p>Examples:</p> <ul> <li><code>[1, 2] | Lt</code>\\(\\mapsto\\)<code>true</code></li> <li><code>41 | Lt(42)</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#le","title":"Le","text":"<p>Signature: Binary</p> <p>Lesser or equal</p> <p>Examples:</p> <ul> <li><code>[1, 2] | Le</code>\\(\\mapsto\\)<code>true</code></li> <li><code>42 | Le(42)</code>\\(\\mapsto\\)<code>true</code></li> </ul>"},{"location":"dsl-reference/expressions/#gt","title":"Gt","text":"<p>Signature: Binary</p> <p>Greater than</p> <p>Examples:</p> <ul> <li><code>[2, 1] | Gt</code>\\(\\mapsto\\)<code>true</code></li> <li><code>43 | Gt(42)</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#ge","title":"Ge","text":"<p>Signature: Binary</p> <p>Greater or equal</p> <p>Examples:</p> <ul> <li><code>[2, 1] | Ge</code>\\(\\mapsto\\)<code>true</code></li> <li><code>42 | Ge(42)</code>\\(\\mapsto\\)<code>true</code></li> </ul>"},{"location":"dsl-reference/expressions/#near","title":"Near","text":"<p>Signature: Binary</p> <p>Aliases: Approx</p> <p>Floating point approximately equal</p> <p>Based on numpy.isclose:   abs(x - ref) &lt;= (atol + rtol * abs(ref))</p> <p>Rhs parameters:   ref: reference value   rtol: relative tolerance, default = 1e-05   atol: absolute tolerance, default = 1e-08</p> <p>Rhs dynamic evaluation:   1. ref                -&gt; [ref, default, default]   2. [ref]              -&gt; [ref, default, default]   3. [ref, rtol]        -&gt; [ref, rtol   , default]   4. [ref, rtol, atol]  -&gt; [ref, rtol   , atol   ]</p> <p>Examples:</p> <ul> <li><code>[42, 42] | Approx</code>\\(\\mapsto\\)<code>true</code></li> <li><code>42 | Approx(42.0 + 1e-09)</code>\\(\\mapsto\\)<code>true</code></li> <li><code>42 | Approx(42.001)</code>\\(\\mapsto\\)<code>false</code></li> </ul> <p>Relative tolerance 1e-03  * <code>pi | Approx([3.14, 0.001])</code>\\(\\mapsto\\)<code>true</code> Absolute tolerance 0.01  * <code>pi | Approx([3.14, 0, 0.01])</code>\\(\\mapsto\\)<code>true</code></p>"},{"location":"dsl-reference/expressions/#set-operators","title":"Set Operators","text":""},{"location":"dsl-reference/expressions/#union","title":"Union","text":"<p>Signature: Binary</p> <p>Set union</p> <p>Examples:</p> <ul> <li><code>[[1, 2], [2, 3]] | Union</code>\\(\\mapsto\\)<code>[1, 2, 3]</code></li> <li><code>[1, 2] | Union([2, 3])</code>\\(\\mapsto\\)<code>[1, 2, 3]</code></li> </ul>"},{"location":"dsl-reference/expressions/#intersect","title":"Intersect","text":"<p>Signature: Binary</p> <p>Set intersection</p> <p>Examples:</p> <ul> <li><code>[[1, 2], [2, 3]] | Intersect</code>\\(\\mapsto\\)<code>[2]</code></li> <li><code>[1, 2] | Intersect([2, 3])</code>\\(\\mapsto\\)<code>[2]</code></li> </ul>"},{"location":"dsl-reference/expressions/#diff","title":"Diff","text":"<p>Signature: Binary</p> <p>Set difference</p> <p>Examples:</p> <ul> <li><code>[[1, 2], [2, 3]] | Diff</code>\\(\\mapsto\\)<code>[1]</code></li> <li><code>[1, 2] | Diff([2, 3])</code>\\(\\mapsto\\)<code>[1]</code></li> </ul>"},{"location":"dsl-reference/expressions/#set-relation-operators","title":"Set Relation Operators","text":""},{"location":"dsl-reference/expressions/#seteq","title":"SetEq","text":"<p>Signature: Binary</p> <p>Equal as set</p> <p>Examples:</p> <ul> <li><code>[[1, 2], [2, 1]] | SetEq</code>\\(\\mapsto\\)<code>true</code></li> <li><code>[1, 2] | SetEq([2, 1])</code>\\(\\mapsto\\)<code>true</code></li> </ul>"},{"location":"dsl-reference/expressions/#subset","title":"Subset","text":"<p>Signature: Binary</p> <p>Is subset</p> <p>Examples:</p> <ul> <li><code>[[1, 2], [1, 2, 3]] | Subset</code>\\(\\mapsto\\)<code>true</code></li> <li> <p><code>[1, 2] | Subset([1, 2, 3])</code>\\(\\mapsto\\)<code>true</code></p> </li> <li> <p><code>[[1, 2, 3], [2, 3]] | Subset</code>\\(\\mapsto\\)<code>false</code></p> </li> <li> <p><code>[1, 2, 3] | Subset([2, 3])</code>\\(\\mapsto\\)<code>false</code></p> </li> <li> <p><code>[[1, 2], []] | Subset</code>\\(\\mapsto\\)<code>true</code></p> </li> <li><code>[[], []] | Subset</code>\\(\\mapsto\\)<code>true</code></li> </ul>"},{"location":"dsl-reference/expressions/#superset","title":"Superset","text":"<p>Signature: Binary</p> <p>Is superset</p> <p>Examples:</p> <ul> <li><code>[[1, 2, 3], [1, 2]] | Superset</code>\\(\\mapsto\\)<code>true</code></li> <li> <p><code>[1, 2, 3] | Superset([1, 2])</code>\\(\\mapsto\\)<code>true</code></p> </li> <li> <p><code>[[2, 3], [1, 2, 3]] | Superset</code>\\(\\mapsto\\)<code>false</code></p> </li> <li> <p><code>[2, 3] | Superset([1, 2, 3])</code>\\(\\mapsto\\)<code>false</code></p> </li> <li> <p><code>[[], [1, 2]] | Superset</code>\\(\\mapsto\\)<code>true</code></p> </li> <li><code>[[], []] | Superset</code>\\(\\mapsto\\)<code>true</code></li> </ul>"},{"location":"dsl-reference/expressions/#psubset","title":"PSubset","text":"<p>Signature: Binary</p> <p>Is proper subset</p> <p>Examples:</p> <ul> <li><code>[[1, 2], [1, 2, 3]] | PSubset</code>\\(\\mapsto\\)<code>true</code></li> <li> <p><code>[1, 2] | PSubset([1, 2, 3])</code>\\(\\mapsto\\)<code>true</code></p> </li> <li> <p><code>[[1, 2, 3], [2, 3]] | PSubset</code>\\(\\mapsto\\)<code>false</code></p> </li> <li> <p><code>[1, 2, 3] | PSubset([2, 3])</code>\\(\\mapsto\\)<code>false</code></p> </li> <li> <p><code>[[1, 2], []] | PSubset</code>\\(\\mapsto\\)<code>true</code></p> </li> <li><code>[[], []] | PSubset</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#psuperset","title":"PSuperset","text":"<p>Signature: Binary</p> <p>Is proper superset</p> <p>Examples:</p> <ul> <li><code>[[1, 2, 3], [1, 2]] | PSuperset</code>\\(\\mapsto\\)<code>true</code></li> <li> <p><code>[1, 2, 3] | PSuperset([1, 2])</code>\\(\\mapsto\\)<code>true</code></p> </li> <li> <p><code>[[2, 3], [1, 2, 3]] | PSuperset</code>\\(\\mapsto\\)<code>false</code></p> </li> <li> <p><code>[2, 3] | PSuperset([1, 2, 3])</code>\\(\\mapsto\\)<code>false</code></p> </li> <li> <p><code>[[], [1, 2]] | PSuperset</code>\\(\\mapsto\\)<code>true</code></p> </li> <li><code>[[], []] | PSuperset</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#in","title":"In","text":"<p>Signature: Binary</p> <p>Element is in</p> <p>Examples:</p> <ul> <li><code>[1, [1, 2]] | In</code>\\(\\mapsto\\)<code>true</code></li> <li><code>3 | In([1, 2])</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#notin","title":"NotIn","text":"<p>Signature: Binary</p> <p>Element is not in</p> <p>Examples:</p> <ul> <li><code>[3, [1, 2]] | NotIn</code>\\(\\mapsto\\)<code>true</code></li> <li><code>1 | NotIn([1, 2])</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#ni","title":"Ni","text":"<p>Signature: Binary</p> <p>Aliases: Contains</p> <p>Contains element</p> <p>Examples:</p> <ul> <li><code>[[1, 2], 1] | Ni</code>\\(\\mapsto\\)<code>true</code></li> <li><code>3 | Ni([1, 2])</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#notni","title":"NotNi","text":"<p>Signature: Binary</p> <p>Not contains element</p> <p>Examples:</p> <ul> <li><code>[[1, 2], 3] | NotNi</code>\\(\\mapsto\\)<code>true</code></li> <li><code>1 | NotNi([1, 2])</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#branching-operators","title":"Branching Operators","text":""},{"location":"dsl-reference/expressions/#bool","title":"Bool","text":"<p>Signature: Unary</p> <p>Aliases: Truthy</p> <p>Predicate on boolean transform (aka truthy)</p> <p>Examples:</p> <ul> <li><code>42 | Bool</code>\\(\\mapsto\\)<code>true</code></li> <li><code>0 | Bool</code>\\(\\mapsto\\)<code>false</code></li> <li><code>\"false\" | Bool</code>\\(\\mapsto\\)<code>true</code></li> <li><code>\"\" | Bool</code>\\(\\mapsto\\)<code>false</code></li> <li><code>[1] | Bool</code>\\(\\mapsto\\)<code>true</code></li> <li><code>[] | Bool</code>\\(\\mapsto\\)<code>false</code></li> <li><code>{} | Bool</code>\\(\\mapsto\\)<code>false</code></li> <li><code>null | Bool</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#not","title":"Not","text":"<p>Signature: Unary</p> <p>Aliases: Falsy, Nil</p> <p>Logical complement</p> <p>Examples:</p> <ul> <li><code>42 | Nil</code>\\(\\mapsto\\)<code>false</code></li> <li><code>0 | Nil</code>\\(\\mapsto\\)<code>true</code></li> </ul>"},{"location":"dsl-reference/expressions/#and","title":"And","text":"<p>Signature: Binary</p> <p>Logical and</p> <p>Generic behavior:   if first operand is truthy,   returns second operand, otherwise first</p> <p>Examples:</p> <ul> <li><code>[true, false] | And</code>\\(\\mapsto\\)<code>false</code></li> <li><code>[true, true] | And</code>\\(\\mapsto\\)<code>true</code></li> </ul> <p>Generic behavior:</p> <ul> <li><code>[\"foo\", [42, 43]] | And</code>\\(\\mapsto\\)<code>[42, 43]</code></li> <li> <p><code>[\"\"   , [42, 43]] | And</code>\\(\\mapsto\\)<code>\"\"</code></p> </li> <li> <p><code>13 | And(42)</code>\\(\\mapsto\\)<code>42</code></p> </li> <li><code>[] | And(42)</code>\\(\\mapsto\\)<code>[]</code></li> </ul> <p>If-Else using composition:</p> <ul> <li><code>true | And(42) | Or(13)</code>\\(\\mapsto\\)<code>42</code></li> <li><code>false | And(42) | Or(13)</code>\\(\\mapsto\\)<code>13</code></li> </ul>"},{"location":"dsl-reference/expressions/#or","title":"Or","text":"<p>Signature: Binary</p> <p>Logical or</p> <p>Generic behavior:   if first operand is truthy,   returns first operand, second otherwise</p> <p>Examples:</p> <ul> <li><code>[true, false] | Or</code>\\(\\mapsto\\)<code>true</code></li> <li><code>[false, false] | Or</code>\\(\\mapsto\\)<code>false</code></li> </ul> <p>Generic behavior:</p> <ul> <li><code>[\"foo\", [42, 43]] | Or</code>\\(\\mapsto\\)<code>\"foo\"</code></li> <li> <p><code>[\"\"   , [42, 43]] | Or</code>\\(\\mapsto\\)<code>[42, 43]</code></p> </li> <li> <p><code>13 | Or(42)</code>\\(\\mapsto\\)<code>13</code></p> </li> <li><code>[] | Or(42)</code>\\(\\mapsto\\)<code>42</code></li> </ul> <p>If-Else using composition:</p> <ul> <li><code>true | And(42) | Or(13)</code>\\(\\mapsto\\)<code>42</code></li> <li><code>false | And(42) | Or(13)</code>\\(\\mapsto\\)<code>13</code></li> </ul>"},{"location":"dsl-reference/expressions/#unary-structural-transforms","title":"Unary Structural transforms","text":""},{"location":"dsl-reference/expressions/#id","title":"Id","text":"<p>Signature: Unary</p> <p>Identity function</p> <p>Examples:</p> <ul> <li><code>42 | Id</code>\\(\\mapsto\\)<code>42</code></li> </ul>"},{"location":"dsl-reference/expressions/#transp","title":"Transp","text":"<p>Signature: Unary</p> <p>Transpose multidimensional list, turning rows into columns</p> <p>May be used to zip sequences of equal length.</p> <p>Examples:</p> <ul> <li><code>[[1, 2, 3], [4, 5, 6]] | Transp</code>\\(\\mapsto\\)<code>[[1, 4], [2, 5], [3, 6]]</code></li> </ul>"},{"location":"dsl-reference/expressions/#cartesian","title":"Cartesian","text":"<p>Signature: Unary</p> <p>Cartesian product</p> <p>Examples:</p> <ul> <li><code>[[1, 2], [3, 4]] | Cartesian</code>\\(\\mapsto\\)<code>[[1, 3], [1, 4], [2, 3], [2, 4]]</code></li> </ul>"},{"location":"dsl-reference/expressions/#reverse","title":"Reverse","text":"<p>Signature: Unary</p> <p>Reverse sequence</p> <p>Examples:</p> <ul> <li><code>[1, 2, 3] | Reverse</code>\\(\\mapsto\\)<code>[3, 2, 1]</code></li> </ul>"},{"location":"dsl-reference/expressions/#uniques","title":"Uniques","text":"<p>Signature: Unary</p> <p>Filter unique elements</p> <p>Examples:</p> <ul> <li><code>[1, 2, 1, 3, 2] | Uniques</code>\\(\\mapsto\\)<code>[1, 2, 3]</code></li> </ul>"},{"location":"dsl-reference/expressions/#items","title":"Items","text":"<p>Signature: Unary</p> <p>Extract key-value pairs from object</p> <p>Examples:</p> <ul> <li><code>{\"a\": 1, \"b\": 2} | Items</code>\\(\\mapsto\\)<code>[[\"a\", 1], [\"b\", 2]]</code></li> </ul>"},{"location":"dsl-reference/expressions/#keys","title":"Keys","text":"<p>Signature: Unary</p> <p>Extract keys from object</p> <p>Examples:</p> <ul> <li><code>{\"a\": 1, \"b\": 2} | Keys</code>\\(\\mapsto\\)<code>[\"a\", \"b\"]</code></li> </ul>"},{"location":"dsl-reference/expressions/#values","title":"Values","text":"<p>Signature: Unary</p> <p>Extract values from object</p> <p>Examples:</p> <ul> <li><code>{\"a\": 1, \"b\": 2} | Values</code>\\(\\mapsto\\)<code>[1, 2]</code></li> </ul>"},{"location":"dsl-reference/expressions/#enumerate","title":"Enumerate","text":"<p>Signature: Unary</p> <p>Enumerate sequence</p> <p>Enumerate sequence with index.</p> <p>Examples:</p> <ul> <li><code>[1, 2, 3] | Enumerate</code>\\(\\mapsto\\)<code>[[0, 1], [1, 2], [2, 3]]</code></li> </ul>"},{"location":"dsl-reference/expressions/#flatten","title":"Flatten","text":"<p>Signature: Unary</p> <p>Flatten nested list</p> <p>Examples:</p> <ul> <li><code>[[1, 2], [3, 4]] | Flatten</code>\\(\\mapsto\\)<code>[1, 2, 3, 4]</code></li> </ul>"},{"location":"dsl-reference/expressions/#tolist","title":"ToList","text":"<p>Signature: Unary</p> <p>Put argument into a list</p> <p>Equivalent to At([\"\"])</p> <p>Examples:</p> <ul> <li><code>42 | List</code>\\(\\mapsto\\)<code>[42]</code></li> </ul>"},{"location":"dsl-reference/expressions/#first","title":"First","text":"<p>Signature: Unary</p> <p>First item of sequence</p> <p>Equivalent to At(0)</p> <p>Examples:</p> <ul> <li><code>[1,2,3] | First</code>\\(\\mapsto\\)<code>1</code></li> <li><code>[] | First</code>\\(\\mapsto\\)<code>null</code></li> </ul>"},{"location":"dsl-reference/expressions/#last","title":"Last","text":"<p>Signature: Unary</p> <p>Last item of sequence</p> <p>Equivalent to At(-1)</p> <p>Examples:</p> <ul> <li><code>[1,2,3] | Last</code>\\(\\mapsto\\)<code>3</code></li> <li><code>[] | Last</code>\\(\\mapsto\\)<code>null</code></li> </ul>"},{"location":"dsl-reference/expressions/#unary-generators","title":"Unary Generators","text":""},{"location":"dsl-reference/expressions/#arange","title":"Arange","text":"<p>Signature: Unary</p> <p>Generate range of numbers</p> <p>Return evenly spaced values within a given interval.</p> <p>Parameters:   1. start: start value   2. stop: stop value   3. step: step value</p> <p>Parameters dynamic evaluation:   1. stop: int            -&gt; [0, stop, 1]   2. [start, stop]        -&gt; [start, stop, 1]   3. [start, stop, step]  -&gt; [start, stop, step]</p> <p>Examples:</p> <ul> <li><code>6 | Arange</code>\\(\\mapsto\\)<code>[0,1,2,3,4,5]</code></li> <li><code>[2,6] | Arange</code>\\(\\mapsto\\)<code>[2,3,4,5]</code></li> <li><code>[1,9,2] | Arange</code>\\(\\mapsto\\)<code>[1,3,5,7]</code></li> <li> <p><code>[5,1,-1] | Arange</code>\\(\\mapsto\\)<code>[5,4,3,2]</code></p> </li> <li> <p><code>\"2:6\" | Arange</code>\\(\\mapsto\\)<code>[2,3,4,5]</code></p> </li> <li><code>\"1:9:2\" | Arange</code>\\(\\mapsto\\)<code>[1,3,5,7]</code></li> <li><code>\"5:1:-1\" | Arange</code>\\(\\mapsto\\)<code>[5,4,3,2]</code></li> </ul>"},{"location":"dsl-reference/expressions/#string-transforms","title":"String Transforms","text":""},{"location":"dsl-reference/expressions/#parse","title":"Parse","text":"<p>Signature: Unary</p> <p>Parse string as json</p> <p>Examples:</p> <ul> <li><code>'{\"a\": 42}' | Parse</code>\\(\\mapsto\\)<code>{\"a\": 42}</code></li> </ul>"},{"location":"dsl-reference/expressions/#str","title":"Str","text":"<p>Signature: Unary</p> <p>Aliases: Serialize</p> <p>Serialize json as string</p> <p>Examples:</p> <ul> <li><code>{\"a\": 42} | Serialize</code>\\(\\mapsto\\)<code>'{\"a\":42}'</code></li> </ul>"},{"location":"dsl-reference/expressions/#re","title":"Re","text":"<p>Signature: Binary</p> <p>Aliases: Regex</p> <p>Regular expression match</p> <p>If input is not a string, match it's serialized form.</p> <p>Examples:</p> <ul> <li><code>[\"[0-9]+\", \"42\"] | Re</code>\\(\\mapsto\\)<code>true</code></li> <li><code>\"42\" | Re(\"[0-9]+\")</code>\\(\\mapsto\\)<code>true</code></li> </ul>"},{"location":"dsl-reference/expressions/#fmt","title":"Fmt","text":"<p>Signature: Variadic</p> <p>Aliases: Format</p> <p>Format string with the given parameter list.</p> <p>Constant expressions are supported for the token list, s.t. \"%s\" | Fmt(Pi)  produces \"3.141592653589793E0\"</p> <p>Examples:</p> <ul> <li><code>[\"Hello, %s!\", [\"world\"]] | Format</code>\\(\\mapsto\\)<code>\"Hello, world!\"</code></li> <li><code>\"%d + %d = %d\" | Format(2,2,4)</code>\\(\\mapsto\\)<code>\"2 + 2 = 4\"</code></li> </ul>"},{"location":"dsl-reference/expressions/#capitalize","title":"Capitalize","text":"<p>Signature: Unary</p> <p>Capitalize string</p> <p>Examples:</p> <ul> <li><code>\"foo\" | Capitalize</code>\\(\\mapsto\\)<code>\"Foo\"</code></li> </ul>"},{"location":"dsl-reference/expressions/#lowercase","title":"LowerCase","text":"<p>Signature: Unary</p> <p>Lower case string</p> <p>Examples:</p> <ul> <li><code>\"Foo\" | LowerCase</code>\\(\\mapsto\\)<code>\"foo\"</code></li> </ul>"},{"location":"dsl-reference/expressions/#uppercase","title":"UpperCase","text":"<p>Signature: Unary</p> <p>Upper case string</p> <p>Examples:</p> <ul> <li><code>\"foo\" | UpperCase</code>\\(\\mapsto\\)<code>\"FOO\"</code></li> </ul>"},{"location":"dsl-reference/expressions/#structural-properties","title":"Structural properties","text":""},{"location":"dsl-reference/expressions/#card","title":"Card","text":"<p>Signature: Unary</p> <p>Set cardinality (uniques count)</p> <p>Examples:</p> <ul> <li><code>[1, 2, 1, 3, 2] | Card</code>\\(\\mapsto\\)<code>3</code></li> <li><code>{\"a\": 1, \"b\": 2} | Card</code>\\(\\mapsto\\)<code>2</code></li> </ul>"},{"location":"dsl-reference/expressions/#size","title":"Size","text":"<p>Signature: Unary</p> <p>Sequence size</p> <p>Examples:</p> <ul> <li><code>[1, 1, 1] | Size</code>\\(\\mapsto\\)<code>3</code></li> <li><code>{\"a\": 1, \"b\": 2} | Size</code>\\(\\mapsto\\)<code>2</code></li> </ul>"},{"location":"dsl-reference/expressions/#sum","title":"Sum","text":"<p>Signature: Unary</p> <p>Summation reduction</p> <p>Equivalent to Reduce(Add)</p> <p>Examples:</p> <ul> <li><code>[1, 2, 3] | Sum</code>\\(\\mapsto\\)<code>6</code></li> </ul>"},{"location":"dsl-reference/expressions/#prod","title":"Prod","text":"<p>Signature: Unary</p> <p>Multiplication reduction</p> <p>Equivalent to Reduce(Mul)</p> <p>Examples:</p> <ul> <li><code>[1, 2, 3] | Prod</code>\\(\\mapsto\\)<code>6</code></li> </ul>"},{"location":"dsl-reference/expressions/#avg","title":"Avg","text":"<p>Signature: Unary</p> <p>Arythmetic average</p> <p>Examples:</p> <ul> <li><code>[1, 2, 3] | Avg</code>\\(\\mapsto\\)<code>2</code></li> </ul>"},{"location":"dsl-reference/expressions/#binary-structural-transforms","title":"Binary Structural transforms","text":""},{"location":"dsl-reference/expressions/#slide","title":"Slide","text":"<p>Signature: Binary</p> <p>Sliding-window iteration</p> <p>Sliding window iteration by specified window width.</p> <p>Examples:</p> <ul> <li><code>[1,2,3,4,5] | Slide(3)</code>\\(\\mapsto\\)<code>[[1,2,3],[2,3,4],[3,4,5]]</code></li> <li><code>[1,2,3,4,5] | Slide(42)</code>\\(\\mapsto\\)<code>[]</code></li> </ul>"},{"location":"dsl-reference/expressions/#stride","title":"Stride","text":"<p>Signature: Binary</p> <p>Striding iteration</p> <p>Striding iteration by specified step width. Reminder subsequence smaller then step width is discarded.</p> <p>Examples:</p> <ul> <li><code>[1,2,3,4,5,6] | Stride(2)</code>\\(\\mapsto\\)<code>[[1,2],[3,4],[5,6]]</code></li> <li><code>[1,2,3,4,5] | Stride(3)</code>\\(\\mapsto\\)<code>[[1,2,3]]</code></li> </ul>"},{"location":"dsl-reference/expressions/#chunks","title":"Chunks","text":"<p>Signature: Binary</p> <p>Split into chunks of specified max width</p> <p>Similar to Stride, but includes the last subsequence smaller then step width.</p> <p>Examples:</p> <ul> <li><code>[1,2,3,4,5,6] | Chunks(2)</code>\\(\\mapsto\\)<code>[[1,2],[3,4],[5,6]]</code></li> <li><code>[1,2,3,4,5] | Chunks(3)</code>\\(\\mapsto\\)<code>[[1,2,3],[4,5]]</code></li> </ul>"},{"location":"dsl-reference/expressions/#repeat","title":"Repeat","text":"<p>Signature: Binary</p> <p>Repeat value in list</p> <p>Examples:</p> <ul> <li><code>42 | Repeat(3)</code>\\(\\mapsto\\)<code>[42, 42, 42]</code></li> <li><code>1 | Repeat(3) | Repeat(2)</code>\\(\\mapsto\\)<code>[[1,1,1],[1,1,1]]</code></li> </ul>"},{"location":"dsl-reference/expressions/#cat","title":"Cat","text":"<p>Signature: Binary</p> <p>Aliases: Concat</p> <p>Concatenate sequences</p> <p>Examples:</p> <ul> <li><code>[[1, 2], [3, 4]] | Concat</code>\\(\\mapsto\\)<code>[1, 2, 3, 4]</code></li> <li><code>\"Hello, \" | Concat(\"World!\")</code>\\(\\mapsto\\)<code>\"Hello, World!\"</code></li> </ul>"},{"location":"dsl-reference/expressions/#push","title":"Push","text":"<p>Signature: Binary</p> <p>Push element into a front of sequence</p> <p>Examples:</p> <ul> <li><code>[[1, 2], 3] | Push</code>\\(\\mapsto\\)<code>[3, 1, 2]</code></li> <li><code>[1, 2] | Push(3)</code>\\(\\mapsto\\)<code>[3, 1, 2]</code></li> </ul>"},{"location":"dsl-reference/expressions/#at","title":"At","text":"<p>Signature: Binary</p> <p>Transform json value with given query</p> <p>Query evaluation rules:</p> <ol> <li>Structure index (negative resolves as reverse): \\(q: int   \\mapsto x: list  \\mapsto x_q\\)</li> <li>Array slice: \\(q: slice \\mapsto x: list  \\mapsto x[start:stop:step]\\)</li> <li>JSON Pointer: \\(q: str   \\mapsto x: any   \\mapsto x_q\\)</li> <li>Array pack: \\(q: list  \\mapsto x: any   \\mapsto [x_{q_1}, x_{q_2}, ...]\\)</li> <li>Object pack:     \\(\\{key: q_1, \\$q_2: q_3, ...\\} \\mapsto x: any \\mapsto \\{ key: x_{q_1}, q_2: x_{q_3}, ...\\}\\)</li> </ol> <p>Structure index is evaluated as array index or as key-value pair index for objects   on order-preserving backends.</p> <p>Result is null if requested element not found.</p> <p>Examples:</p> <p>Array index:</p> <ul> <li><code>[1, 2, 3] | At(2)</code>\\(\\mapsto\\)<code>3</code></li> <li><code>[1, 2, 3] | At(3)</code>\\(\\mapsto\\)<code>nullptr</code></li> <li><code>42 | At(0)</code>\\(\\mapsto\\)<code>nullptr</code></li> </ul> <p>Array slice:</p> <ul> <li><code>[1,2,3,4,5,6,7,8] | At(\"::2\")</code>\\(\\mapsto\\)<code>[1,3,5,7]</code></li> <li><code>[1,2,3,4,5,6,7,8] | At(\"4:\")</code>\\(\\mapsto\\)<code>[5,6,7,8]</code></li> <li><code>[1,2,3,4,5,6,7,8] | At(\"-1:0:-1\")</code>\\(\\mapsto\\)<code>[8,7,6,5,4,3,2,1]</code></li> </ul> <p>JSON Pointer:</p> <ul> <li><code>\"foo\" | At(\"\")</code>\\(\\mapsto\\)<code>\"foo\"</code></li> <li><code>{\"a\": 42, \"b\": 13} | At(\"/a\")</code>\\(\\mapsto\\)<code>42</code></li> </ul> <p>Array pack:</p> <ul> <li><code>{\"a\": 42, \"b\": 13} | At([\"/a\", \"/b\"])</code>\\(\\mapsto\\)<code>[42, 13]</code></li> <li><code>42 | At([\"\"])</code>\\(\\mapsto\\)<code>[42]</code></li> </ul> <p>Object pack:</p> <ul> <li><code>{\"a\": 42, \"b\": 13} | At({\"f\": \"/a\", \"g\": \"/b\"})</code>\\(\\mapsto\\)<code>{\"f\": 42, \"g\": 13}</code></li> <li><code>{\"a\": 42, \"b\": 13} | At({\"$/b\": \"/a\"})</code>\\(\\mapsto\\)<code>{\"13\": 42}</code></li> </ul>"},{"location":"dsl-reference/expressions/#del","title":"Del","text":"<p>Signature: Binary</p> <p>Aliases: Delete</p> <p>Delete elements from structure by given query</p> <p>Possible queries:   1. Structure index (negative resolves as reverse)   2. JSON Pointer   3. List of queries</p> <p>Structure index is evaluated as array index or as key-value pair index for objects   on order-preserving backends. When deleting an object element, resulting items order may change.</p> <p>Examples:</p> <ul> <li><code>[1,2,3,4,5] | Del(2)</code>\\(\\mapsto\\)<code>[1,2,4,5]</code></li> <li><code>[[1, 2], 3] | Del(\"/0/1\")</code>\\(\\mapsto\\)<code>[[1], 3]</code></li> <li><code>{\"a\": {\"b\": [1,2,3]}} | Del({\"/a/b/0\", \"/a/b/1\"})</code>\\(\\mapsto\\)<code>{\"a\": {\"b\": [3]}}</code></li> </ul>"},{"location":"dsl-reference/expressions/#lookup","title":"Lookup","text":"<p>Signature: Binary</p> <p>Lookup table function</p> <p>Parametrized at design time with fixed array or object, produces the value at corresponding At query given as eval-time argument. Equivalent to ~At(...)</p> <p>Examples:</p> <ul> <li><code>0 | Lookup([1,2,3])</code>\\(\\mapsto\\)<code>1</code></li> <li><code>\"/foo\" | Lookup([1,2,3])</code>\\(\\mapsto\\)<code>null</code></li> </ul>"},{"location":"dsl-reference/expressions/#cast","title":"Cast","text":"<p>Signature: Special</p> <p>Aliases: Decorate</p> <p>Reserialize decorated type as decorator</p>"},{"location":"dsl-reference/expressions/#uncast","title":"Uncast","text":"<p>Signature: Special</p> <p>Aliases: Undecorate</p> <p>Reserialize decorator as decorated type</p>"},{"location":"dsl-reference/expressions/#high-order","title":"High-Order","text":""},{"location":"dsl-reference/expressions/#fold","title":"Fold","text":"<p>Signature: Binary</p> <p>Aliases: Reduce</p> <p>Reduce sequence with binary operator</p> <p>To set a specific initial value, use composition with Push, e.g. <code>Push(0) | Fold(Add)</code></p> <p>For reverse operation, see Unfold</p> <p>Examples:</p> <ul> <li><code>[-1, 2, 3] | Fold(Add)</code>\\(\\mapsto\\)<code>4</code></li> <li><code>[-1, 2, 3] | Fold(Mul)</code>\\(\\mapsto\\)<code>-6</code></li> </ul>"},{"location":"dsl-reference/expressions/#map","title":"Map","text":"<p>Signature: Binary</p> <p>Apply param expr to every element of sequence</p> <p>Examples:</p> <ul> <li><code>[1, 2, 3] | Map(Add(1))</code>\\(\\mapsto\\)<code>[2, 3, 4]</code></li> </ul>"},{"location":"dsl-reference/expressions/#filter","title":"Filter","text":"<p>Signature: Binary</p> <p>Filter sequence by predicate param</p> <p>Examples:</p> <ul> <li><code>[1, 2, 3, 4] | Filter(Gt(2))</code>\\(\\mapsto\\)<code>[3, 4]</code></li> </ul>"},{"location":"dsl-reference/expressions/#count","title":"Count","text":"<p>Signature: Binary</p> <p>Count matches by predicate param</p> <p>Examples:</p> <ul> <li><code>[1, 2, 3, 4] | Count(Gt(2))</code>\\(\\mapsto\\)<code>2</code></li> </ul>"},{"location":"dsl-reference/expressions/#each","title":"Each","text":"<p>Signature: Binary</p> <p>Test predicate for each item in a sequence</p> <p>Equivalent to <code>Count(p | Not) | Eq(0)</code></p> <p>Examples:</p> <ul> <li><code>[1, 2, 3, 4] | Each(Gt(2))</code>\\(\\mapsto\\)<code>false</code></li> <li><code>[1, 2, 3, 4] | Slide(2) | Each(Lt)</code>\\(\\mapsto\\)<code>true</code></li> </ul>"},{"location":"dsl-reference/expressions/#sort","title":"Sort","text":"<p>Signature: Binary</p> <p>Sort list by key function</p> <p>Examples:</p> <ul> <li><code>[3, 1, 2] | Sort</code>\\(\\mapsto\\)<code>[1, 2, 3]</code></li> <li><code>[3, 1, 2] | Sort(Id)</code>\\(\\mapsto\\)<code>[1, 2, 3]</code></li> <li><code>[-3, 1, -2] | Sort(Abs)</code>\\(\\mapsto\\)<code>[1, -2, -3]</code></li> <li><code>[3, 1, 2] | Sort | Reverse</code>\\(\\mapsto\\)<code>[3, 2, 1]</code></li> </ul>"},{"location":"dsl-reference/expressions/#find","title":"Find","text":"<p>Signature: Binary</p> <p>Find the first element that satisfies given predicate</p> <p>Examples:</p> <ul> <li><code>[-3, 1, -2] | Find(Ge(2))</code>\\(\\mapsto\\)<code>nullptr</code></li> <li><code>[-3, 1,  4] | Find(Ge(2))</code>\\(\\mapsto\\)<code>4</code></li> </ul>"},{"location":"dsl-reference/expressions/#findptr","title":"FindPtr","text":"<p>Signature: Binary</p> <p>Find json pointer of the first element that satisfies given predicate</p> <p>Examples:</p> <ul> <li><code>[-3, 1, -2] | FindPtr(Ge(2))</code>\\(\\mapsto\\)<code>nullptr</code></li> <li><code>[-3, 1,  4] | FindPtr(Ge(2))</code>\\(\\mapsto\\)<code>\"/2\"</code></li> </ul>"},{"location":"dsl-reference/expressions/#findidx","title":"FindIdx","text":"<p>Signature: Binary</p> <p>Find index of the first element that satisfies given predicate</p> <p>Similar to FindPtr, but will integer index or nullptr for non-indexable input. Objects are processed as list of key-value pairs.</p> <p>Examples:</p> <ul> <li><code>[-3, 1, -2] | FindIdx(Ge(2))</code>\\(\\mapsto\\)<code>nullptr</code></li> <li><code>[-3, 1,  4] | FindIdx(Ge(2))</code>\\(\\mapsto\\)<code>2</code></li> </ul>"},{"location":"dsl-reference/expressions/#min","title":"Min","text":"<p>Signature: Binary</p> <p>Min value by key function</p> <p>Examples:</p> <ul> <li><code>[-3, 1, -2] | Min</code>\\(\\mapsto\\)<code>1</code></li> <li><code>[-3, 1, -2] | Min(Abs)</code>\\(\\mapsto\\)<code>-3</code></li> </ul>"},{"location":"dsl-reference/expressions/#max","title":"Max","text":"<p>Signature: Binary</p> <p>Max value by key function</p> <p>Examples:</p> <ul> <li><code>[-3, 1, -2] | Max</code>\\(\\mapsto\\)<code>1</code></li> <li><code>[-3, 1, -2] | Max(Abs)</code>\\(\\mapsto\\)<code>-3</code></li> </ul>"},{"location":"dsl-reference/expressions/#argmin","title":"Argmin","text":"<p>Signature: Binary</p> <p>Min value index by key function</p> <p>Examples:</p> <ul> <li><code>[-3, 1, -2] | Argmin</code>\\(\\mapsto\\)<code>0</code></li> <li><code>[-3, 1, -2] | Argmin(Abs)</code>\\(\\mapsto\\)<code>1</code></li> </ul>"},{"location":"dsl-reference/expressions/#argmax","title":"Argmax","text":"<p>Signature: Binary</p> <p>Max value index by key function</p> <p>Examples:</p> <ul> <li><code>[-3, 1, -2] | Argmax</code>\\(\\mapsto\\)<code>1</code></li> <li><code>[-3, 1, -2] | Argmax(Abs)</code>\\(\\mapsto\\)<code>0</code></li> </ul>"},{"location":"dsl-reference/expressions/#recur","title":"Recur","text":"<p>Signature: Binary</p> <p>Apply recursion to parameter expr and initial value</p> <p>Inference rules:</p> <ul> <li><code>n | Recur(x &amp; f)</code> \\(\\mapsto \u25ef\u207f f(x)\\), or</li> <li> <p><code>Q(p) | Recur(x\u2080 &amp; f)</code> \\(\\mapsto x_k\\), where</p> <ul> <li>\\(x_{i+1} = f(x_i)\\)</li> <li>\\(p(x_{i}) = \\top \\quad \\forall i \\le k\\)</li> <li>\\(p(x_{i+1}) = \\bot\\) (exit condition)</li> </ul> </li> </ul> <p>Examples:</p> <ul> <li><code>0 | Recur(0 &amp; Add(1))</code>\\(\\mapsto\\)<code>3</code></li> <li><code>3 | Recur(1 &amp; Mul(-1))</code>\\(\\mapsto\\)<code>-1</code></li> </ul>"},{"location":"dsl-reference/expressions/#unfold","title":"Unfold","text":"<p>Signature: Binary</p> <p>Put results of recursive fn call on initial value into an array</p> <p>Inference rules:</p> <ul> <li><code>n | Unfold(x &amp; f)</code>\\(\\mapsto [x_0, x_1, ...,  x_n]\\), or</li> <li> <p><code>Q(p) | Unfold(x\u2080 &amp; f)</code> \\(\\mapsto [x_0, x_1, ...,  x_k]\\), where</p> <ul> <li>\\(x_{i+1} = f(x_i)\\)</li> <li>\\(p(x_{i}) = \\top \\quad \\forall i \\le k\\)</li> <li>\\(p(x_{i+1}) = \\bot\\) (exit condition)</li> </ul> </li> </ul> <p>Examples:</p> <ul> <li><code>3 | Unfold(0 &amp; Add(1))</code>\\(\\mapsto\\)<code>[0, 1, 2, 3]</code></li> <li><code>3 | Unfold(1 &amp; Mul(-1))</code>\\(\\mapsto\\)<code>[1,-1, 1,-1]</code></li> </ul>"},{"location":"dsl-reference/expressions/#op","title":"Op","text":"<p>Signature: Special</p> <p>Aliases: Overload</p> <p>Bind type-specific operator handler to function</p> <p>Expression Op(op, f) instructs f to use op operator on invocation instead of the default generic.</p> <p>Operator parameter singleton can be referenced with a string key or constructed in place using type tag. <p>This operator handler is propagated downstream to all terminal subexpression in <code>f</code>. The result of <code>f(x)</code> is not decorated as type. <p>Examples:</p> <ul> <li><code>[0.5, 2] | Op(\"complex\", Add(1))</code>\\(\\mapsto\\)<code>[1.5, 2]</code></li> </ul>"},{"location":"dsl-reference/expressions/#bind","title":"Bind","text":"<p>Signature: Binary</p> <p>Bind design-time parameters to function.</p> <p>Examples:</p> <ul> <li><code>42 &amp; Q(Add) | Bind</code>\\(\\mapsto\\)<code>Add(42)</code></li> <li><code>42 | Bind(F) | Bind(G) | Bind(H)</code>\\(\\mapsto\\)<code>H(G(F(42)))</code></li> </ul>"},{"location":"dsl-reference/expressions/#fn","title":"Fn","text":"<p>Signature: Binary</p> <p>Inline named function</p> <p>Expression <code>Fn(reference, expr)</code> creates a symbolic link to expr, at the same time evaluating given arguments (inlining the expr). The reference is avaliable in the evaluation context, including in the expr itself (essentially enabling an arbitrary recursion).</p> <p>Infix operator form (left shift):</p> <p>\"\\(f\" &lt;&lt; E \u2261 Fn(\"\\)f\", E)</p> <p>Examples:</p> <p>x | (\"\\(f\" &lt;&lt; Add(1)) | \"\\)f\"  | \"$f\" = x + 1 + 1 + 1</p> <p>auto const factorial = \"\\(f\" &lt;&lt; (\"\\)x\"   | Assert(Ge(0))   | Lt(2)   | And(1)   | Or(\"\\(x\" &amp; (\"\\)x\" | Sub(1) | \"$f\") | Mul) );</p>"},{"location":"dsl-reference/expressions/#link","title":"Link","text":"<p>Signature: Binary</p> <p>Symbolic binding of the input value</p> <p>The capture is referenced by an arbitrary string preceded by dollar sign, e.g. \"$x\".</p> <p>On the first access it stores the input value in isolated expression context, and returns it on each subsequent call. It can't be reset after the first access.</p> <p>The string after $ sign shall not be enclosed in [], {}, or (), as those formats are reserved for internal usage.</p> <p>Examples:</p> <ul> <li><code>42 | \"$x\" | Ge(0) | And(\"$x\") | Or(\"$x\" | Mul(-1))</code>\\(\\mapsto\\)<code>42</code></li> <li><code>-7 | \"$x\" | Ge(0) | And(\"$x\") | Or(\"$x\" | Mul(-1))</code>\\(\\mapsto\\)<code>7</code></li> </ul>"},{"location":"dsl-reference/expressions/#any","title":"Any","text":"<p>Signature: Variadic</p> <p>Match any predicate</p> <p>Examples:</p> <ul> <li><code>3 | Any(Gt(2), Lt(0))</code>\\(\\mapsto\\)<code>true</code></li> <li><code>0 | Any(Gt(2), Lt(0))</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#all","title":"All","text":"<p>Signature: Variadic</p> <p>Match all predicates</p> <p>Examples:</p> <ul> <li><code>3 | All(Gt(2), Lt(0))</code>\\(\\mapsto\\)<code>false</code></li> <li><code>2.5 | All(Gt(2), Lt(3))</code>\\(\\mapsto\\)<code>true</code></li> </ul>"},{"location":"dsl-reference/expressions/#saturate","title":"Saturate","text":"<p>Signature: Variadic</p> <p>Saturate matches in order</p> <p>Examples:</p> <ul> <li><code>3 | Saturate(Gt(2), Lt(0))</code>\\(\\mapsto\\)<code>true</code></li> <li> <p><code>0 | Saturate(Gt(2), Lt(0))</code>\\(\\mapsto\\)<code>false</code></p> </li> <li> <p><code>[2,4,8,42,1,2] | Saturate(42, Mod(2)|0)</code>\\(\\mapsto\\)<code>true</code></p> </li> <li><code>[2,4,8,41,2] | Saturate(42, Mod(2)|0)</code>\\(\\mapsto\\)<code>false</code></li> <li><code>[2,4,8,42] | Saturate(42, Mod(2)|0)</code>\\(\\mapsto\\)<code>false</code></li> </ul>"},{"location":"dsl-reference/expressions/#pipe","title":"Pipe","text":"<p>Signature: Variadic</p> <p>Pipe functions in left-to-right composition</p> <p>Examples:</p> <ul> <li><code>3 | Pipe(Mul(2), Add(1))</code>\\(\\mapsto\\)<code>7</code></li> <li><code>4 | Pipe(Mul(2), Add(1))</code>\\(\\mapsto\\)<code>9</code></li> </ul> <p>Infix operator form (pipe):</p> <ul> <li><code>Add(1) | Mul(2)</code>\\(\\equiv\\)<code>Pipe(Add(1), Mul(2))</code></li> <li><code>3 | Add(1) | Mul(2)</code>\\(\\mapsto\\)<code>8</code></li> </ul>"},{"location":"dsl-reference/expressions/#tuple","title":"Tuple","text":"<p>Signature: Variadic</p> <p>Pack expressions into an tuple without evaluation</p> <p>Examples:</p> <ul> <li><code>null | Tuple(Reduce(Add), Size)</code>\\(\\mapsto\\)<code>[Reduce(Add), Size]</code></li> </ul> <p>Infix operator form (plus):</p> <ul> <li><code>Add(1) + Mul(2)</code>\\(\\equiv\\)<code>Tuple(Add(1), Mul(2))</code></li> </ul>"},{"location":"dsl-reference/expressions/#fork","title":"Fork","text":"<p>Signature: Variadic</p> <p>Pack results from enveloped functions into an array</p> <p>Allows to combine different properties in a single expression. Parameter</p> <p>Examples:</p> <ul> <li><code>[1,2,3] | Fork(Reduce(Add), Size)</code>\\(\\mapsto\\)<code>[6,3]</code></li> <li><code>[1,2,3] | Fork(42, Card, Id)</code>\\(\\mapsto\\)<code>[42, 3, [1,2,3]]</code></li> </ul> <p>Infix operator form (ampersand):</p> <ul> <li><code>Add(1) &amp; Mul(2)</code>\\(\\equiv\\)<code>Fork(Add(1), Mul(2))</code></li> <li><code>[1,2,3] | Reduce(Add) &amp; Size</code>\\(\\mapsto\\)<code>[6,3]</code></li> <li><code>[1,2,3] | Reduce(Add) &amp; Size | Div</code>\\(\\mapsto\\)<code>2</code></li> </ul> <p>Note that the Fork is not associative, therefore an infix operator chain is not unfolded as it is done for variadic Pipe or Tuple:  * <code>a &amp; b &amp; c</code>\\(\\equiv\\)<code>(a &amp; b) &amp; c</code>\\(\\equiv\\)<code>Fork(Fork(a, b), c)</code></p>"},{"location":"dsl-reference/expressions/#flip","title":"Flip","text":"<p>Signature: Binary</p> <p>Flip design-time and eval-time parameters.</p> <p>Useful for binding lhs operands to non-commutative operators. Unlike Haskell's flip, won't change the order or eval-time parameters - for that case use the Reverse keyword instead.</p> <p>Prefix operator form (tilde):</p> <p>Flip(Div(1)) \u2261 ~Div(1)</p> <p>Examples:</p> <ul> <li><code>2 | Div(1)</code>\\(\\mapsto\\)<code>2/1</code></li> <li><code>2 | ~Div(1)</code>\\(\\mapsto\\)<code>1/2</code></li> </ul>"},{"location":"dsl-reference/expressions/#dbg","title":"Dbg","text":"<p>Signature: Binary</p> <p>Aliases: Debug</p> <p>Evaluate function and print evaluation log to stderr</p> <p>Examples:</p> <p>42 | Dbg(Trace(ZMBT_CUR_LOC) | Add(2))</p>"},{"location":"dsl-reference/expressions/#eval","title":"Eval","text":"<p>Signature: Binary</p> <p>Flip designtime and run-time parameters, evaluating input as expression</p>"},{"location":"dsl-reference/expressions/#try","title":"Try","text":"<p>Signature: Binary</p> <p>Evaluate function and return result or null if it returns error</p> <p>Examples:</p> <ul> <li><code>42 | Try(Add(1))</code>\\(\\mapsto\\)<code>43</code></li> <li><code>\"foo\" | Try(Add(1))</code>\\(\\mapsto\\)<code>null</code></li> </ul>"},{"location":"dsl-reference/expressions/#kwrd","title":"Kwrd","text":"<p>Signature: Unary</p> <p>Introspect expression keyword.</p> <p>Examples:</p> <ul> <li><code>Q(Fold(Add)) | Kwrd</code>\\(\\mapsto\\)<code>\"Fold\"</code></li> <li><code>[1, 1, 1] | Kwrd</code>\\(\\mapsto\\)<code>\"Literal\"</code></li> </ul>"},{"location":"dsl-reference/expressions/#prms","title":"Prms","text":"<p>Signature: Unary</p> <p>Aliases: Parameters</p> <p>Introspect expression parameters.</p> <p>Examples:</p> <ul> <li><code>Q(Fold(Add)) | Prms</code>\\(\\mapsto\\)<code>Add</code></li> <li><code>[1, 1, 1] | Prms</code>\\(\\mapsto\\)<code>[1, 1, 1]</code></li> </ul>"},{"location":"dsl-reference/expressions/#evaluation-handlers","title":"Evaluation handlers","text":""},{"location":"dsl-reference/expressions/#q","title":"Q","text":"<p>Signature: Binary</p> <p>Aliases: C, Const</p> <p>Quote parameter, similar to lisp quotation.</p> <p>Quotation lifts any parameter to constant, s.t. produced expression will return the design-time parameter on evaluation, ignoring input. If evaluable expression is passed, it is returned unevaluated. Unlike plain literals which can be treated as predicate matchers in certain context, Q(x) is always a constant expression discarding input. ~Q (Flip(Q)) is equivalent to Id.</p> <p>Examples:</p> <ul> <li><code>null | C(42)</code>\\(\\mapsto\\)<code>42</code></li> </ul>"},{"location":"dsl-reference/expressions/#d","title":"D","text":"<p>Signature: Binary</p> <p>Aliases: Default</p> <p>Return x if not null, else return default value</p> <p>Examples:</p> <ul> <li><code>null | Default(42)</code>\\(\\mapsto\\)<code>42</code></li> <li><code>13 | Default(42)</code>\\(\\mapsto\\)<code>13</code></li> </ul>"},{"location":"dsl-reference/expressions/#err","title":"Err","text":"<p>Signature: Special</p> <p>Aliases: Error</p> <p>Error object</p> <p>Error object handling the message and context info</p>"},{"location":"dsl-reference/expressions/#iserr","title":"IsErr","text":"<p>Signature: Unary</p> <p>Aliases: IsError</p> <p>Test the argument is err expression</p>"},{"location":"dsl-reference/expressions/#assert","title":"Assert","text":"<p>Signature: Binary</p> <p>Return argument if it holds assertion or error otherwise.</p> <p>Examples:</p> <ul> <li><code>42 | Assert(Ge(0))</code>\\(\\mapsto\\)<code>42</code></li> <li><code>-7 | Assert(Ge(0))</code>\\(\\mapsto\\)<code>Err(\"assertion failed\", \"-7 | Ge(0)\")</code></li> </ul>"},{"location":"dsl-reference/expressions/#trace","title":"Trace","text":"<p>Signature: Binary</p> <p>Same as id, but also prints identifier parameter to debug log.</p>"},{"location":"dsl-reference/expressions/#preproc","title":"PreProc","text":"<p>Signature: Binary</p> <p>Preprocessing token</p> <p>String token that can be substituted with arbitrary expression on expression preprocessing.</p> <p>Examples:</p> <ul> <li><code>null | C(42)</code>\\(\\mapsto\\)<code>42</code></li> </ul>"},{"location":"dsl-reference/signal-mapping/","title":"Signal mapping","text":""},{"location":"dsl-reference/signal-mapping/#signal-mapping-test-model","title":"Signal Mapping Test Model","text":"<p> This document is in progress </p> <p>The model API utilizes method cascading with an entry point at SignalMapping class, which consumes a model name.</p> <p>Each subsequent method call consumes parameters and transitions to a subclass of [ModelDefinition/zmbt-framework/CxxRef/classzmbt_1_1mapping_1_1ModelDefinition/) that narrows the choices to methods valid for that specific step, effectively forming a push-down automaton. This technique simplifies the API usage, enhancing the code completion and checking certain errors at compilation stage.</p> <p>Each model is resolved and tested on reaching its destructor.</p> <p>The railroad diagram below shows the incomplete BNF definition of the Signal Mapping DSL. Certain terminal rules are not given in BNF but linked to the corresponding method overload set (see the following description).</p> <pre>66aafbbac5a0c2e22594965f5364c7e4ac1abfbf000dbffcdfbb3f99b315c08231d25b5269e78e82cbb0ebf0ee53b34fcddaefde866fc33f244dcc1c8edba5b3</pre><pre>0bb13f8bf95cbcdb621d210b36fa1523731814463107a11c19f2de4da5dde1b4abf8c1e72718a02e9d548eb93b26e7ca479a6aeb4186a5a31673023d6d0f5c8e</pre>"},{"location":"dsl-reference/signal-mapping/#clauses","title":"Clauses","text":"Clause API reference Purpose <code>SignalMapping</code> SignalMapping Opens a new test model with a descriptive name. <code>OnTrigger</code> <code>@T_OnTrigger</code> Declares the function or method that triggers test logic. <code>Repeat</code> <code>@T_Repeat</code> Sets the number of trigger invocations per test case. <code>At</code> <code>@T_At</code> Starts a signal channel on a specific interface. <code>Args</code>, <code>Return</code>, <code>Exception</code>, <code>Timestamp</code>, <code>ThreadId</code> <code>@T_Filter</code> Select data from the interface call. <code>Take</code> <code>@T_Take</code> Applies a transformation expression to the channel value. <code>Alias</code> <code>@T_Alias</code> Annotates the channel for identification/logging. <code>Group</code>, <code>Blend</code> <code>@T_ContinuePipe</code> Combine channels into a single pipe. <code>As</code> <code>@T_Decor</code> Applies operator overloading on the pipe. <code>Inject</code>, <code>Expect</code> <code>@T_TerminatePipe</code> Define test conditions and terminate the pipe. <code>Test</code> <code>@T_Test</code> Provides test vectors for unspecified inputs/outputs. <code>Zip</code>, <code>Prod</code>, <code>Pairwise</code>, <code>Parametrize</code> <code>@T_Param</code>, <code>@T_CustomParam</code> Add high-level parameter combinations. <code>PreRun</code>, <code>PostRun</code> <code>@T_PreRun</code>, <code>@T_PostRun</code> Set optional setup/teardown hooks. <code>Description</code> <code>@T_Description</code> Adds a human-readable test summary."},{"location":"user-guide/concepts/","title":"Framework Concepts","text":"<ul> <li>Channel: Specification for addressing the test stimuli or responses. Channel parameters include role (stimulus or response), interface (callable reference), kind (arguments, return value, exception, or call count), signal path, call (number of invocation).</li> <li>Environment: A globally available registry containing all test stimuli and observed responses.</li> <li>Interface: Function, member function with host object, or callable object, referenced directly (with C++ pointers or refs) or by string key (if registered in the Environment).</li> <li>Model: SUT abstraction focusing on verification of particular feature.</li> <li>Mock: Test double for callable that reroute any interactions to the Environment.</li> <li>Response: observable signal on SUT</li> <li>Stimulus: signal affecting the SUT</li> <li>SUT: System under test</li> <li>Trigger: A safe SUT execution wrapper for callable that feeds stimuli and captures responses in serialized form, enabling rerouting to the Environment.</li> <li>Test Vector: A list of test values - stimuli signals and expectation matchers for a single test case.</li> <li>Tasks: Test setup and cleanup callbacks.</li> </ul>"},{"location":"user-guide/environment/","title":"Environment","text":""},{"location":"user-guide/environment/#environment-api","title":"Environment API","text":"<p> This document is in progress </p> <p>Class: <code>zmbt::Environment</code></p> <p>Environment is basically a sophisticated associative container. It's only purpose is to provide safe and convenient storage for the test data. It does not interact with any other component on its own, but test model runners may use it for interaction with triggers and mocks.</p> <p>Considering its implementation as a weak singleton, the environment may be viewed as an internal database for the test I/O data, accessible from any part of the test application. The lifetime of the environment affects observability of the manageable effects - it is recommended to keep an instance of <code>zmbt::Environment</code> in the test fixture, allowing the RAII to reset the environment between tests.</p> <p>The Environment class methods are organized in the following groups:</p> <ul> <li>InterfaceRecord API</li> <li>Arbitrary Data Management</li> <li>Environment Checkout</li> <li>Environment Cleanup</li> </ul>"},{"location":"user-guide/environment/#interfacerecord-api","title":"InterfaceRecord API","text":"<p>Method: <code>zmbt::InterfaceRecord</code></p> <p>The method creates an extension to the environment that manages the signal records for particular interface. It owns an instance of environment, prolonging its lifetime.</p> <p>The resulting object provides an interface for mock call rerouting: <code>Hook</code> - this method registers an interface call in the environment, recording the argument values, and returns an injected stimuli or default values.</p>"},{"location":"user-guide/environment/#arbitrary-data-management","title":"Arbitrary data management","text":"<p>A set of interfaces not managed by test runners directly, but allowing the user to utilize safe storage for globally-accessed data.</p> <p>JSON-serializable variables managed by: - <code>zmbt::Environment::SetVar</code> - <code>zmbt::Environment::GetVar</code> - <code>zmbt::Environment::GetVarOrDefault</code> - <code>zmbt::Environment::GetVarOrUpdate</code></p> <p>Interfaces managing non-serializable data: - <code>zmbt::Environment::SetShared</code> - <code>zmbt::Environment::GetShared</code>: requires an explicit template parameter to check the type correctness in run-time.</p>"},{"location":"user-guide/environment/#thread-safety","title":"Thread safety","text":"<p>Every method in the Environment class is designed to be thread-safe. For scenarios requiring transactional logic, the environment can be secured using a RAII lock object that manages a recursive mutex. The relevant methods for this functionality are  - <code>zmbt::Environment::Lock</code>  - <code>zmbt::Environment::TryLock</code>  - <code>zmbt::Environment::DeferLock</code></p>"},{"location":"user-guide/environment/#environment-lifetime","title":"Environment Lifetime","text":"<p>The Environment class functions as a proxy to the back-end data and is implemented as a weak singleton. This implies that the global back-end instance is constructed upon the creation of the first proxy and remains active as long as there are references to it. Once all proxies are released, the back-end instance expires and may be constructed again.</p> <p>In the context of testing, both the test model and fixture classes hold an Environment object, thereby keeping the global back-end instance alive throughout the testing process. InterfaceRecord instances extends the environment lifetime too.</p> <p>All automated test models are designed to reset their data before each test, ensuring that any leaked or preserved objects between tests do not cause issues. However, the data, managed through the Arbitrary Data Management methods, is preserved.</p>"},{"location":"user-guide/environment/#environment-cleanup","title":"Environment Cleanup","text":"<p>The clean-up methods are  - <code>zmbt::Environment::ResetInterfaceData</code>  - <code>zmbt::Environment::ResetAll</code></p>"},{"location":"user-guide/expressions/","title":"Expressions","text":""},{"location":"user-guide/expressions/#zmbt-expressions","title":"ZMBT Expressions","text":"<p> This document is in progress </p> <p>ZMBT utilizes an embedded functional programming language for the test data manipulation and matching, referred to in the documentation simply as expressions.</p> <p>The language resides in the <code>zmbt::expr</code> namespace and consists of keywords that can be parametrized and combined into a single expression, resulting in a pure <code>JSON -&gt; JSON</code> function, which is evaluated by test model runners. The language belongs to a family of tacit programming languages. As it operates on JSON, certain elements may resemble the jq language, however, ZMBT Expressions focus more on a simpler syntax, allowing to embed them in any C-like language, and provide certain test-specific features such as typed operator handling.</p> <p>The main purpose of using an embedded language over common C++ functions is to give the model runners a full control over test inputs, notably:</p> <ul> <li>serialization: any complex transformations are represented in JSON</li> <li>introspection: model runner can explain in detail each step of evaluation without any additional effort from user</li> <li>reflection: model runner can preprocess expressions terms to enable high-level parametrization</li> </ul>"},{"location":"user-guide/expressions/#everything-is-a-function","title":"Everything is a function","text":"<p>Each expression has the same JSON \u2192 JSON evaluation type, which also applies to both built-in and user-defined constants like <code>Pi</code> or JSON literals. For example, <code>42</code> represents the function \\(x \\mapsto 42\\). This function simply discards its evaluation input instead of yielding an error. Using a constant or literal as the initial term in composition yields a constant expression.</p> <p>The Everything is a function principle allows different types of expressions to be composed using uniform syntactic rules. This design makes the expression system monadic in spirit, though not a full monad in the Haskell sense.</p> <p>Note</p> <p>The \\(E = x \\mapsto ...\\) notation is used below to define functor expression E in conventional mathematical notation. \\(E = value\\) is a shortcut for a constant expressions, which stands for \\(E = x \\mapsto value\\).</p>"},{"location":"user-guide/expressions/#syntax","title":"Syntax","text":"<p>General expression syntax is <code>literal | keyword[(expression...)]</code>, which expands to following options:</p> <ul> <li><code>literal</code>: JSON or any JSON-convertible value (not necessarily an actual C++ literal).</li> <li><code>keyword</code>: builtin expression keyword from zmbt::expr namespace.</li> <li><code>keyword(expression...)</code>: keyword with parameters (not yet an evaluation call).</li> </ul> <p>Both <code>keyword</code> forms yield a <code>Expression</code> object with an <code>eval</code> method, used by the framework at runtime, and <code>literal</code> is converted implicitly in corresponding context.</p> <p>In addition to verbose <code>keyword(expression...)</code> notation the Expression API provides syntactic sugar in form of shortcut infix and prefix operators:</p> Shortcut Verbose form Description Example <code>A | B | C</code> <code>Pipe(A, B, C)</code> Left-to-Right composition <code>X | Add(2) | Mul(3)</code> \\(= x \\mapsto (x + 2) * 3\\) <code>A + B</code> <code>Tuple(A, B)</code> Quoted constants tuple <code>x + y</code> \\(= x \\mapsto [x, y]\\) <code>A &amp; B</code> <code>Fork(A, B)</code> Evaluation branching <code>x | Add(2) &amp; Mul(3)</code> \\(= x \\mapsto [x + 2, 3x]\\) <code>~A</code> <code>Flip(A)</code> Operands swap <code>x | ~Div(1)</code> \\(= x \\mapsto 1 / x\\),  but <code>x | Div(1)</code> \\(= x \\mapsto x / 1\\) <p>The expression pipe (<code>|</code>) operator is associative from evaluation perspective, and the chain of multiple infix pipes is unfolded on construction, producing a single variadic <code>Pipe</code>: <code>A | B | C</code> yields <code>Pipe(A, B, C)</code> rather than <code>Pipe(Pipe(A, B), C)</code>.</p> <p>Infix unfolding is not applied to the fork (<code>&amp;</code>) operator, which is non-associative at evaluation. For this operator the grouping of infix operands is preserved, following the conventional C operator left-associativity: <code>A &amp; B &amp; C</code> = <code>(A &amp; B) &amp; C</code> = <code>Fork(Fork(A, B), C)</code>.</p>"},{"location":"user-guide/expressions/#arity-forms","title":"Arity forms","text":"<p>Expression keywords are grouped by their design-time plus evaluation-time parameters arity.</p> Form Resulting Expression Type Examples Const \\(E^C            \\mapsto (x \\mapsto C)\\) <code>Pi</code> \\(= 3.1415...\\) Unary \\(E^f            \\mapsto (x \\mapsto f(x))\\) <code>Div</code> in <code>Pi | Div(2) | Sin</code>\\(= 1\\) Binary\u2081 \\(E^*            \\mapsto ([x, y] \\mapsto x * y )\\) <code>Add</code> in <code>[2,2] | Add</code> \\(= 4\\) Binary\u2082 \\(E^*(y)         \\mapsto (x \\mapsto x * y      )\\) <code>Eq</code> in <code>13 | Eq(42)</code> \\(= false\\) Binary\u2083 \\(E^*            \\mapsto (x \\mapsto x * default)\\) <code>Max</code> in <code>[-1,1] | Max</code> \\(= 1\\) Variadic \\(E^f(a,b,c,...) \\mapsto (x \\mapsto f(a,b,c,...)(x))\\) <code>All</code> in <code>6 | All(Gt(5), Le(6))</code> \\(= true\\) Literal\u2081 Evaluated as Const where a value is expected <code>Map(Eq(0))</code> \\(\\not\\equiv\\) <code>Map(0)</code> Literal\u2082 Evaluated as <code>Eq(value)</code> where a predicate is expected <code>Filter(42)</code> \\(\\equiv\\) <code>Filter(Eq(42))</code> <p>The Const keywords are constant functions. They are syntactically equivalent to Unary, with the difference that constants will ignore the eval input value.</p> <p>Custom constants can be created with <code>Q</code> keyword, e.g. <code>Q(42)</code> or <code>Q(Add)</code>.</p> <p>JSON or JSON-convertible values produce a Literal form which is interpreted as a constants (Literal\u2081) or a predicate (Literal\u2082) depending on a context.</p> <p>Binary keywords have the most flexible syntax. The canonical Binary\u2081 form with no parameters like <code>Add</code> expects a pair of operands at eval input, but Binary\u2082 form like <code>Add(42)</code> essentially creates a curried unary functor with bound right-hand side operand. To curry a left-hand side operand instead, the <code>Flip</code> keyword may be helpful. This is especially useful for non-commutative operators, e.g.:</p> <ul> <li><code>2 | Div(1)</code> \\(= 2\\)</li> <li><code>2 | Flip(Div(1))</code> \\(= 0.5\\)</li> </ul> <p>For the Binary\u2081 the composition with <code>Reverse</code> can be utilized instead of <code>Flip</code> to get the proper commutation, as <code>Flip</code> only swaps the design-time and evaluation-time arguments, which differs from Haskell's <code>flip</code>.</p> <p>The predicates in Binary\u2082 form are very similar to GoogleTest matchers, e.g. <code>Eq(42)</code> or <code>Lt(0.5)</code>. It may also be helpful to view this form from an OOP perspective, considering it as a class method on evaluation-time argument object. E.g.,</p> <p><pre><code>input | At(1)\n</code></pre> is equivalent to <pre><code>input.At(1)\n</code></pre> in a generic OOP syntax.</p> <p>The Binary\u2083 form replaces the Binary\u2081 behavior for a small group of expressions that have the default rhs value, e.g. <code>Max(Id)</code> is equivalent to just <code>Max</code>, where the identity expression <code>Id</code> is a default parameter (a key function in this case).</p> <p>Evaluation of the unparametrized Variadic keywords follow the same rule as Binary\u2081 vs Binary\u2082, e.g. variadic <code>Fmt</code>:</p> <ul> <li><code>\"%s, %s!\" | Fmt(\"Hello\", \"world\")</code> \\(=\\) <code>\"Hello, world!\"</code></li> <li><code>[\"%s, %s!\", [\"Hello\", \"world\"]] | Fmt</code> \\(=\\) <code>\"Hello, world!\"</code></li> </ul>"},{"location":"user-guide/expressions/#parameter-evaluation","title":"Parameter evaluation","text":"<p>Design-time parameters are constant expressions. A simple use case is to utilize math constants like <code>Lt(Pi)</code>, but any complex expression can be used as long as it is constant, e. g. <code>Lt(Pi|Div(2))</code>.</p> <p>Parameter evaluation is lazy, s.t. in the ternary and-or idiom <code>condition | And(then) | Or(else)</code> the <code>else</code> part is only evaluated if <code>And(then)</code> produces falsy output.</p> <p>In the higher-order expressions parameters are passed unevaluated, similar to quoted expressions.</p>"},{"location":"user-guide/expressions/#preprocessing","title":"Preprocessing","text":"<p>The Expression API provides preprocessing functionality similar to C Preprocessor, s.t. any string literal starting with $ sign and enclosed in square brackets (e.g. <code>\"$[foo]\"</code>) is considered a macro. The macro substitution is done on Expression deserialization from raw JSON data, and user-defined parameter handling is delegated to the test model runners.</p>"},{"location":"user-guide/expressions/#error-handling","title":"Error handling","text":"<p>Expression evaluation is pure and non-throwing \u2014 errors are represented using the <code>Err</code> expression instead of throwing host-language exceptions. Terminal expressions, such as arithmetic or logical operators, do not process Err values but propagate them unchanged through the pipeline.</p> <p>To handle errors and control branching, expressions such as <code>Try</code>, <code>D</code> (<code>Default</code>), <code>IsErr</code>, and <code>Assert</code> are available.</p>"},{"location":"user-guide/expressions/#high-order-keywords-and-structural-transforms","title":"High-order keywords and structural transforms","text":"<p>Several keywords produce higher-order expressions that are useful for creating a more complex matchers or generators.</p> <p>The most powerful in this group are <code>Pipe</code> and <code>Fork</code>. In addition to what is described above, composition also applies a special rule to literals beyond the initial term - they are interpreted as predicates, e.g. <code>[1,2,3] | Size | 3</code> is equivalent to <code>[1,2,3] | Size | Eq(3)</code>. To treat literal <code>3</code> as a constant expression, quote it as <code>Q(3)</code>.</p> <p>Other useful keywords are:</p> <ul> <li><code>Filter</code>, <code>Map</code>, <code>Fold</code> - similar to Python functools, e.g.:     <pre><code>[\n   [1, \"one\"  ],\n   [3, \"two\"  ],\n   [2, \"three\"],\n   [4, \"four\" ],\n] | Filter(At(1)|Lt(3)) | Map(At(0)) |-&gt; [\"one\", \"two\"]\n</code></pre></li> <li><code>At</code>, <code>Transp</code>, <code>Slide</code> - powerful data transformers, e.g.:<ul> <li><code>Slide(3)|Map(Avg)</code>: moving average with step width = 3</li> <li><code>At(\"key\")</code>, <code>At(0)</code> - simple element getters</li> <li><code>At(\"/foo/bar\")</code> - JSON pointer query</li> <li><code>At(\"::2\")</code> - array slice query</li> </ul> </li> <li><code>Saturate</code>, <code>All</code>, <code>Any</code>, <code>Count</code> - matcher building elements</li> <li><code>Recur</code>, <code>Unfold</code> - recursion handlers with exit condition:<ul> <li><code>Q(Ge(12)) | Recur( 4 &amp; Add(1))</code> \\(= 11\\)</li> <li><code>Q(Ge(12)) | Unfold(8 &amp; Add(1))</code> \\(= [8,9,10,11]\\)</li> </ul> </li> </ul> <p>For the complete information see Expression Language Reference.</p>"},{"location":"user-guide/expressions/#symbolic-linking","title":"Symbolic linking","text":"<p> This feature is in prototype state </p> <p>As a step aside from tacit style, Expressions support two levels of symbolic linking using $-prefixed strings as references.</p>"},{"location":"user-guide/expressions/#eval-level-linking","title":"Eval-level linking","text":"<pre><code>\"$x\" | Ne(0) | And(\"$x\" | Flip(Div(1))) | Or(\"$x\")\n</code></pre> <p>In this example the first encounter of <code>\"$x\"</code> will store the argument in isolated evaluation context and pass to the consequent term, making it available to all subexpressions, s.a. <code>And(\"$x\" | ...)</code> (recall that expression parameters computation is lazy).</p>"},{"location":"user-guide/expressions/#design-level-linking","title":"Design-level linking","text":"<pre><code>\"$f\" &lt;&lt; (\"$x\"\n   | Assert(Ge(0))\n   | Lt(2)\n   | And(1)\n   | Or(\"$x\" &amp; (\"$x\" | Sub(1) | \"$f\") | Mul)\n);\n</code></pre> <p>This example constructs a recursive factorial function using &lt;&lt; as an assignment operator. As with <code>\"$x\"</code>, the <code>\"$f\"</code> link is accessible in all subsequent subexpressions. From an implementation perspective, it behaves like a <code>goto</code> - the evaluation context stores a view of the expression (an AST pointer), so no design-time data is copied.</p> <p>Note</p> <p>Note that the evaluation context does not yet support local scoping, so any recursive <code>\"$f\"</code> invocation updates the same <code>\"$x\"</code> value. Because of this, \"$x\" is not used directly inside the final Mul expression. With the local scoping implemented, the equivalent expression would be <pre><code>Or(\"$x\" | Sub(1) | \"$f\" | Mul(\"$x\"))\n</code></pre></p>"},{"location":"user-guide/expressions/#quotation","title":"Quotation","text":"<p>The keyword <code>Q</code> (aliases: C, Const) serves as a quotation operator, similar to Lisp\u2019s quote. It lifts its parameter into a constant expression, preventing evaluation.</p> <p>This allows you to pass expressions as values to <code>Eval</code> or <code>~Bind(...)</code>, or to escape the special treatment of $-prefixed strings in parameters: <pre><code>\"$x\" | Eq(Q(\"$x\"))\n</code></pre></p>"},{"location":"user-guide/expressions/#debug-and-trace","title":"Debug and Trace","text":"<p>Consider the following example:</p> <pre><code>auto const f = Debug(Reduce(Add) &amp; Size | Div);\nauto const x = L{1,2,3,42.5};\nBOOST_CHECK_EQUAL(f.eval(x), 12.125);\n</code></pre> <p>When log level is set to <code>DEBUG</code> or higher, the following evaluation log is printed:</p> <pre><code>2025-07-20T14:04:14.485827201Z DEBUG ZMBT_EXPR_DEBUG\n           \u250c\u2500\u2500 Add $ [1,2] = 3\n           \u251c\u2500\u2500 Add $ [3,3] = 6\n           \u251c\u2500\u2500 Add $ [6,4.25E1] = 4.85E1\n        \u250c\u2500\u2500 Fold(Add) $ [1,2,3,4.25E1] = 4.85E1\n        \u251c\u2500\u2500 Size $ [1,2,3,4.25E1] = 4\n     \u250c\u2500\u2500 Fold(Add) &amp; Size $ [1,2,3,4.25E1] = [4.85E1,4]\n     \u251c\u2500\u2500 Div $ [4.85E1,4] = 1.2125E1\n  \u25a1  (Fold(Add) &amp; Size) | Div $ [1,2,3,4.25E1] = 1.2125E1\n</code></pre> <p>Log lines are formatted as <code>f $ x = result</code>, and connected with line-drawing to show the expression terms hierarchy.</p> <p>In model tests, the evaluation is logged on failing tests by default.</p> <p>Another debugging utility keyword is <code>Trace</code>, which works like <code>Id</code> but also prints it's parameter to the call. It can be combined with <code>ZMBT_CUR_LOC</code> macro to trace mock invocations:</p> <pre><code>auto const f = Trace(ZMBT_CUR_LOC) | Reduce(Add) &amp; Size | Div;\nauto const x = L{1,2,3,42.5};\n</code></pre> <p>outputs</p> <pre><code>zmbt-framework/backends/cxx/test/expr_api.cpp#1010 [1,2,3,4.25E1]\n</code></pre> <p>to the log.</p> <p>The <code>Debug</code> keyword respects nesting - you can use it on different levels on the same expression, possibly chaining with <code>Trace</code> to distinguish subexpressions, e.g.</p> <pre><code>40 | Debug(Trace(\"foo\") | Add(2) | Debug(Trace(\"bar\") | Sub(2)))\n</code></pre> <p>produces</p> <pre><code>2025-07-21T20:55:32.037990154Z DEBUG ZMBT_EXPR_DEBUG\n     \u250c\u2500\u2500 Trace(\"bar\") $ 42 = 42\n     \u251c\u2500\u2500 Sub(2) $ 42 = 40\n  \u25a1  Trace(\"bar\") | Sub(2) $ 42 = 40\n\n2025-07-21T20:55:32.038143599Z DEBUG ZMBT_EXPR_DEBUG\n     \u250c\u2500\u2500 Trace(\"foo\") $ 40 = 40\n     \u251c\u2500\u2500 Add(2) $ 40 = 42\n     \u2502      \u250c\u2500\u2500 Trace(\"bar\") $ 42 = 42\n     \u2502      \u251c\u2500\u2500 Sub(2) $ 42 = 40\n     \u2502   \u250c\u2500\u2500 Trace(\"bar\") | Sub(2) $ 42 = 40\n     \u251c\u2500\u2500 Dbg(Trace(\"bar\") | Sub(2)) $ 42 = 40\n  \u25a1  Trace(\"foo\") | Add(2) | Dbg(Trace(\"bar\") | Sub(2)) $ 40 = 40\n</code></pre>"},{"location":"user-guide/expressions/#line-trimming","title":"Line trimming","text":"<p>For the bulky log messages, elements are trimmed with <code>...</code> while trying to keep the evaluation result visible. This option can be disabled with <code>--zmbt_log_notrim</code> flag.</p>"},{"location":"user-guide/expressions/#grammar","title":"Grammar","text":"<pre>61c37abf7e531ca11218b7dd5f095202a2956dfe71d7544f2b9ee6eae0819bb48af1b8e1252094c5d0822630297e04e278d2457b30d7af05721f829f385150e4</pre><pre>caad8d7978089f87ef6688b050685c1a506ec138cccc584c21228e62a680b4497819f2486d3f17d99a92738769905cfb63f7f6d38422be8540e74c2f7cd1caac</pre>"},{"location":"user-guide/reflection/","title":"Reflection","text":""},{"location":"user-guide/reflection/#reflection-api","title":"Reflection API","text":"<p> This document is in progress </p> <p>Currently, ZMBT does not require complete type reflection. The <code>SignalMapping</code> tests rely solely on signal serialization and default value initialization. Future updates will ensure interoperability with Boost C++ libraries that provide data reflection capabilities.</p> <p>To operate on test data and interfaces within the test model, the framework utilizes the following metafunctions in the <code>zmbt::reflect</code> namespace:</p> <ul> <li><code>serialization&lt;T&gt;</code>: JSON serialization and deserialization for type <code>T</code>.</li> <li><code>signal_traits&lt;T&gt;</code>: Default values for type <code>T</code>.</li> <li><code>invocation&lt;T&gt;</code>: Type traits and a runtime <code>apply</code> method for callable type <code>T</code>.</li> </ul> <p>For customization, specialize the metafunctions <code>zmbt::reflect::custom_*&lt;T, E = void&gt;</code>, as detailed below. The template parameter <code>E</code> serves as an optional SFINAE enabler.</p>"},{"location":"user-guide/reflection/#serialization","title":"Serialization","text":"<p>Serialization is based on Boost.JSON, and it can be enabled by following the Boost.JSON API. However, the recommended approach is to use the metafunction <code>zmbt::reflect::custom_serialization&lt;T, E = void&gt;</code>. This enables serialization independently of Boost.JSON, preventing argument-dependent lookup pollution in the tested system (see the example in demo_hermetic_serialization.cpp). This is particularly useful when user data already has defined serialization that is unsuitable for testing or when template types in tests are not expected to be serializable in the SUT context.</p> <pre><code>template &lt;class T&gt;\nstruct zmbt::reflect::custom_serialization&lt;T, std::enable_if_t&lt;my_trait&lt;T&gt;&gt;&gt; {\n    // Convert T to JSON\n    static boost::json::value json_from(const T&amp; t);\n    // Convert JSON to T\n    static T dejsonize(const boost::json::value&amp; v);\n};\n</code></pre> <p>For simpler serialization, use the Boost.Describe:</p> <pre><code>namespace sut {\nBOOST_DESCRIBE_STRUCT(Point, (), (x, y))\nBOOST_DESCRIBE_ENUM(Enum, A, B)\n} // namespace sut\n</code></pre> <p>Support for other Boost reflection libraries may be added in the future.</p> <p>Note that <code>zmbt::reflect::serialization</code> is not intended for direct use. Instead, use <code>zmbt::json_from</code> and <code>zmbt::dejsonize</code>, which fall back to Boost.JSON when no default or custom conversions are defined.</p> <p>To enable full interoperability with Boost.JSON for user data types, use the following macros to inject <code>tag_invoke</code> and <code>operator&lt;&lt;</code>:</p> <ul> <li><code>ZMBT_INJECT_JSON_TAG_INVOKE</code></li> <li><code>ZMBT_INJECT_OSTREAM_OPERATOR</code></li> <li><code>ZMBT_INJECT_SERIALIZATION</code> (wraps both <code>tag_invoke</code> and <code>operator&lt;&lt;</code>)</li> <li><code>ZMBT_INJECT_JSON_TAG_INVOKE_INTO(...)</code> - pass nested namespaces as list</li> <li><code>ZMBT_INJECT_OSTREAM_OPERATOR_INTO(...)</code></li> <li><code>ZMBT_INJECT_SERIALIZATION_INTO(...)</code></li> </ul>"},{"location":"user-guide/reflection/#signal-traits","title":"Signal Traits","text":"<p>This metafunction currently provides initial signal values for models and the environment. Use <code>reflect::custom_signal_traits</code> to provide initial values for types without a default constructor or to specify custom default values for testing.</p> <p>Future updates may extend this metafunction to include other traits, such as boundary values.</p> <pre><code>template &lt;&gt;\nstruct zmbt::reflect::custom_signal_traits&lt;MySignal&gt; {\n    static constexpr MySignal init() {\n        return MySignal{/* parameters for default test value */};\n    }\n};\n\n// Macros for simpler cases:\nZMBT_DEFINE_CUSTOM_INIT(MySignal, (...))\n</code></pre>"},{"location":"user-guide/reflection/#invocation","title":"Invocation","text":"<p>This metafunction provides type information about interface invocation details and a runtime <code>apply</code> method, which is useful for model triggers.</p> <p>The default invocation covers most use cases: free functions, functor objects with a single <code>operator()</code>, and member functions. Customization may be necessary for edge cases, such as handling unserializable signal types.</p> <pre><code>template &lt;&gt;\nstruct zmbt::reflect::custom_invocation&lt;void(*)(MySignal*)&gt; {\n    using type     = void(*)(MySignal*);\n    using host_t   = void;\n    using return_t = void;\n    using args_t   = std::tuple&lt;MySignal&amp;&gt;;\n\n    template &lt;class Ignore&gt;\n    static return_t apply(Ignore, type ifc, args_t args) {\n        MySignal&amp; value_out = std::get&lt;0&gt;(args);\n        return ifc(&amp;value_out);\n    }\n};\n</code></pre> <p>This example transforms a function of type <code>(MySignal*) -&gt; void</code> into <code>(MySignal&amp;) -&gt; void</code>, allowing the framework to handle interfaces that involve pointers, which are not supported by default.</p>"},{"location":"user-guide/signal-mapping/","title":"Signal Mapping Model","text":""},{"location":"user-guide/signal-mapping/#signal-mapping-model","title":"Signal Mapping model","text":"<p>Signal Mapping models the interaction with the system under test (SUT) as a trace-level mapping from generated input sequences to observable outputs, evaluated via matchers. While the SUT may retain internal state or side effects, the test model abstracts it as a function over time, capturing only what is exposed through interfaces.</p> <p>Instead of embedding logic in procedural test code, the framework defines inputs, outputs, and expectations as condition pipes \u2014 structured, composable expressions tied to interface contracts. It shifts focus from \u201cwhat happens when\u201d to \u201cwhat is observed where\u201d, utilizing powerful and expressive generators and matchers, and structural introspection of the test model.</p> <p>Its embedded DSL enforces valid composition rules and eliminates ambiguity, guiding users toward correct-by-construction test designs and making misconfigurations easier to catch \u2014 often at compile time.</p> <p>The following guide illustrates the model DSL using code examples from examples/cxx/signal-mapping-demo.cpp. For complete documentation, refer to the Signal Mapping DSL Reference.</p>"},{"location":"user-guide/signal-mapping/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/signal-mapping/#requirements","title":"Requirements","text":"<ul> <li>C++ 14 or later</li> <li>Boost C++ 1.84 or later</li> </ul> <pre><code>*/\n\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n\n#include &lt;boost/test/unit_test.hpp&gt; //(1)\n#include &lt;zenseact-mbt.hpp&gt;\n\nnamespace utf = boost::unit_test;\nusing namespace zmbt::api;  //(2)\nusing namespace zmbt::expr; //(3)\n\nusing namespace std::literals::chrono_literals;\n\n/*\n</code></pre> <ol> <li>These examples use Boost.Test as a host framework, but ZMBT can be embedded into any other. A standalone suite runner is also in development.</li> <li>Main testing API namespace</li> <li>Expression Language namespace</li> </ol>"},{"location":"user-guide/signal-mapping/#minimal-example","title":"Minimal Example","text":"<pre><code>*/\nBOOST_AUTO_TEST_CASE(QuickExample)\n{\n    auto sum = [](int x, int y){ return x + y; };\n\n    SignalMapping(\"Simple function test\")\n    .OnTrigger(sum)\n        .At(sum) .Args(0)  .Inject()\n        .At(sum) .Args(1)  .Inject()\n        .At(sum) .Return() .Expect()\n    .Test\n        ( 2,  2,  4 )\n        ( 2, -2,  0 )\n    .Description(\"inject x and y and check returning sum\")\n    ;\n}\n/*\n</code></pre> <p>This example defines a basic signal mapping model with two inputs and one output.</p> <ul> <li><code>OnTrigger(sum)</code> defines the entry point: the function under test.</li> <li><code>At(sum).Args(n).Inject()</code> maps inputs by position in the argument tuple.</li> <li><code>At(sum).Return().Expect()</code> defines the expected output to observe.</li> </ul> <p>The <code>.Test(...)</code> clause defines list of test vectors using chained operator() calls. Each column corresponds 1:1 with an input or output channel defined in the pipe configuration above.</p> <p>In this case, the runner:</p> <ol> <li>Takes the first two values as inputs to sum</li> <li>Calls <code>sum(x, y)</code></li> <li>Checks whether the result matches the third value</li> </ol> <p>The Test clause defines a list of test vectors using cascade of <code>operator()</code> calls, where each line represents one test case. The <code>At(sum)...</code> lines form a list of signal pipes, which can be viewed as headers for the corresponding columns in the test matrix. The channel-to-column indexation is 1-to-1 for pipes with empty <code>Inject()</code> or <code>Expect()</code> clauses;</p> <p>For each test case, the runner invokes <code>sum</code> with the first two values as inputs and checks whether the result matches the third value.</p> <p>The same test can be expressed with a single channel for both input arguments: <pre><code>*/\nBOOST_AUTO_TEST_CASE(NonScalarValues)\n{\n    auto sum = [](double x, double y){ return x + y; };\n\n    SignalMapping(\"Simple test with non-scalar input\")\n    .OnTrigger(sum)\n        .At(sum) .Inject()\n        .At(sum) .Expect()\n    .Test\n        ( { 2,   2},    4 )\n        ( { 2,  -2},    0 )\n        ( {42, 0.1}, 42.1 )\n    ;\n}\n/*\n</code></pre></p> <p>Following the default configuration rules, <code>.At(sum).Inject()</code> is equivalent to <code>.At(sum).Args(\"\").Inject()</code> for non-unary triggers. This means the entire argument tuple is treated as a JSON array and passed as a single value.</p>"},{"location":"user-guide/signal-mapping/#basic-concepts","title":"Basic Concepts","text":""},{"location":"user-guide/signal-mapping/#structure-overview","title":"Structure Overview","text":"<p>Signal Mapping tests are defined declaratively using a Domain-Specific Language (DSL) embedded in C++. Each test case specifies how the system under test (SUT) is exercised and observed using the following elements:</p> <ul> <li>Clauses \u2014 chained method calls that define test configuration.</li> <li>Trigger \u2014 the interface that initiates test execution.</li> <li>Test Conditions \u2014 input generators and output matchers.</li> <li>Channels \u2014 individual signal selectors associated with interface.</li> <li>Condition Pipes \u2014 combinations of channels that share a test condition.</li> </ul>"},{"location":"user-guide/signal-mapping/#pipes-and-channels","title":"Pipes and Channels","text":"<ul> <li>A channel represents a specific interface point (e.g., function input, return, or exception) with optional filters.</li> <li>A pipe is a group of one or more channels that share the same condition.</li> <li>Channels can be grouped into pipes using <code>.Group()</code> or <code>.Blend()</code> to express different composition logic (see below).</li> </ul> <pre><code>// One-channel pipe\n.At(f).Args(0).Inject(42);\n\n// Multi-channel pipe\n.At(x).Args(0).Group().At(y).Args(0).Inject(42);\n</code></pre>"},{"location":"user-guide/signal-mapping/#test-conditions","title":"Test Conditions","text":"<p>An input condition is a generating function \u2014 a mapping from the call index to a value. An output condition is a matcher \u2014 a predicate that maps an observed value to a boolean result.</p> <p>Literals, constants, and constant expressions are interpreted differently depending on context:</p> <ul> <li>Input: constants are treated as a subset of generators that always return the same value. See Input generators.</li> <li>Output: constants are implicitly converted to equality matchers (<code>Eq(value)</code>).</li> </ul> <p>The embedded expression language supports constructing conditions of arbitrary complexity in both input and output contexts.</p> <p>Test conditions can be specified:</p> <ul> <li>Inline, directly on pipes using <code>.Inject</code> and <code>.Expect*</code> or <code>.Assert*</code> clause parameters, or</li> <li>Externally, using the <code>.Test</code> clause to provide tabular test vectors.</li> </ul>"},{"location":"user-guide/signal-mapping/#1-inline-conditions","title":"1. Inline Conditions","text":"<p>Attach expressions directly to the pipe using <code>.Inject</code> or <code>.Expect</code>.</p> <p><pre><code>*/\nBOOST_AUTO_TEST_CASE(InlineConditions)\n{\n    auto sum = [](double x, double y){ return x + y; };\n\n    SignalMapping(\"Inline condition example\")\n    .OnTrigger(sum).Repeat(100) //(1)\n        .At(sum).Args(0).Inject(42) //(2)\n        .At(sum).Args(1).Inject(Add(1)) //(3)\n        .At(sum).Return().Expect(Each(Ge(42))) //(4)\n        .At(sum).Return().Expect(Slide(2) | Each(Lt)) //(5)\n    ;\n}\n/*\n</code></pre> 1. Repeat sum 100 times and apply matchers to an array of collected outputs instead of an atomic value 2. The first argument is fixed to 42. 3. The second input increments per call. 4. Check all outputs are &gt;= 42 5. Check the output is increasing using sliding window matcher</p>"},{"location":"user-guide/signal-mapping/#2-tabular-conditions","title":"2. Tabular Conditions","text":"<p>Leave <code>.Inject()</code> or <code>.Expect()</code> empty, and use <code>.Test</code> to supply values:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(TabularConditions)\n{\n    auto sum = [](double x, double y){ return x + y; };\n\n    SignalMapping(\"Tabular condition example\")\n    .OnTrigger(sum).Repeat(100)\n        .At(sum).Args(0).Inject()\n        .At(sum).Args(1).Inject()\n        .At(sum).Return().Expect()\n        .At(sum).Return().Expect()\n    .Test\n        ( 42, Add(1) , Each(Ge(42)), Slide(2) | Each(Lt) )\n        ( 13, Mul(-1), Each(Le(13)), At(-1) | Lt(0)      )\n    ;\n}\n/*\n</code></pre> <p>Each value in a test vector under <code>.Test</code> clause corresponds to one tabular pipe, by the order of declaration.</p>"},{"location":"user-guide/signal-mapping/#3-mixed-mode","title":"3. Mixed Mode","text":"<p>Mix inline and tabular pipes in the same test:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(MixedConditions)\n{\n    auto sum = [](double x, double y){ return x + y; };\n\n    SignalMapping(\"Mixed condition example\")\n    .OnTrigger(sum)\n        .At(sum).Args(0).Inject(42)    // Fixed\n        .At(sum).Args(1).Inject()      // Tabular\n        .At(sum).Return().Expect()     // Tabular\n    .Test\n        (  1, 43 )\n        ( -1, 41 )\n    ;\n}\n/*\n</code></pre> <p>Here, <code>.Inject(42)</code> is constant across all test cases, while the second input and output vary per row.</p>"},{"location":"user-guide/signal-mapping/#test-procedure","title":"Test Procedure","text":"<p>The following procedure is applied to each model instance obtained from the parameter resolver over each test vector:</p> <ol> <li>Reset the environment (drop all input test data).</li> <li>Execute pre-run tasks.</li> <li>Inject the input generators into the environment.</li> <li>Execute the trigger.</li> <li>Observe the responses captured in the environment and verify them against expectations.</li> <li>Execute post-run tasks.</li> <li>Report the results.</li> </ol>"},{"location":"user-guide/signal-mapping/#advanced-topics","title":"Advanced Topics","text":""},{"location":"user-guide/signal-mapping/#expressions","title":"Expressions","text":"<p>The framework provides an embedded functional programming language that enables flexible matchers and more complex test data manipulation:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(ExpressionsExample)\n{\n    auto id = [](boost::json::value const&amp; x){ return x; };\n\n    SignalMapping(\"Expressions example\")\n    .OnTrigger(id)\n        .At(id).Inject()\n        .At(id).Expect()\n    .Test\n        ( 42                , Eq(42)                             )\n        ( 42                , 42     /*(1)*/                     )\n        ( {1,2,3}           , Size|3 /*(2)*/                     ) [\"Expect structure size equal 3\"] //(3)\n        ( {1,2,3}           , Saturate(1, Ne(1), Ge(2)) /*(4)*/  )\n        ( {1,2,3,4}         , Fold(Add) &amp; Size | Div | Eq(2.5)   ) //(5)\n        ( Pi | Div(2) | Sin , Approx(1)                          ) //(6)\n        ( Pi | ~Div(1)      , Approx(1.0/3.14159265359)          ) //(7)\n        ( \"5:1:-1\" | Arange , {5,4,3,2}                          ) //(8)\n    ;\n}\n/*\n</code></pre> <ol> <li><code>Eq</code> may be omitted in the context of predicate.</li> <li>Expression composition with pipe operator. Equivalent to <code>Pipe(Size, Eq(3))</code>.</li> <li>Optional comment.</li> <li>Saturate the matchers over sequence input in given order.</li> <li>Ampersand operator packs evaluation into array as <code>f &amp; g \u21a6 x \u21a6 [f(x), g(x)]</code>.     Output is processed as <code>(((Reduce(Add) &amp; Size) | Div) | Eq(2.5))</code>     in the following steps:<ol> <li><code>Reduce(Add) &amp; Size</code> on input <code>[1,2,3,4]</code> produces [10, 4]</li> <li><code>Div</code> on input <code>[10, 4]</code> produces [2.5]</li> <li><code>Eq(2.5)</code> on input <code>[2.5]</code> produces <code>true</code></li> </ol> </li> <li>A constant function can be used on input channel instead of literal</li> <li>Flip expression (prefix ~) swaps the operands, which is useful for non-commutative transforms</li> <li><code>Arange</code> is a generator similar to     numpy.arange</li> </ol> <p>For more detailes, see Expression Guide and Expression Language Reference.</p>"},{"location":"user-guide/signal-mapping/#input-generators","title":"Input generators","text":"<p>Inputs in SignalMapping are not limited to fixed values - they can be dynamic generators that produce a new value on each call, created from expressions of type \\(\\mathbb{N}^0 \\mapsto JSON\\), (aka indexed families).</p> <p>A constant input like <code>Inject(42)</code> is just a trivial generator that ignores the index. Generators allows to define input streams that evolve over time, for example:</p> <ul> <li><code>Add(1)</code> \\(\\mapsto 1, 2, 3, ...\\)</li> <li><code>Format(\"item_%d\", Id)</code> \\(\\mapsto\\) <code>\"item_0\", \"item_1\", ...</code></li> </ul> <p>Internally, the framework keeps track on generator counters and allocation to channels. On each interface call, either trigger or mock, the test runner pulls values from a set of allocated generators and compose a returning value. In <code>Blend</code> pipes, the test condition is a unique generator shared between all pipe channels, See Combining channels in pipes for details.</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(InputsGenerators)\n{\n    auto const id = [](boost::json::value const&amp; x) { return x; };\n\n    SignalMapping(\"Input generators\")\n    .OnTrigger(id).Repeat(3)\n        .At(id)             .Inject()\n        .At(id)             .Expect()\n    .Test\n        (42/*(1)*/          , {42, 42, 42}         )\n        (Pi/*(2)*/          , At(0)|Approx(3.14159))\n        (Add(42)/*(3)*/     , {42, 43, 44}         )\n        (Lookup({1,2})|D(42), {1,2,42}             )//(4)\n    ;\n}\n/*\n</code></pre> <ol> <li>Top level JSON literal input stands for constant, a canonical form would be <code>C(42)</code></li> <li>Mathematical constant</li> <li>Simple generating function</li> <li>Lookup function with Default 42 as generator</li> </ol>"},{"location":"user-guide/signal-mapping/#order-matters","title":"Order matters","text":"<p>The input injections are evaluated in the order of their definition in a channel list, with exception that all inline inuts evaluated before tabular inputs (so it is recommended to group them at the beginning for clarity).</p> <p>The injection may be overwritten fully or partially by the following injections when channels share the same interface and selector.</p> <p>The input evaluation order can be utilized to do some preparations before injecting more specific subsignal. It is especially useful with dynamic structures like STL containers or variant types like boost::json::value itself.</p> <p>E.g. having an interface with vector input, <pre><code>auto sut = [](std::vector&lt;int&gt; const&amp; x){ ... };\n</code></pre> we may need to initialize a non-empty input before injecting to speciic elements:</p> <pre><code>    .At(sut) .Args(\"/0\").Inject(0|Repeat(64))\n    .At(sut) .Args(\"/0/1\") // (1)\n</code></pre> <ol> <li>Injecting to the second element will fail without the previous line, as the default vector is empty.</li> </ol>"},{"location":"user-guide/signal-mapping/#output-matchers","title":"Output matchers","text":"<p>Output condition are matchers of type \\(JSON \\mapsto bool\\) (predicates).</p> <p>In this context, any constant expression like <code>42</code> is interpreted as an equality check: <code>Expect(42)</code> is equivalent to <code>Expect(Eq(42))</code>.</p> <p>ZMBT provides several matcher clauses with varying behavior:</p> <ul> <li><code>Expect</code> records matcher failure but allows the test to continue.</li> <li><code>Assert</code>  triggers an immediate failure, stopping execution.</li> </ul>"},{"location":"user-guide/signal-mapping/#series-vs-atomic-samples","title":"Series vs atomic samples","text":"<p>The <code>Expect</code> or <code>Assert</code> clauses provide captured sample series directly to the matcher.</p> <p>For convenience, the output is implicitly flattened (i.e., [x] becomes x) in the following cases:</p> <ul> <li>The channel has a CallCount clause.</li> <li>The channel is bound to a trigger interface and the Repeat clause is not set.</li> </ul> <p>This implicit flattening improves ergonomics:</p> <p><pre><code>OnTrigger(f)\n    .At(f).Expect(42);\n</code></pre> vs <pre><code>OnTrigger(f).Repeat(N)\n    .At(f).Expect(Each(Eq(42)));\n</code></pre></p> <p>Specifying <code>Repeat(1)</code> explicitly disables flattening on trigger channels.</p>"},{"location":"user-guide/signal-mapping/#json-serialization","title":"JSON Serialization","text":"<p>ZMBT internally operates on JSON data, using Boost.JSON as the backend. All injected inputs, observed outputs, and expressions are evaluated in terms of JSON values. This means that any type used in the model shall be serializable to and from JSON. Out of the box, it works for fundamental types and STL containers, and any user-defined types can be supported with Boost.Describe library or by specializing <code>zmbt::reflect::custom_serialization</code> template (see Reflection guide).</p>"},{"location":"user-guide/signal-mapping/#json-pointer","title":"JSON Pointer","text":"<p>ZMBT supports signal path addressing using JSON Pointer strings. This allows fine-grained control over which subsignals (fields or array elements) are injected or matched:</p> <pre><code>.At(sut).Args(\"/0/foo/bar\")  .Inject()\n.At(sut).Args(\"/1/foo/bar\")  .Inject()\n.At(sut).Return(\"/foo/bar\")  .Expect()\n</code></pre> <p>Each path refers to a subsignal within the arguments or return value. The pointer syntax resembles Unix-style paths, with key differences:</p> <ul> <li><code>\"\"</code> (empty string) means the root of the JSON structure.</li> <li><code>\"/\"</code> addresses anonymous fields.</li> <li><code>\"/0\"</code>, <code>\"/1\"</code> refer to elements in the argument tuple (index-based).</li> </ul> <p>Recall the default behavior:</p> <p>Unary function arguments resolve to path <code>\"/0\"</code>, making scalar injection and observation intuitive.</p>"},{"location":"user-guide/signal-mapping/#custom-types","title":"Custom Types","text":"<p>ZMBT uses Boost.JSON with Boost.Describe to serialize and access custom C++ types:</p> <pre><code>*/\nnamespace {\nenum class Foo { A, B, C };\n\nstruct Bar {\n    Foo foo;\n    int x;\n    Bar() = delete;\n    Bar(Foo br, int x) : foo{br}, x{x} {}\n};\n\nBOOST_DESCRIBE_ENUM(Foo, A, B, C) //(1)\nBOOST_DESCRIBE_STRUCT(Bar, (void), (foo, x)) //(2)\nZMBT_INJECT_JSON_TAG_INVOKE //(3)\n}\n\nZMBT_DEFINE_CUSTOM_INIT(Bar, (Foo::A, 0)) //(4)\n/*\n</code></pre> <ol> <li>Boost.Describe reflection for enum <code>Foo</code>.</li> <li>Boost.Describe struct support for <code>Bar</code> (with no base class).</li> <li>JSON serialization support via argument-dependent lookup.</li> <li>Default initialization for custom types, required for signals with deleted default constructor.</li> </ol> <p>Example usage:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(UserDataTypes)\n{\n    auto sut = [](Bar a, Bar b) {\n        Foo foo = a.x &gt; b.x ? a.foo : b.foo;\n        int x = a.x + b.x;\n        return Bar {foo, x};\n    };\n\n    SignalMapping(\"Test Call\")\n    .OnTrigger(sut)\n        .At(sut).Args(\"/0/x\")   .Inject()\n        .At(sut).Args(\"/1/x\")   .Inject()\n        .At(sut).Args(\"/0/foo\") .Inject()\n        .At(sut).Args(\"/1/foo\") .Inject()\n        .At(sut).Return(\"/foo\") .Expect()\n    .Test\n        (1, 0, Foo::A, Foo::B, Foo::A)\n        (0, 1, Foo::A, Foo::B, Foo::B)\n    ;\n}\n/*\n</code></pre> <p>This test validates logic involving structured inputs and enum matching via JSON field access.</p>"},{"location":"user-guide/signal-mapping/#parametrized-paths","title":"Parametrized Paths","text":"<p><code>Args</code> and <code>Return</code> accept constant expressions, which are evaluated to a JSON pointer string or integer index. This allows dynamic construction of paths based on parameters:</p> <pre><code>.At(sut).Args(\"/%d/%s/bar\" | Fmt(Index, Field))\n// or printf-like overload:\n.At(sut).Args(\"/%d/%s/bar\", Index, Field)\n</code></pre> <p><code>Index</code> and <code>Field</code> can be constants or literals, as well as ZMBT model parameters which are resolved during test model instantiation.</p>"},{"location":"user-guide/signal-mapping/#operator-overloading","title":"Operator overloading","text":"<p>ZMBT serialization mechanism lacks type information, and Expressions by default operate on JSON values following a most intuitive interpretation of their type, e.g. pair of real numbers is treated as complex <code>[real, img]</code> in arithmetic operations.</p> <p><code>Overload</code> expression can be utilized to apply certain type-specific operators in expressions:</p> <pre><code>Overload(type&lt;Foo&gt;, f)\n</code></pre> <p>The operator handler constructed from <code>type&lt;Foo&gt;</code> tag will provide to the enveloped <code>f</code> expression all existing operators for this type. If specific type does not support certain operators, they will be substituted with stubs that will fail in runtime without blocking compilation.</p> <p>The <code>.As</code> clause that precedes pipe condition can be used to specify the default overload per pipe to avoid repetition in <code>.Test</code> table. In addition to overloading, it also decorates the result of non-boolean constant expressions by piping it to Cast expression, reducing the conversion boilerplate in both inputs and outputs.</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(DecorUnderlying)\n{\n\n    auto const id = [](int x) -&gt; int { return x; };\n    using decor::Underlying;\n\n    SignalMapping(\"Decorate int -&gt; int as Foo -&gt; Foo\")\n    .OnTrigger(id)\n        .At(id).As(Underlying&lt;Foo&gt;).Inject()\n        .At(id).As(Underlying&lt;Foo&gt;).Expect()\n    .Test\n        (Foo::A              , Foo::A              )\n        (Foo::B              , Foo::B              )\n        (Foo::A              , Ne(Foo::B)          )\n        (Foo::B              , Ne(Foo::C)          )\n        (Foo::A | Add(Foo::B), Foo::B | Add(Foo::A))\n    ;\n\n\n    SignalMapping(\"Equivalent test with verbose casts and overloads\")\n    .OnTrigger(id)\n        .At(id).Inject()\n        .At(id).Expect()\n    .Test\n        (Foo::A | Cast(Underlying&lt;Foo&gt;), Cast(type&lt;Foo&gt;) | Eq(Foo::A))\n        (Foo::B | Cast(Underlying&lt;Foo&gt;), Cast(type&lt;Foo&gt;) | Eq(Foo::B))\n        (Foo::B | Cast(Underlying&lt;Foo&gt;), Cast(type&lt;Foo&gt;) | Eq(Foo::B))\n\n        (Foo::A | Cast(Underlying&lt;Foo&gt;), Cast(type&lt;Foo&gt;) | Ne(Foo::B))\n        (Foo::B | Cast(Underlying&lt;Foo&gt;), Cast(type&lt;Foo&gt;) | Ne(Foo::C))\n\n        (\n            Overload(Underlying&lt;Foo&gt;, Foo::A | Add(Foo::B)),\n            Eq(Overload(Underlying&lt;Foo&gt;, Foo::B | Add(Foo::A)))\n        )\n    ;\n}\n\n/*\n</code></pre> <p>In this example we utilize a signal decorator <code>zmbt::decor::Underlying</code>, that maps input Foo to int before passing to trigger function. Without this cast the test will yield an error on attempt to cast string representation of Foo:A to integer, or on trying to evaluate <code>Foo::A | Add(Foo::B)</code> as <code>Foo::A + Foo::B</code> rather then <code>static_cast&lt;std::underlying_t&lt;Foo&gt;(Foo::A) + static_cast&lt;std::underlying_t&lt;Foo&gt;(Foo::B)</code>.</p> <p>Note that in the verbose example the <code>Cast(Underlying&lt;Foo&gt;)</code> cannot be replaced with <code>Cast(type&lt;int&gt;)</code>, as the conversion is done on serialized JSON values and not on C++ types. The <code>Cast(type&lt;Foo&gt;)</code> in this context is equivalent to <code>Uncast(Underlying&lt;Foo&gt;)</code>.</p> <p>Any user-defined type can be used as an argument to <code>Overload</code> and <code>Cast/Uncast</code> expressions as <code>type&lt;MyType&gt;</code> tag. If default MyType JSON serialization is not sufficient for all test conversions, it is possible to customize it by creating a decorator class with <code>decorated_type</code> member type, that should provide non-explicit constructor and conversion operator for <code>decorated_type</code>.</p>"},{"location":"user-guide/signal-mapping/#mocks","title":"Mocks","text":"<p>So far, we\u2019ve used the same function reference for <code>OnTrigger</code> and <code>At</code> clauses. The reason each clause accepts a function reference is that you can also attach to mock interfaces, processing side effects the same way as trigger arguments and return values:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(SingletoneMock)\n{\n    struct Mock {\n        bool set_values(int&amp; x_out, int&amp; y_out) {\n            return InterfaceRecord(&amp;Mock::set_values) // (1)\n                .Hook(x_out, y_out);  // (2)\n        }\n    };\n\n    struct Sut {\n        Mock mock {}; // (3)\n        int operator()()\n        {\n            int x, y;\n            bool ok = mock.set_values(x, y);\n            return ok ? (x + y) : 0;\n        }\n    } sut {}; // (4)\n\n    SignalMapping(\"Test with mock\")\n    .OnTrigger(sut)\n        .At(&amp;Mock::set_values) .Return() .Inject() // (5)\n        .At(&amp;Mock::set_values) .Args(0)  .Inject() // (6)\n        .At(&amp;Mock::set_values) .Args(1)  .Inject()\n        .At(sut)               .Return() .Expect()\n    .Test\n        (true , 2,  2, 4)\n        (true , 2, -2, 0)\n        (false, 2,  2, 0) [\"values discarded when set_values returns false\"]\n    ;\n}\n/*\n</code></pre> <ol> <li>Access the <code>Environment</code> record associated with this interface</li> <li>Reroute call arguments to the <code>Environment</code></li> <li>A common way to inject mock into the sut is to separate mock interface and implementation,     and link the mocked implementation to the test executable.     For brevity we keep it simple in the present guide.     When using dependency injection, you may also utilize inheritance-based     mocks, as it is done in GMock.</li> <li>In this example the trigger is a functor - an object with a single <code>operator()</code> overload.</li> <li><code>Return()</code> clause observes the mock\u2019s return value.     This can be omitted - it\u2019s the default expansion for <code>At(mock)</code> channels.</li> <li><code>Args(index)</code> clause gives access to individual mock arguments by index.     <code>At(mock).Args(...).Inject()</code> will handle the mutable references as outputs,     but their incoming values are also accessible separately with <code>At(mock).Args(...).Expect()</code>.</li> </ol> <p>In this example, the stimuli are injected into the mock object rather than directly into the trigger.</p> <p>The mocking mechanism uses <code>InterfaceRecord</code>, which reroutes calls to the <code>Environment</code> - the central test harness state accessed by the test runner. This API works uniformly for all callables, including templates, deducing arguments and return type from callable signature.</p> <p>By default, the mock behaves as a singleton \u2014 all Mock instances delegate to the same record. If a singleton mock is not sufficient and you need to differentiate between multiple mock instances, you can pass an additional reference object to the <code>InterfaceRecord</code>. This allows the <code>Environment</code> to distinguish calls from separate instances:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(MultiInstanceMock)\n{\n    struct Mock {\n        void set_value(int&amp; x) const {\n            return InterfaceRecord(&amp;Mock::set_value, this) // (1)\n                .Hook(x);\n        }\n    };\n\n    struct ConsumeAndSubstract {\n        Mock const&amp; mock_x;\n        Mock const&amp; mock_y;\n\n        ConsumeAndSubstract(Mock const&amp; mx, Mock const&amp; my) : mock_x{mx}, mock_y{my} {}\n\n        int operator()() {\n            int x, y;\n            mock_x.set_value(x);\n            mock_y.set_value(y);\n            return x - y; //(2)\n        }\n    };\n\n    Mock mock_x {};\n    Mock mock_y {};\n    ConsumeAndSubstract sut {mock_x, mock_y};\n\n    SignalMapping(\"Test with multi-instance mock\")\n    .OnTrigger(sut)\n        .At(&amp;Mock::set_value, mock_x) .Args() .Inject()\n        .At(&amp;Mock::set_value, mock_y) .Args() .Inject()\n        .At(sut) .Expect()\n    .Test\n        ( 2,  2,  0)\n        ( 2, -2,  4)\n        (-2,  2, -4)\n    ;\n}\n/*\n</code></pre> <ol> <li>The <code>this</code> pointer is used as a reference object here, but it can be any     <code>void*</code> pointer - it simply serves as an identifier to find the interface     record in the <code>Environment</code>. The default reference object is <code>nullptr</code>.</li> <li>Using non-commutative op here to demonstrate the mock instance tracing.</li> </ol> <p>Example of using string key instead of this pointer to reference the mock instance in test:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(MockReferencingByString)\n{\n    struct Mock {\n        std::string const id_;\n\n        Mock(std::string const id) : id_{id} {}\n\n        void foo() {\n            return InterfaceRecord(&amp;Mock::foo, id_).Hook();\n        }\n    };\n\n    auto SUT = []{\n        Mock(\"lol\").foo();\n        Mock(\"kek\").foo();\n    };\n\n    SignalMapping(\"Test interface associated with string\")\n    .OnTrigger(SUT)\n        .At(&amp;Mock::foo, \"lol\").CallCount().Expect(1)\n        .At(&amp;Mock::foo, \"kek\").CallCount().Expect(1)\n    ;\n}\n/*\n</code></pre>"},{"location":"user-guide/signal-mapping/#parametrization","title":"Parametrization","text":"<p>The previous examples used invariant test models with all components and condition values hardcoded. The example below demonstrates how to define parametrized test models for greater flexibility and reusability:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(ZipParametrization)\n{\n    struct Mock {\n        void log(std::string msg) {\n            return InterfaceRecord(&amp;Mock::log).Hook(msg);\n        }\n    };\n\n    struct Sut {\n        Mock mock {};\n\n        void foo() { mock.log(\"Sut::foo\"); };\n        void bar() { mock.log(\"Sut::bar\"); };\n        void baz() { mock.log(\"Sut::baz\"); };\n    };\n\n    auto sut = std::make_shared&lt;Sut&gt;();\n\n    Param const Method  {\"test interface\"}; // (1)\n    Param const Name {\"interface name\"};\n\n\n    SignalMapping(\"Test with zip params on %s\", Name /*(2)*/)\n    .OnTrigger(Method, sut)\n        .At(&amp;Mock::log)\n            .Take(Last) // 3\n            .Expect(All(Contains(Name/*(4)*/), Contains(\"Sut\")))\n    .Zip // (5)\n        (Name   , \"Sut::foo\", \"Sut::bar\", \"Sut::baz\") // (6)\n        (Method , &amp;Sut::foo , &amp;Sut::bar , &amp;Sut::baz ) // (7)\n\n    .Description(\"Method: %s, Name: %s\", Method, Name) // (8)\n    ;\n}\n/*\n</code></pre> <ol> <li><code>Param</code> is a placeholder object with string or int identifier.     It must be unique within the test model. These identifiers are also     used for diagnostics and reporting, so meaningful names are encouraged.</li> <li>Strings can be parametrized as expressions, deferring the string formatting.</li> <li>Extracting captured value from series, as mock outputs are not flattened by default.</li> <li>Parameters can be nested deep in the expressions.</li> <li>Use <code>Zip</code> or <code>Pro</code> to generate multiple test instances with different parameter combinations.</li> <li>Each parameter list follows the syntax: \\((key, x_1, x_2, ..., x_n)\\).</li> <li>Any model element can be parametrized - including member function pointers.</li> <li>An optional test description clause.</li> </ol> <p>In this example, the <code>Zip</code> clause introduces model parametrization. Like <code>Test</code>, it initiates a list of parameters in an <code>operator()</code> cascade. Each row in this table begins with a parameter key (created with <code>Param</code>), followed by corresponding values.</p> <p>Before the model runner comes into play, the model resolver transforms such a definition into a series of invariant instances, resulting in three tests in this case.</p> <p>Another feature in this example is a channel parameters deduction - we can omit <code>Args(0)</code> and <code>Return()</code> clauses, as they are expanded by model resolver from the interface by the following rule:</p> <ul> <li>on trigger: inject to args and observe on return,</li> <li>on mock: inject to return and observe on args,</li> <li>unary function args resolves to value, the rest      resolve to the arguments tuple (more on this later).</li> </ul> <p>The <code>Zip</code> clause requires all parameter lists to be of equal length or containing a single element which intended to be repeated with other parameters:</p> <p><pre><code>.Zip\n    (X, 1, 2, 3)\n    (Y, 1, 2, 3)\n    (Z, 4)\n</code></pre> This clause yields <code>(1,1,4), (2,2,4), (3,3,4)</code>, but the following one will fail at runtime due to inconsistent zip parameters count: <pre><code>.Zip\n    (X, 1, 2, 3)\n    (Y, 1, 2)\n    (Z, 4)\n</code></pre></p> <p>You can also repeat the same parameter key in multiple rows to avoid super-wide tables like this:</p> <pre><code>.Zip\n    (X, 1, 2, 3)\n    (Y, 1, 2, 3)\n\n    (X, 4, 5, 6)\n    (Y, 4, 5, 6)\n</code></pre> <p>which is equivalent to</p> <pre><code>.Zip\n    (X, 1, 2, 3, 4, 5, 6)\n    (Y, 1, 2, 3, 4, 5, 6)\n</code></pre> <p>The order of parameter keys doesn't matter, and you may notice that parameters table oriented horizontally, i. e. row -&gt; parameter, unlike the test matrix, which is column -&gt; channel.</p> <p>Another parametrization clause is <code>Prod</code>, which stands for Cartesian product, s.t. <pre><code>.Prod\n    (X,  1,  2)\n    (Y, 10, 20)\n</code></pre> yields a set of 4 model instances with X, Y equals <code>(1, 10), (1, 20), (2, 10), (20, 20)</code> correspondingly.</p> <p>Parameter clauses can be used multiple times - each clause creates an independent group. <code>Prod</code> and <code>Zip</code> clauses also can be chained</p> <pre><code>.Prod\n    (X,  1)\n    (Y, 10, 20)\n.Prod\n    (X,  2)\n    (Y, 30, 40)\n.Zip\n    (X,  3,  4)\n    (Y, 50, 60)\n</code></pre> <p>Here each clause initiates a separate product or zip set, resulting in <pre><code>(1, 10), (1, 20), (2, 30), (2, 40), (3, 50), (3, 60), (4, 50), (4, 60)\n</code></pre></p>"},{"location":"user-guide/signal-mapping/#registering-non-serializable-components","title":"Registering non-serializable components","text":"<p>Any non-serializable model component may be registered in the <code>Environment</code> and referenced by a string key. This is what actually happens under the hood when we placed mfp literals in zip parameters in one of the examples above:</p> <pre><code>.Zip\n    (Method, &amp;Sut::foo , &amp;Sut::bar , &amp;Sut::baz )\n    (Name  , \"Sut::foo\", \"Sut::bar\", \"Sut::baz\")\n</code></pre> <p>We can do that registration explicitly:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(UsingRegistry)\n{\n    struct Mock {\n        void log(std::string msg) {\n            return InterfaceRecord(&amp;Mock::log).Hook(msg);\n        }\n    };\n\n    struct Sut {\n        Mock mock {};\n\n        void foo() { mock.log(\"Sut::foo\"); };\n        void bar() { mock.log(\"Sut::bar\"); };\n        void baz() { mock.log(\"Sut::baz\"); };\n    };\n\n    auto sut = std::make_shared&lt;Sut&gt;();\n\n    Environment env{};\n    env.RegisterTrigger(\"Sut::foo\", &amp;Sut::foo, sut);\n    env.RegisterTrigger(\"Sut::bar\", &amp;Sut::bar, sut);\n    env.RegisterTrigger(\"Sut::baz\", &amp;Sut::baz, sut);\n    env.RegisterInterface(\"Mock::log\", &amp;Mock::log);\n\n    Param const Method {\"interface method\"};\n\n\n    SignalMapping(\"Test with zip params on %s\", Method)\n    .OnTrigger(Method)\n        .At(\"Mock::log\")\n            .Expect(Eq({Method}))\n    .Zip(Method, \"Sut::foo\", \"Sut::bar\", \"Sut::baz\")\n    ;\n}\n/*\n</code></pre> <p>In the same way tasks and operators may be registered and referenced by key.</p> <p>Benefits from this approach are:</p> <ul> <li>meaningful interface names in test report.</li> <li>enabled deferred string formatting for interfaces.</li> <li>reuse string parameters in different roles (like <code>Method</code> in the example)</li> </ul>"},{"location":"user-guide/signal-mapping/#combining-channels-in-pipes","title":"Combining channels in pipes","text":"<p>When testing the relationship between different channels, it may be necessary to apply a single condition on them. It can be made with clauses like <code>Group</code> or <code>Blend</code>, placed in place of terminal <code>Inject</code> or <code>Expect</code> clauses. Channels separated by such clauses will be combined in a single condition pipe.</p> <p>Input pipes will reuse generator, and output pipes will compose observed samples into a single structure as following:</p> Group Blend Input Copy generator for each channel Share single generator between channels Output Pack samples into a tuple Merge samples into a series of <code>[id, sample]</code> <p>For piped outputs, the test runner will combine the captured samples from the chained channels according to certain rules. The result is passed then to the matcher expression specified at <code>Expect</code> clause argument or on the corresponding test matrix column.</p> <p>Input <code>Group</code> pipe simply reduces repetition by reusing the same condition for different channels, while keeping their evaluation independent.</p> <p>Input <code>Blend</code> pipe will share the same generator instance, and the difference with <code>Group</code> will be visible on non-constant generators.</p> <p>The output <code>Blend</code> pipr merges captured samples in a time series, producing a list of pairs <code>[id, signal]</code>, sorted by timestamp. Id field, if not defined explicitly with <code>Alias</code> clause, is a channel absolute index (ignoring the pipe boundaries).</p> <p>In combination with <code>Saturate</code> or other custom matchers, the <code>Blend</code> output can be utilized for testing a strict or partial order on mock calls.</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(TestMultichannelPipes)\n{\n\n    auto const repack = [](int a, int b, int c){\n        return boost::json::object{\n            {\"a\", a},\n            {\"b\", b},\n            {\"c\", c},\n        };\n    };\n\n    SignalMapping(\"Test Group on input\")\n    .OnTrigger(repack).Repeat(16)\n        .At(repack).Args(0).Group()\n        .At(repack).Args(1).Group()\n        .At(repack).Args(2).Inject(42)\n\n        .At(repack).Return(\"/a\").Group()\n        .At(repack).Return(\"/b\").Group()\n        .At(repack).Return(\"/c\").Expect(Each(42|Repeat(16)))\n    ;\n\n\n    SignalMapping(\"Test Blend on input\")\n    .OnTrigger(repack).Repeat(2)\n        .At(repack).Args(0).Blend()\n        .At(repack).Args(1).Blend()\n        .At(repack).Args(2).Inject(Id)\n\n        .At(repack).Return(\"/a\").Group()\n        .At(repack).Return(\"/b\").Group()\n        .At(repack).Return(\"/c\").Expect({{0,3},{1,4},{2,5}})\n    ;\n\n\n    struct Mock {\n        void foo(int x) {\n            return InterfaceRecord(&amp;Mock::foo).Hook(x);\n        }\n        void bar(int x) {\n            return InterfaceRecord(&amp;Mock::bar).Hook(x);\n        }\n    } mock;\n    bool flip {};\n    int count{};\n\n    auto const SUT = [&amp;](){\n        if (flip = !flip) mock.foo(count++);\n        else mock.bar(count++);\n    };\n\n    Param const N{\"N\"};\n    Param const Match{\"Match\"};\n\n    SignalMapping(\"Test Blend on output\")\n    .OnTrigger(SUT).Repeat(N)\n        .At(SUT) .Inject()\n        .At(&amp;Mock::foo).Alias(\"f\").Blend()\n        .At(&amp;Mock::bar).Alias(\"b\").Expect(Match)\n    .Zip\n        (N,  2)\n        (Match, Serialize | R\"([[\"f\",0],[\"b\",1]])\")\n    .Zip\n        (N, 42)\n        (Match, Map(At(0)) | All(Count(\"f\")|21, Count(\"b\")|21))\n        (Match, Map(At(1)) | Slide(2) | Map(Sub) | Count(1) | 41)\n    ;\n}\n/*\n</code></pre> <p>As it is stated previously, the list of non-fixed pipes acts as a table header for the test matrix (1).</p> <ol> <li>Defined with the <code>Test</code> clause</li> </ol>"},{"location":"user-guide/signal-mapping/#multithreading","title":"Multithreading","text":"<p>ZMBT mocks implemented with <code>InterfaceRecord(...).Hook(...)</code> calls are thread safe:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(TestMultithreading)\n{\n    struct Mock {\n        int produce() const {\n            return InterfaceRecord(&amp;Mock::produce, this).Hook();\n        }\n        void consume(int const x) {\n            return InterfaceRecord(&amp;Mock::consume, this).Hook(x);\n        }\n    } producer, consumer;\n\n    auto const task = [&amp;](){\n        while(true) {\n            auto const item = producer.produce();\n            if (item &lt;= 0) break;\n            std::this_thread::sleep_for(1ms);\n            consumer.consume(item);\n        }\n    };\n\n    auto const SUT = [&amp;](){\n        constexpr int N {8};\n        std::vector&lt;std::thread&gt; threads;\n        for(int i = 0; i &lt; N; ++i) threads.emplace_back(task);\n        for(auto&amp; thread: threads) {\n            thread.join();\n        }\n    };\n\n\n    SignalMapping(\"Test SUT with multithreading\")\n    .OnTrigger(SUT)\n        .At(&amp;Mock::produce, producer).Inject(~Sub(42)) // xi = 42 - i\n        .At(&amp;Mock::consume, consumer).Take(Max).Expect(42)\n        .At(&amp;Mock::consume, consumer).CallCount().Expect(42)\n        .At(&amp;Mock::consume, consumer).ThreadId().Expect(Card|8)\n    ;\n}\n/*\n</code></pre>"},{"location":"user-guide/signal-mapping/#fixture-tasks","title":"Fixture tasks","text":"<p>The signal mapping models are tested in a presumably clean environment, which mean that you can't affect the model execution from outside by injecting some values to the mocks - the test runner will clean the environment test data before each test case. In many cases we may need some preparation or cleanup to be done outside the test, a typical task for the test fixture. This can be done with <code>PreRun</code> and <code>PostRun</code> methods, that takes a list of tasks:</p> <pre><code>*/\nBOOST_AUTO_TEST_CASE(FixtureTasks)\n{\n    struct Mock {\n        int get_value() {\n            return InterfaceRecord(&amp;Mock::get_value).Hook();\n        }\n    };\n\n    auto sut = []() { return Mock().get_value(); };\n\n    SignalMapping(\"Test pre- and post-run tasks\")\n    .OnTrigger(sut)\n        .At(&amp;Mock::get_value).Inject()\n        .At(sut)             .Expect()\n    .Test\n        (13    , 13)\n        (Noop  , 42)\n    .PreRun([]{\n        InterfaceRecord(&amp;Mock::get_value).InjectReturn(42);\n    })\n    .PostRun([]{\n        BOOST_CHECK_EQUAL(InterfaceRecord(&amp;Mock::get_value).ObservedCalls(), 1);\n    })\n    ;\n}\n/*\n</code></pre> <p>The pre-run task will reset the stimulus to 42 before each test. On the first test case, this stimulus is overwritten by the value from the test vector, but in the second case, <code>Noop</code> tells the runner to skip injection.</p> <p>The order of <code>InjectReturn</code> or <code>InjectArgs</code> calls on <code>InterfaceRecord</code> has the same effect as order of injections on channel clauses (see Order matters). For such a such simple logic as in the given example it is recommended to use inline conditions instead, but the tasks can be useful in handling side-effects not accessible in Expressions, like SUT reset or extra logging.</p>"},{"location":"user-guide/signal-mapping/#diagnostic-output","title":"Diagnostic output","text":"<p>Consider the following example: <pre><code>*/\nBOOST_AUTO_TEST_CASE(ExpressionDiagnostics, * utf::disabled())\n{\n    auto id = [](boost::json::value const&amp; x){ return x; };\n\n    SignalMapping(\"SignalMapping test\")\n    .OnTrigger(id)\n        .At(id).Inject(\"1:5\"|Arange)\n        .At(id).Expect(Reduce(Add) &amp; Size | Div | Eq(2.5) | Not) //(1)\n    ;\n}\n/*\n</code></pre></p> <ol> <li>Naive average computation - use Avg instead for real tasks.</li> </ol> <p>Negation at the matcher end lead to test failure, and the log message is following:</p> <pre><code>  - ZMBT FAIL:\n      model: \"SignalMapping test\"\n      message: \"expectation match failed\"\n      expected: (Fold(Add) &amp; Size) | Div | Eq(2.5E0) | Not\n      observed: [1,2,3,4]\n      condition: {\"pipe\":1}\n      expression eval stack: |-\n        ---\n                 \u250c\u2500\u2500 Add $ [1,2] = 3\n                 \u251c\u2500\u2500 Add $ [3,3] = 6\n                 \u251c\u2500\u2500 Add $ [6,4] = 10\n              \u250c\u2500\u2500 Fold(Add) $ [1,2,3,4] = 10\n              \u251c\u2500\u2500 Size $ [1,2,3,4] = 4\n           \u250c\u2500\u2500 Fold(Add) &amp; Size $ [1,2,3,4] = [10,4]\n           \u251c\u2500\u2500 Div $ [10,4] = 2.5E0\n           \u251c\u2500\u2500 Eq(2.5E0) $ 2.5E0 = true\n           \u251c\u2500\u2500 Not $ true = false\n        \u25a1  (Fold(Add) &amp; Size) | Div | Eq(2.5E0) | Not $ [1,2,3,4] = false\n</code></pre> <p>To enable pretty-printing for JSON items, pass <code>--zmbt_log_prettify</code> command line argument.</p> <p>*/</p>"},{"location":"CxxRef/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace zmbt ZMBT root namespace. <ul> <li>class Config Global app config. </li> <li>class Environment Controlled environment data storage. <ul> <li>class InterfaceHandle Environment extension handling the interface data. </li> <li>class TypedInterfaceHandle Environment API handler for specific interface. </li> </ul> </li> <li>struct EnvironmentData Data container for the Environment . </li> <li>struct ErrorInfo </li> <li>class ErrorOr </li> <li>class Generator </li> <li>class InjectionTable <ul> <li>struct Record </li> </ul> </li> <li>class JsonIter Boost JSON array iterator interface. </li> <li>class JsonIterZipProdBase Boost JSON array iterator base for zip or cartesian product. </li> <li>class JsonNode Mutator/accessor wrapper over shared JSON value. </li> <li>class JsonProdIter Cartesian Product Iterator. </li> <li>class JsonTraverse Boost JSON value depth-first traverser. </li> <li>class JsonZipIter Zip Iterator. </li> <li>class Logger </li> <li>class OutputRecorder <ul> <li>struct Frame </li> </ul> </li> <li>class Param Generic Parameter Placeholder. </li> <li>struct PermanentEnvData </li> <li>struct StubLogger </li> <li>class Trigger Controlled environment interface executor. </li> <li>class TriggerIfc </li> <li>class TriggerObj Object handler to be used with TriggerIfc . </li> <li>namespace api Framework API with fixture classes and entries from main ns. <ul> <li>class Environment Alias for zmbt::Environment .</li> <li>class Expression Alias for lang::Expression .</li> <li>struct ModelTestFixture Generic model-driven test fixture. </li> <li>class Param Alias for zmbt::Param .</li> <li>class SignalMapping Alias for zmbt::mapping::SignalMapping .</li> <li>namespace decor Signal type decorators API. </li> <li>namespace expr Expression Language API.</li> <li>class precise Alias for zmbt::precise. </li> </ul> </li> <li>namespace application Test application configuration (work in progress) </li> <li>struct base_error ZMBT Base exception. </li> <li>namespace decor Signal type decorators API. <ul> <li>struct precise Type decorator for floating point numbers. Throws on precision loss in runtime. </li> <li>struct precision_loss_error Exception thrown by decor::precise .</li> <li>struct underlying </li> </ul> </li> <li>class entity_id Base class for annotated key objects. </li> <li>struct environment_error Test environment error. </li> <li>namespace expr Expression Language API. </li> <li>namespace flags <ul> <li>class ConversionTime </li> <li>class InjectionTime </li> <li>class RecordingTime </li> <li>class TestIsRunning </li> </ul> </li> <li>struct has_bit_and </li> <li>struct has_bit_or </li> <li>struct has_bit_xor </li> <li>struct has_complement </li> <li>struct has_divides </li> <li>struct has_equal_to </li> <li>struct has_greater </li> <li>struct has_greater_equal </li> <li>struct has_left_shift </li> <li>struct has_less </li> <li>struct has_less_equal </li> <li>struct has_logical_and </li> <li>struct has_logical_not </li> <li>struct has_logical_or </li> <li>struct has_minus </li> <li>struct has_modulus </li> <li>struct has_multiplies </li> <li>struct has_negate </li> <li>struct has_not_equal_to </li> <li>struct has_plus </li> <li>struct has_right_shift </li> <li>struct has_serialization </li> <li>struct ifc_args </li> <li>struct ifc_handle </li> <li>struct ifc_host </li> <li>struct ifc_pointer </li> <li>struct ifc_return </li> <li>class interface_id Pointer-based interface id with type annotation. </li> <li>struct is_const_iterable Variable template that checks if a type has begin() and end() member functions. </li> <li>namespace lang Expression Language implementation. <ul> <li>struct Encoding </li> <li>class EncodingView <ul> <li>struct ExprRow </li> <li>class Iterator </li> </ul> </li> <li>struct EvalContext Expression evaluation context. </li> <li>struct EvalImpl </li> <li>class EvalImplBase </li> <li>struct EvalLog Expression evaluation log. </li> <li>class EvalParams </li> <li>struct EvalValidator </li> <li>class Expression <ul> <li>class Subexpression </li> </ul> </li> <li>struct ExpressionGrammar </li> <li>class ExpressionView </li> <li>struct FixedEvalParams </li> <li>struct KeywordGrammar Boost.Sirit.Qi Grammar for zmbt::lang::Keyword parsing. </li> <li>struct KeywordInfo </li> <li>struct KeywordSymbol Boost.Sirit.Qi Symbol for zmbt::lang::Keyword parsing. </li> <li>class LazyParam </li> <li>class Operator Signal transformation and comparison handler. Enables type erasure. <ul> <li>struct operator_error </li> </ul> </li> <li>struct SignatureBase </li> <li>struct SignatureBinary Binary expression. </li> <li>struct SignatureBinary&lt; Keyword::PreProc &gt; </li> <li>struct SignatureCast </li> <li>struct SignatureConst Const expression. </li> <li>struct SignatureErr </li> <li>struct SignatureOp </li> <li>struct SignatureUnary Unary expression. </li> <li>struct SignatureUncast </li> <li>struct SignatureVariadic Variadic expression. </li> <li>namespace attr </li> </ul> </li> <li>namespace mapping Signal Mapping model functionality. <ul> <li>class ChannelHandle Channel clause handle for SignalMapping model. </li> <li>class ModelDefinition Mapping model definition machine. <ul> <li>class BaseTransition </li> <li>class N_Alias </li> <li>class N_Channel </li> <li>class N_ChannelEnd </li> <li>class N_Decor </li> <li>class N_Descr </li> <li>class N_Filter </li> <li>class N_Main </li> <li>class N_MaybeChannel </li> <li>class N_Param </li> <li>class N_ParamTable </li> <li>class N_Post </li> <li>class N_Pre </li> <li>class N_Repeat </li> <li>class N_Take </li> <li>class N_Term </li> <li>class N_Test </li> <li>class N_TestTable </li> </ul> </li> <li>class PipeHandle Pipe clause handle for SignalMapping model. </li> <li>class SignalMapping Signal Mapping Test Model. </li> <li>struct TestDiagnostics Test diagnostics for test case execution. </li> <li>class TestParameterResolver Test spec generator that handles parameter resolution. </li> <li>class TestRunner Test runner for SignalMapping model. </li> </ul> </li> <li>struct model_error Model definition error. </li> <li>class object_id Pointer-based object id with type annotation. <ul> <li>struct string_key </li> </ul> </li> <li>struct output_recorder_error </li> <li>namespace reflect Reflection metafunctions. <ul> <li>class Prototypes Interface prototypes in JSON as {\"args\": [...], \"return\": ... }. </li> <li>struct custom_invocation Customize the interface reflection metafunction. </li> <li>struct custom_serialization User-defined serialization. </li> <li>struct custom_serialization&lt; ChannelKind &gt; </li> <li>struct custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt; </li> <li>struct custom_serialization&lt; lang::Encoding &gt; </li> <li>struct custom_serialization&lt; lang::ExpressionView &gt; </li> <li>struct custom_signal_traits Customize signal traits metafunction. </li> <li>struct default_invocation Interface reflection metafunction. </li> <li>struct default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt; </li> <li>struct default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt; </li> <li>struct default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt; </li> <li>struct has_invocation_for Trait check for reflect::invocation&lt;T&gt; </li> <li>struct invocation Interface reflection metafunction. </li> <li>struct invocation&lt; S, detail::enable_custom_invocation&lt; S &gt; &gt; </li> <li>struct invocation&lt; S, detail::enable_default_invocation&lt; S &gt; &gt; </li> <li>struct serialization Serialization metafunction. </li> <li>struct serialization&lt; T, detail::enable_for_custom_serialization&lt; T &gt; &gt; </li> <li>struct serialization&lt; T, detail::enable_for_default_serialization&lt; T &gt; &gt; </li> <li>struct signal_traits Signal traits metafunction, providing default values. </li> <li>struct signal_traits&lt; T, detail::enable_custom_signal_traits&lt; T &gt; &gt; </li> <li>struct signal_traits&lt; T, detail::enable_default_signal_traits&lt; T &gt; &gt; </li> <li>struct signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt; Unhandled types catcher. </li> <li>struct signal_traits&lt; void &gt; </li> </ul> </li> <li>struct serialization_error Failed serialization. </li> <li>class shared_resource </li> <li>struct test_assertion_failure Failed test assertion. </li> <li>struct type_tag Type tag to pass template parameters as function arguments. </li> </ul> </li> <li>struct PersistentConfig </li> <li>struct Registry <ul> <li>struct FrameBuffs </li> </ul> </li> <li>struct internal_ctor </li> <li>struct Handle <ul> <li>struct Handle </li> <li>struct Handle </li> <li>struct Handle </li> <li>struct Handle </li> <li>struct Handle </li> <li>struct Handle </li> </ul> </li> <li>struct T_Alias T_Alias transition. </li> <li>struct T_As T_As transition. </li> <li>struct T_At T_At transition. </li> <li>struct T_ContinuePipe T_ContinuePipe transition. </li> <li>struct T_CustomParam T_CustomParam transition. </li> <li>struct T_Description T_Description transition. </li> <li>struct T_Filter T_Filter transition. </li> <li>struct T_OnTrigger T_OnTrigger transition. </li> <li>struct T_Param T_Param transition. </li> <li>struct T_ParamRow T_ParamRow transition. </li> <li>struct T_PostRun T_PostRun transition. </li> <li>struct T_PreRun T_PreRun transition. </li> <li>struct T_Repeat T_Repeat transition. </li> <li>struct T_Take T_Take transition. </li> <li>struct T_TerminatePipe T_TerminatePipe transition. </li> <li>struct T_Test T_Test transition. </li> <li>struct T_TestRow T_TestRow transition. </li> <li>struct custom_serialization&lt; decor::precise&lt; T &gt; &gt; </li> <li>struct custom_serialization&lt; decor::underlying&lt; T &gt; &gt; </li> </ul>"},{"location":"CxxRef/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>file namespaces.dox </li> <li>dir zmbt-framework <ul> <li>dir zmbt-framework <ul> <li>dir backends <ul> <li>dir cxx <ul> <li>dir include <ul> <li>file zenseact-mbt.hpp </li> <li>dir zmbt <ul> <li>file all.hpp </li> <li>file api.hpp </li> <li>file application.hpp </li> <li>file core.hpp </li> <li>file decor.hpp </li> <li>file expr.hpp </li> <li>file mapping.hpp </li> <li>file model.hpp </li> <li>file reflect.hpp </li> <li>dir api <ul> <li>file model_test.hpp </li> <li>file ns.hpp </li> </ul> </li> <li>dir application <ul> <li>file config.hpp </li> <li>file init.hpp </li> <li>file log.hpp </li> <li>file test_failure.hpp </li> </ul> </li> <li>dir core <ul> <li>file aliases.hpp </li> <li>file entity_id.hpp </li> <li>file exceptions.hpp </li> <li>file file_parser.hpp </li> <li>file format_string.hpp </li> <li>file generic_traits.hpp </li> <li>file get_info.hpp </li> <li>file interface_id.hpp </li> <li>file interface_traits.hpp </li> <li>file json_iter.hpp </li> <li>file json_node.hpp </li> <li>file json_number_cast.hpp </li> <li>file json_pretty_print.hpp </li> <li>file json_traverse.hpp </li> <li>file object_id.hpp </li> <li>file operator_traits.hpp </li> <li>file preprocessor.hpp type traits to check serialization compatibility </li> <li>file shared_resource.hpp </li> <li>file slice.hpp </li> <li>file tuple_conversion.hpp </li> <li>file tuple_exchange.hpp </li> <li>file tuple_indexator.hpp </li> <li>file type_info.hpp </li> <li>file type_tag.hpp </li> </ul> </li> <li>dir decor <ul> <li>file precise_real.hpp </li> <li>file underlying.hpp </li> </ul> </li> <li>dir expr <ul> <li>file api.hpp </li> <li>file api_signatures.hpp </li> <li>file attributes.hpp </li> <li>file encoding.hpp </li> <li>file eval_context.hpp </li> <li>file eval_impl.hpp </li> <li>file eval_impl_pp.hpp </li> <li>file eval_log.hpp </li> <li>file eval_params.hpp </li> <li>file eval_validator.hpp </li> <li>file expression.hpp </li> <li>file expression_grammar.hpp </li> <li>file keyword.hpp </li> <li>file keyword_grammar.hpp </li> <li>file keyword_info.hpp </li> <li>file lazy_param.hpp </li> <li>file operator.hpp </li> <li>file subexpression.hpp </li> </ul> </li> <li>dir mapping <ul> <li>file channel_handle.hpp </li> <li>file model_definition.hpp </li> <li>file model_definition_helper.hpp </li> <li>file model_definition_main.hpp </li> <li>file model_definition_node.hpp </li> <li>file model_definition_states.hpp </li> <li>file model_definition_transitions.hpp </li> <li>file pipe_handle.hpp </li> <li>file test_diagnostics.hpp </li> <li>file test_parameter_resolver.hpp </li> <li>file test_runner.hpp </li> </ul> </li> <li>dir model <ul> <li>file channel_kind.hpp </li> <li>file environment.hpp </li> <li>file environment_data.hpp </li> <li>file environment_interface_record.hpp </li> <li>file error_info.hpp </li> <li>file error_or_return.hpp </li> <li>file exceptions.hpp </li> <li>file generator.hpp </li> <li>file global_flags.hpp </li> <li>file global_stats.hpp </li> <li>file injection_table.hpp </li> <li>file output_recorder.hpp </li> <li>file param_transform.hpp </li> <li>file parameter.hpp </li> <li>file permanent_data.hpp </li> <li>file traits.hpp </li> <li>file trigger.hpp </li> </ul> </li> <li>dir reflect <ul> <li>file ducktyping_traits_pp.hpp </li> <li>file invocation.hpp </li> <li>file prototypes.hpp </li> <li>file serialization.hpp </li> <li>file serialization_defaults.hpp </li> <li>file signal_traits.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"CxxRef/namespacezmbt/","title":"Namespace zmbt","text":"<p>Namespace List &gt; zmbt</p> <p>ZMBT root namespace. More...</p>"},{"location":"CxxRef/namespacezmbt/#namespaces","title":"Namespaces","text":"Type Name namespace api Framework API with fixture classes and entries from main ns. namespace application Test application configuration (work in progress) namespace decor Signal type decorators API. namespace expr Expression Language API. namespace flags namespace lang Expression Language implementation. namespace mapping Signal Mapping model functionality. namespace reflect Reflection metafunctions."},{"location":"CxxRef/namespacezmbt/#classes","title":"Classes","text":"Type Name class Config Global app config. class Environment Controlled environment data storage. struct EnvironmentData Data container for the Environment . struct ErrorInfo class ErrorOr &lt;class Return&gt; class Generator class InjectionTable class JsonIter Boost JSON array iterator interface. class JsonIterZipProdBase Boost JSON array iterator base for zip or cartesian product. class JsonNode Mutator/accessor wrapper over shared JSON value. class JsonProdIter Cartesian Product Iterator. class JsonTraverse Boost JSON value depth-first traverser. class JsonZipIter Zip Iterator. class Logger class OutputRecorder class Param Generic Parameter Placeholder. struct PermanentEnvData struct StubLogger class Trigger Controlled environment interface executor. class TriggerIfc class TriggerObj Object handler to be used with TriggerIfc . struct base_error ZMBT Base exception. class entity_id Base class for annotated key objects. struct environment_error Test environment error. struct has_bit_and &lt;class T, class E&gt; struct has_bit_or &lt;class T, class E&gt; struct has_bit_xor &lt;class T, class E&gt; struct has_complement &lt;class T, class E&gt; struct has_divides &lt;class T, class E&gt; struct has_equal_to &lt;class T, class E&gt; struct has_greater &lt;class T, class E&gt; struct has_greater_equal &lt;class T, class E&gt; struct has_left_shift &lt;class T, class E&gt; struct has_less &lt;class T, class E&gt; struct has_less_equal &lt;class T, class E&gt; struct has_logical_and &lt;class T, class E&gt; struct has_logical_not &lt;class T, class E&gt; struct has_logical_or &lt;class T, class E&gt; struct has_minus &lt;class T, class E&gt; struct has_modulus &lt;class T, class E&gt; struct has_multiplies &lt;class T, class E&gt; struct has_negate &lt;class T, class E&gt; struct has_not_equal_to &lt;class T, class E&gt; struct has_plus &lt;class T, class E&gt; struct has_right_shift &lt;class T, class E&gt; struct has_serialization &lt;class T, class E&gt; struct ifc_args &lt;class Interface&gt; struct ifc_handle &lt;class Interface&gt; struct ifc_host &lt;class Interface, class&gt; struct ifc_pointer &lt;class Interface&gt; struct ifc_return &lt;class Interface&gt; class interface_id Pointer-based interface id with type annotation. struct is_const_iterable &lt;class, class&gt;Variable template that checks if a type has begin() and end() member functions. struct model_error Model definition error. class object_id Pointer-based object id with type annotation. struct output_recorder_error struct serialization_error Failed serialization. class shared_resource &lt;class T&gt; struct test_assertion_failure Failed test assertion. struct type_tag &lt;class T&gt;Type tag to pass template parameters as function arguments."},{"location":"CxxRef/namespacezmbt/#public-types","title":"Public Types","text":"Type Name enum unsigned ChannelKind enum FileFormat typedef std::add_const&lt; T &gt; add_const typedef typename add_const&lt; T &gt;::type add_const_t typedef std::add_cv&lt; T &gt; add_cv typedef typename add_cv&lt; T &gt;::type add_cv_t typedef std::add_lvalue_reference&lt; T &gt; add_lvalue_reference typedef typename add_lvalue_reference&lt; T &gt;::type add_lvalue_reference_t typedef std::add_pointer&lt; T &gt; add_pointer typedef typename add_pointer&lt; T &gt;::type add_pointer_t typedef std::add_rvalue_reference&lt; T &gt; add_rvalue_reference typedef typename add_rvalue_reference&lt; T &gt;::type add_rvalue_reference_t typedef std::add_volatile&lt; T &gt; add_volatile typedef typename add_volatile&lt; T &gt;::type add_volatile_t typedef integral_constant&lt; bool, V &gt; bool_constant typedef std::common_type&lt; T... &gt; common_type typedef typename common_type&lt; T... &gt;::type common_type_t typedef std::conditional&lt; B, T, F &gt; conditional typedef typename conditional&lt; B, T, F &gt;::type conditional_t typedef std::decay&lt; T &gt; decay typedef typename decay&lt; T &gt;::type decay_t typedef mp_if&lt; mp_any&lt; C... &gt;, R &gt; first_if_any_t typedef mp_if&lt; mp_not&lt; mp_any&lt; C... &gt; &gt;, R &gt; first_if_none_t typedef mp_if&lt; mp_all&lt; C... &gt;, R &gt; first_if_t typedef std::has_virtual_destructor&lt; T &gt; has_virtual_destructor typedef typename ifc_args&lt; Interface &gt;::type ifc_args_t typedef typename ifc_handle&lt; Interface &gt;::type ifc_handle_t typedef typename ifc_host&lt; Interface &gt;::type ifc_host_t typedef mp_any&lt; ifc_is_fn_ref&lt; Interface &gt;, ifc_is_fn_ptr&lt; Interface &gt; &gt; ifc_is_fn_handle typedef mp_all&lt; is_pointer&lt; Interface &gt;, is_function&lt; remove_pointer_t&lt; DecayedInterface &gt; &gt; &gt; ifc_is_fn_ptr typedef mp_all&lt; is_lvalue_reference&lt; Interface &gt;, is_function&lt; remove_pointer_t&lt; DecayedInterface &gt; &gt; &gt; ifc_is_fn_ref typedef mp_any&lt; ifc_is_functor_ptr&lt; Interface &gt;, ifc_is_functor_ref&lt; Interface &gt; &gt; ifc_is_functor_handle typedef mp_all&lt; is_pointer&lt; InterfacePointer &gt;, is_class&lt; Functor &gt;, detail::support_calltraits_function&lt; Functor &gt; &gt; ifc_is_functor_ptr typedef mp_all&lt; is_reference&lt; Interface &gt;, is_class&lt; Functor &gt;, detail::support_calltraits_function&lt; Functor &gt; &gt; ifc_is_functor_ref typedef is_member_pointer&lt; DecayedInterface &gt; ifc_is_member_handle typedef is_member_object_pointer&lt; DecayedInterface &gt; ifc_is_pmd_handle typedef is_member_function_pointer&lt; DecayedInterface &gt; ifc_is_pmf_handle typedef typename ifc_pointer&lt; Interface &gt;::type ifc_pointer_t typedef typename ifc_return&lt; Interface &gt;::type ifc_return_t typedef typename detail::tuple_indexator&lt; T &gt;::type indexator_for Make indexator tuple for T. typedef std::integral_constant&lt; T, V &gt; integral_constant typedef std::is_abstract&lt; T &gt; is_abstract typedef std::is_arithmetic&lt; T &gt; is_arithmetic typedef std::is_array&lt; T &gt; is_array typedef std::is_assignable&lt; A, B &gt; is_assignable typedef std::is_base_of&lt; A, B &gt; is_base_of typedef std::is_class&lt; T &gt; is_class typedef std::is_compound&lt; T &gt; is_compound typedef std::is_const&lt; T &gt; is_const typedef std::is_constructible&lt; T, Args... &gt; is_constructible typedef std::is_convertible&lt; A, B &gt; is_convertible typedef std::is_copy_assignable&lt; T &gt; is_copy_assignable typedef std::is_copy_constructible&lt; T &gt; is_copy_constructible typedef std::is_default_constructible&lt; T &gt; is_default_constructible typedef std::is_destructible&lt; T &gt; is_destructible typedef std::is_empty&lt; T &gt; is_empty typedef std::is_enum&lt; T &gt; is_enum typedef std::is_final&lt; T &gt; is_final typedef std::is_floating_point&lt; T &gt; is_floating_point typedef std::is_function&lt; T &gt; is_function typedef std::is_fundamental&lt; T &gt; is_fundamental typedef mp_any&lt; ifc_is_pmf_handle&lt; Interface &gt;, ifc_is_pmd_handle&lt; Interface &gt;, ifc_is_fn_handle&lt; Interface &gt;, ifc_is_functor_handle&lt; Interface &gt; &gt; is_ifc_handle typedef std::is_integral&lt; T &gt; is_integral typedef std::is_lvalue_reference&lt; T &gt; is_lvalue_reference typedef std::is_member_function_pointer&lt; T &gt; is_member_function_pointer typedef std::is_member_object_pointer&lt; T &gt; is_member_object_pointer typedef std::is_member_pointer&lt; T &gt; is_member_pointer typedef std::is_move_assignable&lt; T &gt; is_move_assignable typedef std::is_move_constructible&lt; T &gt; is_move_constructible typedef std::is_nothrow_assignable&lt; A, B &gt; is_nothrow_assignable typedef std::is_nothrow_constructible&lt; T, Args... &gt; is_nothrow_constructible typedef std::is_nothrow_copy_assignable&lt; T &gt; is_nothrow_copy_assignable typedef std::is_nothrow_copy_constructible&lt; T &gt; is_nothrow_copy_constructible typedef std::is_nothrow_default_constructible&lt; T &gt; is_nothrow_default_constructible typedef std::is_nothrow_destructible&lt; T &gt; is_nothrow_destructible typedef std::is_nothrow_move_assignable&lt; T &gt; is_nothrow_move_assignable typedef std::is_nothrow_move_constructible&lt; T &gt; is_nothrow_move_constructible typedef std::is_null_pointer&lt; T &gt; is_null_pointer typedef std::is_object&lt; T &gt; is_object typedef std::is_pointer&lt; T &gt; is_pointer typedef std::is_polymorphic&lt; T &gt; is_polymorphic typedef std::is_reference&lt; T &gt; is_reference typedef std::is_rvalue_reference&lt; T &gt; is_rvalue_reference typedef std::is_same&lt; A, B &gt; is_same typedef std::is_scalar&lt; T &gt; is_scalar typedef std::is_signed&lt; T &gt; is_signed typedef std::is_standard_layout&lt; T &gt; is_standard_layout typedef std::is_trivial&lt; T &gt; is_trivial typedef std::is_trivially_assignable&lt; A, B &gt; is_trivially_assignable typedef std::is_trivially_constructible&lt; T, Args... &gt; is_trivially_constructible typedef std::is_trivially_copy_assignable&lt; T &gt; is_trivially_copy_assignable typedef std::is_trivially_copy_constructible&lt; T &gt; is_trivially_copy_constructible typedef std::is_trivially_copyable&lt; T &gt; is_trivially_copyable typedef std::is_trivially_default_constructible&lt; T &gt; is_trivially_default_constructible typedef std::is_trivially_destructible&lt; T &gt; is_trivially_destructible typedef std::is_trivially_move_assignable&lt; T &gt; is_trivially_move_assignable typedef std::is_trivially_move_constructible&lt; T &gt; is_trivially_move_constructible typedef mp_or&lt; mp_similar&lt; tuple&lt;&gt;, T &gt;, mp_similar&lt; std::pair&lt; void, void &gt;, T &gt; &gt; is_tuple typedef mp_similar&lt; decay_t&lt; T &gt;, type_tag&lt; void &gt; &gt; is_type_tag typedef std::is_union&lt; T &gt; is_union typedef std::is_unsigned&lt; T &gt; is_unsigned typedef std::is_void&lt; T &gt; is_void typedef std::is_volatile&lt; T &gt; is_volatile typedef std::function&lt; boost::json::array::const_iterator()&gt; js_array_slice_const_gen typedef std::function&lt; boost::json::array::iterator()&gt; js_array_slice_gen typedef std::function&lt; boost::json::string_view::const_iterator()&gt; js_string_slice_gen typedef std::make_signed&lt; T &gt; make_signed typedef typename make_signed&lt; T &gt;::type make_signed_t typedef std::make_unsigned&lt; T &gt; make_unsigned typedef typename make_unsigned&lt; T &gt;::type make_unsigned_t typedef std::remove_const&lt; T &gt; remove_const typedef typename remove_const&lt; T &gt;::type remove_const_t typedef std::remove_cv&lt; T &gt; remove_cv typedef typename remove_cv&lt; T &gt;::type remove_cv_t typedef remove_cv_t&lt; remove_pointer_t&lt; T &gt; &gt; remove_cvptr_t typedef remove_cv_t&lt; remove_reference_t&lt; T &gt; &gt; remove_cvref_t typedef std::remove_pointer&lt; T &gt; remove_pointer typedef typename remove_pointer&lt; T &gt;::type remove_pointer_t typedef std::remove_reference&lt; T &gt; remove_reference typedef typename remove_reference&lt; T &gt;::type remove_reference_t typedef std::remove_volatile&lt; T &gt; remove_volatile typedef typename remove_volatile&lt; T &gt;::type remove_volatile_t typedef mp_if&lt; detail::is_cal&lt; T &gt;, R &gt; require_cal typedef mp_if&lt; boost::json::has_value_from&lt; T &gt;, R &gt; require_json_from typedef mp_if&lt; mp_and&lt; detail::maybe_obj&lt; O &gt;, detail::is_cal&lt; I &gt; &gt;, R &gt; require_literal typedef mp_if&lt; mp_not&lt; boost::json::has_value_from&lt; T &gt; &gt;, R &gt; require_no_json_from typedef mp_if&lt; detail::not_cal&lt; T &gt;, R &gt; require_not_cal typedef mp_if&lt; mp_not&lt; boost::json::is_string_like&lt; T &gt; &gt;, R &gt; require_not_str typedef mp_if&lt; detail::maybe_obj&lt; T &gt;, R &gt; require_obj typedef mp_if&lt; boost::json::is_string_like&lt; T &gt;, R &gt; require_str typedef std::tuple&lt; T... &gt; tuple typedef std::tuple_size&lt; T &gt; tuple_size typedef mp_transform&lt; remove_cvref_t, L &gt; tuple_unqf_t typedef std::underlying_type&lt; T &gt; underlying_type typedef typename underlying_type&lt; T &gt;::type underlying_type_t"},{"location":"CxxRef/namespacezmbt/#public-attributes","title":"Public Attributes","text":"Type Name constexpr add_pointer_t&lt; remove_reference_t&lt; ifc_host_t&lt; Interface &gt; &gt; &gt; ifc_host_nullptr   = <code>{}</code>Resolves to H*{} for member function pointers of H, or to nullptr_t for other callables. constexpr type_tag&lt; T &gt; const type   = <code>{}</code>type tag value"},{"location":"CxxRef/namespacezmbt/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr detail::emplace_shared_tag emplace_shared constexpr bool has_virtual_destructor_v   = <code>has\\_virtual\\_destructor &amp;lt;T&amp;gt;::value</code> constexpr bool is_abstract_v   = <code>is\\_abstract &amp;lt;T&amp;gt;::value</code> constexpr bool is_arithmetic_v   = <code>is\\_arithmetic &amp;lt;T&amp;gt;::value</code> constexpr bool is_array_v   = <code>is\\_array &amp;lt;T&amp;gt;::value</code> constexpr bool is_assignable_v   = <code>is\\_assignable &amp;lt;A, B&amp;gt;::value</code> constexpr bool is_base_of_v   = <code>is\\_base\\_of &amp;lt;A, B&amp;gt;::value</code> constexpr bool is_class_v   = <code>is\\_class &amp;lt;T&amp;gt;::value</code> constexpr bool is_compound_v   = <code>is\\_compound &amp;lt;T&amp;gt;::value</code> constexpr bool is_const_v   = <code>is\\_const &amp;lt;T&amp;gt;::value</code> constexpr bool is_convertible_v   = <code>is\\_convertible &amp;lt;A, B&amp;gt;::value</code> constexpr bool is_copy_assignable_v   = <code>is\\_copy\\_assignable &amp;lt;T&amp;gt;::value</code> constexpr bool is_copy_constructible_v   = <code>is\\_copy\\_constructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_default_constructible_v   = <code>is\\_default\\_constructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_destructible_v   = <code>is\\_destructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_empty_v   = <code>is\\_empty &amp;lt;T&amp;gt;::value</code> constexpr bool is_enum_v   = <code>is\\_enum &amp;lt;T&amp;gt;::value</code> constexpr bool is_final_v   = <code>is\\_final &amp;lt;T&amp;gt;::value</code> constexpr bool is_floating_point_v   = <code>is\\_floating\\_point &amp;lt;T&amp;gt;::value</code> constexpr bool is_function_v   = <code>is\\_function &amp;lt;T&amp;gt;::value</code> constexpr bool is_fundamental_v   = <code>is\\_fundamental &amp;lt;T&amp;gt;::value</code> constexpr bool is_integral_v   = <code>is\\_integral &amp;lt;T&amp;gt;::value</code> constexpr bool is_lvalue_reference_v   = <code>is\\_lvalue\\_reference &amp;lt;T&amp;gt;::value</code> constexpr bool is_member_function_pointer_v   = <code>is\\_member\\_function\\_pointer &amp;lt;T&amp;gt;::value</code> constexpr bool is_member_object_pointer_v   = <code>is\\_member\\_object\\_pointer &amp;lt;T&amp;gt;::value</code> constexpr bool is_member_pointer_v   = <code>is\\_member\\_pointer &amp;lt;T&amp;gt;::value</code> constexpr bool is_move_assignable_v   = <code>is\\_move\\_assignable &amp;lt;T&amp;gt;::value</code> constexpr bool is_move_constructible_v   = <code>is\\_move\\_constructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_nothrow_assignable_v   = <code>is\\_nothrow\\_assignable &amp;lt;A, B&amp;gt;::value</code> constexpr bool is_nothrow_copy_assignable_v   = <code>is\\_nothrow\\_copy\\_assignable &amp;lt;T&amp;gt;::value</code> constexpr bool is_nothrow_copy_constructible_v   = <code>is\\_nothrow\\_copy\\_constructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_nothrow_default_constructible_v   = <code>is\\_nothrow\\_default\\_constructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_nothrow_destructible_v   = <code>is\\_nothrow\\_destructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_nothrow_move_assignable_v   = <code>is\\_nothrow\\_move\\_assignable &amp;lt;T&amp;gt;::value</code> constexpr bool is_nothrow_move_constructible_v   = <code>is\\_nothrow\\_move\\_constructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_null_pointer_v   = <code>is\\_null\\_pointer &amp;lt;T&amp;gt;::value</code> constexpr bool is_object_v   = <code>is\\_object &amp;lt;T&amp;gt;::value</code> constexpr bool is_pointer_v   = <code>is\\_pointer &amp;lt;T&amp;gt;::value</code> constexpr bool is_polymorphic_v   = <code>is\\_polymorphic &amp;lt;T&amp;gt;::value</code> constexpr bool is_reference_v   = <code>is\\_reference &amp;lt;T&amp;gt;::value</code> constexpr bool is_rvalue_reference_v   = <code>is\\_rvalue\\_reference &amp;lt;T&amp;gt;::value</code> constexpr bool is_same_v   = <code>is\\_same &amp;lt;A, B&amp;gt;::value</code> constexpr bool is_scalar_v   = <code>is\\_scalar &amp;lt;T&amp;gt;::value</code> constexpr bool is_signed_v   = <code>is\\_signed &amp;lt;T&amp;gt;::value</code> constexpr bool is_standard_layout_v   = <code>is\\_standard\\_layout &amp;lt;T&amp;gt;::value</code> constexpr bool is_trivial_v   = <code>is\\_trivial &amp;lt;T&amp;gt;::value</code> constexpr bool is_trivially_assignable_v   = <code>is\\_trivially\\_assignable &amp;lt;A, B&amp;gt;::value</code> constexpr bool is_trivially_copy_assignable_v   = <code>is\\_trivially\\_copy\\_assignable &amp;lt;T&amp;gt;::value</code> constexpr bool is_trivially_copy_constructible_v   = <code>is\\_trivially\\_copy\\_constructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_trivially_copyable_v   = <code>is\\_trivially\\_copyable &amp;lt;T&amp;gt;::value</code> constexpr bool is_trivially_default_constructible_v   = <code>is\\_trivially\\_default\\_constructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_trivially_destructible_v   = <code>is\\_trivially\\_destructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_trivially_move_assignable_v   = <code>is\\_trivially\\_move\\_assignable &amp;lt;T&amp;gt;::value</code> constexpr bool is_trivially_move_constructible_v   = <code>is\\_trivially\\_move\\_constructible &amp;lt;T&amp;gt;::value</code> constexpr bool is_union_v   = <code>is\\_union &amp;lt;T&amp;gt;::value</code> constexpr bool is_unsigned_v   = <code>is\\_unsigned &amp;lt;T&amp;gt;::value</code> constexpr bool is_void_v   = <code>is\\_void &amp;lt;T&amp;gt;::value</code> constexpr bool is_volatile_v   = <code>is\\_volatile &amp;lt;T&amp;gt;::value</code> constexpr size_t tuple_size_v   = <code>tuple\\_size&amp;lt;T&amp;gt;::value</code>"},{"location":"CxxRef/namespacezmbt/#public-functions","title":"Public Functions","text":"Type Name void InitZmbt (int argc, char ** argv) Initialize test application. Environment::TypedInterfaceHandle&lt; Interface &gt; InterfaceRecord (Interface const &amp; interface, object_id const &amp; obj={ifc_host_nullptr&lt; Interface &gt;}) Make TypedInterfaceHandle instance. T construct_or_default (A &amp;&amp;... args) Construct T from the given arguments or return default T if construction is invalid. T convert_tuple_to (tuple&lt; A... &gt; &amp; source) Convert given tuple to a tuple of type T. void default_test_failure (boost::json::value const &amp; report) default test failure handler reflect::detail::disable_hermetic_serialization&lt; T, T &gt; dejsonize (boost::json::value const &amp; v)  reflect::detail::enable_hermetic_serialization&lt; T, T &gt; dejsonize (boost::json::value const &amp; v)  void dejsonize&lt; void &gt; (boost::json::value const &amp;)  void dejsonize_array (boost::json::array const &amp; jarr, T(&amp;) array)  std::string format (boost::json::string_view fmtstr, A &amp;&amp;... arg) boost::format wrapper with printf-like api void format_failure_report (std::ostream &amp; os, boost::json::value const &amp; report) default failure report formatter auto get_ifc_handle (Interface const x) Get reference to callable object. auto get_ifc_handle (Interface * x)  auto get_ifc_handle (Interface &amp; x)  auto get_ifc_pointer (Interface x) Get pointer to callable object. auto get_ifc_pointer (Interface * x)  auto get_ifc_pointer (Interface &amp; x)  std::string get_tid () get thread id in string std::size_t get_ts () get timestamp reflect::detail::disable_hermetic_serialization&lt; TT, boost::json::value &gt; json_from (T &amp;&amp; t)  reflect::detail::enable_hermetic_serialization&lt; TT, boost::json::value &gt; json_from (T &amp;&amp; t)  boost::json::value json_from (std::tuple&lt;&gt;)  boost::json::value json_from_array (T const (&amp;) array)  js_array_slice_const_gen make_slice_const_generator (boost::json::array const &amp; src, std::int64_t const start=0, std::int64_t const stop=-1, std::int64_t const step=1)  js_string_slice_gen make_slice_const_generator (boost::json::string_view const src, std::int64_t const start=0, std::int64_t const stop=-1, std::int64_t const step=1)  js_array_slice_gen make_slice_generator (boost::json::array &amp; src, std::int64_t const start=0, std::int64_t const stop=-1, std::int64_t const step=1)  boost::json::value maybe_real_to_number (boost::json::value const &amp; value)  bool maybe_real_to_number_inplace (boost::json::value &amp; value)  boost::json::value param_transform (Param const &amp; param, boost::json::array const &amp; pointers, T &amp;&amp; value) Transform Param value of type T to json value and handle type-specific environment effects. std::ostream &amp; pretty_print (std::ostream &amp; os, boost::json::value const &amp; jv, int const indent=0) Pretty print JSON data. boost::json::value real_to_number (double value)  boost::json::value real_to_number (std::int64_t value)  boost::json::array slice (boost::json::array const &amp; src, boost::json::string_view jp, std::int64_t const start=0, std::int64_t const stop=-1, std::int64_t const step=1) Slice array with inclusive boundaries and subsignal cherry-pick. boost::json::array slice (boost::json::array const &amp; src, std::int64_t const start=0, std::int64_t const stop=-1, std::int64_t const step=1) Slice array with inclusive boundaries. boost::json::string slice (boost::json::string_view const src, std::int64_t const start=0, std::int64_t const stop=-1, std::int64_t const step=1)  void throw_exception (E &amp;&amp; e)  std::string tid2str (std::id const tid) thread id to string void tuple_exchange (T1 &amp; target, T2 const &amp; src)  std::string type_name () Prettified typename. std::string type_name (T) Prettified typename."},{"location":"CxxRef/namespacezmbt/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/namespacezmbt/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/namespacezmbt/#enum-channelkind","title":"enum ChannelKind","text":"<pre><code>enum zmbt::ChannelKind {\n    Args,\n    Return,\n    Exception,\n    Timestamp,\n    ThreadId,\n    CallCount,\n    Undefined\n};\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#enum-fileformat","title":"enum FileFormat","text":"<pre><code>enum zmbt::FileFormat {\n    DeduceFromExtension,\n    JSON,\n    YAML,\n    XML\n};\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_const","title":"typedef add_const","text":"<pre><code>using zmbt::add_const = typedef std:: add_const &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_const_t","title":"typedef add_const_t","text":"<pre><code>using zmbt::add_const_t = typedef typename add_const &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_cv","title":"typedef add_cv","text":"<pre><code>using zmbt::add_cv = typedef std:: add_cv &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_cv_t","title":"typedef add_cv_t","text":"<pre><code>using zmbt::add_cv_t = typedef typename add_cv &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_lvalue_reference","title":"typedef add_lvalue_reference","text":"<pre><code>using zmbt::add_lvalue_reference = typedef std:: add_lvalue_reference &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_lvalue_reference_t","title":"typedef add_lvalue_reference_t","text":"<pre><code>using zmbt::add_lvalue_reference_t = typedef typename add_lvalue_reference &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_pointer","title":"typedef add_pointer","text":"<pre><code>using zmbt::add_pointer = typedef std:: add_pointer &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_pointer_t","title":"typedef add_pointer_t","text":"<pre><code>using zmbt::add_pointer_t = typedef typename add_pointer &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_rvalue_reference","title":"typedef add_rvalue_reference","text":"<pre><code>using zmbt::add_rvalue_reference = typedef std:: add_rvalue_reference &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_rvalue_reference_t","title":"typedef add_rvalue_reference_t","text":"<pre><code>using zmbt::add_rvalue_reference_t = typedef typename add_rvalue_reference &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_volatile","title":"typedef add_volatile","text":"<pre><code>using zmbt::add_volatile = typedef std:: add_volatile &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-add_volatile_t","title":"typedef add_volatile_t","text":"<pre><code>using zmbt::add_volatile_t = typedef typename add_volatile &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-bool_constant","title":"typedef bool_constant","text":"<pre><code>using zmbt::bool_constant = typedef integral_constant&lt;bool, V&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-common_type","title":"typedef common_type","text":"<pre><code>using zmbt::common_type = typedef std::common_type&lt;T...&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-common_type_t","title":"typedef common_type_t","text":"<pre><code>using zmbt::common_type_t = typedef typename common_type&lt;T...&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-conditional","title":"typedef conditional","text":"<pre><code>using zmbt::conditional = typedef std::conditional&lt;B, T, F&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-conditional_t","title":"typedef conditional_t","text":"<pre><code>using zmbt::conditional_t = typedef typename conditional&lt;B, T, F&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-decay","title":"typedef decay","text":"<pre><code>using zmbt::decay = typedef std:: decay &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-decay_t","title":"typedef decay_t","text":"<pre><code>using zmbt::decay_t = typedef typename decay &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-first_if_any_t","title":"typedef first_if_any_t","text":"<pre><code>using zmbt::first_if_any_t = typedef mp_if&lt;mp_any&lt;C...&gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-first_if_none_t","title":"typedef first_if_none_t","text":"<pre><code>using zmbt::first_if_none_t = typedef mp_if&lt;mp_not&lt;mp_any&lt;C...&gt; &gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-first_if_t","title":"typedef first_if_t","text":"<pre><code>using zmbt::first_if_t = typedef mp_if&lt;mp_all&lt;C...&gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-has_virtual_destructor","title":"typedef has_virtual_destructor","text":"<pre><code>using zmbt::has_virtual_destructor = typedef std:: has_virtual_destructor &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_args_t","title":"typedef ifc_args_t","text":"<pre><code>using zmbt::ifc_args_t = typedef typename ifc_args&lt;Interface&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_handle_t","title":"typedef ifc_handle_t","text":"<pre><code>using zmbt::ifc_handle_t = typedef typename ifc_handle&lt;Interface&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_host_t","title":"typedef ifc_host_t","text":"<pre><code>using zmbt::ifc_host_t = typedef typename ifc_host&lt;Interface&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_is_fn_handle","title":"typedef ifc_is_fn_handle","text":"<pre><code>using zmbt::ifc_is_fn_handle = typedef mp_any&lt; ifc_is_fn_ref&lt;Interface&gt;, ifc_is_fn_ptr&lt;Interface&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_is_fn_ptr","title":"typedef ifc_is_fn_ptr","text":"<pre><code>using zmbt::ifc_is_fn_ptr = typedef mp_all&lt; is_pointer&lt;Interface&gt;, is_function&lt;remove_pointer_t&lt;DecayedInterface&gt; &gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_is_fn_ref","title":"typedef ifc_is_fn_ref","text":"<pre><code>using zmbt::ifc_is_fn_ref = typedef mp_all&lt; is_lvalue_reference&lt;Interface&gt;, is_function&lt;remove_pointer_t&lt;DecayedInterface&gt; &gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_is_functor_handle","title":"typedef ifc_is_functor_handle","text":"<pre><code>using zmbt::ifc_is_functor_handle = typedef mp_any&lt; ifc_is_functor_ptr&lt;Interface&gt;, ifc_is_functor_ref&lt;Interface&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_is_functor_ptr","title":"typedef ifc_is_functor_ptr","text":"<pre><code>using zmbt::ifc_is_functor_ptr = typedef mp_all&lt; is_pointer&lt;InterfacePointer&gt;, is_class&lt;Functor&gt;, detail::support_calltraits_function&lt;Functor&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_is_functor_ref","title":"typedef ifc_is_functor_ref","text":"<pre><code>using zmbt::ifc_is_functor_ref = typedef mp_all&lt; is_reference&lt;Interface&gt;, is_class&lt;Functor&gt;, detail::support_calltraits_function&lt;Functor&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_is_member_handle","title":"typedef ifc_is_member_handle","text":"<pre><code>using zmbt::ifc_is_member_handle = typedef is_member_pointer&lt;DecayedInterface&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_is_pmd_handle","title":"typedef ifc_is_pmd_handle","text":"<pre><code>using zmbt::ifc_is_pmd_handle = typedef is_member_object_pointer&lt;DecayedInterface&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_is_pmf_handle","title":"typedef ifc_is_pmf_handle","text":"<pre><code>using zmbt::ifc_is_pmf_handle = typedef is_member_function_pointer&lt;DecayedInterface&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_pointer_t","title":"typedef ifc_pointer_t","text":"<pre><code>using zmbt::ifc_pointer_t = typedef typename ifc_pointer&lt;Interface&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-ifc_return_t","title":"typedef ifc_return_t","text":"<pre><code>using zmbt::ifc_return_t = typedef typename ifc_return&lt;Interface&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-indexator_for","title":"typedef indexator_for","text":"<p>Make indexator tuple for T. <pre><code>using zmbt::indexator_for = typedef typename detail::tuple_indexator&lt;T&gt;::type;\n</code></pre></p> <p>Create std::tuple of std::integral_constant with 0, ..., N-1 values for input tuple of size N </p> <p>Template parameters:</p> <ul> <li><code>T</code> input tuple </li> </ul>"},{"location":"CxxRef/namespacezmbt/#typedef-integral_constant","title":"typedef integral_constant","text":"<pre><code>using zmbt::integral_constant = typedef std::integral_constant&lt;T, V&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_abstract","title":"typedef is_abstract","text":"<pre><code>using zmbt::is_abstract = typedef std:: is_abstract &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_arithmetic","title":"typedef is_arithmetic","text":"<pre><code>using zmbt::is_arithmetic = typedef std:: is_arithmetic &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_array","title":"typedef is_array","text":"<pre><code>using zmbt::is_array = typedef std:: is_array &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_assignable","title":"typedef is_assignable","text":"<pre><code>using zmbt::is_assignable = typedef std:: is_assignable &lt;A, B&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_base_of","title":"typedef is_base_of","text":"<pre><code>using zmbt::is_base_of = typedef std:: is_base_of &lt;A, B&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_class","title":"typedef is_class","text":"<pre><code>using zmbt::is_class = typedef std:: is_class &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_compound","title":"typedef is_compound","text":"<pre><code>using zmbt::is_compound = typedef std:: is_compound &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_const","title":"typedef is_const","text":"<pre><code>using zmbt::is_const = typedef std:: is_const &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_constructible","title":"typedef is_constructible","text":"<pre><code>using zmbt::is_constructible = typedef std::is_constructible&lt;T, Args...&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_convertible","title":"typedef is_convertible","text":"<pre><code>using zmbt::is_convertible = typedef std:: is_convertible &lt;A, B&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_copy_assignable","title":"typedef is_copy_assignable","text":"<pre><code>using zmbt::is_copy_assignable = typedef std:: is_copy_assignable &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_copy_constructible","title":"typedef is_copy_constructible","text":"<pre><code>using zmbt::is_copy_constructible = typedef std:: is_copy_constructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_default_constructible","title":"typedef is_default_constructible","text":"<pre><code>using zmbt::is_default_constructible = typedef std:: is_default_constructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_destructible","title":"typedef is_destructible","text":"<pre><code>using zmbt::is_destructible = typedef std:: is_destructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_empty","title":"typedef is_empty","text":"<pre><code>using zmbt::is_empty = typedef std:: is_empty &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_enum","title":"typedef is_enum","text":"<pre><code>using zmbt::is_enum = typedef std:: is_enum &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_final","title":"typedef is_final","text":"<pre><code>using zmbt::is_final = typedef std:: is_final &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_floating_point","title":"typedef is_floating_point","text":"<pre><code>using zmbt::is_floating_point = typedef std:: is_floating_point &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_function","title":"typedef is_function","text":"<pre><code>using zmbt::is_function = typedef std:: is_function &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_fundamental","title":"typedef is_fundamental","text":"<pre><code>using zmbt::is_fundamental = typedef std:: is_fundamental &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_ifc_handle","title":"typedef is_ifc_handle","text":"<pre><code>using zmbt::is_ifc_handle = typedef mp_any&lt; ifc_is_pmf_handle&lt;Interface&gt;, ifc_is_pmd_handle&lt;Interface&gt;, ifc_is_fn_handle&lt;Interface&gt;, ifc_is_functor_handle&lt;Interface&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_integral","title":"typedef is_integral","text":"<pre><code>using zmbt::is_integral = typedef std:: is_integral &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_lvalue_reference","title":"typedef is_lvalue_reference","text":"<pre><code>using zmbt::is_lvalue_reference = typedef std:: is_lvalue_reference &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_member_function_pointer","title":"typedef is_member_function_pointer","text":"<pre><code>using zmbt::is_member_function_pointer = typedef std:: is_member_function_pointer &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_member_object_pointer","title":"typedef is_member_object_pointer","text":"<pre><code>using zmbt::is_member_object_pointer = typedef std:: is_member_object_pointer &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_member_pointer","title":"typedef is_member_pointer","text":"<pre><code>using zmbt::is_member_pointer = typedef std:: is_member_pointer &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_move_assignable","title":"typedef is_move_assignable","text":"<pre><code>using zmbt::is_move_assignable = typedef std:: is_move_assignable &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_move_constructible","title":"typedef is_move_constructible","text":"<pre><code>using zmbt::is_move_constructible = typedef std:: is_move_constructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_nothrow_assignable","title":"typedef is_nothrow_assignable","text":"<pre><code>using zmbt::is_nothrow_assignable = typedef std:: is_nothrow_assignable &lt;A, B&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_nothrow_constructible","title":"typedef is_nothrow_constructible","text":"<pre><code>using zmbt::is_nothrow_constructible = typedef std::is_nothrow_constructible&lt;T, Args...&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_nothrow_copy_assignable","title":"typedef is_nothrow_copy_assignable","text":"<pre><code>using zmbt::is_nothrow_copy_assignable = typedef std:: is_nothrow_copy_assignable &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_nothrow_copy_constructible","title":"typedef is_nothrow_copy_constructible","text":"<pre><code>using zmbt::is_nothrow_copy_constructible = typedef std:: is_nothrow_copy_constructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_nothrow_default_constructible","title":"typedef is_nothrow_default_constructible","text":"<pre><code>using zmbt::is_nothrow_default_constructible = typedef std:: is_nothrow_default_constructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_nothrow_destructible","title":"typedef is_nothrow_destructible","text":"<pre><code>using zmbt::is_nothrow_destructible = typedef std:: is_nothrow_destructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_nothrow_move_assignable","title":"typedef is_nothrow_move_assignable","text":"<pre><code>using zmbt::is_nothrow_move_assignable = typedef std:: is_nothrow_move_assignable &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_nothrow_move_constructible","title":"typedef is_nothrow_move_constructible","text":"<pre><code>using zmbt::is_nothrow_move_constructible = typedef std:: is_nothrow_move_constructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_null_pointer","title":"typedef is_null_pointer","text":"<pre><code>using zmbt::is_null_pointer = typedef std:: is_null_pointer &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_object","title":"typedef is_object","text":"<pre><code>using zmbt::is_object = typedef std:: is_object &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_pointer","title":"typedef is_pointer","text":"<pre><code>using zmbt::is_pointer = typedef std:: is_pointer &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_polymorphic","title":"typedef is_polymorphic","text":"<pre><code>using zmbt::is_polymorphic = typedef std:: is_polymorphic &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_reference","title":"typedef is_reference","text":"<pre><code>using zmbt::is_reference = typedef std:: is_reference &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_rvalue_reference","title":"typedef is_rvalue_reference","text":"<pre><code>using zmbt::is_rvalue_reference = typedef std:: is_rvalue_reference &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_same","title":"typedef is_same","text":"<pre><code>using zmbt::is_same = typedef std:: is_same &lt;A, B&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_scalar","title":"typedef is_scalar","text":"<pre><code>using zmbt::is_scalar = typedef std:: is_scalar &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_signed","title":"typedef is_signed","text":"<pre><code>using zmbt::is_signed = typedef std:: is_signed &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_standard_layout","title":"typedef is_standard_layout","text":"<pre><code>using zmbt::is_standard_layout = typedef std:: is_standard_layout &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivial","title":"typedef is_trivial","text":"<pre><code>using zmbt::is_trivial = typedef std:: is_trivial &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivially_assignable","title":"typedef is_trivially_assignable","text":"<pre><code>using zmbt::is_trivially_assignable = typedef std:: is_trivially_assignable &lt;A, B&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivially_constructible","title":"typedef is_trivially_constructible","text":"<pre><code>using zmbt::is_trivially_constructible = typedef std::is_trivially_constructible&lt;T, Args...&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivially_copy_assignable","title":"typedef is_trivially_copy_assignable","text":"<pre><code>using zmbt::is_trivially_copy_assignable = typedef std:: is_trivially_copy_assignable &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivially_copy_constructible","title":"typedef is_trivially_copy_constructible","text":"<pre><code>using zmbt::is_trivially_copy_constructible = typedef std:: is_trivially_copy_constructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivially_copyable","title":"typedef is_trivially_copyable","text":"<pre><code>using zmbt::is_trivially_copyable = typedef std:: is_trivially_copyable &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivially_default_constructible","title":"typedef is_trivially_default_constructible","text":"<pre><code>using zmbt::is_trivially_default_constructible = typedef std:: is_trivially_default_constructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivially_destructible","title":"typedef is_trivially_destructible","text":"<pre><code>using zmbt::is_trivially_destructible = typedef std:: is_trivially_destructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivially_move_assignable","title":"typedef is_trivially_move_assignable","text":"<pre><code>using zmbt::is_trivially_move_assignable = typedef std:: is_trivially_move_assignable &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_trivially_move_constructible","title":"typedef is_trivially_move_constructible","text":"<pre><code>using zmbt::is_trivially_move_constructible = typedef std:: is_trivially_move_constructible &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_tuple","title":"typedef is_tuple","text":"<pre><code>using zmbt::is_tuple = typedef mp_or&lt; mp_similar&lt;tuple&lt;&gt;, T&gt;, mp_similar&lt;std::pair&lt;void, void&gt;, T&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_type_tag","title":"typedef is_type_tag","text":"<pre><code>using zmbt::is_type_tag = typedef mp_similar&lt;decay_t&lt;T&gt;, type_tag&lt;void&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_union","title":"typedef is_union","text":"<pre><code>using zmbt::is_union = typedef std:: is_union &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_unsigned","title":"typedef is_unsigned","text":"<pre><code>using zmbt::is_unsigned = typedef std:: is_unsigned &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_void","title":"typedef is_void","text":"<pre><code>using zmbt::is_void = typedef std:: is_void &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-is_volatile","title":"typedef is_volatile","text":"<pre><code>using zmbt::is_volatile = typedef std:: is_volatile &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-js_array_slice_const_gen","title":"typedef js_array_slice_const_gen","text":"<pre><code>using zmbt::js_array_slice_const_gen = typedef std::function&lt;boost::json::array::const_iterator()&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-js_array_slice_gen","title":"typedef js_array_slice_gen","text":"<pre><code>using zmbt::js_array_slice_gen = typedef std::function&lt;boost::json::array::iterator()&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-js_string_slice_gen","title":"typedef js_string_slice_gen","text":"<pre><code>using zmbt::js_string_slice_gen = typedef std::function&lt;boost::json::string_view::const_iterator()&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-make_signed","title":"typedef make_signed","text":"<pre><code>using zmbt::make_signed = typedef std:: make_signed &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-make_signed_t","title":"typedef make_signed_t","text":"<pre><code>using zmbt::make_signed_t = typedef typename make_signed &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-make_unsigned","title":"typedef make_unsigned","text":"<pre><code>using zmbt::make_unsigned = typedef std:: make_unsigned &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-make_unsigned_t","title":"typedef make_unsigned_t","text":"<pre><code>using zmbt::make_unsigned_t = typedef typename make_unsigned &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_const","title":"typedef remove_const","text":"<pre><code>using zmbt::remove_const = typedef std:: remove_const &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_const_t","title":"typedef remove_const_t","text":"<pre><code>using zmbt::remove_const_t = typedef typename remove_const &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_cv","title":"typedef remove_cv","text":"<pre><code>using zmbt::remove_cv = typedef std:: remove_cv &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_cv_t","title":"typedef remove_cv_t","text":"<pre><code>using zmbt::remove_cv_t = typedef typename remove_cv &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_cvptr_t","title":"typedef remove_cvptr_t","text":"<pre><code>using zmbt::remove_cvptr_t = typedef remove_cv_t&lt;remove_pointer_t&lt;T&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_cvref_t","title":"typedef remove_cvref_t","text":"<pre><code>using zmbt::remove_cvref_t = typedef remove_cv_t&lt;remove_reference_t&lt;T&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_pointer","title":"typedef remove_pointer","text":"<pre><code>using zmbt::remove_pointer = typedef std:: remove_pointer &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_pointer_t","title":"typedef remove_pointer_t","text":"<pre><code>using zmbt::remove_pointer_t = typedef typename remove_pointer &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_reference","title":"typedef remove_reference","text":"<pre><code>using zmbt::remove_reference = typedef std:: remove_reference &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_reference_t","title":"typedef remove_reference_t","text":"<pre><code>using zmbt::remove_reference_t = typedef typename remove_reference &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_volatile","title":"typedef remove_volatile","text":"<pre><code>using zmbt::remove_volatile = typedef std:: remove_volatile &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-remove_volatile_t","title":"typedef remove_volatile_t","text":"<pre><code>using zmbt::remove_volatile_t = typedef typename remove_volatile &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-require_cal","title":"typedef require_cal","text":"<pre><code>using zmbt::require_cal = typedef mp_if&lt;detail::is_cal&lt;T&gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-require_json_from","title":"typedef require_json_from","text":"<pre><code>using zmbt::require_json_from = typedef mp_if&lt;boost::json::has_value_from&lt;T&gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-require_literal","title":"typedef require_literal","text":"<pre><code>using zmbt::require_literal = typedef mp_if&lt;mp_and&lt;detail::maybe_obj&lt;O&gt;, detail::is_cal&lt;I&gt; &gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-require_no_json_from","title":"typedef require_no_json_from","text":"<pre><code>using zmbt::require_no_json_from = typedef mp_if&lt;mp_not&lt;boost::json::has_value_from&lt;T&gt; &gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-require_not_cal","title":"typedef require_not_cal","text":"<pre><code>using zmbt::require_not_cal = typedef mp_if&lt;detail::not_cal&lt;T&gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-require_not_str","title":"typedef require_not_str","text":"<pre><code>using zmbt::require_not_str = typedef mp_if&lt;mp_not&lt;boost::json::is_string_like&lt;T&gt; &gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-require_obj","title":"typedef require_obj","text":"<pre><code>using zmbt::require_obj = typedef mp_if&lt;detail::maybe_obj&lt;T&gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-require_str","title":"typedef require_str","text":"<pre><code>using zmbt::require_str = typedef mp_if&lt;boost::json::is_string_like&lt;T&gt;, R&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-tuple","title":"typedef tuple","text":"<pre><code>using zmbt::tuple = typedef std::tuple&lt;T...&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-tuple_size","title":"typedef tuple_size","text":"<pre><code>using zmbt::tuple_size = typedef std::tuple_size&lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-tuple_unqf_t","title":"typedef tuple_unqf_t","text":"<pre><code>using zmbt::tuple_unqf_t = typedef mp_transform&lt;remove_cvref_t, L&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-underlying_type","title":"typedef underlying_type","text":"<pre><code>using zmbt::underlying_type = typedef std:: underlying_type &lt;T&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#typedef-underlying_type_t","title":"typedef underlying_type_t","text":"<pre><code>using zmbt::underlying_type_t = typedef typename underlying_type &lt;T&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/namespacezmbt/#variable-ifc_host_nullptr","title":"variable ifc_host_nullptr","text":"<p>Resolves to H*{} for member function pointers of H, or to nullptr_t for other callables. <pre><code>constexpr add_pointer_t&lt;remove_reference_t&lt;ifc_host_t&lt;Interface&gt; &gt; &gt; zmbt::ifc_host_nullptr;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#variable-type","title":"variable type","text":"<p>type tag value <pre><code>constexpr type_tag&lt;T&gt; const zmbt::type;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul>"},{"location":"CxxRef/namespacezmbt/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"CxxRef/namespacezmbt/#variable-emplace_shared","title":"variable emplace_shared","text":"<pre><code>constexpr detail::emplace_shared_tag zmbt::emplace_shared;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-has_virtual_destructor_v","title":"variable has_virtual_destructor_v","text":"<pre><code>constexpr bool zmbt::has_virtual_destructor_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_abstract_v","title":"variable is_abstract_v","text":"<pre><code>constexpr bool zmbt::is_abstract_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_arithmetic_v","title":"variable is_arithmetic_v","text":"<pre><code>constexpr bool zmbt::is_arithmetic_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_array_v","title":"variable is_array_v","text":"<pre><code>constexpr bool zmbt::is_array_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_assignable_v","title":"variable is_assignable_v","text":"<pre><code>constexpr bool zmbt::is_assignable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_base_of_v","title":"variable is_base_of_v","text":"<pre><code>constexpr bool zmbt::is_base_of_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_class_v","title":"variable is_class_v","text":"<pre><code>constexpr bool zmbt::is_class_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_compound_v","title":"variable is_compound_v","text":"<pre><code>constexpr bool zmbt::is_compound_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_const_v","title":"variable is_const_v","text":"<pre><code>constexpr bool zmbt::is_const_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_convertible_v","title":"variable is_convertible_v","text":"<pre><code>constexpr bool zmbt::is_convertible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_copy_assignable_v","title":"variable is_copy_assignable_v","text":"<pre><code>constexpr bool zmbt::is_copy_assignable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_copy_constructible_v","title":"variable is_copy_constructible_v","text":"<pre><code>constexpr bool zmbt::is_copy_constructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_default_constructible_v","title":"variable is_default_constructible_v","text":"<pre><code>constexpr bool zmbt::is_default_constructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_destructible_v","title":"variable is_destructible_v","text":"<pre><code>constexpr bool zmbt::is_destructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_empty_v","title":"variable is_empty_v","text":"<pre><code>constexpr bool zmbt::is_empty_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_enum_v","title":"variable is_enum_v","text":"<pre><code>constexpr bool zmbt::is_enum_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_final_v","title":"variable is_final_v","text":"<pre><code>constexpr bool zmbt::is_final_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_floating_point_v","title":"variable is_floating_point_v","text":"<pre><code>constexpr bool zmbt::is_floating_point_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_function_v","title":"variable is_function_v","text":"<pre><code>constexpr bool zmbt::is_function_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_fundamental_v","title":"variable is_fundamental_v","text":"<pre><code>constexpr bool zmbt::is_fundamental_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_integral_v","title":"variable is_integral_v","text":"<pre><code>constexpr bool zmbt::is_integral_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_lvalue_reference_v","title":"variable is_lvalue_reference_v","text":"<pre><code>constexpr bool zmbt::is_lvalue_reference_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_member_function_pointer_v","title":"variable is_member_function_pointer_v","text":"<pre><code>constexpr bool zmbt::is_member_function_pointer_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_member_object_pointer_v","title":"variable is_member_object_pointer_v","text":"<pre><code>constexpr bool zmbt::is_member_object_pointer_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_member_pointer_v","title":"variable is_member_pointer_v","text":"<pre><code>constexpr bool zmbt::is_member_pointer_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_move_assignable_v","title":"variable is_move_assignable_v","text":"<pre><code>constexpr bool zmbt::is_move_assignable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_move_constructible_v","title":"variable is_move_constructible_v","text":"<pre><code>constexpr bool zmbt::is_move_constructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_nothrow_assignable_v","title":"variable is_nothrow_assignable_v","text":"<pre><code>constexpr bool zmbt::is_nothrow_assignable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_nothrow_copy_assignable_v","title":"variable is_nothrow_copy_assignable_v","text":"<pre><code>constexpr bool zmbt::is_nothrow_copy_assignable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_nothrow_copy_constructible_v","title":"variable is_nothrow_copy_constructible_v","text":"<pre><code>constexpr bool zmbt::is_nothrow_copy_constructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_nothrow_default_constructible_v","title":"variable is_nothrow_default_constructible_v","text":"<pre><code>constexpr bool zmbt::is_nothrow_default_constructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_nothrow_destructible_v","title":"variable is_nothrow_destructible_v","text":"<pre><code>constexpr bool zmbt::is_nothrow_destructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_nothrow_move_assignable_v","title":"variable is_nothrow_move_assignable_v","text":"<pre><code>constexpr bool zmbt::is_nothrow_move_assignable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_nothrow_move_constructible_v","title":"variable is_nothrow_move_constructible_v","text":"<pre><code>constexpr bool zmbt::is_nothrow_move_constructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_null_pointer_v","title":"variable is_null_pointer_v","text":"<pre><code>constexpr bool zmbt::is_null_pointer_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_object_v","title":"variable is_object_v","text":"<pre><code>constexpr bool zmbt::is_object_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_pointer_v","title":"variable is_pointer_v","text":"<pre><code>constexpr bool zmbt::is_pointer_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_polymorphic_v","title":"variable is_polymorphic_v","text":"<pre><code>constexpr bool zmbt::is_polymorphic_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_reference_v","title":"variable is_reference_v","text":"<pre><code>constexpr bool zmbt::is_reference_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_rvalue_reference_v","title":"variable is_rvalue_reference_v","text":"<pre><code>constexpr bool zmbt::is_rvalue_reference_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_same_v","title":"variable is_same_v","text":"<pre><code>constexpr bool zmbt::is_same_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_scalar_v","title":"variable is_scalar_v","text":"<pre><code>constexpr bool zmbt::is_scalar_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_signed_v","title":"variable is_signed_v","text":"<pre><code>constexpr bool zmbt::is_signed_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_standard_layout_v","title":"variable is_standard_layout_v","text":"<pre><code>constexpr bool zmbt::is_standard_layout_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_trivial_v","title":"variable is_trivial_v","text":"<pre><code>constexpr bool zmbt::is_trivial_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_trivially_assignable_v","title":"variable is_trivially_assignable_v","text":"<pre><code>constexpr bool zmbt::is_trivially_assignable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_trivially_copy_assignable_v","title":"variable is_trivially_copy_assignable_v","text":"<pre><code>constexpr bool zmbt::is_trivially_copy_assignable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_trivially_copy_constructible_v","title":"variable is_trivially_copy_constructible_v","text":"<pre><code>constexpr bool zmbt::is_trivially_copy_constructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_trivially_copyable_v","title":"variable is_trivially_copyable_v","text":"<pre><code>constexpr bool zmbt::is_trivially_copyable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_trivially_default_constructible_v","title":"variable is_trivially_default_constructible_v","text":"<pre><code>constexpr bool zmbt::is_trivially_default_constructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_trivially_destructible_v","title":"variable is_trivially_destructible_v","text":"<pre><code>constexpr bool zmbt::is_trivially_destructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_trivially_move_assignable_v","title":"variable is_trivially_move_assignable_v","text":"<pre><code>constexpr bool zmbt::is_trivially_move_assignable_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_trivially_move_constructible_v","title":"variable is_trivially_move_constructible_v","text":"<pre><code>constexpr bool zmbt::is_trivially_move_constructible_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_union_v","title":"variable is_union_v","text":"<pre><code>constexpr bool zmbt::is_union_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_unsigned_v","title":"variable is_unsigned_v","text":"<pre><code>constexpr bool zmbt::is_unsigned_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_void_v","title":"variable is_void_v","text":"<pre><code>constexpr bool zmbt::is_void_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-is_volatile_v","title":"variable is_volatile_v","text":"<pre><code>constexpr bool zmbt::is_volatile_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#variable-tuple_size_v","title":"variable tuple_size_v","text":"<pre><code>constexpr size_t zmbt::tuple_size_v;\n</code></pre>"},{"location":"CxxRef/namespacezmbt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/namespacezmbt/#function-initzmbt","title":"function InitZmbt","text":"<p>Initialize test application. <pre><code>void zmbt::InitZmbt (\n    int argc,\n    char ** argv\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-interfacerecord","title":"function InterfaceRecord","text":"<p>Make TypedInterfaceHandle instance. <pre><code>template&lt;class Interface&gt;\nEnvironment::TypedInterfaceHandle &lt; Interface &gt; zmbt::InterfaceRecord (\n    Interface const &amp; interface,\n    object_id const &amp; obj={ ifc_host_nullptr &lt; Interface &gt;}\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Interface</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>obj</code> </li> <li><code>interface</code> </li> </ul> <p>Returns:</p> <p>TypedInterfaceHandle&lt;Interface&gt; </p>"},{"location":"CxxRef/namespacezmbt/#function-construct_or_default","title":"function construct_or_default","text":"<p>Construct T from the given arguments or return default T if construction is invalid. <pre><code>template&lt;class T, class... A&gt;\nT zmbt::construct_or_default (\n    A &amp;&amp;... args\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-convert_tuple_to","title":"function convert_tuple_to","text":"<p>Convert given tuple to a tuple of type T. <pre><code>template&lt;class T, class... A&gt;\ninline T zmbt::convert_tuple_to (\n    tuple&lt; A... &gt; &amp; source\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> target tuple type </li> <li><code>A</code> source tuple parameters </li> </ul> <p>Parameters:</p> <ul> <li><code>source</code> input tuple </li> </ul> <p>Returns:</p> <p>T </p>"},{"location":"CxxRef/namespacezmbt/#function-default_test_failure","title":"function default_test_failure","text":"<p>default test failure handler <pre><code>void zmbt::default_test_failure (\n    boost::json::value const &amp; report\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-dejsonize","title":"function dejsonize","text":"<pre><code>template&lt;class T&gt;\nreflect::detail::disable_hermetic_serialization&lt; T, T &gt; zmbt::dejsonize (\n    boost::json::value const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-dejsonize_1","title":"function dejsonize","text":"<pre><code>template&lt;class T&gt;\nreflect::detail::enable_hermetic_serialization&lt; T, T &gt; zmbt::dejsonize (\n    boost::json::value const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-dejsonize-void","title":"function dejsonize&lt; void &gt;","text":"<pre><code>template&lt;&gt;\ninline void zmbt::dejsonize&lt; void &gt; (\n    boost::json::value const &amp;\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-dejsonize_array","title":"function dejsonize_array","text":"<pre><code>template&lt;class T, std::size_t N&gt;\nvoid zmbt::dejsonize_array (\n    boost::json::array const &amp; jarr,\n    T(&amp;) array\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-format","title":"function format","text":"<p>boost::format wrapper with printf-like api <pre><code>template&lt;class... A&gt;\nstd::string zmbt::format (\n    boost::json::string_view fmtstr,\n    A &amp;&amp;... arg\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-format_failure_report","title":"function format_failure_report","text":"<p>default failure report formatter <pre><code>void zmbt::format_failure_report (\n    std::ostream &amp; os,\n    boost::json::value const &amp; report\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-get_ifc_handle","title":"function get_ifc_handle","text":"<p>Get reference to callable object. <pre><code>template&lt;class Interface, class Result&gt;\nauto zmbt::get_ifc_handle (\n    Interface const x\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-get_ifc_handle_1","title":"function get_ifc_handle","text":"<pre><code>template&lt;class Interface, class Result&gt;\nauto zmbt::get_ifc_handle (\n    Interface * x\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-get_ifc_handle_2","title":"function get_ifc_handle","text":"<pre><code>template&lt;class Interface, class Result&gt;\nauto zmbt::get_ifc_handle (\n    Interface &amp; x\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-get_ifc_pointer","title":"function get_ifc_pointer","text":"<p>Get pointer to callable object. <pre><code>template&lt;class Interface, class Result&gt;\nauto zmbt::get_ifc_pointer (\n    Interface x\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-get_ifc_pointer_1","title":"function get_ifc_pointer","text":"<pre><code>template&lt;class Interface, class Result&gt;\nauto zmbt::get_ifc_pointer (\n    Interface * x\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-get_ifc_pointer_2","title":"function get_ifc_pointer","text":"<pre><code>template&lt;class Interface, class Result&gt;\nauto zmbt::get_ifc_pointer (\n    Interface &amp; x\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-get_tid","title":"function get_tid","text":"<p>get thread id in string <pre><code>std::string zmbt::get_tid () \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-get_ts","title":"function get_ts","text":"<p>get timestamp <pre><code>std::size_t zmbt::get_ts () \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-json_from","title":"function json_from","text":"<pre><code>template&lt;class T, class TT&gt;\nreflect::detail::disable_hermetic_serialization&lt; TT, boost::json::value &gt; zmbt::json_from (\n    T &amp;&amp; t\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-json_from_1","title":"function json_from","text":"<pre><code>template&lt;class T, class TT&gt;\nreflect::detail::enable_hermetic_serialization&lt; TT, boost::json::value &gt; zmbt::json_from (\n    T &amp;&amp; t\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-json_from_2","title":"function json_from","text":"<pre><code>inline boost::json::value zmbt::json_from (\n    std::tuple&lt;&gt;\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-json_from_array","title":"function json_from_array","text":"<pre><code>template&lt;class T, std::size_t N&gt;\nboost::json::value zmbt::json_from_array (\n    T const (&amp;) array\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-make_slice_const_generator","title":"function make_slice_const_generator","text":"<pre><code>js_array_slice_const_gen zmbt::make_slice_const_generator (\n    boost::json::array const &amp; src,\n    std::int64_t const start=0,\n    std::int64_t const stop=-1,\n    std::int64_t const step=1\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-make_slice_const_generator_1","title":"function make_slice_const_generator","text":"<pre><code>js_string_slice_gen zmbt::make_slice_const_generator (\n    boost::json::string_view const src,\n    std::int64_t const start=0,\n    std::int64_t const stop=-1,\n    std::int64_t const step=1\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-make_slice_generator","title":"function make_slice_generator","text":"<pre><code>js_array_slice_gen zmbt::make_slice_generator (\n    boost::json::array &amp; src,\n    std::int64_t const start=0,\n    std::int64_t const stop=-1,\n    std::int64_t const step=1\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-maybe_real_to_number","title":"function maybe_real_to_number","text":"<pre><code>boost::json::value zmbt::maybe_real_to_number (\n    boost::json::value const &amp; value\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-maybe_real_to_number_inplace","title":"function maybe_real_to_number_inplace","text":"<pre><code>bool zmbt::maybe_real_to_number_inplace (\n    boost::json::value &amp; value\n) \n</code></pre> <p>Convert a signed integer to JSON number in place, storing result as uint64_t if possible. </p>"},{"location":"CxxRef/namespacezmbt/#function-param_transform","title":"function param_transform","text":"<p>Transform Param value of type T to json value and handle type-specific environment effects. <pre><code>template&lt;class T&gt;\nboost::json::value zmbt::param_transform (\n    Param const &amp; param,\n    boost::json::array const &amp; pointers,\n    T &amp;&amp; value\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-pretty_print","title":"function pretty_print","text":"<p>Pretty print JSON data. <pre><code>std::ostream &amp; zmbt::pretty_print (\n    std::ostream &amp; os,\n    boost::json::value const &amp; jv,\n    int const indent=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>jv</code> </li> <li><code>indent</code> initial indent </li> </ul> <p>Returns:</p> <p>std::ostream&amp; </p>"},{"location":"CxxRef/namespacezmbt/#function-real_to_number","title":"function real_to_number","text":"<pre><code>boost::json::value zmbt::real_to_number (\n    double value\n) \n</code></pre> <p>Convert a double to a JSON number, storing result as uint64_t or int64_t if possible. </p>"},{"location":"CxxRef/namespacezmbt/#function-real_to_number_1","title":"function real_to_number","text":"<pre><code>boost::json::value zmbt::real_to_number (\n    std::int64_t value\n) \n</code></pre> <p>Convert a signed integer to JSON number, storing result as uint64_t if possible. </p>"},{"location":"CxxRef/namespacezmbt/#function-slice","title":"function slice","text":"<p>Slice array with inclusive boundaries and subsignal cherry-pick. <pre><code>boost::json::array zmbt::slice (\n    boost::json::array const &amp; src,\n    boost::json::string_view jp,\n    std::int64_t const start=0,\n    std::int64_t const stop=-1,\n    std::int64_t const step=1\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src</code> source array </li> <li><code>jp</code> JSON Pointer for subsignal cherry-pick </li> <li><code>start</code> start index, 0-based, inclusive; negative value yields reverse index; </li> <li><code>stop</code> stop index, 0-based, inclusive; negative value yields reverse index; </li> <li><code>step</code> step value, negative value yields reverse iteration </li> </ul> <p>Returns:</p> <p>slice array </p>"},{"location":"CxxRef/namespacezmbt/#function-slice_1","title":"function slice","text":"<p>Slice array with inclusive boundaries. <pre><code>boost::json::array zmbt::slice (\n    boost::json::array const &amp; src,\n    std::int64_t const start=0,\n    std::int64_t const stop=-1,\n    std::int64_t const step=1\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src</code> source array </li> <li><code>start</code> start index, 0-based, inclusive; negative value yields reverse index; </li> <li><code>stop</code> stop index, 0-based, inclusive; negative value yields reverse index; </li> <li><code>step</code> step value, negative value yields reverse iteration </li> </ul> <p>Returns:</p> <p>slice array </p>"},{"location":"CxxRef/namespacezmbt/#function-slice_2","title":"function slice","text":"<pre><code>boost::json::string zmbt::slice (\n    boost::json::string_view const src,\n    std::int64_t const start=0,\n    std::int64_t const stop=-1,\n    std::int64_t const step=1\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-throw_exception","title":"function throw_exception","text":"<pre><code>template&lt;class E&gt;\nvoid zmbt::throw_exception (\n    E &amp;&amp; e\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-tid2str","title":"function tid2str","text":"<p>thread id to string <pre><code>std::string zmbt::tid2str (\n    std::thread::id const tid\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt/#function-tuple_exchange","title":"function tuple_exchange","text":"<pre><code>template&lt;class T1, class T2&gt;\nvoid zmbt::tuple_exchange (\n    T1 &amp; target,\n    T2 const &amp; src\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt/#function-type_name","title":"function type_name","text":"<p>Prettified typename. <pre><code>template&lt;class T&gt;\ninline std::string zmbt::type_name () \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Returns:</p> <p>std::string </p>"},{"location":"CxxRef/namespacezmbt/#function-type_name_1","title":"function type_name","text":"<p>Prettified typename. <pre><code>template&lt;class T&gt;\ninline std::string zmbt::type_name (\n    T\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Returns:</p> <p>std::string </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/model_test.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1Config/","title":"Class zmbt::Config","text":"<p>ClassList &gt; zmbt &gt; Config</p> <p>Global app config. </p> <ul> <li><code>#include &lt;config.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1Config/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; void(boost::json::value const  &amp;)&gt; FailureHandler"},{"location":"CxxRef/classzmbt_1_1Config/#public-functions","title":"Public Functions","text":"Type Name Config ()  Config (Config const &amp;) = default Config (Config &amp;&amp;) = default Config &amp; HandleTestFailure (boost::json::value const &amp; diagnostics)  Config &amp; ResetFailureHandler () Reset the test handler to default. Config &amp; SetFailureHandler (FailureHandler const &amp; fn) Set custom test failure handler. Config &amp; operator= (Config const &amp;) = default Config &amp; operator= (Config &amp;&amp;) = default ~Config () = default"},{"location":"CxxRef/classzmbt_1_1Config/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Config/#typedef-failurehandler","title":"typedef FailureHandler","text":"<pre><code>using zmbt::Config::FailureHandler =  std::function&lt;void(boost::json::value const&amp;)&gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Config/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Config/#function-config-13","title":"function Config [1/3]","text":"<pre><code>zmbt::Config::Config () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Config/#function-config-23","title":"function Config [2/3]","text":"<pre><code>zmbt::Config::Config (\n    Config const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Config/#function-config-33","title":"function Config [3/3]","text":"<pre><code>zmbt::Config::Config (\n    Config &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Config/#function-handletestfailure","title":"function HandleTestFailure","text":"<pre><code>Config &amp; zmbt::Config::HandleTestFailure (\n    boost::json::value const &amp; diagnostics\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Config/#function-resetfailurehandler","title":"function ResetFailureHandler","text":"<p>Reset the test handler to default. <pre><code>Config &amp; zmbt::Config::ResetFailureHandler () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Config/#function-setfailurehandler","title":"function SetFailureHandler","text":"<p>Set custom test failure handler. <pre><code>Config &amp; zmbt::Config::SetFailureHandler (\n    FailureHandler const &amp; fn\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Config/#function-operator","title":"function operator=","text":"<pre><code>Config &amp; zmbt::Config::operator= (\n    Config const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Config/#function-operator_1","title":"function operator=","text":"<pre><code>Config &amp; zmbt::Config::operator= (\n    Config &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Config/#function-config","title":"function ~Config","text":"<pre><code>zmbt::Config::~Config () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application/config.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1Environment/","title":"Class zmbt::Environment","text":"<p>ClassList &gt; zmbt &gt; Environment</p> <p>Controlled environment data storage. More...</p> <ul> <li><code>#include &lt;environment.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1Environment/#classes","title":"Classes","text":"Type Name class InterfaceHandle Environment extension handling the interface data. class TypedInterfaceHandle &lt;class Interface&gt;Environment API handler for specific interface."},{"location":"CxxRef/classzmbt_1_1Environment/#public-functions","title":"Public Functions","text":"Type Name bool ContainsShared (lang::Expression const &amp; key_expr) constCheck if shared variable exists. object_id DefaultObjectId (interface_id const &amp; ifc_id) const lock_t DeferLock () constGet the Environment thread lock with std::defer_lock tag. void DumpToJsonLog () Dump current environment state to JSON log. Environment ()  Environment (Environment &amp;&amp;) = default Environment (Environment const &amp;) = default boost::json::string GetOrRegisterInterface (object_id const &amp; obj_id, interface_id const &amp; ifc_id)  boost::json::string GetOrRegisterParametricTrigger (object_id const &amp; obj_id, interface_id const &amp; ifc_id)  reflect::Prototypes GetPrototypes (interface_id const &amp; id) const std::shared_ptr&lt; OutputRecorder &gt; GetRecorder (Interface &amp;&amp; interface)  std::shared_ptr&lt; OutputRecorder &gt; GetRecorder (interface_id const &amp; ifc_id, object_id const &amp; obj_id)  std::shared_ptr&lt; T &gt; GetShared (lang::Expression const &amp; key_expr) constGet the shared data associated with object and string key. T &amp; GetSharedRef (lang::Expression const &amp; key_expr, A &amp;&amp;... args) Get reference to shared var, creating it if necessary. boost::json::value GetVar (lang::Expression const &amp; key_expr) Get the environment variable. T GetVar (lang::Expression const &amp; key_expr)  boost::json::value GetVarOrDefault (lang::Expression const &amp; key_expr, boost::json::value default_value={}) Get the environment variable or use default. T GetVarOrDefault (lang::Expression const &amp; key_expr, T default_value=reflect::signal_traits&lt; T &gt;::init())  boost::json::value GetVarOrUpdate (lang::Expression const &amp; key_expr, boost::json::value update_value) Get or update the environment variable. T GetVarOrUpdate (lang::Expression const &amp; key_expr, T update_value)  bool HasAction (boost::json::string_view key) const bool HasTestError () Current test error payload, null if none. bool HasTrigger (boost::json::string_view key) const Environment &amp; InitializeInterfaceHandlers (Interface &amp;&amp; interface)  interface_id InterfaceId (boost::json::string_view interface_key) const lock_t Lock () constGet the Environment thread lock. object_id ObjectId (boost::json::string_view interface_key) const Environment &amp; RegisterAction (lang::Expression const &amp; key_expr, std::function&lt; void()&gt; action)  Environment &amp; RegisterAnonymousInterface (interface_id const &amp; ifc_id, object_id const &amp; obj_id)  enable_if_t&lt; is_ifc_handle&lt; Interface &gt;::value, Environment &amp; &gt; RegisterAnonymousInterface (Interface &amp;&amp; interface, object_id const &amp; obj_id=object_id{ifc_host_nullptr&lt; Interface &gt;})  boost::json::string RegisterAnonymousTrigger (Interface &amp;&amp; interface, H &amp;&amp; host)  Environment &amp; RegisterInterface (boost::json::string_view key, interface_id const &amp; ifc_id, object_id const &amp; obj_id) Register interface to enable FFI in the test model runners. enable_if_t&lt; is_ifc_handle&lt; Interface &gt;::value, Environment &amp; &gt; RegisterInterface (boost::json::string_view key, Interface &amp;&amp; interface, object_id const &amp; obj_id=object_id{ifc_host_nullptr&lt; Interface &gt;})  interface_id RegisterParametricTriggerIfc (Interface &amp;&amp; interface)  object_id RegisterParametricTriggerObj (T &amp;&amp; obj)  Environment &amp; RegisterTrigger (boost::json::string_view key, Interface &amp;&amp; interface, H &amp;&amp; host) Register test trigger to enable FFI in the test model runners. Environment &amp; RegisterTrigger (boost::json::string_view key, Interface &amp;&amp; interface)  void ResetAll () Clear all data. void ResetInterfaceData () Clear all interface data (accessed via ArgsFor/ReturnFor) Environment &amp; RunAction (lang::Expression const &amp; key_expr)  Environment &amp; RunActionNoCatch (lang::Expression const &amp; key_expr)  void SetShared (lang::Expression const &amp; key_expr, std::shared_ptr&lt; T &gt; data) Set the shared data associated with key. void SetVar (lang::Expression const &amp; key_expr, boost::json::value var) Set the environment variable. void SetVar (lang::Expression const &amp; key_expr, T var)  boost::json::value const &amp; TestError () Current test error payload, null if none. lock_t TryLock () constGet the Environment thread lock with std::try_to_lock tag. JsonNode &amp; json_data ()  JsonNode const &amp; json_data () const Environment &amp; operator= (Environment &amp;&amp;) = default Environment &amp; operator= (Environment const &amp;) = default virtual ~Environment ()"},{"location":"CxxRef/classzmbt_1_1Environment/#public-static-functions","title":"Public Static Functions","text":"Type Name boost::json::string autokey (object_id const &amp; obj_id, interface_id const &amp; ifc_id)"},{"location":"CxxRef/classzmbt_1_1Environment/#protected-types","title":"Protected Types","text":"Type Name typedef reflect::invocation_args_t&lt; ifc_pointer_t&lt; Interface &gt; &gt; argsref_t typedef mp_transform&lt; rvref_to_val, argsref_t&lt; Interface &gt; &gt; hookout_args_t typedef typename EnvironmentData::lock_t lock_t typedef reflect::invocation_ret_t&lt; ifc_pointer_t&lt; Interface &gt; &gt; return_t typedef mp_if&lt; std::is_rvalue_reference&lt; T &gt;, std::remove_reference_t&lt; T &gt;, T &gt; rvref_to_val typedef reflect::invocation_args_unqf_t&lt; ifc_pointer_t&lt; Interface &gt; &gt; unqf_args_t"},{"location":"CxxRef/classzmbt_1_1Environment/#protected-attributes","title":"Protected Attributes","text":"Type Name std::shared_ptr&lt; EnvironmentData &gt; data_ std::shared_ptr&lt; PermanentEnvData &gt; permanent_data_"},{"location":"CxxRef/classzmbt_1_1Environment/#protected-functions","title":"Protected Functions","text":"Type Name void SetTestError (boost::json::value &amp;&amp; msg)"},{"location":"CxxRef/classzmbt_1_1Environment/#detailed-description","title":"Detailed Description","text":"<p>Handles signal values and calls counters to/from environment, using interface pointers as keys </p> <p>See also: Environment API </p>"},{"location":"CxxRef/classzmbt_1_1Environment/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Environment/#function-containsshared","title":"function ContainsShared","text":"<p>Check if shared variable exists. <pre><code>bool zmbt::Environment::ContainsShared (\n    lang::Expression const &amp; key_expr\n) const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-defaultobjectid","title":"function DefaultObjectId","text":"<pre><code>object_id zmbt::Environment::DefaultObjectId (\n    interface_id const &amp; ifc_id\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-deferlock","title":"function DeferLock","text":"<p>Get the Environment thread lock with std::defer_lock tag. <pre><code>lock_t zmbt::Environment::DeferLock () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-dumptojsonlog","title":"function DumpToJsonLog","text":"<p>Dump current environment state to JSON log. <pre><code>void zmbt::Environment::DumpToJsonLog () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-environment-13","title":"function Environment [1/3]","text":"<pre><code>zmbt::Environment::Environment () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-environment-23","title":"function Environment [2/3]","text":"<pre><code>zmbt::Environment::Environment (\n    Environment &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-environment-33","title":"function Environment [3/3]","text":"<pre><code>zmbt::Environment::Environment (\n    Environment const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getorregisterinterface","title":"function GetOrRegisterInterface","text":"<pre><code>boost::json::string zmbt::Environment::GetOrRegisterInterface (\n    object_id const &amp; obj_id,\n    interface_id const &amp; ifc_id\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getorregisterparametrictrigger","title":"function GetOrRegisterParametricTrigger","text":"<pre><code>boost::json::string zmbt::Environment::GetOrRegisterParametricTrigger (\n    object_id const &amp; obj_id,\n    interface_id const &amp; ifc_id\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getprototypes","title":"function GetPrototypes","text":"<pre><code>inline reflect::Prototypes zmbt::Environment::GetPrototypes (\n    interface_id const &amp; id\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getrecorder-12","title":"function GetRecorder [1/2]","text":"<pre><code>template&lt;class Interface&gt;\ninline std::shared_ptr&lt; OutputRecorder &gt; zmbt::Environment::GetRecorder (\n    Interface &amp;&amp; interface\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getrecorder-22","title":"function GetRecorder [2/2]","text":"<pre><code>inline std::shared_ptr&lt; OutputRecorder &gt; zmbt::Environment::GetRecorder (\n    interface_id const &amp; ifc_id,\n    object_id const &amp; obj_id\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getshared","title":"function GetShared","text":"<p>Get the shared data associated with object and string key. <pre><code>template&lt;class T&gt;\ninline std::shared_ptr&lt; T &gt; zmbt::Environment::GetShared (\n    lang::Expression const &amp; key_expr\n) const\n</code></pre></p> <p>Dynamic polymorphism is not supported, as the type safety is ensured by comparing typeid(T). If the type T is not exactly the same as was used on corresponding SetShared call, the method will throw environment_error.</p> <p>If corresponding data was not set, the metod return nullptr.</p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> <li><code>A</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>fmtstr</code> key format string </li> <li><code>arg</code> key format arguments </li> </ul> <p>Returns:</p> <p>std::shared_ptr&lt;T&gt; </p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getsharedref","title":"function GetSharedRef","text":"<p>Get reference to shared var, creating it if necessary. <pre><code>template&lt;class T, class... A&gt;\ninline T &amp; zmbt::Environment::GetSharedRef (\n    lang::Expression const &amp; key_expr,\n    A &amp;&amp;... args\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> <li><code>...A</code> Constructor args for initial value </li> </ul> <p>Parameters:</p> <ul> <li><code>key_expr</code> </li> </ul> <p>Returns:</p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getvar-12","title":"function GetVar [1/2]","text":"<p>Get the environment variable. <pre><code>boost::json::value zmbt::Environment::GetVar (\n    lang::Expression const &amp; key_expr\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>obj</code> </li> <li><code>key</code> </li> </ul> <p>Returns:</p> <p>T </p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getvar-22","title":"function GetVar [2/2]","text":"<pre><code>template&lt;class T&gt;\ninline T zmbt::Environment::GetVar (\n    lang::Expression const &amp; key_expr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getvarordefault-12","title":"function GetVarOrDefault [1/2]","text":"<p>Get the environment variable or use default. <pre><code>boost::json::value zmbt::Environment::GetVarOrDefault (\n    lang::Expression const &amp; key_expr,\n    boost::json::value default_value={}\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>obj</code> </li> <li><code>key</code> </li> <li><code>default_value</code> </li> </ul> <p>Returns:</p> <p>T </p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getvarordefault-22","title":"function GetVarOrDefault [2/2]","text":"<pre><code>template&lt;class T&gt;\ninline T zmbt::Environment::GetVarOrDefault (\n    lang::Expression const &amp; key_expr,\n    T default_value=reflect::signal_traits &lt; T &gt;::init()\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getvarorupdate-12","title":"function GetVarOrUpdate [1/2]","text":"<p>Get or update the environment variable. <pre><code>boost::json::value zmbt::Environment::GetVarOrUpdate (\n    lang::Expression const &amp; key_expr,\n    boost::json::value update_value\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>obj</code> </li> <li><code>key</code> </li> <li><code>update_value</code> </li> </ul> <p>Returns:</p> <p>T </p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-getvarorupdate-22","title":"function GetVarOrUpdate [2/2]","text":"<pre><code>template&lt;class T&gt;\ninline T zmbt::Environment::GetVarOrUpdate (\n    lang::Expression const &amp; key_expr,\n    T update_value\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-hasaction","title":"function HasAction","text":"<pre><code>bool zmbt::Environment::HasAction (\n    boost::json::string_view key\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-hastesterror","title":"function HasTestError","text":"<p>Current test error payload, null if none. <pre><code>bool zmbt::Environment::HasTestError () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-hastrigger","title":"function HasTrigger","text":"<pre><code>bool zmbt::Environment::HasTrigger (\n    boost::json::string_view key\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-initializeinterfacehandlers","title":"function InitializeInterfaceHandlers","text":"<pre><code>template&lt;class Interface&gt;\ninline Environment &amp; zmbt::Environment::InitializeInterfaceHandlers (\n    Interface &amp;&amp; interface\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-interfaceid","title":"function InterfaceId","text":"<pre><code>interface_id zmbt::Environment::InterfaceId (\n    boost::json::string_view interface_key\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-lock","title":"function Lock","text":"<p>Get the Environment thread lock. <pre><code>lock_t zmbt::Environment::Lock () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-objectid","title":"function ObjectId","text":"<pre><code>object_id zmbt::Environment::ObjectId (\n    boost::json::string_view interface_key\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registeraction","title":"function RegisterAction","text":"<pre><code>Environment &amp; zmbt::Environment::RegisterAction (\n    lang::Expression const &amp; key_expr,\n    std::function&lt; void()&gt; action\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registeranonymousinterface-12","title":"function RegisterAnonymousInterface [1/2]","text":"<pre><code>inline Environment &amp; zmbt::Environment::RegisterAnonymousInterface (\n    interface_id const &amp; ifc_id,\n    object_id const &amp; obj_id\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registeranonymousinterface-22","title":"function RegisterAnonymousInterface [2/2]","text":"<pre><code>template&lt;class Interface&gt;\ninline enable_if_t&lt; is_ifc_handle&lt; Interface &gt;::value, Environment &amp; &gt; zmbt::Environment::RegisterAnonymousInterface (\n    Interface &amp;&amp; interface,\n    object_id const &amp; obj_id=object_id { ifc_host_nullptr &lt; Interface &gt;}\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registeranonymoustrigger","title":"function RegisterAnonymousTrigger","text":"<pre><code>template&lt;class Interface, class H&gt;\ninline boost::json::string zmbt::Environment::RegisterAnonymousTrigger (\n    Interface &amp;&amp; interface,\n    H &amp;&amp; host\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registerinterface-12","title":"function RegisterInterface [1/2]","text":"<p>Register interface to enable FFI in the test model runners. <pre><code>Environment &amp; zmbt::Environment::RegisterInterface (\n    boost::json::string_view key,\n    interface_id const &amp; ifc_id,\n    object_id const &amp; obj_id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>obj_id</code> object associated with callable </li> <li><code>ifc_id</code> callable handle </li> <li><code>key</code> string key, unique per environment </li> </ul> <p>Returns:</p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registerinterface-22","title":"function RegisterInterface [2/2]","text":"<pre><code>template&lt;class Interface&gt;\ninline enable_if_t&lt; is_ifc_handle&lt; Interface &gt;::value, Environment &amp; &gt; zmbt::Environment::RegisterInterface (\n    boost::json::string_view key,\n    Interface &amp;&amp; interface,\n    object_id const &amp; obj_id=object_id { ifc_host_nullptr &lt; Interface &gt;}\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registerparametrictriggerifc","title":"function RegisterParametricTriggerIfc","text":"<pre><code>template&lt;class Interface&gt;\ninline interface_id zmbt::Environment::RegisterParametricTriggerIfc (\n    Interface &amp;&amp; interface\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registerparametrictriggerobj","title":"function RegisterParametricTriggerObj","text":"<pre><code>template&lt;class T&gt;\ninline object_id zmbt::Environment::RegisterParametricTriggerObj (\n    T &amp;&amp; obj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registertrigger-12","title":"function RegisterTrigger [1/2]","text":"<p>Register test trigger to enable FFI in the test model runners. <pre><code>template&lt;class Interface, class H&gt;\ninline Environment &amp; zmbt::Environment::RegisterTrigger (\n    boost::json::string_view key,\n    Interface &amp;&amp; interface,\n    H &amp;&amp; host\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>H</code> </li> <li><code>Interface</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>host</code> callable host object </li> <li><code>interface</code> callable interface handle </li> <li><code>key</code> string key, unique per environment </li> </ul> <p>Returns:</p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-registertrigger-22","title":"function RegisterTrigger [2/2]","text":"<pre><code>template&lt;class Interface&gt;\ninline Environment &amp; zmbt::Environment::RegisterTrigger (\n    boost::json::string_view key,\n    Interface &amp;&amp; interface\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-resetall","title":"function ResetAll","text":"<p>Clear all data. <pre><code>void zmbt::Environment::ResetAll () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-resetinterfacedata","title":"function ResetInterfaceData","text":"<p>Clear all interface data (accessed via ArgsFor/ReturnFor) <pre><code>void zmbt::Environment::ResetInterfaceData () \n</code></pre></p> <p>Warning:</p> <p>this will invalidate interface records </p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-runaction","title":"function RunAction","text":"<pre><code>Environment &amp; zmbt::Environment::RunAction (\n    lang::Expression const &amp; key_expr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-runactionnocatch","title":"function RunActionNoCatch","text":"<pre><code>Environment &amp; zmbt::Environment::RunActionNoCatch (\n    lang::Expression const &amp; key_expr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-setshared","title":"function SetShared","text":"<p>Set the shared data associated with key. <pre><code>template&lt;class T&gt;\ninline void zmbt::Environment::SetShared (\n    lang::Expression const &amp; key_expr,\n    std::shared_ptr&lt; T &gt; data\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> <li><code>A</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>key_expr</code> </li> <li><code>data</code> </li> </ul>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-setvar-12","title":"function SetVar [1/2]","text":"<p>Set the environment variable. <pre><code>void zmbt::Environment::SetVar (\n    lang::Expression const &amp; key_expr,\n    boost::json::value var\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>key_expr</code> key constant expression </li> <li><code>var</code> </li> </ul>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-setvar-22","title":"function SetVar [2/2]","text":"<pre><code>template&lt;class T&gt;\ninline void zmbt::Environment::SetVar (\n    lang::Expression const &amp; key_expr,\n    T var\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-testerror","title":"function TestError","text":"<p>Current test error payload, null if none. <pre><code>boost::json::value const &amp; zmbt::Environment::TestError () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-trylock","title":"function TryLock","text":"<p>Get the Environment thread lock with std::try_to_lock tag. <pre><code>lock_t zmbt::Environment::TryLock () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-json_data-12","title":"function json_data [1/2]","text":"<pre><code>inline JsonNode &amp; zmbt::Environment::json_data () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-json_data-22","title":"function json_data [2/2]","text":"<pre><code>inline JsonNode const &amp; zmbt::Environment::json_data () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-operator","title":"function operator=","text":"<pre><code>Environment &amp; zmbt::Environment::operator= (\n    Environment &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-operator_1","title":"function operator=","text":"<pre><code>Environment &amp; zmbt::Environment::operator= (\n    Environment const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#function-environment","title":"function ~Environment","text":"<pre><code>inline virtual zmbt::Environment::~Environment () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Environment/#function-autokey","title":"function autokey","text":"<pre><code>static inline boost::json::string zmbt::Environment::autokey (\n    object_id const &amp; obj_id,\n    interface_id const &amp; ifc_id\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Environment/#typedef-argsref_t","title":"typedef argsref_t","text":"<pre><code>using zmbt::Environment::argsref_t =  reflect::invocation_args_t&lt;ifc_pointer_t&lt;Interface&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#typedef-hookout_args_t","title":"typedef hookout_args_t","text":"<pre><code>using zmbt::Environment::hookout_args_t =  mp_transform&lt;rvref_to_val, argsref_t&lt;Interface&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#typedef-lock_t","title":"typedef lock_t","text":"<pre><code>using zmbt::Environment::lock_t =  typename EnvironmentData::lock_t;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#typedef-return_t","title":"typedef return_t","text":"<pre><code>using zmbt::Environment::return_t =  reflect::invocation_ret_t&lt;ifc_pointer_t&lt;Interface&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#typedef-rvref_to_val","title":"typedef rvref_to_val","text":"<pre><code>using zmbt::Environment::rvref_to_val =  mp_if&lt;std::is_rvalue_reference&lt;T&gt;, std::remove_reference_t&lt;T&gt;, T&gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#typedef-unqf_args_t","title":"typedef unqf_args_t","text":"<pre><code>using zmbt::Environment::unqf_args_t =  reflect::invocation_args_unqf_t&lt;ifc_pointer_t&lt;Interface&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Environment/#variable-data_","title":"variable data_","text":"<pre><code>std::shared_ptr&lt;EnvironmentData&gt; zmbt::Environment::data_;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#variable-permanent_data_","title":"variable permanent_data_","text":"<pre><code>std::shared_ptr&lt;PermanentEnvData&gt; zmbt::Environment::permanent_data_;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Environment/#function-settesterror","title":"function SetTestError","text":"<pre><code>void zmbt::Environment::SetTestError (\n    boost::json::value &amp;&amp; msg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/environment.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/","title":"Class zmbt::Environment::InterfaceHandle","text":"<p>ClassList &gt; zmbt &gt; Environment &gt; InterfaceHandle</p> <p>Environment extension handling the interface data.More...</p> <ul> <li><code>#include &lt;environment_interface_record.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: zmbt::Environment::TypedInterfaceHandle</p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#public-functions","title":"Public Functions","text":"Type Name boost::json::array CaptureSlice (boost::json::string_view signal_path) const boost::json::array const &amp; Captures () const void EnableOutputRecordFor (ChannelKind const kind)  Environment &amp; Env () constEnvironment of the interface handle. void Inject (std::shared_ptr&lt; Generator &gt; gen, lang::Expression const &amp; tf, ChannelKind const kind, boost::json::string_view jp=\"\") Set generating function for injection. void InjectArgs (lang::Expression const &amp; e, boost::json::string_view jp=\"\") Set generating function for injection args. void InjectReturn (lang::Expression const &amp; e, boost::json::string_view jp=\"\") Set generating function for injection return. InterfaceHandle (Environment const &amp; e, interface_id const &amp; interface, object_id refobj)  InterfaceHandle (Environment const &amp; e, boost::json::string_view ref)  InterfaceHandle (interface_id const &amp; interface, object_id refobj)  InterfaceHandle (interface_id const &amp; interface, nullptr_t)  InterfaceHandle (boost::json::string_view ref)  InterfaceHandle (interface_id const &amp; interface, H const &amp; obj)  InterfaceHandle (InterfaceHandle const &amp;) = default InterfaceHandle (InterfaceHandle &amp;&amp; o) = default void MaybeThrowException () throw exception if set for current call std::size_t ObservedCalls () constNumber of interface calls. boost::json::array PrototypeArgs () const boost::json::value PrototypeReturn () const InterfaceHandle &amp; RunAsAction ()  InterfaceHandle &amp; RunAsTrigger (std::size_t const repeats=1)  boost::json::value YieldInjection (ChannelKind const kind) Yield input generator. boost::json::value YieldInjectionArgs () Injection at nofcall. boost::json::value YieldInjectionReturn ()  interface_id interface () const boost::json::string const &amp; key () const InterfaceHandle &amp; operator= (InterfaceHandle const &amp;) = default InterfaceHandle &amp; operator= (InterfaceHandle &amp;&amp;) = default object_id refobj () const ~InterfaceHandle () = default"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#protected-attributes","title":"Protected Attributes","text":"Type Name zmbt::Environment env std::shared_ptr&lt; OutputRecorder &gt; output_recorder_"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Interface</code> </li> </ul>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-captureslice","title":"function CaptureSlice","text":"<pre><code>boost::json::array zmbt::Environment::InterfaceHandle::CaptureSlice (\n    boost::json::string_view signal_path\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-captures","title":"function Captures","text":"<pre><code>boost::json::array const &amp; zmbt::Environment::InterfaceHandle::Captures () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-enableoutputrecordfor","title":"function EnableOutputRecordFor","text":"<pre><code>void zmbt::Environment::InterfaceHandle::EnableOutputRecordFor (\n    ChannelKind const kind\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-env","title":"function Env","text":"<p>Environment of the interface handle. <pre><code>inline Environment &amp; zmbt::Environment::InterfaceHandle::Env () const\n</code></pre></p> <p>Returns:</p> <p>zmbt::Environment&amp; </p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-inject","title":"function Inject","text":"<p>Set generating function for injection. <pre><code>void zmbt::Environment::InterfaceHandle::Inject (\n    std::shared_ptr&lt; Generator &gt; gen,\n    lang::Expression const &amp; tf,\n    ChannelKind const kind,\n    boost::json::string_view jp=\"\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>e</code> input generator </li> <li><code>group</code> return | args | exception </li> <li><code>jp</code> JSON Pointer </li> </ul>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-injectargs","title":"function InjectArgs","text":"<p>Set generating function for injection args. <pre><code>inline void zmbt::Environment::InterfaceHandle::InjectArgs (\n    lang::Expression const &amp; e,\n    boost::json::string_view jp=\"\"\n) \n</code></pre></p> <p>The intput conditions are evaluated from the corresponding expressions with 0-based call index as an argument. </p> <p>Parameters:</p> <ul> <li><code>e</code> </li> <li><code>jp</code> JSON Pointer </li> </ul>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-injectreturn","title":"function InjectReturn","text":"<p>Set generating function for injection return. <pre><code>inline void zmbt::Environment::InterfaceHandle::InjectReturn (\n    lang::Expression const &amp; e,\n    boost::json::string_view jp=\"\"\n) \n</code></pre></p> <p>The intput conditions are evaluated from the corresponding expressions with 0-based call index as an argument. </p> <p>Parameters:</p> <ul> <li><code>e</code> generating funcion expression </li> <li><code>jp</code> JSON Pointer </li> </ul>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interfacehandle-18","title":"function InterfaceHandle [1/8]","text":"<pre><code>zmbt::Environment::InterfaceHandle::InterfaceHandle (\n    Environment const &amp; e,\n    interface_id const &amp; interface,\n    object_id refobj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interfacehandle-28","title":"function InterfaceHandle [2/8]","text":"<pre><code>zmbt::Environment::InterfaceHandle::InterfaceHandle (\n    Environment const &amp; e,\n    boost::json::string_view ref\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interfacehandle-38","title":"function InterfaceHandle [3/8]","text":"<pre><code>zmbt::Environment::InterfaceHandle::InterfaceHandle (\n    interface_id const &amp; interface,\n    object_id refobj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interfacehandle-48","title":"function InterfaceHandle [4/8]","text":"<pre><code>zmbt::Environment::InterfaceHandle::InterfaceHandle (\n    interface_id const &amp; interface,\n    nullptr_t\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interfacehandle-58","title":"function InterfaceHandle [5/8]","text":"<pre><code>zmbt::Environment::InterfaceHandle::InterfaceHandle (\n    boost::json::string_view ref\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interfacehandle-68","title":"function InterfaceHandle [6/8]","text":"<pre><code>template&lt;class H, class E&gt;\ninline zmbt::Environment::InterfaceHandle::InterfaceHandle (\n    interface_id const &amp; interface,\n    H const &amp; obj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interfacehandle-78","title":"function InterfaceHandle [7/8]","text":"<pre><code>zmbt::Environment::InterfaceHandle::InterfaceHandle (\n    InterfaceHandle const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interfacehandle-88","title":"function InterfaceHandle [8/8]","text":"<pre><code>zmbt::Environment::InterfaceHandle::InterfaceHandle (\n    InterfaceHandle &amp;&amp; o\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-maybethrowexception","title":"function MaybeThrowException","text":"<p>throw exception if set for current call <pre><code>void zmbt::Environment::InterfaceHandle::MaybeThrowException () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-observedcalls","title":"function ObservedCalls","text":"<p>Number of interface calls. <pre><code>std::size_t zmbt::Environment::InterfaceHandle::ObservedCalls () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-prototypeargs","title":"function PrototypeArgs","text":"<pre><code>boost::json::array zmbt::Environment::InterfaceHandle::PrototypeArgs () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-prototypereturn","title":"function PrototypeReturn","text":"<pre><code>boost::json::value zmbt::Environment::InterfaceHandle::PrototypeReturn () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-runasaction","title":"function RunAsAction","text":"<pre><code>InterfaceHandle &amp; zmbt::Environment::InterfaceHandle::RunAsAction () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-runastrigger","title":"function RunAsTrigger","text":"<pre><code>InterfaceHandle &amp; zmbt::Environment::InterfaceHandle::RunAsTrigger (\n    std::size_t const repeats=1\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-yieldinjection","title":"function YieldInjection","text":"<p>Yield input generator. <pre><code>boost::json::value zmbt::Environment::InterfaceHandle::YieldInjection (\n    ChannelKind const kind\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-yieldinjectionargs","title":"function YieldInjectionArgs","text":"<p>Injection at nofcall. <pre><code>inline boost::json::value zmbt::Environment::InterfaceHandle::YieldInjectionArgs () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-yieldinjectionreturn","title":"function YieldInjectionReturn","text":"<pre><code>inline boost::json::value zmbt::Environment::InterfaceHandle::YieldInjectionReturn () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interface","title":"function interface","text":"<pre><code>inline interface_id zmbt::Environment::InterfaceHandle::interface () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-key","title":"function key","text":"<pre><code>boost::json::string const &amp; zmbt::Environment::InterfaceHandle::key () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-operator","title":"function operator=","text":"<pre><code>InterfaceHandle &amp; zmbt::Environment::InterfaceHandle::operator= (\n    InterfaceHandle const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-operator_1","title":"function operator=","text":"<pre><code>InterfaceHandle &amp; zmbt::Environment::InterfaceHandle::operator= (\n    InterfaceHandle &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-refobj","title":"function refobj","text":"<pre><code>inline object_id zmbt::Environment::InterfaceHandle::refobj () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#function-interfacehandle","title":"function ~InterfaceHandle","text":"<pre><code>zmbt::Environment::InterfaceHandle::~InterfaceHandle () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#variable-env","title":"variable env","text":"<pre><code>zmbt::Environment zmbt::Environment::InterfaceHandle::env;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1InterfaceHandle/#variable-output_recorder_","title":"variable output_recorder_","text":"<pre><code>std::shared_ptr&lt;OutputRecorder&gt; zmbt::Environment::InterfaceHandle::output_recorder_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/environment_interface_record.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/","title":"Class zmbt::Environment::TypedInterfaceHandle","text":"<p>template &lt;class Interface&gt;</p> <p>ClassList &gt; zmbt &gt; Environment &gt; TypedInterfaceHandle</p> <p>Environment API handler for specific interface.</p> <ul> <li><code>#include &lt;environment_interface_record.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::Environment::InterfaceHandle</p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#public-functions","title":"Public Functions","text":"Type Name return_t Hook (hookout_args_t args) Hook the producing interface call to the environment. return_t Hook (A &amp;&amp;... arg) Hook the producing interface call to the environment. TypedInterfaceHandle (interface_id const &amp; interface, H const &amp; refobj)  TypedInterfaceHandle (TypedInterfaceHandle const &amp;) = default TypedInterfaceHandle (TypedInterfaceHandle &amp;&amp;) = default ~TypedInterfaceHandle () = default"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#public-functions-inherited-from-zmbtenvironmentinterfacehandle","title":"Public Functions inherited from zmbt::Environment::InterfaceHandle","text":"<p>See zmbt::Environment::InterfaceHandle</p> Type Name boost::json::array CaptureSlice (boost::json::string_view signal_path) const boost::json::array const &amp; Captures () const void EnableOutputRecordFor (ChannelKind const kind)  Environment &amp; Env () constEnvironment of the interface handle. void Inject (std::shared_ptr&lt; Generator &gt; gen, lang::Expression const &amp; tf, ChannelKind const kind, boost::json::string_view jp=\"\") Set generating function for injection. void InjectArgs (lang::Expression const &amp; e, boost::json::string_view jp=\"\") Set generating function for injection args. void InjectReturn (lang::Expression const &amp; e, boost::json::string_view jp=\"\") Set generating function for injection return. InterfaceHandle (Environment const &amp; e, interface_id const &amp; interface, object_id refobj)  InterfaceHandle (Environment const &amp; e, boost::json::string_view ref)  InterfaceHandle (interface_id const &amp; interface, object_id refobj)  InterfaceHandle (interface_id const &amp; interface, nullptr_t)  InterfaceHandle (boost::json::string_view ref)  InterfaceHandle (interface_id const &amp; interface, H const &amp; obj)  InterfaceHandle (InterfaceHandle const &amp;) = default InterfaceHandle (InterfaceHandle &amp;&amp; o) = default void MaybeThrowException () throw exception if set for current call std::size_t ObservedCalls () constNumber of interface calls. boost::json::array PrototypeArgs () const boost::json::value PrototypeReturn () const InterfaceHandle &amp; RunAsAction ()  InterfaceHandle &amp; RunAsTrigger (std::size_t const repeats=1)  boost::json::value YieldInjection (ChannelKind const kind) Yield input generator. boost::json::value YieldInjectionArgs () Injection at nofcall. boost::json::value YieldInjectionReturn ()  interface_id interface () const boost::json::string const &amp; key () const InterfaceHandle &amp; operator= (InterfaceHandle const &amp;) = default InterfaceHandle &amp; operator= (InterfaceHandle &amp;&amp;) = default object_id refobj () const ~InterfaceHandle () = default"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#protected-attributes-inherited-from-zmbtenvironmentinterfacehandle","title":"Protected Attributes inherited from zmbt::Environment::InterfaceHandle","text":"<p>See zmbt::Environment::InterfaceHandle</p> Type Name zmbt::Environment env std::shared_ptr&lt; OutputRecorder &gt; output_recorder_"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#function-hook-12","title":"function Hook [1/2]","text":"<p>Hook the producing interface call to the environment. <pre><code>inline return_t zmbt::Environment::TypedInterfaceHandle::Hook (\n    hookout_args_t args\n) \n</code></pre></p> <p>Register input arguments, update the output reference arguments, increment call count and return corresponding env value</p> <p>Parameters:</p> <ul> <li><code>args</code> </li> </ul> <p>Returns:</p> <p>return_t </p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#function-hook-22","title":"function Hook [2/2]","text":"<p>Hook the producing interface call to the environment. <pre><code>template&lt;class... A&gt;\ninline return_t zmbt::Environment::TypedInterfaceHandle::Hook (\n    A &amp;&amp;... arg\n) \n</code></pre></p> <p>Register input arguments, update the output reference arguments, increment call count and return corresponding env value</p> <p>Template parameters:</p> <ul> <li><code>A...</code> compatible arg types </li> </ul> <p>Parameters:</p> <ul> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>return_t </p>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#function-typedinterfacehandle-13","title":"function TypedInterfaceHandle [1/3]","text":"<pre><code>template&lt;class H&gt;\ninline zmbt::Environment::TypedInterfaceHandle::TypedInterfaceHandle (\n    interface_id const &amp; interface,\n    H const &amp; refobj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#function-typedinterfacehandle-23","title":"function TypedInterfaceHandle [2/3]","text":"<pre><code>zmbt::Environment::TypedInterfaceHandle::TypedInterfaceHandle (\n    TypedInterfaceHandle const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#function-typedinterfacehandle-33","title":"function TypedInterfaceHandle [3/3]","text":"<pre><code>zmbt::Environment::TypedInterfaceHandle::TypedInterfaceHandle (\n    TypedInterfaceHandle &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Environment_1_1TypedInterfaceHandle/#function-typedinterfacehandle","title":"function ~TypedInterfaceHandle","text":"<pre><code>zmbt::Environment::TypedInterfaceHandle::~TypedInterfaceHandle () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/environment_interface_record.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/","title":"Struct zmbt::EnvironmentData","text":"<p>ClassList &gt; zmbt &gt; EnvironmentData</p> <p>Data container for the Environment .</p> <ul> <li><code>#include &lt;environment_data.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; void(boost::json::value const  &amp;)&gt; FailureHandler typedef std::unique_lock&lt; mutex_t &gt; lock_t typedef std::recursive_mutex mutex_t typedef std::pair&lt; std::type_index, std::shared_ptr&lt; void &gt; &gt; shared_data_record typedef std::map&lt; boost::json::string, shared_data_record &gt; shared_data_table"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; boost::json::string, std::function&lt; void()&gt; &gt; callbacks std::atomic_bool has_test_error   = <code>{false}</code> boost::concurrent_flat_map&lt; std::pair&lt; interface_id, object_id &gt;, shared_resource&lt; InjectionTable &gt; &gt; injection_tables   = <code>{}</code> JsonNode json_data   = <code>{init\\_json\\_data()}</code> mutex_t mutex boost::concurrent_flat_map&lt; std::pair&lt; interface_id, object_id &gt;, shared_resource&lt; OutputRecorder &gt; &gt; output_recorders   = <code>{}</code> shared_data_table shared std::unordered_map&lt; interface_id, TriggerIfc &gt; trigger_ifcs std::unordered_map&lt; object_id, TriggerObj &gt; trigger_objs std::map&lt; boost::json::string, Trigger &gt; triggers"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#public-functions","title":"Public Functions","text":"Type Name EnvironmentData ()  EnvironmentData (EnvironmentData &amp;&amp; o) = delete EnvironmentData (EnvironmentData const &amp; o) = delete EnvironmentData &amp; operator= (EnvironmentData &amp;&amp; o) = delete EnvironmentData &amp; operator= (EnvironmentData const &amp; o) = delete ~EnvironmentData ()"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#public-static-functions","title":"Public Static Functions","text":"Type Name boost::json::value init_json_data ()"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#typedef-failurehandler","title":"typedef FailureHandler","text":"<pre><code>using zmbt::EnvironmentData::FailureHandler =  std::function&lt;void(boost::json::value const&amp;)&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#typedef-lock_t","title":"typedef lock_t","text":"<pre><code>using zmbt::EnvironmentData::lock_t =  std::unique_lock&lt;mutex_t&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#typedef-mutex_t","title":"typedef mutex_t","text":"<pre><code>using zmbt::EnvironmentData::mutex_t =  std::recursive_mutex;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#typedef-shared_data_record","title":"typedef shared_data_record","text":"<pre><code>using zmbt::EnvironmentData::shared_data_record =  std::pair&lt;std::type_index, std::shared_ptr&lt;void&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#typedef-shared_data_table","title":"typedef shared_data_table","text":"<pre><code>using zmbt::EnvironmentData::shared_data_table =  std::map&lt;boost::json::string, shared_data_record&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-callbacks","title":"variable callbacks","text":"<pre><code>std::map&lt;boost::json::string, std::function&lt;void()&gt; &gt; zmbt::EnvironmentData::callbacks;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-has_test_error","title":"variable has_test_error","text":"<pre><code>std::atomic_bool zmbt::EnvironmentData::has_test_error;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-injection_tables","title":"variable injection_tables","text":"<pre><code>boost::concurrent_flat_map&lt; std::pair&lt;interface_id, object_id&gt;, shared_resource&lt;InjectionTable&gt; &gt; zmbt::EnvironmentData::injection_tables;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-json_data","title":"variable json_data","text":"<pre><code>JsonNode zmbt::EnvironmentData::json_data;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-mutex","title":"variable mutex","text":"<pre><code>mutex_t zmbt::EnvironmentData::mutex;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-output_recorders","title":"variable output_recorders","text":"<pre><code>boost::concurrent_flat_map&lt; std::pair&lt;interface_id, object_id&gt;, shared_resource&lt;OutputRecorder&gt; &gt; zmbt::EnvironmentData::output_recorders;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-shared","title":"variable shared","text":"<pre><code>shared_data_table zmbt::EnvironmentData::shared;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-trigger_ifcs","title":"variable trigger_ifcs","text":"<pre><code>std::unordered_map&lt;interface_id, TriggerIfc&gt; zmbt::EnvironmentData::trigger_ifcs;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-trigger_objs","title":"variable trigger_objs","text":"<pre><code>std::unordered_map&lt;object_id, TriggerObj&gt; zmbt::EnvironmentData::trigger_objs;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#variable-triggers","title":"variable triggers","text":"<pre><code>std::map&lt;boost::json::string, Trigger&gt; zmbt::EnvironmentData::triggers;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#function-environmentdata-13","title":"function EnvironmentData [1/3]","text":"<pre><code>zmbt::EnvironmentData::EnvironmentData () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#function-environmentdata-23","title":"function EnvironmentData [2/3]","text":"<pre><code>zmbt::EnvironmentData::EnvironmentData (\n    EnvironmentData &amp;&amp; o\n) = delete\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#function-environmentdata-33","title":"function EnvironmentData [3/3]","text":"<pre><code>zmbt::EnvironmentData::EnvironmentData (\n    EnvironmentData const &amp; o\n) = delete\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#function-operator","title":"function operator=","text":"<pre><code>EnvironmentData &amp; zmbt::EnvironmentData::operator= (\n    EnvironmentData &amp;&amp; o\n) = delete\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#function-operator_1","title":"function operator=","text":"<pre><code>EnvironmentData &amp; zmbt::EnvironmentData::operator= (\n    EnvironmentData const &amp; o\n) = delete\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#function-environmentdata","title":"function ~EnvironmentData","text":"<pre><code>zmbt::EnvironmentData::~EnvironmentData () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1EnvironmentData/#function-init_json_data","title":"function init_json_data","text":"<pre><code>static boost::json::value zmbt::EnvironmentData::init_json_data () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/environment_data.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1ErrorInfo/","title":"Struct zmbt::ErrorInfo","text":"<p>ClassList &gt; zmbt &gt; ErrorInfo</p>"},{"location":"CxxRef/structzmbt_1_1ErrorInfo/#public-attributes","title":"Public Attributes","text":"Type Name boost::json::string context boost::json::string type boost::json::string what"},{"location":"CxxRef/structzmbt_1_1ErrorInfo/#public-functions","title":"Public Functions","text":"Type Name boost::json::value to_json () const"},{"location":"CxxRef/structzmbt_1_1ErrorInfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1ErrorInfo/#variable-context","title":"variable context","text":"<pre><code>boost::json::string zmbt::ErrorInfo::context;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1ErrorInfo/#variable-type","title":"variable type","text":"<pre><code>boost::json::string zmbt::ErrorInfo::type;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1ErrorInfo/#variable-what","title":"variable what","text":"<pre><code>boost::json::string zmbt::ErrorInfo::what;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1ErrorInfo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1ErrorInfo/#function-to_json","title":"function to_json","text":"<pre><code>inline boost::json::value zmbt::ErrorInfo::to_json () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/error_info.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/","title":"Class zmbt::ErrorOr","text":"<p>template &lt;class Return&gt;</p> <p>ClassList &gt; zmbt &gt; ErrorOr</p>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#public-functions","title":"Public Functions","text":"Type Name ErrorOr () = default ErrorInfo const &amp; as_error () const Return const &amp; as_return () const void dump_to (boost::json::object &amp; obj) const bool is_error () const bool is_null () const bool is_return () const"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#public-static-functions","title":"Public Static Functions","text":"Type Name ErrorOr&lt; Return &gt; MakeError (ErrorInfo err)  ErrorOr&lt; Return &gt; MakeValue (Return ret)"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1ErrorOr/#function-erroror","title":"function ErrorOr","text":"<pre><code>zmbt::ErrorOr::ErrorOr () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#function-as_error","title":"function as_error","text":"<pre><code>inline ErrorInfo const &amp; zmbt::ErrorOr::as_error () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#function-as_return","title":"function as_return","text":"<pre><code>inline Return const &amp; zmbt::ErrorOr::as_return () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#function-dump_to","title":"function dump_to","text":"<pre><code>inline void zmbt::ErrorOr::dump_to (\n    boost::json::object &amp; obj\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#function-is_error","title":"function is_error","text":"<pre><code>inline bool zmbt::ErrorOr::is_error () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#function-is_null","title":"function is_null","text":"<pre><code>inline bool zmbt::ErrorOr::is_null () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#function-is_return","title":"function is_return","text":"<pre><code>inline bool zmbt::ErrorOr::is_return () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1ErrorOr/#function-makeerror","title":"function MakeError","text":"<pre><code>static inline ErrorOr &lt; Return &gt; zmbt::ErrorOr::MakeError (\n    ErrorInfo err\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1ErrorOr/#function-makevalue","title":"function MakeValue","text":"<pre><code>static inline ErrorOr &lt; Return &gt; zmbt::ErrorOr::MakeValue (\n    Return ret\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/error_or_return.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1Generator/","title":"Class zmbt::Generator","text":"<p>ClassList &gt; zmbt &gt; Generator</p>"},{"location":"CxxRef/classzmbt_1_1Generator/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; Generator &gt; Shared"},{"location":"CxxRef/classzmbt_1_1Generator/#public-functions","title":"Public Functions","text":"Type Name Generator (boost::json::array const &amp; serialized)  Generator (lang::Expression const &amp; expr)  Generator (Generator const &amp;) = default Generator (Generator &amp;&amp;) = default lang::Expression const &amp; expression () constGet underlying expression. bool is_noop () const std::uint64_t operator() (boost::json::value &amp; value) Generate value and return iteration. Generator &amp; operator= (Generator const &amp;) = default Generator &amp; operator= (Generator &amp;&amp;) = default void reset () Reset atomic counter. ~Generator () = default"},{"location":"CxxRef/classzmbt_1_1Generator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Generator/#typedef-shared","title":"typedef Shared","text":"<pre><code>using zmbt::Generator::Shared =  std::shared_ptr&lt;Generator&gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Generator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Generator/#function-generator-14","title":"function Generator [1/4]","text":"<pre><code>explicit zmbt::Generator::Generator (\n    boost::json::array const &amp; serialized\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-generator-24","title":"function Generator [2/4]","text":"<pre><code>explicit zmbt::Generator::Generator (\n    lang::Expression const &amp; expr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-generator-34","title":"function Generator [3/4]","text":"<pre><code>zmbt::Generator::Generator (\n    Generator const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-generator-44","title":"function Generator [4/4]","text":"<pre><code>zmbt::Generator::Generator (\n    Generator &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-expression","title":"function expression","text":"<p>Get underlying expression. <pre><code>lang::Expression const &amp; zmbt::Generator::expression () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-is_noop","title":"function is_noop","text":"<pre><code>bool zmbt::Generator::is_noop () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-operator","title":"function operator()","text":"<p>Generate value and return iteration. <pre><code>std::uint64_t zmbt::Generator::operator() (\n    boost::json::value &amp; value\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-operator_1","title":"function operator=","text":"<pre><code>Generator &amp; zmbt::Generator::operator= (\n    Generator const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-operator_2","title":"function operator=","text":"<pre><code>Generator &amp; zmbt::Generator::operator= (\n    Generator &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-reset","title":"function reset","text":"<p>Reset atomic counter. <pre><code>void zmbt::Generator::reset () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Generator/#function-generator","title":"function ~Generator","text":"<pre><code>zmbt::Generator::~Generator () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/generator.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1InjectionTable/","title":"Class zmbt::InjectionTable","text":"<p>ClassList &gt; zmbt &gt; InjectionTable</p>"},{"location":"CxxRef/classzmbt_1_1InjectionTable/#classes","title":"Classes","text":"Type Name struct Record"},{"location":"CxxRef/classzmbt_1_1InjectionTable/#public-functions","title":"Public Functions","text":"Type Name InjectionTable (interface_id const &amp; ifc_id, object_id const &amp; obj_id)  void add_record (ChannelKind const &amp; ck, Record &amp;&amp; rec)  Record &amp; last_record (ChannelKind const &amp; ck)  boost::json::value yield (ChannelKind const &amp; ck, boost::json::value &amp; result_value) Evaluate input for given category and return error object if any, null otherwise."},{"location":"CxxRef/classzmbt_1_1InjectionTable/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; InjectionTable &gt; Make (interface_id const &amp; ifc_id, object_id const &amp; obj_id)"},{"location":"CxxRef/classzmbt_1_1InjectionTable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1InjectionTable/#function-injectiontable","title":"function InjectionTable","text":"<pre><code>zmbt::InjectionTable::InjectionTable (\n    interface_id const &amp; ifc_id,\n    object_id const &amp; obj_id\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1InjectionTable/#function-add_record","title":"function add_record","text":"<pre><code>void zmbt::InjectionTable::add_record (\n    ChannelKind const &amp; ck,\n    Record &amp;&amp; rec\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1InjectionTable/#function-last_record","title":"function last_record","text":"<pre><code>Record &amp; zmbt::InjectionTable::last_record (\n    ChannelKind const &amp; ck\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1InjectionTable/#function-yield","title":"function yield","text":"<p>Evaluate input for given category and return error object if any, null otherwise. <pre><code>boost::json::value zmbt::InjectionTable::yield (\n    ChannelKind const &amp; ck,\n    boost::json::value &amp; result_value\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1InjectionTable/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1InjectionTable/#function-make","title":"function Make","text":"<pre><code>static std::shared_ptr&lt; InjectionTable &gt; zmbt::InjectionTable::Make (\n    interface_id const &amp; ifc_id,\n    object_id const &amp; obj_id\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/injection_table.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/","title":"Struct zmbt::InjectionTable::Record","text":"<p>ClassList &gt; zmbt &gt; InjectionTable &gt; Record</p>"},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/#public-attributes","title":"Public Attributes","text":"Type Name Generator::Shared generator boost::json::string jptr boost::optional&lt; boost::json::value &gt; maybe_constant lang::Expression transform"},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/#public-functions","title":"Public Functions","text":"Type Name Record (boost::json::string_view jp, Generator::Shared gen, lang::Expression const &amp; tf)"},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/#variable-generator","title":"variable generator","text":"<pre><code>Generator::Shared zmbt::InjectionTable::Record::generator;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/#variable-jptr","title":"variable jptr","text":"<pre><code>boost::json::string zmbt::InjectionTable::Record::jptr;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/#variable-maybe_constant","title":"variable maybe_constant","text":"<pre><code>boost::optional&lt;boost::json::value&gt; zmbt::InjectionTable::Record::maybe_constant;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/#variable-transform","title":"variable transform","text":"<pre><code>lang::Expression zmbt::InjectionTable::Record::transform;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1InjectionTable_1_1Record/#function-record","title":"function Record","text":"<pre><code>zmbt::InjectionTable::Record::Record (\n    boost::json::string_view jp,\n    Generator::Shared gen,\n    lang::Expression const &amp; tf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/injection_table.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1JsonIter/","title":"Class zmbt::JsonIter","text":"<p>ClassList &gt; zmbt &gt; JsonIter</p> <p>Boost JSON array iterator interface. </p> <ul> <li><code>#include &lt;json_iter.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: zmbt::JsonIterZipProdBase</p>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#public-functions","title":"Public Functions","text":"Type Name JsonIter () = default JsonIter (JsonIter const &amp;) = default JsonIter (JsonIter &amp;&amp;) = default virtual boost::json::array get () = 0iterator value virtual bool halt () const = 0Iterator halted. boost::json::array operator* () iterator value JsonIter &amp; operator++ (int) iterator post-increment JsonIter &amp; operator= (JsonIter const &amp;) = default JsonIter &amp; operator= (JsonIter &amp;&amp;) = default virtual ~JsonIter () = default"},{"location":"CxxRef/classzmbt_1_1JsonIter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-jsoniter-13","title":"function JsonIter [1/3]","text":"<pre><code>zmbt::JsonIter::JsonIter () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-jsoniter-23","title":"function JsonIter [2/3]","text":"<pre><code>zmbt::JsonIter::JsonIter (\n    JsonIter const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-jsoniter-33","title":"function JsonIter [3/3]","text":"<pre><code>zmbt::JsonIter::JsonIter (\n    JsonIter &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-get","title":"function get","text":"<p>iterator value <pre><code>virtual boost::json::array zmbt::JsonIter::get () = 0\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-halt","title":"function halt","text":"<p>Iterator halted. <pre><code>virtual bool zmbt::JsonIter::halt () const = 0\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-operator","title":"function operator*","text":"<p>iterator value <pre><code>inline boost::json::array zmbt::JsonIter::operator* () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-operator_1","title":"function operator++","text":"<p>iterator post-increment <pre><code>inline JsonIter &amp; zmbt::JsonIter::operator++ (\n    int\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-operator_2","title":"function operator=","text":"<pre><code>JsonIter &amp; zmbt::JsonIter::operator= (\n    JsonIter const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-operator_3","title":"function operator=","text":"<pre><code>JsonIter &amp; zmbt::JsonIter::operator= (\n    JsonIter &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIter/#function-jsoniter","title":"function ~JsonIter","text":"<pre><code>virtual zmbt::JsonIter::~JsonIter () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_iter.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/","title":"Class zmbt::JsonIterZipProdBase","text":"<p>ClassList &gt; zmbt &gt; JsonIterZipProdBase</p> <p>Boost JSON array iterator base for zip or cartesian product. </p> <ul> <li><code>#include &lt;json_iter.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::JsonIter</p> <p>Inherited by the following classes: zmbt::JsonProdIter,  zmbt::JsonZipIter</p>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#public-functions","title":"Public Functions","text":"Type Name JsonIterZipProdBase (boost::json::array const &amp; sequences)  JsonIterZipProdBase (boost::json::array &amp;&amp; seqences)  JsonIterZipProdBase ()  JsonIterZipProdBase (JsonIterZipProdBase const &amp;) = default JsonIterZipProdBase (JsonIterZipProdBase &amp;&amp;) = default virtual boost::json::array get () iterator value virtual bool halt () constIterator halted. JsonIterZipProdBase &amp; operator= (JsonIterZipProdBase const &amp;) = default JsonIterZipProdBase &amp; operator= (JsonIterZipProdBase &amp;&amp;) = default virtual ~JsonIterZipProdBase () = default"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#public-functions-inherited-from-zmbtjsoniter","title":"Public Functions inherited from zmbt::JsonIter","text":"<p>See zmbt::JsonIter</p> Type Name JsonIter () = default JsonIter (JsonIter const &amp;) = default JsonIter (JsonIter &amp;&amp;) = default virtual boost::json::array get () = 0iterator value virtual bool halt () const = 0Iterator halted. boost::json::array operator* () iterator value JsonIter &amp; operator++ (int) iterator post-increment JsonIter &amp; operator= (JsonIter const &amp;) = default JsonIter &amp; operator= (JsonIter &amp;&amp;) = default virtual ~JsonIter () = default"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; boost::json::array::const_iterator &gt; begins_   = <code>{}</code> std::vector&lt; boost::json::array::const_iterator &gt; ends_   = <code>{}</code> bool halt_   = <code>{false}</code> std::vector&lt; boost::json::array::const_iterator &gt; its_   = <code>{}</code> boost::json::array owned_sequences_"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-jsoniterzipprodbase-15","title":"function JsonIterZipProdBase [1/5]","text":"<pre><code>inline explicit zmbt::JsonIterZipProdBase::JsonIterZipProdBase (\n    boost::json::array const &amp; sequences\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-jsoniterzipprodbase-25","title":"function JsonIterZipProdBase [2/5]","text":"<pre><code>inline explicit zmbt::JsonIterZipProdBase::JsonIterZipProdBase (\n    boost::json::array &amp;&amp; seqences\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-jsoniterzipprodbase-35","title":"function JsonIterZipProdBase [3/5]","text":"<pre><code>inline zmbt::JsonIterZipProdBase::JsonIterZipProdBase () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-jsoniterzipprodbase-45","title":"function JsonIterZipProdBase [4/5]","text":"<pre><code>zmbt::JsonIterZipProdBase::JsonIterZipProdBase (\n    JsonIterZipProdBase const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-jsoniterzipprodbase-55","title":"function JsonIterZipProdBase [5/5]","text":"<pre><code>zmbt::JsonIterZipProdBase::JsonIterZipProdBase (\n    JsonIterZipProdBase &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-get","title":"function get","text":"<p>iterator value <pre><code>virtual boost::json::array zmbt::JsonIterZipProdBase::get () \n</code></pre></p> <p>Implements zmbt::JsonIter::get</p>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-halt","title":"function halt","text":"<p>Iterator halted. <pre><code>inline virtual bool zmbt::JsonIterZipProdBase::halt () const\n</code></pre></p> <p>Implements zmbt::JsonIter::halt</p>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-operator","title":"function operator=","text":"<pre><code>JsonIterZipProdBase &amp; zmbt::JsonIterZipProdBase::operator= (\n    JsonIterZipProdBase const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-operator_1","title":"function operator=","text":"<pre><code>JsonIterZipProdBase &amp; zmbt::JsonIterZipProdBase::operator= (\n    JsonIterZipProdBase &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#function-jsoniterzipprodbase","title":"function ~JsonIterZipProdBase","text":"<pre><code>virtual zmbt::JsonIterZipProdBase::~JsonIterZipProdBase () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#variable-begins_","title":"variable begins_","text":"<pre><code>std::vector&lt;boost::json::array::const_iterator&gt; zmbt::JsonIterZipProdBase::begins_;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#variable-ends_","title":"variable ends_","text":"<pre><code>std::vector&lt;boost::json::array::const_iterator&gt; zmbt::JsonIterZipProdBase::ends_;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#variable-halt_","title":"variable halt_","text":"<pre><code>bool zmbt::JsonIterZipProdBase::halt_;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#variable-its_","title":"variable its_","text":"<pre><code>std::vector&lt;boost::json::array::const_iterator&gt; zmbt::JsonIterZipProdBase::its_;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonIterZipProdBase/#variable-owned_sequences_","title":"variable owned_sequences_","text":"<pre><code>boost::json::array zmbt::JsonIterZipProdBase::owned_sequences_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_iter.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1JsonNode/","title":"Class zmbt::JsonNode","text":"<p>ClassList &gt; zmbt &gt; JsonNode</p> <p>Mutator/accessor wrapper over shared JSON value. More...</p> <ul> <li><code>#include &lt;json_node.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#public-functions","title":"Public Functions","text":"Type Name JsonNode (std::shared_ptr&lt; boost::json::value &gt; root)  JsonNode ()  JsonNode (boost::json::storage_ptr sp)  JsonNode (JsonNode const &amp; o)  JsonNode (JsonNode &amp; o)  JsonNode (JsonNode &amp;&amp; o)  JsonNode (boost::json::value const &amp; v)  JsonNode (boost::json::value &amp;&amp; v)  boost::json::array const &amp; as_array () const boost::json::array &amp; as_array ()  boost::json::object const &amp; as_object () const boost::json::object &amp; as_object ()  boost::json::value const &amp; at (boost::json::string_view json_ptr) const boost::json::value const &amp; at (boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest) const JsonNode branch (boost::json::kind kind, boost::json::string_view subnode_ptr) create JsonNode proxy over subnode JsonNode branch (boost::json::string_view subnode_ptr)  JsonNode branch (boost::json::kind kind, boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest)  JsonNode branch (boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest)  bool contains (boost::json::string_view json_ptr) const bool contains (boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest) const JsonNode copy () const boost::json::value const * find_pointer (boost::json::string_view json_ptr) const boost::json::value const * find_pointer (boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest) const boost::json::value * find_pointer (boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest)  boost::json::array &amp; get_or_create_array (boost::json::string_view json_ptr=\"\")  boost::json::array &amp; get_or_create_array (boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest)  boost::json::object &amp; get_or_create_object (boost::json::string_view json_ptr=\"\")  boost::json::object &amp; get_or_create_object (boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest)  boost::json::value get_or_default (boost::json::string_view json_ptr, boost::json::value const &amp; dflt) const bool is_null () const boost::json::value const * node (boost::json::error_code &amp; ec) const boost::json::value * node (boost::json::error_code &amp; ec)  boost::json::value const &amp; node () const boost::json::value &amp; node ()  boost::json::string_view node_ptr () const boost::json::value &amp; operator() (boost::json::string_view json_ptr=\"\")  boost::json::value &amp; operator() (boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest)  boost::json::value const &amp; operator() (boost::json::string_view json_ptr=\"\") const boost::json::value const &amp; operator() (boost::json::string_view fmtstr, T &amp;&amp; first, A &amp;&amp;... rest) const JsonNode &amp; operator= (JsonNode const &amp;) = default JsonNode &amp; operator= (JsonNode &amp;&amp;) = default std::shared_ptr&lt; boost::json::value &gt; const &amp; root () const JsonNode root_node () const std::size_t size () const ~JsonNode () noexcept"},{"location":"CxxRef/classzmbt_1_1JsonNode/#detailed-description","title":"Detailed Description","text":"<p>Provides read/write access to the referenced value internal structure via JSON Pointer. Each instance owns a shared pointer to the root value, so subnode proxies may prolong original object lifetime.</p> <p>Additions to the standard JSON Pointer syntax: At-the-end token: '@'. Points to the last element of an array. Queries with at-the-end token always results in creating a new node on empty array. Past-the-end token: '+'. Points to the new element of an array. Queries with past-the-end token always results in creating a new node.</p> <p>The rules for the additional tokens are:</p> <p>For each @ token * if the node is null, the token substituted with 0; otherwise * if the node is an empty array, the token substituted with 0; otherwise * if the node is a non-empty array, the token substituted with node size - 1; otherwise * an error is produced.</p> <p>For each + token * if the node is null, the token substituted with 0; otherwise * if the node is an array, the token substituted with node size; otherwise * an error is produced. </p>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-jsonnode-29","title":"function JsonNode [2/9]","text":"<pre><code>inline explicit zmbt::JsonNode::JsonNode (\n    std::shared_ptr&lt; boost::json::value &gt; root\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-jsonnode-39","title":"function JsonNode [3/9]","text":"<pre><code>inline zmbt::JsonNode::JsonNode () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-jsonnode-49","title":"function JsonNode [4/9]","text":"<pre><code>inline explicit zmbt::JsonNode::JsonNode (\n    boost::json::storage_ptr sp\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-jsonnode-59","title":"function JsonNode [5/9]","text":"<pre><code>inline zmbt::JsonNode::JsonNode (\n    JsonNode const &amp; o\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-jsonnode-69","title":"function JsonNode [6/9]","text":"<pre><code>inline zmbt::JsonNode::JsonNode (\n    JsonNode &amp; o\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-jsonnode-79","title":"function JsonNode [7/9]","text":"<pre><code>inline zmbt::JsonNode::JsonNode (\n    JsonNode &amp;&amp; o\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-jsonnode-89","title":"function JsonNode [8/9]","text":"<pre><code>inline zmbt::JsonNode::JsonNode (\n    boost::json::value const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-jsonnode-99","title":"function JsonNode [9/9]","text":"<pre><code>inline zmbt::JsonNode::JsonNode (\n    boost::json::value &amp;&amp; v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-as_array-12","title":"function as_array [1/2]","text":"<pre><code>inline boost::json::array const &amp; zmbt::JsonNode::as_array () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-as_array-22","title":"function as_array [2/2]","text":"<pre><code>inline boost::json::array &amp; zmbt::JsonNode::as_array () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-as_object-12","title":"function as_object [1/2]","text":"<pre><code>inline boost::json::object const &amp; zmbt::JsonNode::as_object () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-as_object-22","title":"function as_object [2/2]","text":"<pre><code>inline boost::json::object &amp; zmbt::JsonNode::as_object () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-at-12","title":"function at [1/2]","text":"<pre><code>boost::json::value const &amp; zmbt::JsonNode::at (\n    boost::json::string_view json_ptr\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-at-22","title":"function at [2/2]","text":"<pre><code>template&lt;class T, class... A&gt;\ninline boost::json::value const &amp; zmbt::JsonNode::at (\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-branch-14","title":"function branch [1/4]","text":"<p>create JsonNode proxy over subnode <pre><code>JsonNode zmbt::JsonNode::branch (\n    boost::json::kind kind,\n    boost::json::string_view subnode_ptr\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-branch-24","title":"function branch [2/4]","text":"<pre><code>inline JsonNode zmbt::JsonNode::branch (\n    boost::json::string_view subnode_ptr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-branch-34","title":"function branch [3/4]","text":"<pre><code>template&lt;class T, class... A&gt;\ninline JsonNode zmbt::JsonNode::branch (\n    boost::json::kind kind,\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-branch-44","title":"function branch [4/4]","text":"<pre><code>template&lt;class T, class... A&gt;\ninline JsonNode zmbt::JsonNode::branch (\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-contains-12","title":"function contains [1/2]","text":"<pre><code>inline bool zmbt::JsonNode::contains (\n    boost::json::string_view json_ptr\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-contains-22","title":"function contains [2/2]","text":"<pre><code>template&lt;class T, class... A&gt;\ninline bool zmbt::JsonNode::contains (\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-copy","title":"function copy","text":"<pre><code>inline JsonNode zmbt::JsonNode::copy () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-find_pointer-13","title":"function find_pointer [1/3]","text":"<pre><code>inline boost::json::value const * zmbt::JsonNode::find_pointer (\n    boost::json::string_view json_ptr\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-find_pointer-23","title":"function find_pointer [2/3]","text":"<pre><code>template&lt;class T, class... A&gt;\ninline boost::json::value const * zmbt::JsonNode::find_pointer (\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-find_pointer-33","title":"function find_pointer [3/3]","text":"<pre><code>template&lt;class T, class... A&gt;\ninline boost::json::value * zmbt::JsonNode::find_pointer (\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-get_or_create_array-12","title":"function get_or_create_array [1/2]","text":"<pre><code>inline boost::json::array &amp; zmbt::JsonNode::get_or_create_array (\n    boost::json::string_view json_ptr=\"\"\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-get_or_create_array-22","title":"function get_or_create_array [2/2]","text":"<pre><code>template&lt;class T, class... A&gt;\ninline boost::json::array &amp; zmbt::JsonNode::get_or_create_array (\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-get_or_create_object-12","title":"function get_or_create_object [1/2]","text":"<pre><code>inline boost::json::object &amp; zmbt::JsonNode::get_or_create_object (\n    boost::json::string_view json_ptr=\"\"\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-get_or_create_object-22","title":"function get_or_create_object [2/2]","text":"<pre><code>template&lt;class T, class... A&gt;\ninline boost::json::object &amp; zmbt::JsonNode::get_or_create_object (\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-get_or_default","title":"function get_or_default","text":"<pre><code>inline boost::json::value zmbt::JsonNode::get_or_default (\n    boost::json::string_view json_ptr,\n    boost::json::value const &amp; dflt\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-is_null","title":"function is_null","text":"<pre><code>inline bool zmbt::JsonNode::is_null () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-node-14","title":"function node [1/4]","text":"<pre><code>inline boost::json::value const * zmbt::JsonNode::node (\n    boost::json::error_code &amp; ec\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-node-24","title":"function node [2/4]","text":"<pre><code>inline boost::json::value * zmbt::JsonNode::node (\n    boost::json::error_code &amp; ec\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-node-34","title":"function node [3/4]","text":"<pre><code>inline boost::json::value const &amp; zmbt::JsonNode::node () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-node-44","title":"function node [4/4]","text":"<pre><code>inline boost::json::value &amp; zmbt::JsonNode::node () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-node_ptr","title":"function node_ptr","text":"<pre><code>inline boost::json::string_view zmbt::JsonNode::node_ptr () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-operator","title":"function operator()","text":"<pre><code>inline boost::json::value &amp; zmbt::JsonNode::operator() (\n    boost::json::string_view json_ptr=\"\"\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-operator_1","title":"function operator()","text":"<pre><code>template&lt;class T, class... A&gt;\ninline boost::json::value &amp; zmbt::JsonNode::operator() (\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-operator_2","title":"function operator()","text":"<pre><code>inline boost::json::value const &amp; zmbt::JsonNode::operator() (\n    boost::json::string_view json_ptr=\"\"\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-operator_3","title":"function operator()","text":"<pre><code>template&lt;class T, class... A&gt;\ninline boost::json::value const &amp; zmbt::JsonNode::operator() (\n    boost::json::string_view fmtstr,\n    T &amp;&amp; first,\n    A &amp;&amp;... rest\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-operator_4","title":"function operator=","text":"<pre><code>JsonNode &amp; zmbt::JsonNode::operator= (\n    JsonNode const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-operator_5","title":"function operator=","text":"<pre><code>JsonNode &amp; zmbt::JsonNode::operator= (\n    JsonNode &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-root","title":"function root","text":"<pre><code>inline std::shared_ptr&lt; boost::json::value &gt; const &amp; zmbt::JsonNode::root () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-root_node","title":"function root_node","text":"<pre><code>inline JsonNode zmbt::JsonNode::root_node () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-size","title":"function size","text":"<pre><code>inline std::size_t zmbt::JsonNode::size () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#function-jsonnode","title":"function ~JsonNode","text":"<pre><code>zmbt::JsonNode::~JsonNode () noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonNode/#friends-documentation","title":"Friends Documentation","text":""},{"location":"CxxRef/classzmbt_1_1JsonNode/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; zmbt::JsonNode::operator&lt;&lt; (\n    std::ostream &amp; os,\n    JsonNode const &amp; view\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_node.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/","title":"Class zmbt::JsonProdIter","text":"<p>ClassList &gt; zmbt &gt; JsonProdIter</p> <p>Cartesian Product Iterator. </p> <ul> <li><code>#include &lt;json_iter.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::JsonIterZipProdBase</p>"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#public-functions","title":"Public Functions","text":"Type Name JsonIterZipProdBase (boost::json::array const &amp; sequences)  JsonIterZipProdBase (boost::json::array &amp;&amp; seqences)  JsonIterZipProdBase ()  JsonIterZipProdBase (JsonIterZipProdBase const &amp;) = default JsonIterZipProdBase (JsonIterZipProdBase &amp;&amp;) = default"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#public-functions-inherited-from-zmbtjsoniterzipprodbase","title":"Public Functions inherited from zmbt::JsonIterZipProdBase","text":"<p>See zmbt::JsonIterZipProdBase</p> Type Name JsonIterZipProdBase (boost::json::array const &amp; sequences)  JsonIterZipProdBase (boost::json::array &amp;&amp; seqences)  JsonIterZipProdBase ()  JsonIterZipProdBase (JsonIterZipProdBase const &amp;) = default JsonIterZipProdBase (JsonIterZipProdBase &amp;&amp;) = default virtual boost::json::array get () iterator value virtual bool halt () constIterator halted. JsonIterZipProdBase &amp; operator= (JsonIterZipProdBase const &amp;) = default JsonIterZipProdBase &amp; operator= (JsonIterZipProdBase &amp;&amp;) = default virtual ~JsonIterZipProdBase () = default"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#public-functions-inherited-from-zmbtjsoniter","title":"Public Functions inherited from zmbt::JsonIter","text":"<p>See zmbt::JsonIter</p> Type Name JsonIter () = default JsonIter (JsonIter const &amp;) = default JsonIter (JsonIter &amp;&amp;) = default virtual boost::json::array get () = 0iterator value virtual bool halt () const = 0Iterator halted. boost::json::array operator* () iterator value JsonIter &amp; operator++ (int) iterator post-increment JsonIter &amp; operator= (JsonIter const &amp;) = default JsonIter &amp; operator= (JsonIter &amp;&amp;) = default virtual ~JsonIter () = default"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#protected-attributes-inherited-from-zmbtjsoniterzipprodbase","title":"Protected Attributes inherited from zmbt::JsonIterZipProdBase","text":"<p>See zmbt::JsonIterZipProdBase</p> Type Name std::vector&lt; boost::json::array::const_iterator &gt; begins_   = <code>{}</code> std::vector&lt; boost::json::array::const_iterator &gt; ends_   = <code>{}</code> bool halt_   = <code>{false}</code> std::vector&lt; boost::json::array::const_iterator &gt; its_   = <code>{}</code> boost::json::array owned_sequences_"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#function-jsoniterzipprodbase-15","title":"function JsonIterZipProdBase [1/5]","text":"<pre><code>inline explicit zmbt::JsonProdIter::JsonIterZipProdBase (\n    boost::json::array const &amp; sequences\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#function-jsoniterzipprodbase-25","title":"function JsonIterZipProdBase [2/5]","text":"<pre><code>inline explicit zmbt::JsonProdIter::JsonIterZipProdBase (\n    boost::json::array &amp;&amp; seqences\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#function-jsoniterzipprodbase-35","title":"function JsonIterZipProdBase [3/5]","text":"<pre><code>inline zmbt::JsonProdIter::JsonIterZipProdBase () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#function-jsoniterzipprodbase-45","title":"function JsonIterZipProdBase [4/5]","text":"<pre><code>zmbt::JsonProdIter::JsonIterZipProdBase (\n    JsonIterZipProdBase const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonProdIter/#function-jsoniterzipprodbase-55","title":"function JsonIterZipProdBase [5/5]","text":"<pre><code>zmbt::JsonProdIter::JsonIterZipProdBase (\n    JsonIterZipProdBase &amp;&amp;\n) = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_iter.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1JsonTraverse/","title":"Class zmbt::JsonTraverse","text":"<p>ClassList &gt; zmbt &gt; JsonTraverse</p> <p>Boost JSON value depth-first traverser. </p> <ul> <li><code>#include &lt;json_traverse.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1JsonTraverse/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; bool(boost::json::value const  &amp;, std::string const)&gt; visitor_fn"},{"location":"CxxRef/classzmbt_1_1JsonTraverse/#public-functions","title":"Public Functions","text":"Type Name JsonTraverse (visitor_fn visit) Construct JSON traverser. void operator() (boost::json::value const &amp; v) const"},{"location":"CxxRef/classzmbt_1_1JsonTraverse/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1JsonTraverse/#typedef-visitor_fn","title":"typedef visitor_fn","text":"<pre><code>typedef std::function&lt;bool(boost::json::value const&amp;, std::string const)&gt; zmbt::JsonTraverse::visitor_fn;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonTraverse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1JsonTraverse/#function-jsontraverse","title":"function JsonTraverse","text":"<p>Construct JSON traverser. <pre><code>inline zmbt::JsonTraverse::JsonTraverse (\n    visitor_fn visit\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>visit</code> JSON node visitor: (Node, JSON Pointer) -&gt; node traverse stop </li> </ul>"},{"location":"CxxRef/classzmbt_1_1JsonTraverse/#function-operator","title":"function operator()","text":"<pre><code>inline void zmbt::JsonTraverse::operator() (\n    boost::json::value const &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_traverse.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/","title":"Class zmbt::JsonZipIter","text":"<p>ClassList &gt; zmbt &gt; JsonZipIter</p> <p>Zip Iterator. </p> <ul> <li><code>#include &lt;json_iter.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::JsonIterZipProdBase</p>"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#public-functions","title":"Public Functions","text":"Type Name JsonIterZipProdBase (boost::json::array const &amp; sequences)  JsonIterZipProdBase (boost::json::array &amp;&amp; seqences)  JsonIterZipProdBase ()  JsonIterZipProdBase (JsonIterZipProdBase const &amp;) = default JsonIterZipProdBase (JsonIterZipProdBase &amp;&amp;) = default"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#public-functions-inherited-from-zmbtjsoniterzipprodbase","title":"Public Functions inherited from zmbt::JsonIterZipProdBase","text":"<p>See zmbt::JsonIterZipProdBase</p> Type Name JsonIterZipProdBase (boost::json::array const &amp; sequences)  JsonIterZipProdBase (boost::json::array &amp;&amp; seqences)  JsonIterZipProdBase ()  JsonIterZipProdBase (JsonIterZipProdBase const &amp;) = default JsonIterZipProdBase (JsonIterZipProdBase &amp;&amp;) = default virtual boost::json::array get () iterator value virtual bool halt () constIterator halted. JsonIterZipProdBase &amp; operator= (JsonIterZipProdBase const &amp;) = default JsonIterZipProdBase &amp; operator= (JsonIterZipProdBase &amp;&amp;) = default virtual ~JsonIterZipProdBase () = default"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#public-functions-inherited-from-zmbtjsoniter","title":"Public Functions inherited from zmbt::JsonIter","text":"<p>See zmbt::JsonIter</p> Type Name JsonIter () = default JsonIter (JsonIter const &amp;) = default JsonIter (JsonIter &amp;&amp;) = default virtual boost::json::array get () = 0iterator value virtual bool halt () const = 0Iterator halted. boost::json::array operator* () iterator value JsonIter &amp; operator++ (int) iterator post-increment JsonIter &amp; operator= (JsonIter const &amp;) = default JsonIter &amp; operator= (JsonIter &amp;&amp;) = default virtual ~JsonIter () = default"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#protected-attributes-inherited-from-zmbtjsoniterzipprodbase","title":"Protected Attributes inherited from zmbt::JsonIterZipProdBase","text":"<p>See zmbt::JsonIterZipProdBase</p> Type Name std::vector&lt; boost::json::array::const_iterator &gt; begins_   = <code>{}</code> std::vector&lt; boost::json::array::const_iterator &gt; ends_   = <code>{}</code> bool halt_   = <code>{false}</code> std::vector&lt; boost::json::array::const_iterator &gt; its_   = <code>{}</code> boost::json::array owned_sequences_"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#function-jsoniterzipprodbase-15","title":"function JsonIterZipProdBase [1/5]","text":"<pre><code>inline explicit zmbt::JsonZipIter::JsonIterZipProdBase (\n    boost::json::array const &amp; sequences\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#function-jsoniterzipprodbase-25","title":"function JsonIterZipProdBase [2/5]","text":"<pre><code>inline explicit zmbt::JsonZipIter::JsonIterZipProdBase (\n    boost::json::array &amp;&amp; seqences\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#function-jsoniterzipprodbase-35","title":"function JsonIterZipProdBase [3/5]","text":"<pre><code>inline zmbt::JsonZipIter::JsonIterZipProdBase () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#function-jsoniterzipprodbase-45","title":"function JsonIterZipProdBase [4/5]","text":"<pre><code>zmbt::JsonZipIter::JsonIterZipProdBase (\n    JsonIterZipProdBase const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1JsonZipIter/#function-jsoniterzipprodbase-55","title":"function JsonIterZipProdBase [5/5]","text":"<pre><code>zmbt::JsonZipIter::JsonIterZipProdBase (\n    JsonIterZipProdBase &amp;&amp;\n) = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_iter.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1Logger/","title":"Class zmbt::Logger","text":"<p>ClassList &gt; zmbt &gt; Logger</p>"},{"location":"CxxRef/classzmbt_1_1Logger/#public-types","title":"Public Types","text":"Type Name enum Level enum Output"},{"location":"CxxRef/classzmbt_1_1Logger/#public-functions","title":"Public Functions","text":"Type Name Logger ()  Logger &amp; WithLevel (Level const level)  Logger &amp; WithOutput (Output const output)  Logger &amp; WithSrcLoc (boost::json::string_view const src_loc)  Logger &amp; operator&lt;&lt; (boost::json::value const &amp; value)  Logger &amp; operator&lt;&lt; (entity_id const &amp; value)  ~Logger ()"},{"location":"CxxRef/classzmbt_1_1Logger/#public-static-functions","title":"Public Static Functions","text":"Type Name bool is_notrim_enabled ()  bool is_pretty_print_enabled ()  Level max_level ()  void open_json (const std::string &amp; filename=\"\") Attach logger to file sink (\"\" means stdout) void set_max_level (Level const max_level)  void set_notrim (bool const trim_line)  void set_pretty_print (bool const trim_line)"},{"location":"CxxRef/classzmbt_1_1Logger/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Logger/#enum-level","title":"enum Level","text":"<pre><code>enum zmbt::Logger::Level {\n    FATAL,\n    ERROR,\n    WARNING,\n    INFO,\n    DEBUG,\n    TRACE\n};\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#enum-output","title":"enum Output","text":"<pre><code>enum zmbt::Logger::Output {\n    NIL = 0,\n    STDERR = 1 &lt;&lt; 0,\n    JSON = 1 &lt;&lt; 1\n};\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Logger/#function-logger","title":"function Logger","text":"<pre><code>zmbt::Logger::Logger () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-withlevel","title":"function WithLevel","text":"<pre><code>Logger &amp; zmbt::Logger::WithLevel (\n    Level const level\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-withoutput","title":"function WithOutput","text":"<pre><code>Logger &amp; zmbt::Logger::WithOutput (\n    Output const output\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-withsrcloc","title":"function WithSrcLoc","text":"<pre><code>Logger &amp; zmbt::Logger::WithSrcLoc (\n    boost::json::string_view const src_loc\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>Logger &amp; zmbt::Logger::operator&lt;&lt; (\n    boost::json::value const &amp; value\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>Logger &amp; zmbt::Logger::operator&lt;&lt; (\n    entity_id const &amp; value\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-logger_1","title":"function ~Logger","text":"<pre><code>zmbt::Logger::~Logger () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Logger/#function-is_notrim_enabled","title":"function is_notrim_enabled","text":"<pre><code>static bool zmbt::Logger::is_notrim_enabled () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-is_pretty_print_enabled","title":"function is_pretty_print_enabled","text":"<pre><code>static bool zmbt::Logger::is_pretty_print_enabled () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-max_level","title":"function max_level","text":"<pre><code>static Level zmbt::Logger::max_level () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-open_json","title":"function open_json","text":"<p>Attach logger to file sink (\"\" means stdout) <pre><code>static void zmbt::Logger::open_json (\n    const std::string &amp; filename=\"\"\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-set_max_level","title":"function set_max_level","text":"<pre><code>static void zmbt::Logger::set_max_level (\n    Level const max_level\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-set_notrim","title":"function set_notrim","text":"<pre><code>static void zmbt::Logger::set_notrim (\n    bool const trim_line\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Logger/#function-set_pretty_print","title":"function set_pretty_print","text":"<pre><code>static void zmbt::Logger::set_pretty_print (\n    bool const trim_line\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application/log.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/","title":"Class zmbt::OutputRecorder","text":"<p>ClassList &gt; zmbt &gt; OutputRecorder</p>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#classes","title":"Classes","text":"Type Name struct Frame &lt;class T&gt;"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#public-functions","title":"Public Functions","text":"Type Name OutputRecorder (interface_id const &amp; ifc_id, object_id const &amp; obj_id)  OutputRecorder (OutputRecorder const &amp;) = default OutputRecorder (OutputRecorder &amp;&amp;) = default void clear ()  std::size_t count () constPush calls count. boost::json::array const &amp; data_frames () const void enable_category (ChannelKind const ck)  void flush () Flush interal bufferregistry_s and complete serialization. boost::json::string_view interface_name () const bool is_registered () constOutputRecorder . std::size_t lost_count () constPush calls count after the capture is closed. OutputRecorder &amp; operator= (OutputRecorder const &amp;) = default OutputRecorder &amp; operator= (OutputRecorder &amp;&amp;) = default void push (ArgsTuple const &amp; args, ErrorOr&lt; Return &gt; const &amp; return_or_error) Multi-producer push. void setup_handlers ()  ~OutputRecorder ()"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-outputrecorder-13","title":"function OutputRecorder [1/3]","text":"<pre><code>zmbt::OutputRecorder::OutputRecorder (\n    interface_id const &amp; ifc_id,\n    object_id const &amp; obj_id\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-outputrecorder-23","title":"function OutputRecorder [2/3]","text":"<pre><code>zmbt::OutputRecorder::OutputRecorder (\n    OutputRecorder const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-outputrecorder-33","title":"function OutputRecorder [3/3]","text":"<pre><code>zmbt::OutputRecorder::OutputRecorder (\n    OutputRecorder &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-clear","title":"function clear","text":"<pre><code>void zmbt::OutputRecorder::clear () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-count","title":"function count","text":"<p>Push calls count. <pre><code>inline std::size_t zmbt::OutputRecorder::count () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-data_frames","title":"function data_frames","text":"<pre><code>boost::json::array const &amp; zmbt::OutputRecorder::data_frames () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-enable_category","title":"function enable_category","text":"<pre><code>void zmbt::OutputRecorder::enable_category (\n    ChannelKind const ck\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-flush","title":"function flush","text":"<p>Flush interal bufferregistry_s and complete serialization. <pre><code>void zmbt::OutputRecorder::flush () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-interface_name","title":"function interface_name","text":"<pre><code>inline boost::json::string_view zmbt::OutputRecorder::interface_name () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-is_registered","title":"function is_registered","text":"<p>OutputRecorder . <pre><code>inline bool zmbt::OutputRecorder::is_registered () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-lost_count","title":"function lost_count","text":"<p>Push calls count after the capture is closed. <pre><code>inline std::size_t zmbt::OutputRecorder::lost_count () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-operator","title":"function operator=","text":"<pre><code>OutputRecorder &amp; zmbt::OutputRecorder::operator= (\n    OutputRecorder const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-operator_1","title":"function operator=","text":"<pre><code>OutputRecorder &amp; zmbt::OutputRecorder::operator= (\n    OutputRecorder &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-push","title":"function push","text":"<p>Multi-producer push. <pre><code>template&lt;class ArgsTuple, class Return&gt;\ninline void zmbt::OutputRecorder::push (\n    ArgsTuple const &amp; args,\n    ErrorOr &lt; Return &gt; const &amp; return_or_error\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-setup_handlers","title":"function setup_handlers","text":"<pre><code>template&lt;class Interface, class InterfacePointer&gt;\ninline void zmbt::OutputRecorder::setup_handlers () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1OutputRecorder/#function-outputrecorder","title":"function ~OutputRecorder","text":"<pre><code>zmbt::OutputRecorder::~OutputRecorder () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/output_recorder.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Frame/","title":"Struct zmbt::OutputRecorder::Frame","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; zmbt &gt; OutputRecorder &gt; Frame</p>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Frame/#public-attributes","title":"Public Attributes","text":"Type Name T data   = <code>{[**reflect::signal\\_traits**](structzmbt_1_1reflect_1_1signal__traits.md)&amp;lt;T&amp;gt;::init()}</code> std::size_t ts"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Frame/#variable-data","title":"variable data","text":"<pre><code>T zmbt::OutputRecorder::Frame&lt; T &gt;::data;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Frame/#variable-ts","title":"variable ts","text":"<pre><code>std::size_t zmbt::OutputRecorder::Frame&lt; T &gt;::ts;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/output_recorder.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1Param/","title":"Class zmbt::Param","text":"<p>ClassList &gt; zmbt &gt; Param</p> <p>Generic Parameter Placeholder. </p> <ul> <li><code>#include &lt;parameter.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::lang::Expression</p>"},{"location":"CxxRef/classzmbt_1_1Param/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/classzmbt_1_1Param/#public-functions","title":"Public Functions","text":"Type Name Param (boost::json::value v)  Param (Param const &amp;) = default Param (Param &amp;&amp;) = default Param &amp; operator= (Param const &amp;) = default Param &amp; operator= (Param &amp;&amp;) = default ~Param () = default"},{"location":"CxxRef/classzmbt_1_1Param/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/classzmbt_1_1Param/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/classzmbt_1_1Param/#public-static-functions","title":"Public Static Functions","text":"Type Name bool isParam (boost::json::value const &amp; v)"},{"location":"CxxRef/classzmbt_1_1Param/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/classzmbt_1_1Param/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/classzmbt_1_1Param/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Param/#function-param-24","title":"function Param [2/4]","text":"<pre><code>inline zmbt::Param::Param (\n    boost::json::value v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Param/#function-param-34","title":"function Param [3/4]","text":"<pre><code>zmbt::Param::Param (\n    Param const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Param/#function-param-44","title":"function Param [4/4]","text":"<pre><code>zmbt::Param::Param (\n    Param &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Param/#function-operator","title":"function operator=","text":"<pre><code>Param &amp; zmbt::Param::operator= (\n    Param const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Param/#function-operator_1","title":"function operator=","text":"<pre><code>Param &amp; zmbt::Param::operator= (\n    Param &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Param/#function-param","title":"function ~Param","text":"<pre><code>zmbt::Param::~Param () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Param/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Param/#function-isparam","title":"function isParam","text":"<pre><code>static bool zmbt::Param::isParam (\n    boost::json::value const &amp; v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/parameter.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/","title":"Struct zmbt::PermanentEnvData","text":"<p>ClassList &gt; zmbt &gt; PermanentEnvData</p>"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; void(OutputRecorder &amp;)&gt; SetupOutputRecorder"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#public-attributes","title":"Public Attributes","text":"Type Name boost::concurrent_flat_map&lt; interface_id, object_id &gt; default_objects   = <code>{}</code> boost::concurrent_flat_map&lt; interface_id, SetupOutputRecorder &gt; output_recorder_factories   = <code>{}</code> boost::concurrent_flat_map&lt; interface_id, reflect::Prototypes &gt; prototypes   = <code>{}</code>"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#public-functions","title":"Public Functions","text":"Type Name boost::optional&lt; object_id &gt; get_default_object (interface_id const &amp;) const boost::optional&lt; SetupOutputRecorder &gt; get_output_recorder_factory (interface_id const &amp;) const boost::optional&lt; reflect::Prototypes &gt; get_prototypes (interface_id const &amp;) const"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#typedef-setupoutputrecorder","title":"typedef SetupOutputRecorder","text":"<pre><code>using zmbt::PermanentEnvData::SetupOutputRecorder =  std::function&lt;void(OutputRecorder&amp;)&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#variable-default_objects","title":"variable default_objects","text":"<pre><code>boost::concurrent_flat_map&lt;interface_id, object_id&gt; zmbt::PermanentEnvData::default_objects;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#variable-output_recorder_factories","title":"variable output_recorder_factories","text":"<pre><code>boost::concurrent_flat_map&lt;interface_id, SetupOutputRecorder&gt; zmbt::PermanentEnvData::output_recorder_factories;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#variable-prototypes","title":"variable prototypes","text":"<pre><code>boost::concurrent_flat_map&lt;interface_id, reflect::Prototypes&gt; zmbt::PermanentEnvData::prototypes;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#function-get_default_object","title":"function get_default_object","text":"<pre><code>boost::optional&lt; object_id &gt; zmbt::PermanentEnvData::get_default_object (\n    interface_id const &amp;\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#function-get_output_recorder_factory","title":"function get_output_recorder_factory","text":"<pre><code>boost::optional&lt; SetupOutputRecorder &gt; zmbt::PermanentEnvData::get_output_recorder_factory (\n    interface_id const &amp;\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1PermanentEnvData/#function-get_prototypes","title":"function get_prototypes","text":"<pre><code>boost::optional&lt; reflect::Prototypes &gt; zmbt::PermanentEnvData::get_prototypes (\n    interface_id const &amp;\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/permanent_data.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1StubLogger/","title":"Struct zmbt::StubLogger","text":"<p>ClassList &gt; zmbt &gt; StubLogger</p>"},{"location":"CxxRef/structzmbt_1_1StubLogger/#public-functions","title":"Public Functions","text":"Type Name StubLogger &amp; operator&lt;&lt; (boost::json::value const &amp;)"},{"location":"CxxRef/structzmbt_1_1StubLogger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1StubLogger/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>inline StubLogger &amp; zmbt::StubLogger::operator&lt;&lt; (\n    boost::json::value const &amp;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application/log.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1Trigger/","title":"Class zmbt::Trigger","text":"<p>ClassList &gt; zmbt &gt; Trigger</p> <p>Controlled environment interface executor. </p> <ul> <li><code>#include &lt;trigger.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1Trigger/#public-functions","title":"Public Functions","text":"Type Name Trigger (Trigger const &amp;) = default Trigger (Trigger &amp;&amp;) = default Trigger (T &amp;&amp; obj, Interface &amp;&amp; interface, std::shared_ptr&lt; OutputRecorder &gt; recorder)  interface_id ifc_id () const object_id obj_id () const bool operator!= (Trigger const &amp; o) const void operator() (boost::json::value args_in) const Trigger &amp; operator= (Trigger const &amp;) = default Trigger &amp; operator= (Trigger &amp;&amp;) = default bool operator== (Trigger const &amp; o) const ~Trigger () = default"},{"location":"CxxRef/classzmbt_1_1Trigger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1Trigger/#function-trigger-24","title":"function Trigger [2/4]","text":"<pre><code>zmbt::Trigger::Trigger (\n    Trigger const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-trigger-34","title":"function Trigger [3/4]","text":"<pre><code>zmbt::Trigger::Trigger (\n    Trigger &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-trigger-44","title":"function Trigger [4/4]","text":"<pre><code>template&lt;class T, class Interface&gt;\ninline zmbt::Trigger::Trigger (\n    T &amp;&amp; obj,\n    Interface &amp;&amp; interface,\n    std::shared_ptr&lt; OutputRecorder &gt; recorder\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-ifc_id","title":"function ifc_id","text":"<pre><code>inline interface_id zmbt::Trigger::ifc_id () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-obj_id","title":"function obj_id","text":"<pre><code>inline object_id zmbt::Trigger::obj_id () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-operator","title":"function operator!=","text":"<pre><code>inline bool zmbt::Trigger::operator!= (\n    Trigger const &amp; o\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-operator_1","title":"function operator()","text":"<pre><code>inline void zmbt::Trigger::operator() (\n    boost::json::value args_in\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-operator_2","title":"function operator=","text":"<pre><code>Trigger &amp; zmbt::Trigger::operator= (\n    Trigger const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-operator_3","title":"function operator=","text":"<pre><code>Trigger &amp; zmbt::Trigger::operator= (\n    Trigger &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-operator_4","title":"function operator==","text":"<pre><code>inline bool zmbt::Trigger::operator== (\n    Trigger const &amp; o\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1Trigger/#function-trigger","title":"function ~Trigger","text":"<pre><code>zmbt::Trigger::~Trigger () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/trigger.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/","title":"Class zmbt::TriggerIfc","text":"<p>ClassList &gt; zmbt &gt; TriggerIfc</p> <p>More...</p> <ul> <li><code>#include &lt;trigger.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#public-functions","title":"Public Functions","text":"Type Name TriggerIfc (Interface &amp;&amp; interface)  TriggerIfc (TriggerIfc const &amp;) = default TriggerIfc (TriggerIfc &amp;) = default TriggerIfc (TriggerIfc &amp;&amp;) = default void execute (std::shared_ptr&lt; void &gt; obj, boost::json::value const &amp; args_in, OutputRecorder &amp; recorder) const interface_id id () const TriggerIfc &amp; operator= (TriggerIfc const &amp;) = default TriggerIfc &amp; operator= (TriggerIfc &amp;&amp;) = default virtual ~TriggerIfc () = default"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#detailed-description","title":"Detailed Description","text":"<p>Function wrapper. Transforms <code>(T...) -&gt; R</code> or <code>(O*)(T...) -&gt; R</code> to <code>(shared_ptr&lt;void&gt;, JSON) -&gt; void</code>, capturing R with OutputRecorder </p>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#function-triggerifc-14","title":"function TriggerIfc [1/4]","text":"<pre><code>template&lt;class Interface&gt;\ninline zmbt::TriggerIfc::TriggerIfc (\n    Interface &amp;&amp; interface\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#function-triggerifc-24","title":"function TriggerIfc [2/4]","text":"<pre><code>zmbt::TriggerIfc::TriggerIfc (\n    TriggerIfc const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#function-triggerifc-34","title":"function TriggerIfc [3/4]","text":"<pre><code>zmbt::TriggerIfc::TriggerIfc (\n    TriggerIfc &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#function-triggerifc-44","title":"function TriggerIfc [4/4]","text":"<pre><code>zmbt::TriggerIfc::TriggerIfc (\n    TriggerIfc &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#function-execute","title":"function execute","text":"<pre><code>inline void zmbt::TriggerIfc::execute (\n    std::shared_ptr&lt; void &gt; obj,\n    boost::json::value const &amp; args_in,\n    OutputRecorder &amp; recorder\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#function-id","title":"function id","text":"<pre><code>inline interface_id zmbt::TriggerIfc::id () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#function-operator","title":"function operator=","text":"<pre><code>TriggerIfc &amp; zmbt::TriggerIfc::operator= (\n    TriggerIfc const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#function-operator_1","title":"function operator=","text":"<pre><code>TriggerIfc &amp; zmbt::TriggerIfc::operator= (\n    TriggerIfc &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerIfc/#function-triggerifc","title":"function ~TriggerIfc","text":"<pre><code>virtual zmbt::TriggerIfc::~TriggerIfc () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/trigger.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/","title":"Class zmbt::TriggerObj","text":"<p>ClassList &gt; zmbt &gt; TriggerObj</p> <p>Object handler to be used with TriggerIfc .</p> <ul> <li><code>#include &lt;trigger.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#public-functions","title":"Public Functions","text":"Type Name TriggerObj (std::shared_ptr&lt; T &gt; obj)  TriggerObj (T * obj)  TriggerObj (T const * obj)  TriggerObj (T &amp; obj)  TriggerObj (T const &amp; obj)  TriggerObj (nullptr_t)  TriggerObj (TriggerObj const &amp;) = default TriggerObj (TriggerObj &amp;&amp;) = default object_id id () const TriggerObj &amp; operator= (TriggerObj const &amp;) = default TriggerObj &amp; operator= (TriggerObj &amp;&amp;) = default std::shared_ptr&lt; void &gt; ptr () const bool unsafe () const virtual ~TriggerObj () = default"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-triggerobj-18","title":"function TriggerObj [1/8]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::TriggerObj::TriggerObj (\n    std::shared_ptr&lt; T &gt; obj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-triggerobj-28","title":"function TriggerObj [2/8]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::TriggerObj::TriggerObj (\n    T * obj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-triggerobj-38","title":"function TriggerObj [3/8]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::TriggerObj::TriggerObj (\n    T const * obj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-triggerobj-48","title":"function TriggerObj [4/8]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::TriggerObj::TriggerObj (\n    T &amp; obj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-triggerobj-58","title":"function TriggerObj [5/8]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::TriggerObj::TriggerObj (\n    T const &amp; obj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-triggerobj-68","title":"function TriggerObj [6/8]","text":"<pre><code>inline zmbt::TriggerObj::TriggerObj (\n    nullptr_t\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-triggerobj-78","title":"function TriggerObj [7/8]","text":"<pre><code>zmbt::TriggerObj::TriggerObj (\n    TriggerObj const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-triggerobj-88","title":"function TriggerObj [8/8]","text":"<pre><code>zmbt::TriggerObj::TriggerObj (\n    TriggerObj &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-id","title":"function id","text":"<pre><code>inline object_id zmbt::TriggerObj::id () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-operator","title":"function operator=","text":"<pre><code>TriggerObj &amp; zmbt::TriggerObj::operator= (\n    TriggerObj const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-operator_1","title":"function operator=","text":"<pre><code>TriggerObj &amp; zmbt::TriggerObj::operator= (\n    TriggerObj &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-ptr","title":"function ptr","text":"<pre><code>inline std::shared_ptr&lt; void &gt; zmbt::TriggerObj::ptr () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-unsafe","title":"function unsafe","text":"<pre><code>inline bool zmbt::TriggerObj::unsafe () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1TriggerObj/#function-triggerobj","title":"function ~TriggerObj","text":"<pre><code>virtual zmbt::TriggerObj::~TriggerObj () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/trigger.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1api/","title":"Namespace zmbt::api","text":"<p>Namespace List &gt; zmbt &gt; api</p> <p>Framework API with fixture classes and entries from main ns. </p>"},{"location":"CxxRef/namespacezmbt_1_1api/#namespaces","title":"Namespaces","text":"Type Name namespace decor Signal type decorators API. namespace expr Expression Language API."},{"location":"CxxRef/namespacezmbt_1_1api/#classes","title":"Classes","text":"Type Name class Environment Alias for zmbt::Environment . class Expression Alias for lang::Expression . struct ModelTestFixture Generic model-driven test fixture. class Param Alias for zmbt::Param . class SignalMapping Alias for zmbt::mapping::SignalMapping . class precise Alias for zmbt::precise."},{"location":"CxxRef/namespacezmbt_1_1api/#public-attributes","title":"Public Attributes","text":"Type Name constexpr auto type Alias for zmbt::type ."},{"location":"CxxRef/namespacezmbt_1_1api/#public-functions","title":"Public Functions","text":"Type Name auto InterfaceRecord (...) Alias for zmbt::InterfaceRecord ."},{"location":"CxxRef/namespacezmbt_1_1api/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/namespacezmbt_1_1api/#variable-type","title":"variable type","text":"<p>Alias for zmbt::type . <pre><code>constexpr auto zmbt::api::type;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1api/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/namespacezmbt_1_1api/#function-interfacerecord","title":"function InterfaceRecord","text":"<p>Alias for zmbt::InterfaceRecord . <pre><code>auto zmbt::api::InterfaceRecord (\n    ...\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/model_test.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1api_1_1Environment/","title":"Class zmbt::api::Environment","text":"<p>ClassList &gt; zmbt &gt; api &gt; Environment</p> <p>Alias for zmbt::Environment .</p> <ul> <li><code>#include &lt;ns.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: zmbt::api::ModelTestFixture</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/ns.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1api_1_1Expression/","title":"Class zmbt::api::Expression","text":"<p>ClassList &gt; zmbt &gt; api &gt; Expression</p> <p>Alias for lang::Expression .</p> <ul> <li><code>#include &lt;ns.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/ns.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1api_1_1ModelTestFixture/","title":"Struct zmbt::api::ModelTestFixture","text":"<p>ClassList &gt; zmbt &gt; api &gt; ModelTestFixture</p> <p>Generic model-driven test fixture. </p> <ul> <li><code>#include &lt;model_test.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::api::Environment</p>"},{"location":"CxxRef/structzmbt_1_1api_1_1ModelTestFixture/#public-functions","title":"Public Functions","text":"Type Name ModelTestFixture () = default ModelTestFixture (ModelTestFixture &amp;&amp;) = default ModelTestFixture (const ModelTestFixture &amp;) = delete ModelTestFixture &amp; operator= (ModelTestFixture &amp;&amp;) = default ModelTestFixture &amp; operator= (const ModelTestFixture &amp;) = delete virtual ~ModelTestFixture () = default"},{"location":"CxxRef/structzmbt_1_1api_1_1ModelTestFixture/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1api_1_1ModelTestFixture/#function-modeltestfixture-13","title":"function ModelTestFixture [1/3]","text":"<pre><code>zmbt::api::ModelTestFixture::ModelTestFixture () = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1api_1_1ModelTestFixture/#function-modeltestfixture-23","title":"function ModelTestFixture [2/3]","text":"<pre><code>zmbt::api::ModelTestFixture::ModelTestFixture (\n    ModelTestFixture &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1api_1_1ModelTestFixture/#function-modeltestfixture-33","title":"function ModelTestFixture [3/3]","text":"<pre><code>zmbt::api::ModelTestFixture::ModelTestFixture (\n    const ModelTestFixture &amp;\n) = delete\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1api_1_1ModelTestFixture/#function-operator","title":"function operator=","text":"<pre><code>ModelTestFixture &amp; zmbt::api::ModelTestFixture::operator= (\n    ModelTestFixture &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1api_1_1ModelTestFixture/#function-operator_1","title":"function operator=","text":"<pre><code>ModelTestFixture &amp; zmbt::api::ModelTestFixture::operator= (\n    const ModelTestFixture &amp;\n) = delete\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1api_1_1ModelTestFixture/#function-modeltestfixture","title":"function ~ModelTestFixture","text":"<pre><code>virtual zmbt::api::ModelTestFixture::~ModelTestFixture () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/model_test.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1api_1_1Param/","title":"Class zmbt::api::Param","text":"<p>ClassList &gt; zmbt &gt; api &gt; Param</p> <p>Alias for zmbt::Param .</p> <ul> <li><code>#include &lt;ns.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/ns.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1api_1_1SignalMapping/","title":"Class zmbt::api::SignalMapping","text":"<p>ClassList &gt; zmbt &gt; api &gt; SignalMapping</p> <p>Alias for zmbt::mapping::SignalMapping .</p> <ul> <li><code>#include &lt;ns.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/ns.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1api_1_1decor/","title":"Namespace zmbt::api::decor","text":"<p>Namespace List &gt; zmbt &gt; api &gt; decor</p> <p>Signal type decorators API. More...</p>"},{"location":"CxxRef/namespacezmbt_1_1api_1_1decor/#detailed-description","title":"Detailed Description","text":"<p>See also: zmbt::decor </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/ns.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1api_1_1expr/","title":"Namespace zmbt::api::expr","text":"<p>Namespace List &gt; zmbt &gt; api &gt; expr</p> <p>Expression Language API.More...</p>"},{"location":"CxxRef/namespacezmbt_1_1api_1_1expr/#detailed-description","title":"Detailed Description","text":"<p>See also: zmbt::expr </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/ns.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1api_1_1precise/","title":"Class zmbt::api::precise","text":"<p>ClassList &gt; zmbt &gt; api &gt; precise</p> <p>Alias for zmbt::precise. </p> <ul> <li><code>#include &lt;ns.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/ns.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1application/","title":"Namespace zmbt::application","text":"<p>Namespace List &gt; zmbt &gt; application</p> <p>Test application configuration (work in progress) </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/namespaces.dox</code></p>"},{"location":"CxxRef/structzmbt_1_1base__error/","title":"Struct zmbt::base_error","text":"<p>ClassList &gt; zmbt &gt; base_error</p> <p>ZMBT Base exception. </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::runtime_error</p> <p>Inherited by the following classes: zmbt::environment_error,  zmbt::lang::Operator::operator_error,  zmbt::model_error,  zmbt::output_recorder_error,  zmbt::serialization_error,  zmbt::test_assertion_failure</p>"},{"location":"CxxRef/structzmbt_1_1base__error/#public-functions","title":"Public Functions","text":"Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1base__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1base__error/#function-base_error","title":"function base_error","text":"<pre><code>template&lt;class... A&gt;\ninline zmbt::base_error::base_error (\n    boost::json::string_view fmtstr,\n    A &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/exceptions.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1decor/","title":"Namespace zmbt::decor","text":"<p>Namespace List &gt; zmbt &gt; decor</p> <p>Signal type decorators API. </p>"},{"location":"CxxRef/namespacezmbt_1_1decor/#classes","title":"Classes","text":"Type Name struct precise &lt;class VT&gt;Type decorator for floating point numbers. Throws on precision loss in runtime. struct precision_loss_error Exception thrown by decor::precise . struct underlying &lt;class E&gt;"},{"location":"CxxRef/namespacezmbt_1_1decor/#public-attributes","title":"Public Attributes","text":"Type Name constexpr zmbt::type_tag&lt; precise&lt; T &gt; &gt; Precise precise&lt;T&gt; decorator constexpr zmbt::type_tag&lt; underlying&lt; T &gt; &gt; Underlying underlying&lt;T&gt; decorator"},{"location":"CxxRef/namespacezmbt_1_1decor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/namespacezmbt_1_1decor/#variable-precise","title":"variable Precise","text":"<p>precise&lt;T&gt; decorator <pre><code>constexpr zmbt::type_tag&lt;precise&lt;T&gt; &gt; zmbt::decor::Precise;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1decor/#variable-underlying","title":"variable Underlying","text":"<p>underlying&lt;T&gt; decorator <pre><code>constexpr zmbt::type_tag&lt;underlying&lt;T&gt; &gt; zmbt::decor::Underlying;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/precise_real.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/","title":"Struct zmbt::decor::precise","text":"<p>template &lt;class VT&gt;</p> <p>ClassList &gt; zmbt &gt; decor &gt; precise</p> <p>Type decorator for floating point numbers. Throws on precision loss in runtime. More...</p> <ul> <li><code>#include &lt;precise_real.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#public-types","title":"Public Types","text":"Type Name typedef VT decorated_type The decorated type."},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#public-functions","title":"Public Functions","text":"Type Name operator decorated_type () const bool operator&lt; (precise other) const bool operator&lt; (boost::json::string_view str) const precise &amp; operator= (precise const &amp;) = default precise &amp; operator= (precise &amp;&amp;) = default precise &amp; operator= (T const v)  precise &amp; operator= (precise&lt; T &gt; other)  precise &amp; operator= (boost::json::string_view str)  bool operator== (precise other) const bool operator== (boost::json::string_view str) const precise ()  precise (precise const &amp;) = default precise (precise &amp;&amp;) = default precise (decorated_type v)  precise (T const v)  precise (precise&lt; T &gt; other)  precise (boost::json::string_view str) Construct value from string. Hex literals are supported. std::string stringify () const decorated_type value () const ~precise () = default"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#detailed-description","title":"Detailed Description","text":"<p>The class will ensure exact value conversion between floating point types of different precision on construction and assignment. In addition to handling the f23 vs f63, this class also can be constructed from string literals, enabling support for hex representation. </p>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#typedef-decorated_type","title":"typedef decorated_type","text":"<p>The decorated type. <pre><code>using zmbt::decor::precise&lt; VT &gt;::decorated_type =  VT;\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator-decorated_type","title":"function operator decorated_type","text":"<pre><code>inline zmbt::decor::precise::operator decorated_type () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator","title":"function operator&lt;","text":"<pre><code>inline bool zmbt::decor::precise::operator&lt; (\n    precise other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator_1","title":"function operator&lt;","text":"<pre><code>inline bool zmbt::decor::precise::operator&lt; (\n    boost::json::string_view str\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator_2","title":"function operator=","text":"<pre><code>precise &amp; zmbt::decor::precise::operator= (\n    precise const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator_3","title":"function operator=","text":"<pre><code>precise &amp; zmbt::decor::precise::operator= (\n    precise &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator_4","title":"function operator=","text":"<pre><code>template&lt;class T, class&gt;\ninline precise &amp; zmbt::decor::precise::operator= (\n    T const v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator_5","title":"function operator=","text":"<pre><code>template&lt;class T&gt;\ninline precise &amp; zmbt::decor::precise::operator= (\n    precise &lt; T &gt; other\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator_6","title":"function operator=","text":"<pre><code>inline precise &amp; zmbt::decor::precise::operator= (\n    boost::json::string_view str\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator_7","title":"function operator==","text":"<pre><code>inline bool zmbt::decor::precise::operator== (\n    precise other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-operator_8","title":"function operator==","text":"<pre><code>inline bool zmbt::decor::precise::operator== (\n    boost::json::string_view str\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-precise-17","title":"function precise [1/7]","text":"<pre><code>inline zmbt::decor::precise::precise () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-precise-27","title":"function precise [2/7]","text":"<pre><code>zmbt::decor::precise::precise (\n    precise const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-precise-37","title":"function precise [3/7]","text":"<pre><code>zmbt::decor::precise::precise (\n    precise &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-precise-47","title":"function precise [4/7]","text":"<pre><code>inline explicit zmbt::decor::precise::precise (\n    decorated_type v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-precise-57","title":"function precise [5/7]","text":"<pre><code>template&lt;class T, class&gt;\ninline zmbt::decor::precise::precise (\n    T const v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-precise-67","title":"function precise [6/7]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::decor::precise::precise (\n    precise &lt; T &gt; other\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-precise-77","title":"function precise [7/7]","text":"<p>Construct value from string. Hex literals are supported. <pre><code>inline zmbt::decor::precise::precise (\n    boost::json::string_view str\n) \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-stringify","title":"function stringify","text":"<pre><code>inline std::string zmbt::decor::precise::stringify () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-value","title":"function value","text":"<pre><code>inline decorated_type zmbt::decor::precise::value () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precise/#function-precise","title":"function ~precise","text":"<pre><code>zmbt::decor::precise::~precise () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/precise_real.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1decor_1_1precision__loss__error/","title":"Struct zmbt::decor::precision_loss_error","text":"<p>ClassList &gt; zmbt &gt; decor &gt; precision_loss_error</p> <p>Exception thrown by decor::precise .</p> <ul> <li><code>#include &lt;precise_real.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::runtime_error</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/precise_real.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/","title":"Struct zmbt::decor::underlying","text":"<p>template &lt;class E&gt;</p> <p>ClassList &gt; zmbt &gt; decor &gt; underlying</p>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#public-types","title":"Public Types","text":"Type Name typedef std::underlying_type_t&lt; E &gt; decorated_type"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#public-functions","title":"Public Functions","text":"Type Name operator decorated_type () const auto operator! () const auto operator!= (T const &amp; other) const auto operator% (T const &amp; other) const auto operator&amp; (T const &amp; other) const auto operator&amp;&amp; (T const &amp; other) const auto operator* (T const &amp; other) const auto operator+ (T const &amp; other) const auto operator- () const auto operator- (T const &amp; other) const auto operator/ (T const &amp; other) const auto operator&lt; (T const &amp; other) const auto operator&lt;&lt; (T const &amp; other) const auto operator&lt;= (T const &amp; other) const underlying &amp; operator= (underlying const &amp;) = default underlying &amp; operator= (underlying &amp;&amp;) = default underlying &amp; operator= (decorated_type const v)  underlying &amp; operator= (E const v)  underlying &amp; operator= (boost::json::string_view v)  auto operator== (T const &amp; other) const auto operator&gt; (T const &amp; other) const auto operator&gt;= (T const &amp; other) const auto operator&gt;&gt; (T const &amp; other) const auto operator^ (T const &amp; other) const auto operator| (T const &amp; other) const auto operator|| (T const &amp; other) const auto operator~ () const std::string stringify () const underlying () = default underlying (underlying const &amp;) = default underlying (underlying &amp;&amp;) = default underlying (decorated_type const v)  underlying (E const v)  underlying (boost::json::string_view v)  decorated_type value () const ~underlying () = default"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#typedef-decorated_type","title":"typedef decorated_type","text":"<pre><code>using zmbt::decor::underlying&lt; E &gt;::decorated_type =  std::underlying_type_t&lt;E&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator-decorated_type","title":"function operator decorated_type","text":"<pre><code>inline zmbt::decor::underlying::operator decorated_type () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator","title":"function operator!","text":"<pre><code>inline auto zmbt::decor::underlying::operator! () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_1","title":"function operator!=","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator!= (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_2","title":"function operator%","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator% (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_3","title":"function operator&amp;","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator&amp; (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_4","title":"function operator&amp;&amp;","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator&amp;&amp; (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_5","title":"function operator*","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator* (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_6","title":"function operator+","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator+ (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator-","title":"function operator-","text":"<pre><code>inline auto zmbt::decor::underlying::operator- () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator-_1","title":"function operator-","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator- (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_7","title":"function operator/","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator/ (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_8","title":"function operator&lt;","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator&lt; (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_9","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator&lt;&lt; (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_10","title":"function operator&lt;=","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator&lt;= (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_11","title":"function operator=","text":"<pre><code>underlying &amp; zmbt::decor::underlying::operator= (\n    underlying const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_12","title":"function operator=","text":"<pre><code>underlying &amp; zmbt::decor::underlying::operator= (\n    underlying &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_13","title":"function operator=","text":"<pre><code>inline underlying &amp; zmbt::decor::underlying::operator= (\n    decorated_type const v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_14","title":"function operator=","text":"<pre><code>inline underlying &amp; zmbt::decor::underlying::operator= (\n    E const v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_15","title":"function operator=","text":"<pre><code>inline underlying &amp; zmbt::decor::underlying::operator= (\n    boost::json::string_view v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_16","title":"function operator==","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator== (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_17","title":"function operator&gt;","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator&gt; (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_18","title":"function operator&gt;=","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator&gt;= (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_19","title":"function operator&gt;&gt;","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator&gt;&gt; (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_20","title":"function operator^","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator^ (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_21","title":"function operator|","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator| (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_22","title":"function operator||","text":"<pre><code>template&lt;class T&gt;\ninline auto zmbt::decor::underlying::operator|| (\n    T const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-operator_23","title":"function operator~","text":"<pre><code>inline auto zmbt::decor::underlying::operator~ () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-stringify","title":"function stringify","text":"<pre><code>inline std::string zmbt::decor::underlying::stringify () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-underlying-16","title":"function underlying [1/6]","text":"<pre><code>zmbt::decor::underlying::underlying () = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-underlying-26","title":"function underlying [2/6]","text":"<pre><code>zmbt::decor::underlying::underlying (\n    underlying const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-underlying-36","title":"function underlying [3/6]","text":"<pre><code>zmbt::decor::underlying::underlying (\n    underlying &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-underlying-46","title":"function underlying [4/6]","text":"<pre><code>inline zmbt::decor::underlying::underlying (\n    decorated_type const v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-underlying-56","title":"function underlying [5/6]","text":"<pre><code>inline zmbt::decor::underlying::underlying (\n    E const v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-underlying-66","title":"function underlying [6/6]","text":"<pre><code>inline zmbt::decor::underlying::underlying (\n    boost::json::string_view v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-value","title":"function value","text":"<pre><code>inline decorated_type zmbt::decor::underlying::value () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1decor_1_1underlying/#function-underlying","title":"function ~underlying","text":"<pre><code>zmbt::decor::underlying::~underlying () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/underlying.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1entity__id/","title":"Class zmbt::entity_id","text":"<p>ClassList &gt; zmbt &gt; entity_id</p> <p>Base class for annotated key objects. </p> <ul> <li><code>#include &lt;entity_id.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: zmbt::interface_id,  zmbt::object_id</p>"},{"location":"CxxRef/classzmbt_1_1entity__id/#public-functions","title":"Public Functions","text":"Type Name boost::json::string_view annotation () const entity_id () = default entity_id (boost::json::string_view key, std::type_index type_index)  entity_id (boost::json::string_view key, std::size_t type_index_hash)  entity_id (boost::json::array const &amp; str)  entity_id (boost::json::value const &amp; val)  entity_id (entity_id const &amp;) = default entity_id (entity_id &amp;&amp;) = default boost::json::string_view key () const bool operator!= (entity_id const &amp; other) const entity_id &amp; operator= (entity_id const &amp;) = default entity_id &amp; operator= (entity_id &amp;&amp;) = default entity_id &amp; operator= (boost::json::value const &amp; v)  entity_id &amp; operator= (boost::json::value &amp;&amp; v)  bool operator== (entity_id const &amp; other) const boost::json::string_view str () const virtual ~entity_id () = default"},{"location":"CxxRef/classzmbt_1_1entity__id/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1entity__id/#function-annotation","title":"function annotation","text":"<pre><code>boost::json::string_view zmbt::entity_id::annotation () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-entity_id-17","title":"function entity_id [1/7]","text":"<pre><code>zmbt::entity_id::entity_id () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-entity_id-27","title":"function entity_id [2/7]","text":"<pre><code>zmbt::entity_id::entity_id (\n    boost::json::string_view key,\n    std::type_index type_index\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-entity_id-37","title":"function entity_id [3/7]","text":"<pre><code>zmbt::entity_id::entity_id (\n    boost::json::string_view key,\n    std::size_t type_index_hash\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-entity_id-47","title":"function entity_id [4/7]","text":"<pre><code>explicit zmbt::entity_id::entity_id (\n    boost::json::array const &amp; str\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-entity_id-57","title":"function entity_id [5/7]","text":"<pre><code>explicit zmbt::entity_id::entity_id (\n    boost::json::value const &amp; val\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-entity_id-67","title":"function entity_id [6/7]","text":"<pre><code>zmbt::entity_id::entity_id (\n    entity_id const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-entity_id-77","title":"function entity_id [7/7]","text":"<pre><code>zmbt::entity_id::entity_id (\n    entity_id &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-key","title":"function key","text":"<pre><code>inline boost::json::string_view zmbt::entity_id::key () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-operator","title":"function operator!=","text":"<pre><code>inline bool zmbt::entity_id::operator!= (\n    entity_id const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-operator_1","title":"function operator=","text":"<pre><code>entity_id &amp; zmbt::entity_id::operator= (\n    entity_id const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-operator_2","title":"function operator=","text":"<pre><code>entity_id &amp; zmbt::entity_id::operator= (\n    entity_id &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-operator_3","title":"function operator=","text":"<pre><code>inline entity_id &amp; zmbt::entity_id::operator= (\n    boost::json::value const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-operator_4","title":"function operator=","text":"<pre><code>inline entity_id &amp; zmbt::entity_id::operator= (\n    boost::json::value &amp;&amp; v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-operator_5","title":"function operator==","text":"<pre><code>inline bool zmbt::entity_id::operator== (\n    entity_id const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-str","title":"function str","text":"<pre><code>boost::json::string_view zmbt::entity_id::str () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#function-entity_id","title":"function ~entity_id","text":"<pre><code>virtual zmbt::entity_id::~entity_id () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1entity__id/#friends-documentation","title":"Friends Documentation","text":""},{"location":"CxxRef/classzmbt_1_1entity__id/#friend-hash_value","title":"friend hash_value","text":"<p>Boost.Hash customization point. <pre><code>inline std::size_t zmbt::entity_id::hash_value (\n    entity_id const &amp; v\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1entity__id/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; zmbt::entity_id::operator&lt;&lt; (\n    std::ostream &amp; os,\n    entity_id const &amp; id\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/entity_id.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1environment__error/","title":"Struct zmbt::environment_error","text":"<p>ClassList &gt; zmbt &gt; environment_error</p> <p>Test environment error. </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::base_error</p>"},{"location":"CxxRef/structzmbt_1_1environment__error/#public-functions","title":"Public Functions","text":"Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1environment__error/#public-functions-inherited-from-zmbtbase_error","title":"Public Functions inherited from zmbt::base_error","text":"<p>See zmbt::base_error</p> Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1environment__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1environment__error/#function-base_error","title":"function base_error","text":"<pre><code>template&lt;class... A&gt;\ninline zmbt::environment_error::base_error (\n    boost::json::string_view fmtstr,\n    A &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/exceptions.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/","title":"Namespace zmbt::expr","text":"<p>Namespace List &gt; zmbt &gt; expr</p> <p>Expression Language API. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#public-attributes","title":"Public Attributes","text":"Type Name lang::SignatureUnary&lt;::zmbt::lang::Keyword::Abs &gt; const Abs Absolute value. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Acos &gt; const Acos Arccos function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Acosh &gt; const Acosh Hyperbolic arccos. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Add &gt; const Add Addition. lang::SignatureVariadic&lt;::zmbt::lang::Keyword::All &gt; const All Match all predicates. lang::SignatureBinary&lt;::zmbt::lang::Keyword::And &gt; const And Logical and. lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Any &gt; const Any Match any predicate. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Near &gt; const Approx Alias for Near. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Arange &gt; const Arange Generate range of numbers. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Argmax &gt; const Argmax Max value index by key function. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Argmin &gt; const Argmin Min value index by key function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Asin &gt; const Asin Arcsin function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Asinh &gt; const Asinh Hyperbolic arcsin. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Assert &gt; const Assert Return argument if it holds assertion or error otherwise. lang::SignatureBinary&lt;::zmbt::lang::Keyword::At &gt; const At lang::SignatureUnary&lt;::zmbt::lang::Keyword::Atan &gt; const Atan Arctan function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Atanh &gt; const Atanh Hyperbolic arctan. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Avg &gt; const Avg Arythmetic average. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Bind &gt; const Bind Bind design-time parameters to function. lang::SignatureBinary&lt;::zmbt::lang::Keyword::BitAnd &gt; const BitAnd Bitwise and. lang::SignatureUnary&lt;::zmbt::lang::Keyword::BitNot &gt; const BitNot Bitwise not. lang::SignatureBinary&lt;::zmbt::lang::Keyword::BitOr &gt; const BitOr Bitwise or. lang::SignatureBinary&lt;::zmbt::lang::Keyword::BitXor &gt; const BitXor Bitwise xor. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Bool &gt; const Bool Predicate on boolean transform (aka truthy) lang::SignatureBinary&lt;::zmbt::lang::Keyword::Q &gt; const C Alias for Q. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Capitalize &gt; const Capitalize Capitalize string. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Card &gt; const Card Set cardinality (uniques count) lang::SignatureUnary&lt;::zmbt::lang::Keyword::Cartesian &gt; const Cartesian Cartesian product. lang::SignatureCast const Cast Reserialize decorated type as decorator. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Cat &gt; const Cat Concatenate sequences. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Ceil &gt; const Ceil Ceil. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Chunks &gt; const Chunks Split into chunks of specified max width. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Cat &gt; const Concat Alias for Cat. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Q &gt; const Const Alias for Q. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ni &gt; const Contains Alias for Ni. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Cos &gt; const Cos Cosinus function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Cosh &gt; const Cosh Hyperbolic cos. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Count &gt; const Count Count matches by predicate param. lang::SignatureBinary&lt;::zmbt::lang::Keyword::D &gt; const D Return x if not null, else return default value. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Dbg &gt; const Dbg Evaluate function and print evaluation log to stderr. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Dbg &gt; const Debug Alias for Dbg. lang::SignatureCast const Decorate Alias for Cast. lang::SignatureBinary&lt;::zmbt::lang::Keyword::D &gt; const Default Alias for D. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Del &gt; const Del Delete elements from structure by given query. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Del &gt; const Delete Alias for Del. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Diff &gt; const Diff Set difference. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Div &gt; const Div Division. lang::SignatureConst&lt;::zmbt::lang::Keyword::E &gt; const E Euler's number. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Each &gt; const Each Test predicate for each item in a sequence. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Enumerate &gt; const Enumerate Enumerate sequence. lang::SignatureConst&lt;::zmbt::lang::Keyword::Eps &gt; const Eps Machine epsilon. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Eq &gt; const Eq Is equal. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Erf &gt; const Erf Error function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Erfc &gt; const Erfc Error function complement. lang::SignatureErr const Err Error object. lang::SignatureErr const Error Alias for Err. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Eval &gt; const Eval Flip designtime and run-time parameters, evaluating input as expression. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Exp &gt; const Exp Exponential (e^x) lang::SignatureConst&lt;::zmbt::lang::Keyword::False &gt; const False Logical false. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Not &gt; const Falsy Alias for Not. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Filter &gt; const Filter Filter sequence by predicate param. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Find &gt; const Find Find the first element that satisfies given predicate. lang::SignatureBinary&lt;::zmbt::lang::Keyword::FindIdx &gt; const FindIdx Find index of the first element that satisfies given predicate. lang::SignatureBinary&lt;::zmbt::lang::Keyword::FindPtr &gt; const FindPtr Find json pointer of the first element that satisfies given predicate. lang::SignatureUnary&lt;::zmbt::lang::Keyword::First &gt; const First First item of sequence. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Flatten &gt; const Flatten Flatten nested list. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Flip &gt; const Flip Flip design-time and eval-time parameters. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Floor &gt; const Floor Floor. lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Fmt &gt; const Fmt Format string with the given parameter list. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Fn &gt; const Fn Inline named function. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Fold &gt; const Fold Reduce sequence with binary operator. lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Fork &gt; const Fork Pack results from enveloped functions into an array. lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Fmt &gt; const Format Alias for Fmt. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Gamma &gt; const Gamma Gamma function. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ge &gt; const Ge Greater or equal. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Gt &gt; const Gt Greater than. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Id &gt; const Id Identity function. lang::SignatureBinary&lt;::zmbt::lang::Keyword::In &gt; const In Element is in. lang::SignatureConst&lt;::zmbt::lang::Keyword::Inf &gt; const Inf Infinity. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Intersect &gt; const Intersect Set intersection. lang::SignatureUnary&lt;::zmbt::lang::Keyword::IsErr &gt; const IsErr Test the argument is err expression. lang::SignatureUnary&lt;::zmbt::lang::Keyword::IsErr &gt; const Iserror Alias for IsErr. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Items &gt; const Items Extract key-value pairs from object. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Keys &gt; const Keys Extract keys from object. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Kwrd &gt; const Kwrd Introspect expression keyword. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Last &gt; const Last Last item of sequence. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Le &gt; const Le Lesser or equal. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Link &gt; const Link Symbolic binding of the input value. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Log &gt; const Log Logarithm. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Lookup &gt; const Lookup Lookup table function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::LowerCase &gt; const LowerCase Lower case string. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Lshift &gt; const Lshift Bitwise left shift. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Lt &gt; const Lt Lesser than. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Map &gt; const Map Apply param expr to every element of sequence. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Max &gt; const Max Max value by key function. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Min &gt; const Min Min value by key function. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Mod &gt; const Mod Modulo. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Mul &gt; const Mul Multiplication. lang::SignatureConst&lt;::zmbt::lang::Keyword::NaN &gt; const NaN Not a number. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ne &gt; const Ne Not equal. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Near &gt; const Near Floating point approximately equal. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Neg &gt; const Neg Negate. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ni &gt; const Ni Contains element. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Not &gt; const Nil Alias for Not. lang::SignatureConst&lt;::zmbt::lang::Keyword::Noop &gt; const Noop No operation. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Not &gt; const Not Logical complement. lang::SignatureBinary&lt;::zmbt::lang::Keyword::NotIn &gt; const NotIn Element is not in. lang::SignatureBinary&lt;::zmbt::lang::Keyword::NotNi &gt; const NotNi Not contains element. lang::SignatureConst&lt;::zmbt::lang::Keyword::Null &gt; const Null Null value. lang::SignatureOp const Op Bind type-specific operator handler to function. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Or &gt; const Or Logical or. lang::SignatureOp const Overload Alias for Op. lang::SignatureBinary&lt;::zmbt::lang::Keyword::PSubset &gt; const PSubset Is proper subset. lang::SignatureBinary&lt;::zmbt::lang::Keyword::PSuperset &gt; const PSuperset Is proper superset. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Prms &gt; const Parameters Alias for Prms. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Parse &gt; const Parse Parse string as json. lang::SignatureConst&lt;::zmbt::lang::Keyword::Pi &gt; const Pi Pi constant. lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Pipe &gt; const Pipe Pipe functions in left-to-right composition. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Pow &gt; const Pow To power. lang::SignatureBinary&lt;::zmbt::lang::Keyword::PreProc &gt; const PreProc Preprocessing token. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Prms &gt; const Prms Introspect expression parameters. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Prod &gt; const Prod Multiplication reduction. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Push &gt; const Push Push element into a front of sequence. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Q &gt; const Q Quote parameter, similar to lisp quotation. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Quot &gt; const Quot Quotient. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Re &gt; const Re Regular expression match. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Recur &gt; const Recur Apply recursion to parameter expr and initial value. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Fold &gt; const Reduce Alias for Fold. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Re &gt; const Regex Alias for Re. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Repeat &gt; const Repeat Repeat value in list. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Reverse &gt; const Reverse Reverse sequence. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Round &gt; const Round Round to nearest integer. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Rshift &gt; const Rshift Bitwise right shift. lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Saturate &gt; const Saturate Saturate matches in order. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Str &gt; const Serialize Alias for Str. lang::SignatureBinary&lt;::zmbt::lang::Keyword::SetEq &gt; const SetEq Equal as set. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sign &gt; const Sign Sign. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sin &gt; const Sin Sinus function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sinh &gt; const Sinh Hyperbolic sin. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Size &gt; const Size Sequence size. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Slide &gt; const Slide Sliding-window iteration. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Sort &gt; const Sort Sort list by key function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sqrt &gt; const Sqrt Square root. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Str &gt; const Str Serialize json as string. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Stride &gt; const Stride Striding iteration. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Sub &gt; const Sub Subtraction. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Subset &gt; const Subset Is subset. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sum &gt; const Sum Summation reduction. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Superset &gt; const Superset Is superset. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Tan &gt; const Tan Tangens function. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Tanh &gt; const Tanh Hyperbolic tan. lang::SignatureConst&lt;::zmbt::lang::Keyword::Thread &gt; const Thread Thread id. lang::SignatureUnary&lt;::zmbt::lang::Keyword::ToList &gt; const ToList Put argument into a list. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Trace &gt; const Trace Same as id, but also prints identifier parameter to debug log. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Transp &gt; const Transp Transpose multidimensional list, turning rows into columns. lang::SignatureConst&lt;::zmbt::lang::Keyword::True &gt; const True Logical true. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Bool &gt; const Truthy Alias for Bool. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Try &gt; const Try Evaluate function and return result or null if it returns error. lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Tuple &gt; const Tuple Pack expressions into an tuple without evaluation. lang::SignatureUncast const Uncast Reserialize decorator as decorated type. lang::SignatureUncast const Undecorate Alias for Uncast. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Unfold &gt; const Unfold Put results of recursive fn call on initial value into an array. lang::SignatureBinary&lt;::zmbt::lang::Keyword::Union &gt; const Union Set union. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Uniques &gt; const Uniques Filter unique elements. lang::SignatureUnary&lt;::zmbt::lang::Keyword::UpperCase &gt; const UpperCase Upper case string. lang::SignatureUnary&lt;::zmbt::lang::Keyword::Values &gt; const Values Extract values from object. lang::SignatureConst&lt;::zmbt::lang::Keyword::Noop &gt; const _ Alias for Noop."},{"location":"CxxRef/namespacezmbt_1_1expr/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-abs","title":"variable Abs","text":"<p>Absolute value. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Abs&gt; const zmbt::expr::Abs;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-acos","title":"variable Acos","text":"<p>Arccos function. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Acos&gt; const zmbt::expr::Acos;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-acosh","title":"variable Acosh","text":"<p>Hyperbolic arccos. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Acosh&gt; const zmbt::expr::Acosh;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-add","title":"variable Add","text":"<p>Addition. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Add&gt; const zmbt::expr::Add;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-all","title":"variable All","text":"<p>Match all predicates. <pre><code>lang::SignatureVariadic&lt;::zmbt::lang::Keyword::All&gt; const zmbt::expr::All;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-and","title":"variable And","text":"<p>Logical and. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::And&gt; const zmbt::expr::And;\n</code></pre></p> <p>Generic behavior: if first operand is truthy, returns second operand, otherwise first </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-any","title":"variable Any","text":"<p>Match any predicate. <pre><code>lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Any&gt; const zmbt::expr::Any;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-approx","title":"variable Approx","text":"<p>Alias for Near. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Near&gt; const zmbt::expr::Approx;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-arange","title":"variable Arange","text":"<p>Generate range of numbers. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Arange&gt; const zmbt::expr::Arange;\n</code></pre></p> <p>Return evenly spaced values within a given interval.</p> <p>Parameters: * start: start value * stop: stop value * step: step value</p> <p>Parameters dynamic evaluation: * stop: int -&gt; [0, stop, 1] * [start, stop] -&gt; [start, stop, 1] * [start, stop, step] -&gt; [start, stop, step] </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-argmax","title":"variable Argmax","text":"<p>Max value index by key function. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Argmax&gt; const zmbt::expr::Argmax;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-argmin","title":"variable Argmin","text":"<p>Min value index by key function. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Argmin&gt; const zmbt::expr::Argmin;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-asin","title":"variable Asin","text":"<p>Arcsin function. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Asin&gt; const zmbt::expr::Asin;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-asinh","title":"variable Asinh","text":"<p>Hyperbolic arcsin. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Asinh&gt; const zmbt::expr::Asinh;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-assert","title":"variable Assert","text":"<p>Return argument if it holds assertion or error otherwise. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Assert&gt; const zmbt::expr::Assert;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-at","title":"variable At","text":"<pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::At&gt; const zmbt::expr::At;\n</code></pre> <p>$</p> <p>Structure index is evaluated as array index or as key-value pair index for objects on order-preserving backends.</p> <p>Result is null if requested element not found. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-atan","title":"variable Atan","text":"<p>Arctan function. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Atan&gt; const zmbt::expr::Atan;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-atanh","title":"variable Atanh","text":"<p>Hyperbolic arctan. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Atanh&gt; const zmbt::expr::Atanh;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-avg","title":"variable Avg","text":"<p>Arythmetic average. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Avg&gt; const zmbt::expr::Avg;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-bind","title":"variable Bind","text":"<p>Bind design-time parameters to function. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Bind&gt; const zmbt::expr::Bind;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-bitand","title":"variable BitAnd","text":"<p>Bitwise and. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::BitAnd&gt; const zmbt::expr::BitAnd;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-bitnot","title":"variable BitNot","text":"<p>Bitwise not. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::BitNot&gt; const zmbt::expr::BitNot;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-bitor","title":"variable BitOr","text":"<p>Bitwise or. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::BitOr&gt; const zmbt::expr::BitOr;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-bitxor","title":"variable BitXor","text":"<p>Bitwise xor. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::BitXor&gt; const zmbt::expr::BitXor;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-bool","title":"variable Bool","text":"<p>Predicate on boolean transform (aka truthy) <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Bool&gt; const zmbt::expr::Bool;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-c","title":"variable C","text":"<p>Alias for Q. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Q&gt; const zmbt::expr::C;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-capitalize","title":"variable Capitalize","text":"<p>Capitalize string. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Capitalize&gt; const zmbt::expr::Capitalize;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-card","title":"variable Card","text":"<p>Set cardinality (uniques count) <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Card&gt; const zmbt::expr::Card;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-cartesian","title":"variable Cartesian","text":"<p>Cartesian product. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Cartesian&gt; const zmbt::expr::Cartesian;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-cast","title":"variable Cast","text":"<p>Reserialize decorated type as decorator. <pre><code>lang::SignatureCast const zmbt::expr::Cast;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-cat","title":"variable Cat","text":"<p>Concatenate sequences. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Cat&gt; const zmbt::expr::Cat;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-ceil","title":"variable Ceil","text":"<p>Ceil. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Ceil&gt; const zmbt::expr::Ceil;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-chunks","title":"variable Chunks","text":"<p>Split into chunks of specified max width. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Chunks&gt; const zmbt::expr::Chunks;\n</code></pre></p> <p>Similar to Stride, but includes the last subsequence smaller then step width. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-concat","title":"variable Concat","text":"<p>Alias for Cat. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Cat&gt; const zmbt::expr::Concat;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-const","title":"variable Const","text":"<p>Alias for Q. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Q&gt; const zmbt::expr::Const;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-contains","title":"variable Contains","text":"<p>Alias for Ni. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ni&gt; const zmbt::expr::Contains;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-cos","title":"variable Cos","text":"<p>Cosinus function. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Cos&gt; const zmbt::expr::Cos;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-cosh","title":"variable Cosh","text":"<p>Hyperbolic cos. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Cosh&gt; const zmbt::expr::Cosh;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-count","title":"variable Count","text":"<p>Count matches by predicate param. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Count&gt; const zmbt::expr::Count;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-d","title":"variable D","text":"<p>Return x if not null, else return default value. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::D&gt; const zmbt::expr::D;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-dbg","title":"variable Dbg","text":"<p>Evaluate function and print evaluation log to stderr. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Dbg&gt; const zmbt::expr::Dbg;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-debug","title":"variable Debug","text":"<p>Alias for Dbg. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Dbg&gt; const zmbt::expr::Debug;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-decorate","title":"variable Decorate","text":"<p>Alias for Cast. <pre><code>lang::SignatureCast const zmbt::expr::Decorate;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-default","title":"variable Default","text":"<p>Alias for D. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::D&gt; const zmbt::expr::Default;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-del","title":"variable Del","text":"<p>Delete elements from structure by given query. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Del&gt; const zmbt::expr::Del;\n</code></pre></p> <p>Possible queries: * Structure index (negative resolves as reverse) * JSON Pointer * List of queries</p> <p>Structure index is evaluated as array index or as key-value pair index for objects on order-preserving backends. When deleting an object element, resulting items order may change. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-delete","title":"variable Delete","text":"<p>Alias for Del. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Del&gt; const zmbt::expr::Delete;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-diff","title":"variable Diff","text":"<p>Set difference. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Diff&gt; const zmbt::expr::Diff;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-div","title":"variable Div","text":"<p>Division. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Div&gt; const zmbt::expr::Div;\n</code></pre></p> <ul> <li>\\([ ] \\mapsto [x, y] \\mapsto x / y\\)</li> <li>\\([y] \\mapsto [x] \\mapsto x / y\\) </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-e","title":"variable E","text":"<p>Euler's number. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::E&gt; const zmbt::expr::E;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-each","title":"variable Each","text":"<p>Test predicate for each item in a sequence. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Each&gt; const zmbt::expr::Each;\n</code></pre></p> <p>Equivalent to <code>Count(p | Not) |  Eq(0)</code> </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-enumerate","title":"variable Enumerate","text":"<p>Enumerate sequence. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Enumerate&gt; const zmbt::expr::Enumerate;\n</code></pre></p> <p>Enumerate sequence with index. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-eps","title":"variable Eps","text":"<p>Machine epsilon. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::Eps&gt; const zmbt::expr::Eps;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-eq","title":"variable Eq","text":"<p>Is equal. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Eq&gt; const zmbt::expr::Eq;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-erf","title":"variable Erf","text":"<p>Error function. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Erf&gt; const zmbt::expr::Erf;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-erfc","title":"variable Erfc","text":"<p>Error function complement. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Erfc&gt; const zmbt::expr::Erfc;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-err","title":"variable Err","text":"<p>Error object. <pre><code>lang::SignatureErr const zmbt::expr::Err;\n</code></pre></p> <p>Error object handling the message and context info </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-error","title":"variable Error","text":"<p>Alias for Err. <pre><code>lang::SignatureErr const zmbt::expr::Error;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-eval","title":"variable Eval","text":"<p>Flip designtime and run-time parameters, evaluating input as expression. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Eval&gt; const zmbt::expr::Eval;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-exp","title":"variable Exp","text":"<p>Exponential (e^x) <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Exp&gt; const zmbt::expr::Exp;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-false","title":"variable False","text":"<p>Logical false. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::False&gt; const zmbt::expr::False;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-falsy","title":"variable Falsy","text":"<p>Alias for Not. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Not&gt; const zmbt::expr::Falsy;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-filter","title":"variable Filter","text":"<p>Filter sequence by predicate param. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Filter&gt; const zmbt::expr::Filter;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-find","title":"variable Find","text":"<p>Find the first element that satisfies given predicate. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Find&gt; const zmbt::expr::Find;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-findidx","title":"variable FindIdx","text":"<p>Find index of the first element that satisfies given predicate. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::FindIdx&gt; const zmbt::expr::FindIdx;\n</code></pre></p> <p>Similar to FindPtr, but will integer index or nullptr for non-indexable input. Objects are processed as list of key-value pairs. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-findptr","title":"variable FindPtr","text":"<p>Find json pointer of the first element that satisfies given predicate. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::FindPtr&gt; const zmbt::expr::FindPtr;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-first","title":"variable First","text":"<p>First item of sequence. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::First&gt; const zmbt::expr::First;\n</code></pre></p> <p>Equivalent to At(0) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-flatten","title":"variable Flatten","text":"<p>Flatten nested list. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Flatten&gt; const zmbt::expr::Flatten;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-flip","title":"variable Flip","text":"<p>Flip design-time and eval-time parameters. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Flip&gt; const zmbt::expr::Flip;\n</code></pre></p> <p>Useful for binding lhs operands to non-commutative operators. Unlike Haskell's flip, won't change the order or eval-time parameters - for that case use the Reverse keyword instead.</p> <p>Prefix operator form (tilde):</p> <p>Flip(Div(1)) \u2261 ~Div(1) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-floor","title":"variable Floor","text":"<p>Floor. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Floor&gt; const zmbt::expr::Floor;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-fmt","title":"variable Fmt","text":"<p>Format string with the given parameter list. <pre><code>lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Fmt&gt; const zmbt::expr::Fmt;\n</code></pre></p> <p>Constant expressions are supported for the token list, s.t. \"%s\" | Fmt(Pi) produces \"3.141592653589793E0\" </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-fn","title":"variable Fn","text":"<p>Inline named function. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Fn&gt; const zmbt::expr::Fn;\n</code></pre></p> <p>Expression <code>Fn(reference, expr)</code> creates a symbolic link to expr, at the same time evaluating given arguments (inlining the expr). The reference is avaliable in the evaluation context, including in the expr itself (essentially enabling an arbitrary recursion).</p> <p>Infix operator form (left shift):</p> <p>\"\\(f\" &lt;&lt; E \u2261 Fn(\"\\)f\", E) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-fold","title":"variable Fold","text":"<p>Reduce sequence with binary operator. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Fold&gt; const zmbt::expr::Fold;\n</code></pre></p> <p>To set a specific initial value, use composition with Push, e.g. <code>Push(0) | Fold(Add)</code></p> <p>For reverse operation, see Unfold </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-fork","title":"variable Fork","text":"<p>Pack results from enveloped functions into an array. <pre><code>lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Fork&gt; const zmbt::expr::Fork;\n</code></pre></p> <p>Allows to combine different properties in a single expression. Parameter </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-format","title":"variable Format","text":"<p>Alias for Fmt. <pre><code>lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Fmt&gt; const zmbt::expr::Format;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-gamma","title":"variable Gamma","text":"<p>Gamma function. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Gamma&gt; const zmbt::expr::Gamma;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-ge","title":"variable Ge","text":"<p>Greater or equal. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ge&gt; const zmbt::expr::Ge;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-gt","title":"variable Gt","text":"<p>Greater than. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Gt&gt; const zmbt::expr::Gt;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-id","title":"variable Id","text":"<p>Identity function. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Id&gt; const zmbt::expr::Id;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-in","title":"variable In","text":"<p>Element is in. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::In&gt; const zmbt::expr::In;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-inf","title":"variable Inf","text":"<p>Infinity. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::Inf&gt; const zmbt::expr::Inf;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-intersect","title":"variable Intersect","text":"<p>Set intersection. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Intersect&gt; const zmbt::expr::Intersect;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-iserr","title":"variable IsErr","text":"<p>Test the argument is err expression. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::IsErr&gt; const zmbt::expr::IsErr;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-iserror","title":"variable Iserror","text":"<p>Alias for IsErr. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::IsErr&gt; const zmbt::expr::Iserror;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-items","title":"variable Items","text":"<p>Extract key-value pairs from object. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Items&gt; const zmbt::expr::Items;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-keys","title":"variable Keys","text":"<p>Extract keys from object. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Keys&gt; const zmbt::expr::Keys;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-kwrd","title":"variable Kwrd","text":"<p>Introspect expression keyword. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Kwrd&gt; const zmbt::expr::Kwrd;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-last","title":"variable Last","text":"<p>Last item of sequence. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Last&gt; const zmbt::expr::Last;\n</code></pre></p> <p>Equivalent to At(-1) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-le","title":"variable Le","text":"<p>Lesser or equal. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Le&gt; const zmbt::expr::Le;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-link","title":"variable Link","text":"<p>Symbolic binding of the input value. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Link&gt; const zmbt::expr::Link;\n</code></pre></p> <p>The capture is referenced by an arbitrary string preceded by dollar sign, e.g. \"$x\".</p> <p>On the first access it stores the input value in isolated expression context, and returns it on each subsequent call. It can't be reset after the first access.</p> <p>The string after $ sign shall not be enclosed in [], {}, or (), as those formats are reserved for internal usage. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-log","title":"variable Log","text":"<p>Logarithm. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Log&gt; const zmbt::expr::Log;\n</code></pre></p> <p>Logarithm with base b: * \\([ ] \\mapsto [x, b] \\mapsto log\\_b(x)\\) * \\([b] \\mapsto [x] \\mapsto log\\_b(x)\\) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-lookup","title":"variable Lookup","text":"<p>Lookup table function. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Lookup&gt; const zmbt::expr::Lookup;\n</code></pre></p> <p>Parametrized at design time with fixed array or object, produces the value at corresponding At query given as eval-time argument. Equivalent to ~At(...) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-lowercase","title":"variable LowerCase","text":"<p>Lower case string. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::LowerCase&gt; const zmbt::expr::LowerCase;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-lshift","title":"variable Lshift","text":"<p>Bitwise left shift. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Lshift&gt; const zmbt::expr::Lshift;\n</code></pre></p> <ul> <li>\\([ ] \\mapsto [x, s] \\mapsto x \\texttt{ &lt;&lt; } s\\)</li> <li>\\([s] \\mapsto [x] \\mapsto x \\texttt{ &lt;&lt; } s\\) </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-lt","title":"variable Lt","text":"<p>Lesser than. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Lt&gt; const zmbt::expr::Lt;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-map","title":"variable Map","text":"<p>Apply param expr to every element of sequence. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Map&gt; const zmbt::expr::Map;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-max","title":"variable Max","text":"<p>Max value by key function. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Max&gt; const zmbt::expr::Max;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-min","title":"variable Min","text":"<p>Min value by key function. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Min&gt; const zmbt::expr::Min;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-mod","title":"variable Mod","text":"<p>Modulo. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Mod&gt; const zmbt::expr::Mod;\n</code></pre></p> <p>Modulo of x: * \\([ ] \\mapsto [x, m] \\mapsto x % m\\) * \\([m] \\mapsto [x] \\mapsto x % m\\) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-mul","title":"variable Mul","text":"<p>Multiplication. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Mul&gt; const zmbt::expr::Mul;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-nan","title":"variable NaN","text":"<p>Not a number. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::NaN&gt; const zmbt::expr::NaN;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-ne","title":"variable Ne","text":"<p>Not equal. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ne&gt; const zmbt::expr::Ne;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-near","title":"variable Near","text":"<p>Floating point approximately equal. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Near&gt; const zmbt::expr::Near;\n</code></pre></p> <p>Based on numpy.isclose: abs(x - ref) &lt;= (atol + rtol * abs(ref))</p> <p>Rhs parameters: ref: reference value rtol: relative tolerance, default = 1e-05 atol: absolute tolerance, default = 1e-08</p> <p>Rhs dynamic evaluation: * ref -&gt; [ref, default, default] * [ref] -&gt; [ref, default, default] * [ref, rtol] -&gt; [ref, rtol , default] * [ref, rtol, atol] -&gt; [ref, rtol , atol ] </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-neg","title":"variable Neg","text":"<p>Negate. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Neg&gt; const zmbt::expr::Neg;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-ni","title":"variable Ni","text":"<p>Contains element. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ni&gt; const zmbt::expr::Ni;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-nil","title":"variable Nil","text":"<p>Alias for Not. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Not&gt; const zmbt::expr::Nil;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-noop","title":"variable Noop","text":"<p>No operation. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::Noop&gt; const zmbt::expr::Noop;\n</code></pre></p> <p>Returns true without input validation. Used in place of matchers for uninteresting signals. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-not","title":"variable Not","text":"<p>Logical complement. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Not&gt; const zmbt::expr::Not;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-notin","title":"variable NotIn","text":"<p>Element is not in. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::NotIn&gt; const zmbt::expr::NotIn;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-notni","title":"variable NotNi","text":"<p>Not contains element. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::NotNi&gt; const zmbt::expr::NotNi;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-null","title":"variable Null","text":"<p>Null value. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::Null&gt; const zmbt::expr::Null;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-op","title":"variable Op","text":"<p>Bind type-specific operator handler to function. <pre><code>lang::SignatureOp const zmbt::expr::Op;\n</code></pre></p> <p>Expression Op(op, f) instructs f to use op operator on invocation instead of the default generic.</p> <p>Operator parameter singleton can be referenced with a string key or constructed in place using type&lt;T&gt; tag.</p> <p>This operator handler is propagated downstream to all terminal subexpression in <code>f</code>. The result of <code>f(x)</code> is not decorated as type&lt;T&gt;. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-or","title":"variable Or","text":"<p>Logical or. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Or&gt; const zmbt::expr::Or;\n</code></pre></p> <p>Generic behavior: if first operand is truthy, returns first operand, second otherwise </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-overload","title":"variable Overload","text":"<p>Alias for Op. <pre><code>lang::SignatureOp const zmbt::expr::Overload;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-psubset","title":"variable PSubset","text":"<p>Is proper subset. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::PSubset&gt; const zmbt::expr::PSubset;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-psuperset","title":"variable PSuperset","text":"<p>Is proper superset. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::PSuperset&gt; const zmbt::expr::PSuperset;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-parameters","title":"variable Parameters","text":"<p>Alias for Prms. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Prms&gt; const zmbt::expr::Parameters;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-parse","title":"variable Parse","text":"<p>Parse string as json. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Parse&gt; const zmbt::expr::Parse;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-pi","title":"variable Pi","text":"<p>Pi constant. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::Pi&gt; const zmbt::expr::Pi;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-pipe","title":"variable Pipe","text":"<p>Pipe functions in left-to-right composition. <pre><code>lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Pipe&gt; const zmbt::expr::Pipe;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-pow","title":"variable Pow","text":"<p>To power. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Pow&gt; const zmbt::expr::Pow;\n</code></pre></p> <p>X to power p * \\([ ] \\mapsto [x, p] \\mapsto x^p\\) * \\([p] \\mapsto [x] \\mapsto x^p\\) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-preproc","title":"variable PreProc","text":"<p>Preprocessing token. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::PreProc&gt; const zmbt::expr::PreProc;\n</code></pre></p> <p>String token that can be substituted with arbitrary expression on expression preprocessing. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-prms","title":"variable Prms","text":"<p>Introspect expression parameters. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Prms&gt; const zmbt::expr::Prms;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-prod","title":"variable Prod","text":"<p>Multiplication reduction. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Prod&gt; const zmbt::expr::Prod;\n</code></pre></p> <p>Equivalent to Reduce(Mul) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-push","title":"variable Push","text":"<p>Push element into a front of sequence. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Push&gt; const zmbt::expr::Push;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-q","title":"variable Q","text":"<p>Quote parameter, similar to lisp quotation. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Q&gt; const zmbt::expr::Q;\n</code></pre></p> <p>Quotation lifts any parameter to constant, s.t. produced expression will return the design-time parameter on evaluation, ignoring input. If evaluable expression is passed, it is returned unevaluated. Unlike plain literals which can be treated as predicate matchers in certain context, Q(x) is always a constant expression discarding input. ~Q (Flip(Q)) is equivalent to Id. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-quot","title":"variable Quot","text":"<p>Quotient. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Quot&gt; const zmbt::expr::Quot;\n</code></pre></p> <p>Quotient of x: * \\([ ] \\mapsto [x, d] \\mapsto x // d\\) * \\([d] \\mapsto [x] \\mapsto x // d\\) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-re","title":"variable Re","text":"<p>Regular expression match. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Re&gt; const zmbt::expr::Re;\n</code></pre></p> <p>If input is not a string, match it's serialized form. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-recur","title":"variable Recur","text":"<p>Apply recursion to parameter expr and initial value. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Recur&gt; const zmbt::expr::Recur;\n</code></pre></p> <p>Inference rules:</p> <ul> <li><code>n | Recur(x &amp; f)</code> \\(\\mapsto \u25ef\u207f f(x)\\), or</li> <li><code>Q(p) | Recur(x\u2080 &amp; f)</code> \\(\\mapsto x\\_k\\), where</li> <li>\\(x\\_{i+1} = f(x\\_i)\\)</li> <li>\\(p(x\\_{i}) = \\top \\quad \\forall i \\le k\\)</li> <li>\\(p(x\\_{i+1}) = \\bot\\) (exit condition) </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-reduce","title":"variable Reduce","text":"<p>Alias for Fold. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Fold&gt; const zmbt::expr::Reduce;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-regex","title":"variable Regex","text":"<p>Alias for Re. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Re&gt; const zmbt::expr::Regex;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-repeat","title":"variable Repeat","text":"<p>Repeat value in list. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Repeat&gt; const zmbt::expr::Repeat;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-reverse","title":"variable Reverse","text":"<p>Reverse sequence. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Reverse&gt; const zmbt::expr::Reverse;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-round","title":"variable Round","text":"<p>Round to nearest integer. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Round&gt; const zmbt::expr::Round;\n</code></pre></p> <p>Hint: To round to ndigits precision after the decimal point, use <code>Mul(ndigits) | Round | Div(ndigits)</code> combo. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-rshift","title":"variable Rshift","text":"<p>Bitwise right shift. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Rshift&gt; const zmbt::expr::Rshift;\n</code></pre></p> <ul> <li>\\([ ] \u21a6 [x, s] \u21a6 x \\texttt{ &gt;&gt; } s\\)</li> <li>\\([s] \u21a6 [x] \u21a6 x \\texttt{ &gt;&gt; } s\\) </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-saturate","title":"variable Saturate","text":"<p>Saturate matches in order. <pre><code>lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Saturate&gt; const zmbt::expr::Saturate;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-serialize","title":"variable Serialize","text":"<p>Alias for Str. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Str&gt; const zmbt::expr::Serialize;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-seteq","title":"variable SetEq","text":"<p>Equal as set. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::SetEq&gt; const zmbt::expr::SetEq;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-sign","title":"variable Sign","text":"<p>Sign. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sign&gt; const zmbt::expr::Sign;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-sin","title":"variable Sin","text":"<p>Sinus function. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sin&gt; const zmbt::expr::Sin;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-sinh","title":"variable Sinh","text":"<p>Hyperbolic sin. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sinh&gt; const zmbt::expr::Sinh;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-size","title":"variable Size","text":"<p>Sequence size. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Size&gt; const zmbt::expr::Size;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-slide","title":"variable Slide","text":"<p>Sliding-window iteration. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Slide&gt; const zmbt::expr::Slide;\n</code></pre></p> <p>Sliding window iteration by specified window width. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-sort","title":"variable Sort","text":"<p>Sort list by key function. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Sort&gt; const zmbt::expr::Sort;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-sqrt","title":"variable Sqrt","text":"<p>Square root. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sqrt&gt; const zmbt::expr::Sqrt;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-str","title":"variable Str","text":"<p>Serialize json as string. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Str&gt; const zmbt::expr::Str;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-stride","title":"variable Stride","text":"<p>Striding iteration. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Stride&gt; const zmbt::expr::Stride;\n</code></pre></p> <p>Striding iteration by specified step width. Reminder subsequence smaller then step width is discarded. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-sub","title":"variable Sub","text":"<p>Subtraction. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Sub&gt; const zmbt::expr::Sub;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-subset","title":"variable Subset","text":"<p>Is subset. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Subset&gt; const zmbt::expr::Subset;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-sum","title":"variable Sum","text":"<p>Summation reduction. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sum&gt; const zmbt::expr::Sum;\n</code></pre></p> <p>Equivalent to Reduce(Add) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-superset","title":"variable Superset","text":"<p>Is superset. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Superset&gt; const zmbt::expr::Superset;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-tan","title":"variable Tan","text":"<p>Tangens function. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Tan&gt; const zmbt::expr::Tan;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-tanh","title":"variable Tanh","text":"<p>Hyperbolic tan. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Tanh&gt; const zmbt::expr::Tanh;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-thread","title":"variable Thread","text":"<p>Thread id. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::Thread&gt; const zmbt::expr::Thread;\n</code></pre></p> <p>Not really a constant, but useful for branching the test input conditions. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-tolist","title":"variable ToList","text":"<p>Put argument into a list. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::ToList&gt; const zmbt::expr::ToList;\n</code></pre></p> <p>Equivalent to At([\"\"]) </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-trace","title":"variable Trace","text":"<p>Same as id, but also prints identifier parameter to debug log. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Trace&gt; const zmbt::expr::Trace;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-transp","title":"variable Transp","text":"<p>Transpose multidimensional list, turning rows into columns. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Transp&gt; const zmbt::expr::Transp;\n</code></pre></p> <p>May be used to zip sequences of equal length. </p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-true","title":"variable True","text":"<p>Logical true. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::True&gt; const zmbt::expr::True;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-truthy","title":"variable Truthy","text":"<p>Alias for Bool. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Bool&gt; const zmbt::expr::Truthy;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-try","title":"variable Try","text":"<p>Evaluate function and return result or null if it returns error. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Try&gt; const zmbt::expr::Try;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-tuple","title":"variable Tuple","text":"<p>Pack expressions into an tuple without evaluation. <pre><code>lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Tuple&gt; const zmbt::expr::Tuple;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-uncast","title":"variable Uncast","text":"<p>Reserialize decorator as decorated type. <pre><code>lang::SignatureUncast const zmbt::expr::Uncast;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-undecorate","title":"variable Undecorate","text":"<p>Alias for Uncast. <pre><code>lang::SignatureUncast const zmbt::expr::Undecorate;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-unfold","title":"variable Unfold","text":"<p>Put results of recursive fn call on initial value into an array. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Unfold&gt; const zmbt::expr::Unfold;\n</code></pre></p> <p>Inference rules:</p> <ul> <li><code>n | Unfold(x &amp; f)</code>\\(\\mapsto [x\\_0, x\\_1, ..., x\\_n]\\), or</li> <li><code>Q(p) | Unfold(x\u2080 &amp; f)</code> \\(\\mapsto [x\\_0, x\\_1, ..., x\\_k]\\), where</li> <li>\\(x\\_{i+1} = f(x\\_i)\\)</li> <li>\\(p(x\\_{i}) = \\top \\quad \\forall i \\le k\\)</li> <li>\\(p(x\\_{i+1}) = \\bot\\) (exit condition) </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-union","title":"variable Union","text":"<p>Set union. <pre><code>lang::SignatureBinary&lt;::zmbt::lang::Keyword::Union&gt; const zmbt::expr::Union;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-uniques","title":"variable Uniques","text":"<p>Filter unique elements. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Uniques&gt; const zmbt::expr::Uniques;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-uppercase","title":"variable UpperCase","text":"<p>Upper case string. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::UpperCase&gt; const zmbt::expr::UpperCase;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-values","title":"variable Values","text":"<p>Extract values from object. <pre><code>lang::SignatureUnary&lt;::zmbt::lang::Keyword::Values&gt; const zmbt::expr::Values;\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1expr/#variable-_","title":"variable _","text":"<p>Alias for Noop. <pre><code>lang::SignatureConst&lt;::zmbt::lang::Keyword::Noop&gt; const zmbt::expr::_;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1flags/","title":"Namespace zmbt::flags","text":"<p>Namespace List &gt; zmbt &gt; flags</p>"},{"location":"CxxRef/namespacezmbt_1_1flags/#classes","title":"Classes","text":"Type Name class ConversionTime class InjectionTime class RecordingTime class TestIsRunning <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/global_flags.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1flags_1_1ConversionTime/","title":"Class zmbt::ConversionTime","text":"<p>ClassList &gt; zmbt &gt; flags &gt; ConversionTime</p>"},{"location":"CxxRef/classzmbt_1_1flags_1_1ConversionTime/#public-static-functions","title":"Public Static Functions","text":"Type Name void add (std::chrono::nanoseconds const duration) noexcept void reset () noexcept std::uint64_t value () noexcept"},{"location":"CxxRef/classzmbt_1_1flags_1_1ConversionTime/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1flags_1_1ConversionTime/#function-add","title":"function add","text":"<pre><code>static inline void zmbt::flags::ConversionTime::add (\n    std::chrono::nanoseconds const duration\n) noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1flags_1_1ConversionTime/#function-reset","title":"function reset","text":"<pre><code>static inline void zmbt::flags::ConversionTime::reset () noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1flags_1_1ConversionTime/#function-value","title":"function value","text":"<pre><code>static inline std::uint64_t zmbt::flags::ConversionTime::value () noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/global_stats.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1flags_1_1InjectionTime/","title":"Class zmbt::InjectionTime","text":"<p>ClassList &gt; zmbt &gt; flags &gt; InjectionTime</p>"},{"location":"CxxRef/classzmbt_1_1flags_1_1InjectionTime/#public-static-functions","title":"Public Static Functions","text":"Type Name void add (std::chrono::nanoseconds const duration) noexcept void reset () noexcept std::uint64_t value () noexcept"},{"location":"CxxRef/classzmbt_1_1flags_1_1InjectionTime/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1flags_1_1InjectionTime/#function-add","title":"function add","text":"<pre><code>static inline void zmbt::flags::InjectionTime::add (\n    std::chrono::nanoseconds const duration\n) noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1flags_1_1InjectionTime/#function-reset","title":"function reset","text":"<pre><code>static inline void zmbt::flags::InjectionTime::reset () noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1flags_1_1InjectionTime/#function-value","title":"function value","text":"<pre><code>static inline std::uint64_t zmbt::flags::InjectionTime::value () noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/global_stats.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1flags_1_1RecordingTime/","title":"Class zmbt::RecordingTime","text":"<p>ClassList &gt; zmbt &gt; flags &gt; RecordingTime</p>"},{"location":"CxxRef/classzmbt_1_1flags_1_1RecordingTime/#public-static-functions","title":"Public Static Functions","text":"Type Name void add (std::chrono::nanoseconds const duration) noexcept void reset () noexcept std::uint64_t value () noexcept"},{"location":"CxxRef/classzmbt_1_1flags_1_1RecordingTime/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1flags_1_1RecordingTime/#function-add","title":"function add","text":"<pre><code>static inline void zmbt::flags::RecordingTime::add (\n    std::chrono::nanoseconds const duration\n) noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1flags_1_1RecordingTime/#function-reset","title":"function reset","text":"<pre><code>static inline void zmbt::flags::RecordingTime::reset () noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1flags_1_1RecordingTime/#function-value","title":"function value","text":"<pre><code>static inline std::uint64_t zmbt::flags::RecordingTime::value () noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/global_stats.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1flags_1_1TestIsRunning/","title":"Class zmbt::TestIsRunning","text":"<p>ClassList &gt; zmbt &gt; flags &gt; TestIsRunning</p>"},{"location":"CxxRef/classzmbt_1_1flags_1_1TestIsRunning/#public-static-functions","title":"Public Static Functions","text":"Type Name void clear () noexcept bool exchange (bool const sts) noexcept void set () noexcept bool status () noexcept"},{"location":"CxxRef/classzmbt_1_1flags_1_1TestIsRunning/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1flags_1_1TestIsRunning/#function-clear","title":"function clear","text":"<pre><code>static inline void zmbt::flags::TestIsRunning::clear () noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1flags_1_1TestIsRunning/#function-exchange","title":"function exchange","text":"<pre><code>static inline bool zmbt::flags::TestIsRunning::exchange (\n    bool const sts\n) noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1flags_1_1TestIsRunning/#function-set","title":"function set","text":"<pre><code>static inline void zmbt::flags::TestIsRunning::set () noexcept\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1flags_1_1TestIsRunning/#function-status","title":"function status","text":"<pre><code>static inline bool zmbt::flags::TestIsRunning::status () noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/global_flags.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__bit__and/","title":"Struct zmbt::has_bit_and","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_bit_and</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__bit__or/","title":"Struct zmbt::has_bit_or","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_bit_or</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__bit__xor/","title":"Struct zmbt::has_bit_xor","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_bit_xor</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__complement/","title":"Struct zmbt::has_complement","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_complement</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__divides/","title":"Struct zmbt::has_divides","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_divides</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__equal__to/","title":"Struct zmbt::has_equal_to","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_equal_to</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__greater/","title":"Struct zmbt::has_greater","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_greater</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__greater__equal/","title":"Struct zmbt::has_greater_equal","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_greater_equal</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__left__shift/","title":"Struct zmbt::has_left_shift","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_left_shift</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__less/","title":"Struct zmbt::has_less","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_less</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__less__equal/","title":"Struct zmbt::has_less_equal","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_less_equal</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__logical__and/","title":"Struct zmbt::has_logical_and","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_logical_and</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__logical__not/","title":"Struct zmbt::has_logical_not","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_logical_not</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__logical__or/","title":"Struct zmbt::has_logical_or","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_logical_or</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__minus/","title":"Struct zmbt::has_minus","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_minus</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__modulus/","title":"Struct zmbt::has_modulus","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_modulus</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__multiplies/","title":"Struct zmbt::has_multiplies","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_multiplies</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__negate/","title":"Struct zmbt::has_negate","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_negate</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__not__equal__to/","title":"Struct zmbt::has_not_equal_to","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_not_equal_to</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__plus/","title":"Struct zmbt::has_plus","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_plus</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__right__shift/","title":"Struct zmbt::has_right_shift","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_right_shift</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1has__serialization/","title":"Struct zmbt::has_serialization","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; has_serialization</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/serialization.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1ifc__args/","title":"Struct zmbt::ifc_args","text":"<p>template &lt;class Interface&gt;</p> <p>ClassList &gt; zmbt &gt; ifc_args</p>"},{"location":"CxxRef/structzmbt_1_1ifc__args/#public-types","title":"Public Types","text":"Type Name typedef typename mp_eval_or&lt; mp_identity&lt; void &gt;, detail::ifc_args_impl, ifc_handle_t&lt; Interface &gt; &gt;::type type"},{"location":"CxxRef/structzmbt_1_1ifc__args/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1ifc__args/#typedef-type","title":"typedef type","text":"<pre><code>using zmbt::ifc_args&lt; Interface &gt;::type =  typename mp_eval_or&lt;mp_identity&lt;void&gt;, detail::ifc_args_impl, ifc_handle_t&lt;Interface&gt; &gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/interface_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1ifc__handle/","title":"Struct zmbt::ifc_handle","text":"<p>template &lt;class Interface&gt;</p> <p>ClassList &gt; zmbt &gt; ifc_handle</p>"},{"location":"CxxRef/structzmbt_1_1ifc__handle/#public-types","title":"Public Types","text":"Type Name typedef mp_eval_or&lt; nullptr_t, detail::ifc_handle_valid_t, Interface &gt; type"},{"location":"CxxRef/structzmbt_1_1ifc__handle/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1ifc__handle/#typedef-type","title":"typedef type","text":"<pre><code>using zmbt::ifc_handle&lt; Interface &gt;::type =  mp_eval_or&lt;nullptr_t, detail::ifc_handle_valid_t, Interface&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/interface_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1ifc__host/","title":"Struct zmbt::ifc_host","text":"<p>template &lt;class Interface, class&gt;</p> <p>ClassList &gt; zmbt &gt; ifc_host</p>"},{"location":"CxxRef/structzmbt_1_1ifc__host/#public-types","title":"Public Types","text":"Type Name typedef typename mp_if&lt; ifc_is_member_handle&lt; Interface &gt;, ct::qualified_class_of&lt; Interface &gt;, mp_identity&lt; nullptr_t &gt; &gt;::type type"},{"location":"CxxRef/structzmbt_1_1ifc__host/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1ifc__host/#typedef-type","title":"typedef type","text":"<pre><code>using zmbt::ifc_host&lt; Interface, class &gt;::type =  typename mp_if&lt;ifc_is_member_handle&lt;Interface&gt;, ct::qualified_class_of&lt;Interface&gt;, mp_identity&lt;nullptr_t&gt; &gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/interface_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1ifc__pointer/","title":"Struct zmbt::ifc_pointer","text":"<p>template &lt;class Interface&gt;</p> <p>ClassList &gt; zmbt &gt; ifc_pointer</p>"},{"location":"CxxRef/structzmbt_1_1ifc__pointer/#public-types","title":"Public Types","text":"Type Name typedef mp_eval_or&lt; nullptr_t, detail::ifc_pointer_valid_t, Interface &gt; type"},{"location":"CxxRef/structzmbt_1_1ifc__pointer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1ifc__pointer/#typedef-type","title":"typedef type","text":"<pre><code>using zmbt::ifc_pointer&lt; Interface &gt;::type =  mp_eval_or&lt;nullptr_t, detail::ifc_pointer_valid_t, Interface&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/interface_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1ifc__return/","title":"Struct zmbt::ifc_return","text":"<p>template &lt;class Interface&gt;</p> <p>ClassList &gt; zmbt &gt; ifc_return</p> <p>Inherits the following classes: boost::callable_traits::return_type&lt; Interface &gt;</p>"},{"location":"CxxRef/structzmbt_1_1ifc__return/#public-types","title":"Public Types","text":"Type Name typedef typename mp_eval_or&lt; mp_identity&lt; void &gt;, ct::return_type, ifc_handle_t&lt; Interface &gt; &gt;::type type"},{"location":"CxxRef/structzmbt_1_1ifc__return/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1ifc__return/#typedef-type","title":"typedef type","text":"<pre><code>using zmbt::ifc_return&lt; Interface &gt;::type =  typename mp_eval_or&lt;mp_identity&lt;void&gt;, ct::return_type, ifc_handle_t&lt;Interface&gt; &gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/interface_traits.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1interface__id/","title":"Class zmbt::interface_id","text":"<p>ClassList &gt; zmbt &gt; interface_id</p> <p>Pointer-based interface id with type annotation. </p> <ul> <li><code>#include &lt;interface_id.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::entity_id</p>"},{"location":"CxxRef/classzmbt_1_1interface__id/#public-functions","title":"Public Functions","text":"Type Name entity_id () = default entity_id (boost::json::string_view key, std::type_index type_index)  entity_id (boost::json::string_view key, std::size_t type_index_hash)  entity_id (boost::json::array const &amp; str)  entity_id (boost::json::value const &amp; val)  entity_id (entity_id const &amp;) = default entity_id (entity_id &amp;&amp;) = default interface_id (Interface const &amp; ifc)  bool operator!= (entity_id const &amp; other) const bool operator== (entity_id const &amp; other) const"},{"location":"CxxRef/classzmbt_1_1interface__id/#public-functions-inherited-from-zmbtentity_id","title":"Public Functions inherited from zmbt::entity_id","text":"<p>See zmbt::entity_id</p> Type Name boost::json::string_view annotation () const entity_id () = default entity_id (boost::json::string_view key, std::type_index type_index)  entity_id (boost::json::string_view key, std::size_t type_index_hash)  entity_id (boost::json::array const &amp; str)  entity_id (boost::json::value const &amp; val)  entity_id (entity_id const &amp;) = default entity_id (entity_id &amp;&amp;) = default boost::json::string_view key () const bool operator!= (entity_id const &amp; other) const entity_id &amp; operator= (entity_id const &amp;) = default entity_id &amp; operator= (entity_id &amp;&amp;) = default entity_id &amp; operator= (boost::json::value const &amp; v)  entity_id &amp; operator= (boost::json::value &amp;&amp; v)  bool operator== (entity_id const &amp; other) const boost::json::string_view str () const virtual ~entity_id () = default"},{"location":"CxxRef/classzmbt_1_1interface__id/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1interface__id/#function-entity_id-17","title":"function entity_id [1/7]","text":"<pre><code>zmbt::interface_id::entity_id () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1interface__id/#function-entity_id-27","title":"function entity_id [2/7]","text":"<pre><code>zmbt::interface_id::entity_id (\n    boost::json::string_view key,\n    std::type_index type_index\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1interface__id/#function-entity_id-37","title":"function entity_id [3/7]","text":"<pre><code>zmbt::interface_id::entity_id (\n    boost::json::string_view key,\n    std::size_t type_index_hash\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1interface__id/#function-entity_id-47","title":"function entity_id [4/7]","text":"<pre><code>explicit zmbt::interface_id::entity_id (\n    boost::json::array const &amp; str\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1interface__id/#function-entity_id-57","title":"function entity_id [5/7]","text":"<pre><code>explicit zmbt::interface_id::entity_id (\n    boost::json::value const &amp; val\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1interface__id/#function-entity_id-67","title":"function entity_id [6/7]","text":"<pre><code>zmbt::interface_id::entity_id (\n    entity_id const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1interface__id/#function-entity_id-77","title":"function entity_id [7/7]","text":"<pre><code>zmbt::interface_id::entity_id (\n    entity_id &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1interface__id/#function-interface_id","title":"function interface_id","text":"<pre><code>template&lt;class Interface, class&gt;\ninline zmbt::interface_id::interface_id (\n    Interface const &amp; ifc\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1interface__id/#function-operator","title":"function operator!=","text":"<pre><code>inline bool zmbt::interface_id::operator!= (\n    entity_id const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1interface__id/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool zmbt::interface_id::operator== (\n    entity_id const &amp; other\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/interface_id.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1is__const__iterable/","title":"Struct zmbt::is_const_iterable","text":"<p>template &lt;class, class&gt;</p> <p>ClassList &gt; zmbt &gt; is_const_iterable</p> <p>Variable template that checks if a type has begin() and end() member functions. </p> <ul> <li><code>#include &lt;generic_traits.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/generic_traits.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1lang/","title":"Namespace zmbt::lang","text":"<p>Namespace List &gt; zmbt &gt; lang</p> <p>Expression Language implementation.</p>"},{"location":"CxxRef/namespacezmbt_1_1lang/#namespaces","title":"Namespaces","text":"Type Name namespace attr"},{"location":"CxxRef/namespacezmbt_1_1lang/#classes","title":"Classes","text":"Type Name struct Encoding class EncodingView struct EvalContext Expression evaluation context. struct EvalImpl &lt;K&gt; class EvalImplBase &lt;K, class Validator&gt; struct EvalLog Expression evaluation log. class EvalParams struct EvalValidator &lt;K&gt; class Expression struct ExpressionGrammar &lt;typename OutputIterator&gt; class ExpressionView struct FixedEvalParams &lt;K&gt; struct KeywordGrammar Boost.Sirit.Qi Grammar for zmbt::lang::Keyword parsing. struct KeywordInfo &lt;k&gt; struct KeywordSymbol Boost.Sirit.Qi Symbol for zmbt::lang::Keyword parsing. class LazyParam class Operator Signal transformation and comparison handler. Enables type erasure. struct SignatureBase &lt;K&gt; struct SignatureBinary &lt;K&gt;Binary expression. struct SignatureBinary&lt; Keyword::PreProc &gt; &lt;&gt; struct SignatureCast struct SignatureConst &lt;K&gt;Const expression. struct SignatureErr struct SignatureOp struct SignatureUnary &lt;K&gt;Unary expression. struct SignatureUncast struct SignatureVariadic &lt;K&gt;Variadic expression."},{"location":"CxxRef/namespacezmbt_1_1lang/#public-types","title":"Public Types","text":"Type Name enum std::uint64_t Keyword ZMBT Expression keyword."},{"location":"CxxRef/namespacezmbt_1_1lang/#public-functions","title":"Public Functions","text":"Type Name constexpr std::uint32_t attributes (Keyword const &amp; k)  Expression dispatch_eval (ExpressionView const &amp; self, ExpressionView const &amp; x, EvalContext context)  boost::json::string_view keyword_to_str (Keyword const &amp;)  void tag_invoke (boost::json::value_from_tag const &amp;, boost::json::value &amp;, Keyword const &amp; t)  Keyword tag_invoke (boost::json::value_to_tag&lt; Keyword &gt; const &amp;, boost::json::value const &amp;)"},{"location":"CxxRef/namespacezmbt_1_1lang/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/namespacezmbt_1_1lang/#enum-keyword","title":"enum Keyword","text":"<p>ZMBT Expression keyword. <pre><code>enum zmbt::lang::Keyword {\n    Undefined,\n    Literal,\n    Void,\n    LazyToken,\n    Noop,\n    Null,\n    True,\n    False,\n    Pi,\n    E,\n    Inf,\n    Eps,\n    NaN,\n    Thread,\n    Sin,\n    Cos,\n    Tan,\n    Asin,\n    Acos,\n    Atan,\n    Sinh,\n    Cosh,\n    Tanh,\n    Asinh,\n    Acosh,\n    Atanh,\n    Exp,\n    Erf,\n    Erfc,\n    Gamma,\n    Abs,\n    Ceil,\n    Floor,\n    Round,\n    Sqrt,\n    Sign,\n    Neg,\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Pow,\n    Log,\n    Mod,\n    Quot,\n    BitNot,\n    BitAnd,\n    BitOr,\n    BitXor,\n    Lshift,\n    Rshift,\n    Eq,\n    Ne,\n    Lt,\n    Le,\n    Gt,\n    Ge,\n    Near,\n    Union,\n    Intersect,\n    Diff,\n    SetEq,\n    Subset,\n    Superset,\n    PSubset,\n    PSuperset,\n    In,\n    NotIn,\n    Ni,\n    NotNi,\n    Bool,\n    Not,\n    And,\n    Or,\n    Id,\n    Transp,\n    Cartesian,\n    Reverse,\n    Uniques,\n    Items,\n    Keys,\n    Values,\n    Enumerate,\n    Flatten,\n    ToList,\n    First,\n    Last,\n    Arange,\n    Parse,\n    Str,\n    Re,\n    Fmt,\n    Capitalize,\n    LowerCase,\n    UpperCase,\n    Card,\n    Size,\n    Sum,\n    Prod,\n    Avg,\n    Slide,\n    Stride,\n    Chunks,\n    Repeat,\n    Cat,\n    Push,\n    At,\n    Del,\n    Lookup,\n    Cast,\n    Uncast,\n    Fold,\n    Map,\n    Filter,\n    Count,\n    Each,\n    Sort,\n    Find,\n    FindPtr,\n    FindIdx,\n    Min,\n    Max,\n    Argmin,\n    Argmax,\n    Recur,\n    Unfold,\n    Op,\n    Bind,\n    Fn,\n    Link,\n    Any,\n    All,\n    Saturate,\n    Pipe,\n    Tuple,\n    Fork,\n    Flip,\n    Dbg,\n    Eval,\n    Try,\n    Kwrd,\n    Prms,\n    Q,\n    D,\n    Err,\n    IsErr,\n    Assert,\n    Trace,\n    PreProc,\n    _count\n};\n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1lang/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/namespacezmbt_1_1lang/#function-attributes","title":"function attributes","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attributes (\n    Keyword const &amp; k\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang/#function-dispatch_eval","title":"function dispatch_eval","text":"<pre><code>template&lt;Keyword K&gt;\nExpression zmbt::lang::dispatch_eval (\n    ExpressionView const &amp; self,\n    ExpressionView const &amp; x,\n    EvalContext context\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang/#function-keyword_to_str","title":"function keyword_to_str","text":"<pre><code>boost::json::string_view zmbt::lang::keyword_to_str (\n    Keyword const &amp;\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang/#function-tag_invoke","title":"function tag_invoke","text":"<pre><code>void zmbt::lang::tag_invoke (\n    boost::json::value_from_tag const &amp;,\n    boost::json::value &amp;,\n    Keyword const &amp; t\n) \n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang/#function-tag_invoke_1","title":"function tag_invoke","text":"<pre><code>Keyword zmbt::lang::tag_invoke (\n    boost::json::value_to_tag&lt; Keyword &gt; const &amp;,\n    boost::json::value const &amp;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/","title":"Struct zmbt::lang::Encoding","text":"<p>ClassList &gt; zmbt &gt; lang &gt; Encoding</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#public-types","title":"Public Types","text":"Type Name typedef Keyword K typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; V &gt; data std::vector&lt; std::size_t &gt; depth std::vector&lt; K &gt; keywords"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#public-functions","title":"Public Functions","text":"Type Name Encoding () = default Encoding (boost::json::value const &amp; value)  Encoding (boost::json::value &amp;&amp; value)  void append_to_root (Encoding const &amp; tail)  void append_to_root (Encoding &amp;&amp; tail)  bool operator!= (Encoding const &amp; o) const bool operator== (Encoding const &amp; o) const bool preprocess () Single-pass preprocessing, return true if no multipass tokens left. void push_back (K const &amp; k, std::size_t const d, V const &amp; v)  void push_back (K const &amp; k, std::size_t const d, V &amp;&amp; v)  std::size_t size () const"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#public-static-functions","title":"Public Static Functions","text":"Type Name bool is_link_token (boost::json::value const &amp; value)  bool is_preproc_token (boost::json::value const &amp; value)"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#typedef-k","title":"typedef K","text":"<pre><code>using zmbt::lang::Encoding::K =  Keyword;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#typedef-v","title":"typedef V","text":"<pre><code>using zmbt::lang::Encoding::V =  boost::json::value;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#variable-data","title":"variable data","text":"<pre><code>std::vector&lt;V&gt; zmbt::lang::Encoding::data;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#variable-depth","title":"variable depth","text":"<pre><code>std::vector&lt;std::size_t&gt; zmbt::lang::Encoding::depth;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#variable-keywords","title":"variable keywords","text":"<pre><code>std::vector&lt;K&gt; zmbt::lang::Encoding::keywords;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-encoding-13","title":"function Encoding [1/3]","text":"<pre><code>zmbt::lang::Encoding::Encoding () = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-encoding-23","title":"function Encoding [2/3]","text":"<pre><code>explicit zmbt::lang::Encoding::Encoding (\n    boost::json::value const &amp; value\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-encoding-33","title":"function Encoding [3/3]","text":"<pre><code>explicit zmbt::lang::Encoding::Encoding (\n    boost::json::value &amp;&amp; value\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-append_to_root-12","title":"function append_to_root [1/2]","text":"<pre><code>void zmbt::lang::Encoding::append_to_root (\n    Encoding const &amp; tail\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-append_to_root-22","title":"function append_to_root [2/2]","text":"<pre><code>void zmbt::lang::Encoding::append_to_root (\n    Encoding &amp;&amp; tail\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-operator","title":"function operator!=","text":"<pre><code>bool zmbt::lang::Encoding::operator!= (\n    Encoding const &amp; o\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-operator_1","title":"function operator==","text":"<pre><code>bool zmbt::lang::Encoding::operator== (\n    Encoding const &amp; o\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-preprocess","title":"function preprocess","text":"<p>Single-pass preprocessing, return true if no multipass tokens left. <pre><code>bool zmbt::lang::Encoding::preprocess () \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-push_back-12","title":"function push_back [1/2]","text":"<pre><code>void zmbt::lang::Encoding::push_back (\n    K const &amp; k,\n    std::size_t const d,\n    V const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-push_back-22","title":"function push_back [2/2]","text":"<pre><code>void zmbt::lang::Encoding::push_back (\n    K const &amp; k,\n    std::size_t const d,\n    V &amp;&amp; v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-size","title":"function size","text":"<pre><code>std::size_t zmbt::lang::Encoding::size () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-is_link_token","title":"function is_link_token","text":"<pre><code>static bool zmbt::lang::Encoding::is_link_token (\n    boost::json::value const &amp; value\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Encoding/#function-is_preproc_token","title":"function is_preproc_token","text":"<pre><code>static bool zmbt::lang::Encoding::is_preproc_token (\n    boost::json::value const &amp; value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/encoding.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/","title":"Class zmbt::lang::EncodingView","text":"<p>ClassList &gt; zmbt &gt; lang &gt; EncodingView</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#classes","title":"Classes","text":"Type Name struct ExprRow class Iterator"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#public-types","title":"Public Types","text":"Type Name typedef Keyword K typedef boost::json::value V typedef Iterator const_iterator typedef std::reverse_iterator&lt; const_iterator &gt; const_reverse_iterator typedef Iterator iterator typedef std::reverse_iterator&lt; iterator &gt; reverse_iterator"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#public-functions","title":"Public Functions","text":"Type Name EncodingView (Encoding &amp;&amp; root) = delete EncodingView () = default EncodingView (K const * k, std::size_t const * d, V const * v, std::size_t sz, std::size_t index_offset)  EncodingView (Encoding const &amp; root)  std::size_t arity () constNumber of children. ExprRow at (std::size_t i) const ExprRow back () const const_iterator begin () const const_iterator cbegin () const const_iterator cend () const EncodingView child (int ord) noexcept const std::size_t child_idx (int ord) noexcept const std::list&lt; EncodingView &gt; children () constChildren subviews. const_reverse_iterator crbegin () const const_reverse_iterator crend () const std::size_t depth_offset () const bool empty () const const_iterator end () const Encoding freeze () constHardcopy referenced encoding subview. ExprRow front () const Keyword head () noexcept constRoot node keyword. V const * if_data () const std::size_t const * if_depth () const K const * if_keywords () const std::size_t index_offset () const bool is_boolean () const bool is_const () const bool operator!= (EncodingView const &amp; o) const bool operator== (EncodingView const &amp; o) const ExprRow operator[] (std::size_t i) const const_reverse_iterator rbegin () const const_reverse_iterator rend () const std::size_t size () const EncodingView slice (std::size_t start, std::size_t count) noexcept constCreate a subview [start, start+count) EncodingView subtree (std::size_t const node) noexcept constGet a subview at specified node. boost::json::value to_json () const EncodingView traverse_subtrees (std::size_t const node, std::size_t &amp; next) noexcept const"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#typedef-k","title":"typedef K","text":"<pre><code>using zmbt::lang::EncodingView::K =  Keyword;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#typedef-v","title":"typedef V","text":"<pre><code>using zmbt::lang::EncodingView::V =  boost::json::value;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#typedef-const_iterator","title":"typedef const_iterator","text":"<pre><code>using zmbt::lang::EncodingView::const_iterator =  Iterator;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#typedef-const_reverse_iterator","title":"typedef const_reverse_iterator","text":"<pre><code>using zmbt::lang::EncodingView::const_reverse_iterator =  std::reverse_iterator&lt;const_iterator&gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#typedef-iterator","title":"typedef iterator","text":"<pre><code>using zmbt::lang::EncodingView::iterator =  Iterator;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#typedef-reverse_iterator","title":"typedef reverse_iterator","text":"<pre><code>using zmbt::lang::EncodingView::reverse_iterator =  std::reverse_iterator&lt; iterator&gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-encodingview-14","title":"function EncodingView [1/4]","text":"<pre><code>zmbt::lang::EncodingView::EncodingView (\n    Encoding &amp;&amp; root\n) = delete\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-encodingview-24","title":"function EncodingView [2/4]","text":"<pre><code>zmbt::lang::EncodingView::EncodingView () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-encodingview-34","title":"function EncodingView [3/4]","text":"<pre><code>zmbt::lang::EncodingView::EncodingView (\n    K const * k,\n    std::size_t const * d,\n    V const * v,\n    std::size_t sz,\n    std::size_t index_offset\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-encodingview-44","title":"function EncodingView [4/4]","text":"<pre><code>zmbt::lang::EncodingView::EncodingView (\n    Encoding const &amp; root\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-arity","title":"function arity","text":"<p>Number of children. <pre><code>std::size_t zmbt::lang::EncodingView::arity () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-at","title":"function at","text":"<pre><code>ExprRow zmbt::lang::EncodingView::at (\n    std::size_t i\n) const\n</code></pre> <p>Get node at index i Throws std::range_error if out of bounds </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-back","title":"function back","text":"<pre><code>ExprRow zmbt::lang::EncodingView::back () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-begin","title":"function begin","text":"<pre><code>inline const_iterator zmbt::lang::EncodingView::begin () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-cbegin","title":"function cbegin","text":"<pre><code>inline const_iterator zmbt::lang::EncodingView::cbegin () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-cend","title":"function cend","text":"<pre><code>inline const_iterator zmbt::lang::EncodingView::cend () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-child","title":"function child","text":"<pre><code>EncodingView zmbt::lang::EncodingView::child (\n    int ord\n) noexcept const\n</code></pre> <p>Get subview on child # ord If not found, returns empty view </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-child_idx","title":"function child_idx","text":"<pre><code>std::size_t zmbt::lang::EncodingView::child_idx (\n    int ord\n) noexcept const\n</code></pre> <p>Get child # ord node index. Negative ord resolves as reverse. If not found, returns size() </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-children","title":"function children","text":"<p>Children subviews. <pre><code>std::list&lt; EncodingView &gt; zmbt::lang::EncodingView::children () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-crbegin","title":"function crbegin","text":"<pre><code>inline const_reverse_iterator zmbt::lang::EncodingView::crbegin () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-crend","title":"function crend","text":"<pre><code>inline const_reverse_iterator zmbt::lang::EncodingView::crend () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-depth_offset","title":"function depth_offset","text":"<pre><code>std::size_t zmbt::lang::EncodingView::depth_offset () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-empty","title":"function empty","text":"<pre><code>bool zmbt::lang::EncodingView::empty () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-end","title":"function end","text":"<pre><code>inline const_iterator zmbt::lang::EncodingView::end () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-freeze","title":"function freeze","text":"<p>Hardcopy referenced encoding subview. <pre><code>Encoding zmbt::lang::EncodingView::freeze () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-front","title":"function front","text":"<pre><code>ExprRow zmbt::lang::EncodingView::front () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-head","title":"function head","text":"<p>Root node keyword. <pre><code>Keyword zmbt::lang::EncodingView::head () noexcept const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-if_data","title":"function if_data","text":"<pre><code>inline V const * zmbt::lang::EncodingView::if_data () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-if_depth","title":"function if_depth","text":"<pre><code>inline std::size_t const * zmbt::lang::EncodingView::if_depth () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-if_keywords","title":"function if_keywords","text":"<pre><code>inline K const * zmbt::lang::EncodingView::if_keywords () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-index_offset","title":"function index_offset","text":"<pre><code>std::size_t zmbt::lang::EncodingView::index_offset () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-is_boolean","title":"function is_boolean","text":"<pre><code>bool zmbt::lang::EncodingView::is_boolean () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-is_const","title":"function is_const","text":"<pre><code>bool zmbt::lang::EncodingView::is_const () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-operator","title":"function operator!=","text":"<pre><code>bool zmbt::lang::EncodingView::operator!= (\n    EncodingView const &amp; o\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-operator_1","title":"function operator==","text":"<pre><code>bool zmbt::lang::EncodingView::operator== (\n    EncodingView const &amp; o\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-operator_2","title":"function operator[]","text":"<pre><code>inline ExprRow zmbt::lang::EncodingView::operator[] (\n    std::size_t i\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-rbegin","title":"function rbegin","text":"<pre><code>inline const_reverse_iterator zmbt::lang::EncodingView::rbegin () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-rend","title":"function rend","text":"<pre><code>inline const_reverse_iterator zmbt::lang::EncodingView::rend () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-size","title":"function size","text":"<pre><code>std::size_t zmbt::lang::EncodingView::size () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-slice","title":"function slice","text":"<p>Create a subview [start, start+count) <pre><code>EncodingView zmbt::lang::EncodingView::slice (\n    std::size_t start,\n    std::size_t count\n) noexcept const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-subtree","title":"function subtree","text":"<p>Get a subview at specified node. <pre><code>EncodingView zmbt::lang::EncodingView::subtree (\n    std::size_t const node\n) noexcept const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-to_json","title":"function to_json","text":"<pre><code>boost::json::value zmbt::lang::EncodingView::to_json () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView/#function-traverse_subtrees","title":"function traverse_subtrees","text":"<pre><code>EncodingView zmbt::lang::EncodingView::traverse_subtrees (\n    std::size_t const node,\n    std::size_t &amp; next\n) noexcept const\n</code></pre> <p>Traverse subtrees from starting position. <code>next</code> arg points to the next subtree index at the same depth, or to size() if none. </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/encoding.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EncodingView_1_1ExprRow/","title":"Struct zmbt::lang::EncodingView::ExprRow","text":"<p>ClassList &gt; zmbt &gt; lang &gt; EncodingView &gt; ExprRow</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EncodingView_1_1ExprRow/#public-attributes","title":"Public Attributes","text":"Type Name V const  * data std::size_t depth std::size_t index K keyword"},{"location":"CxxRef/structzmbt_1_1lang_1_1EncodingView_1_1ExprRow/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1EncodingView_1_1ExprRow/#variable-data","title":"variable data","text":"<pre><code>V const* zmbt::lang::EncodingView::ExprRow::data;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EncodingView_1_1ExprRow/#variable-depth","title":"variable depth","text":"<pre><code>std::size_t zmbt::lang::EncodingView::ExprRow::depth;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EncodingView_1_1ExprRow/#variable-index","title":"variable index","text":"<pre><code>std::size_t zmbt::lang::EncodingView::ExprRow::index;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EncodingView_1_1ExprRow/#variable-keyword","title":"variable keyword","text":"<pre><code>K zmbt::lang::EncodingView::ExprRow::keyword;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/encoding.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/","title":"Class zmbt::lang::EncodingView::Iterator","text":"<p>ClassList &gt; zmbt &gt; lang &gt; EncodingView &gt; Iterator</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#public-types","title":"Public Types","text":"Type Name typedef std::ptrdiff_t difference_type typedef std::random_access_iterator_tag iterator_category typedef void pointer typedef ExprRow reference typedef ExprRow value_type"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#public-functions","title":"Public Functions","text":"Type Name Iterator (K const * k, std::size_t const * d, V const * v, std::size_t index, std::size_t offset)  bool operator!= (Iterator const &amp; other) const reference operator* () const Iterator operator+ (difference_type n) const Iterator &amp; operator++ ()  Iterator operator++ (int)  Iterator &amp; operator+= (difference_type n)  Iterator operator- (difference_type n) const difference_type operator- (Iterator const &amp; other) const Iterator &amp; operator-- ()  Iterator operator-- (int)  Iterator &amp; operator-= (difference_type n)  bool operator&lt; (Iterator const &amp; other) const bool operator&lt;= (Iterator const &amp; other) const bool operator== (Iterator const &amp; other) const bool operator&gt; (Iterator const &amp; other) const bool operator&gt;= (Iterator const &amp; other) const reference operator[] (difference_type n) const"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>using zmbt::lang::EncodingView::Iterator::difference_type =  std::ptrdiff_t;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>using zmbt::lang::EncodingView::Iterator::iterator_category =  std::random_access_iterator_tag;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#typedef-pointer","title":"typedef pointer","text":"<pre><code>using zmbt::lang::EncodingView::Iterator::pointer =  void;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#typedef-reference","title":"typedef reference","text":"<pre><code>using zmbt::lang::EncodingView::Iterator::reference =  ExprRow;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using zmbt::lang::EncodingView::Iterator::value_type =  ExprRow;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-iterator","title":"function Iterator","text":"<pre><code>inline zmbt::lang::EncodingView::Iterator::Iterator (\n    K const * k,\n    std::size_t const * d,\n    V const * v,\n    std::size_t index,\n    std::size_t offset\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator","title":"function operator!=","text":"<pre><code>inline bool zmbt::lang::EncodingView::Iterator::operator!= (\n    Iterator const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_1","title":"function operator*","text":"<pre><code>inline reference zmbt::lang::EncodingView::Iterator::operator* () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_2","title":"function operator+","text":"<pre><code>inline Iterator zmbt::lang::EncodingView::Iterator::operator+ (\n    difference_type n\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_3","title":"function operator++","text":"<pre><code>inline Iterator &amp; zmbt::lang::EncodingView::Iterator::operator++ () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_4","title":"function operator++","text":"<pre><code>inline Iterator zmbt::lang::EncodingView::Iterator::operator++ (\n    int\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_5","title":"function operator+=","text":"<pre><code>inline Iterator &amp; zmbt::lang::EncodingView::Iterator::operator+= (\n    difference_type n\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator-","title":"function operator-","text":"<pre><code>inline Iterator zmbt::lang::EncodingView::Iterator::operator- (\n    difference_type n\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator-_1","title":"function operator-","text":"<pre><code>inline difference_type zmbt::lang::EncodingView::Iterator::operator- (\n    Iterator const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator-_2","title":"function operator--","text":"<pre><code>inline Iterator &amp; zmbt::lang::EncodingView::Iterator::operator-- () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator-_3","title":"function operator--","text":"<pre><code>inline Iterator zmbt::lang::EncodingView::Iterator::operator-- (\n    int\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator-_4","title":"function operator-=","text":"<pre><code>inline Iterator &amp; zmbt::lang::EncodingView::Iterator::operator-= (\n    difference_type n\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_6","title":"function operator&lt;","text":"<pre><code>inline bool zmbt::lang::EncodingView::Iterator::operator&lt; (\n    Iterator const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_7","title":"function operator&lt;=","text":"<pre><code>inline bool zmbt::lang::EncodingView::Iterator::operator&lt;= (\n    Iterator const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_8","title":"function operator==","text":"<pre><code>inline bool zmbt::lang::EncodingView::Iterator::operator== (\n    Iterator const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_9","title":"function operator&gt;","text":"<pre><code>inline bool zmbt::lang::EncodingView::Iterator::operator&gt; (\n    Iterator const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_10","title":"function operator&gt;=","text":"<pre><code>inline bool zmbt::lang::EncodingView::Iterator::operator&gt;= (\n    Iterator const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EncodingView_1_1Iterator/#function-operator_11","title":"function operator[]","text":"<pre><code>inline reference zmbt::lang::EncodingView::Iterator::operator[] (\n    difference_type n\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/encoding.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/","title":"Struct zmbt::lang::EvalContext","text":"<p>ClassList &gt; zmbt &gt; lang &gt; EvalContext</p> <p>Expression evaluation context.</p> <ul> <li><code>#include &lt;eval_context.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#public-attributes","title":"Public Attributes","text":"Type Name std::shared_ptr&lt; boost::json::object &gt; captures reference -&gt; value map std::uint64_t depth Evaluation stack depth. std::shared_ptr&lt; std::map&lt; boost::json::string, ExpressionView &gt; &gt; links EvalLog log Evaluation log. Operator op Operator ."},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#public-functions","title":"Public Functions","text":"Type Name EvalContext ()  EvalContext operator++ () constCopy context with depth increment."},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#public-static-functions","title":"Public Static Functions","text":"Type Name EvalContext make (Operator const &amp; op={})"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#variable-captures","title":"variable captures","text":"<p>reference -&gt; value map <pre><code>std::shared_ptr&lt;boost::json::object&gt; zmbt::lang::EvalContext::captures;\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#variable-depth","title":"variable depth","text":"<p>Evaluation stack depth. <pre><code>std::uint64_t zmbt::lang::EvalContext::depth;\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#variable-links","title":"variable links","text":"<pre><code>std::shared_ptr&lt;std::map&lt;boost::json::string, ExpressionView&gt; &gt; zmbt::lang::EvalContext::links;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#variable-log","title":"variable log","text":"<p>Evaluation log. <pre><code>EvalLog zmbt::lang::EvalContext::log;\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#variable-op","title":"variable op","text":"<p>Operator . <pre><code>Operator zmbt::lang::EvalContext::op;\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#function-evalcontext","title":"function EvalContext","text":"<pre><code>zmbt::lang::EvalContext::EvalContext () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#function-operator","title":"function operator++","text":"<p>Copy context with depth increment. <pre><code>EvalContext zmbt::lang::EvalContext::operator++ () const\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalContext/#function-make","title":"function make","text":"<pre><code>static EvalContext zmbt::lang::EvalContext::make (\n    Operator const &amp; op={}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_context.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalImpl/","title":"Struct zmbt::lang::EvalImpl","text":"<p>template &lt;Keyword K&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; EvalImpl</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_impl.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/","title":"Class zmbt::lang::EvalImplBase","text":"<p>template &lt;Keyword K, class Validator&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; EvalImplBase</p> <p>Inherits the following classes: zmbt::lang::FixedEvalParams</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/#public-functions","title":"Public Functions","text":"Type Name EvalImplBase (ExpressionView const &amp; e, ExpressionView const &amp; x, EvalContext ctx)  EvalContext curr_ctx () const Expression operator() ()"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/#public-functions-inherited-from-zmbtlangfixedevalparams","title":"Public Functions inherited from zmbt::lang::FixedEvalParams","text":"<p>See zmbt::lang::FixedEvalParams</p> Type Name EvalParams (ExpressionView const &amp; e, ExpressionView const &amp; x, EvalContext ctx)"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/#public-functions-inherited-from-zmbtlangevalparams","title":"Public Functions inherited from zmbt::lang::EvalParams","text":"<p>See zmbt::lang::EvalParams</p> Type Name EvalParams (ExpressionView const &amp; e, ExpressionView const &amp; x, EvalContext ctx)  EvalContext context () const ExpressionView const &amp; lhs () const ExpressionView const &amp; rhs () const ExpressionView const &amp; self () const ExpressionView const &amp; x () const"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/#public-functions-inherited-from-zmbtlangkeywordinfo","title":"Public Functions inherited from zmbt::lang::KeywordInfo","text":"<p>See zmbt::lang::KeywordInfo</p> Type Name constexpr std::uint32_t attributes ()  constexpr Keyword keyword ()"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/#public-static-functions-inherited-from-zmbtlangkeywordinfo","title":"Public Static Functions inherited from zmbt::lang::KeywordInfo","text":"<p>See zmbt::lang::KeywordInfo</p> Type Name boost::json::string_view keyword_to_str ()"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/#function-evalimplbase","title":"function EvalImplBase","text":"<pre><code>inline zmbt::lang::EvalImplBase::EvalImplBase (\n    ExpressionView const &amp; e,\n    ExpressionView const &amp; x,\n    EvalContext ctx\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/#function-curr_ctx","title":"function curr_ctx","text":"<pre><code>inline EvalContext zmbt::lang::EvalImplBase::curr_ctx () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalImplBase/#function-operator","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::EvalImplBase::operator() () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_impl.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/","title":"Struct zmbt::lang::EvalLog","text":"<p>ClassList &gt; zmbt &gt; lang &gt; EvalLog</p> <p>Expression evaluation log.</p> <ul> <li><code>#include &lt;eval_log.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#public-attributes","title":"Public Attributes","text":"Type Name std::shared_ptr&lt; boost::json::array &gt; stack"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#public-functions","title":"Public Functions","text":"Type Name EvalLog () = defaultDefault instance with null log stack. void push (Expression const &amp; expr, Expression const &amp; x, Expression const &amp; result, std::uint64_t const depth) constPush record to log stack. boost::json::string str (int const indent=0) constStringify log."},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#public-static-functions","title":"Public Static Functions","text":"Type Name void format (std::ostream &amp; os, boost::json::array const &amp; log, int const indent=0)  EvalLog make () Make non-empty EvalLog ."},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#variable-stack","title":"variable stack","text":"<pre><code>std::shared_ptr&lt;boost::json::array&gt; zmbt::lang::EvalLog::stack;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#function-evallog","title":"function EvalLog","text":"<p>Default instance with null log stack. <pre><code>zmbt::lang::EvalLog::EvalLog () = default\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#function-push","title":"function push","text":"<p>Push record to log stack. <pre><code>void zmbt::lang::EvalLog::push (\n    Expression const &amp; expr,\n    Expression const &amp; x,\n    Expression const &amp; result,\n    std::uint64_t const depth\n) const\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#function-str","title":"function str","text":"<p>Stringify log. <pre><code>boost::json::string zmbt::lang::EvalLog::str (\n    int const indent=0\n) const\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#function-format","title":"function format","text":"<pre><code>static void zmbt::lang::EvalLog::format (\n    std::ostream &amp; os,\n    boost::json::array const &amp; log,\n    int const indent=0\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#function-make","title":"function make","text":"<p>Make non-empty EvalLog . <pre><code>static EvalLog zmbt::lang::EvalLog::make () \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#friends-documentation","title":"Friends Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalLog/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>std::ostream &amp; zmbt::lang::EvalLog::operator&lt;&lt; (\n    std::ostream &amp; os,\n    EvalLog const &amp; log\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_log.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalParams/","title":"Class zmbt::lang::EvalParams","text":"<p>ClassList &gt; zmbt &gt; lang &gt; EvalParams</p> <p>Inherited by the following classes: zmbt::lang::FixedEvalParams</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalParams/#public-functions","title":"Public Functions","text":"Type Name EvalParams (ExpressionView const &amp; e, ExpressionView const &amp; x, EvalContext ctx)  EvalContext context () const ExpressionView const &amp; lhs () const ExpressionView const &amp; rhs () const ExpressionView const &amp; self () const ExpressionView const &amp; x () const"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalParams/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalParams/#function-evalparams","title":"function EvalParams","text":"<pre><code>zmbt::lang::EvalParams::EvalParams (\n    ExpressionView const &amp; e,\n    ExpressionView const &amp; x,\n    EvalContext ctx\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalParams/#function-context","title":"function context","text":"<pre><code>inline EvalContext zmbt::lang::EvalParams::context () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalParams/#function-lhs","title":"function lhs","text":"<pre><code>inline ExpressionView const &amp; zmbt::lang::EvalParams::lhs () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalParams/#function-rhs","title":"function rhs","text":"<pre><code>inline ExpressionView const &amp; zmbt::lang::EvalParams::rhs () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalParams/#function-self","title":"function self","text":"<pre><code>inline ExpressionView const &amp; zmbt::lang::EvalParams::self () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1EvalParams/#function-x","title":"function x","text":"<pre><code>inline ExpressionView const &amp; zmbt::lang::EvalParams::x () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_params.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalValidator/","title":"Struct zmbt::lang::EvalValidator","text":"<p>template &lt;Keyword K&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; EvalValidator</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalValidator/#public-functions","title":"Public Functions","text":"Type Name EvalValidator (ExpressionView const &amp; lhs, ExpressionView const &amp; rhs)  bool is_invalid () const Expression status () const"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalValidator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalValidator/#function-evalvalidator","title":"function EvalValidator","text":"<pre><code>inline zmbt::lang::EvalValidator::EvalValidator (\n    ExpressionView const &amp; lhs,\n    ExpressionView const &amp; rhs\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalValidator/#function-is_invalid","title":"function is_invalid","text":"<pre><code>inline bool zmbt::lang::EvalValidator::is_invalid () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1EvalValidator/#function-status","title":"function status","text":"<pre><code>inline Expression zmbt::lang::EvalValidator::status () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_validator.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/","title":"Class zmbt::lang::Expression","text":"<p>ClassList &gt; zmbt &gt; lang &gt; Expression</p> <p>Inherits the following classes: zmbt::lang::ExpressionView</p> <p>Inherited by the following classes: zmbt::lang::SignatureBase,  zmbt::lang::SignatureBase,  zmbt::lang::SignatureBase,  zmbt::Param,  zmbt::lang::Expression::Subexpression,  zmbt::lang::SignatureBase</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#classes","title":"Classes","text":"Type Name class Subexpression"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#public-functions","title":"Public Functions","text":"Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#public-static-functions","title":"Public Static Functions","text":"Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-111","title":"function Expression [1/11]","text":"<pre><code>zmbt::lang::Expression::Expression () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-211","title":"function Expression [2/11]","text":"<pre><code>explicit zmbt::lang::Expression::Expression (\n    Encoding &amp;&amp; encoding\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-311","title":"function Expression [3/11]","text":"<pre><code>explicit zmbt::lang::Expression::Expression (\n    Encoding const &amp; encoding\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-411","title":"function Expression [4/11]","text":"<pre><code>zmbt::lang::Expression::Expression (\n    boost::json::value const &amp; expr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-511","title":"function Expression [5/11]","text":"<pre><code>zmbt::lang::Expression::Expression (\n    boost::json::value &amp;&amp; expr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-611","title":"function Expression [6/11]","text":"<pre><code>zmbt::lang::Expression::Expression (\n    std::initializer_list&lt; boost::json::value_ref &gt; items\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-711","title":"function Expression [7/11]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::lang::Expression::Expression (\n    T sample\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-811","title":"function Expression [8/11]","text":"<pre><code>explicit zmbt::lang::Expression::Expression (\n    Keyword const &amp; keyword\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-911","title":"function Expression [9/11]","text":"<pre><code>explicit zmbt::lang::Expression::Expression (\n    ExpressionView const &amp; view\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-1011","title":"function Expression [10/11]","text":"<pre><code>zmbt::lang::Expression::Expression (\n    Expression const &amp; other\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression-1111","title":"function Expression [11/11]","text":"<pre><code>zmbt::lang::Expression::Expression (\n    Expression &amp;&amp; other\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-encoding","title":"function encoding","text":"<pre><code>inline Encoding zmbt::lang::Expression::encoding () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-operator","title":"function operator!=","text":"<pre><code>inline bool zmbt::lang::Expression::operator!= (\n    Expression v\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-operator_1","title":"function operator=","text":"<pre><code>Expression &amp; zmbt::lang::Expression::operator= (\n    Expression const &amp; other\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-operator_2","title":"function operator=","text":"<pre><code>Expression &amp; zmbt::lang::Expression::operator= (\n    Expression &amp;&amp; other\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-operator_3","title":"function operator==","text":"<pre><code>inline bool zmbt::lang::Expression::operator== (\n    Expression v\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-expression","title":"function ~Expression","text":"<pre><code>zmbt::lang::Expression::~Expression () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-encodeliteral","title":"function encodeLiteral","text":"<pre><code>static Encoding zmbt::lang::Expression::encodeLiteral (\n    boost::json::value const &amp; params\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-encodenested-23","title":"function encodeNested [2/3]","text":"<pre><code>static Encoding zmbt::lang::Expression::encodeNested (\n    Keyword const &amp; keyword,\n    std::initializer_list&lt; Expression &gt; subexpressions\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-encodenested-33","title":"function encodeNested [3/3]","text":"<pre><code>static Encoding zmbt::lang::Expression::encodeNested (\n    Keyword const &amp; keyword,\n    std::vector&lt; Expression &gt; &amp;&amp; subexpressions\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-encodepreproc","title":"function encodePreProc","text":"<pre><code>static Encoding zmbt::lang::Expression::encodePreProc (\n    boost::json::value const &amp; params\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#function-to_predicate_if_const","title":"function to_predicate_if_const","text":"<pre><code>static bool zmbt::lang::Expression::to_predicate_if_const (\n    Expression &amp; e\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#friends-documentation","title":"Friends Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#friend-operator","title":"friend operator&amp;","text":"<p>Pack expression results into an array. <pre><code>Expression zmbt::lang::Expression::operator&amp; (\n    Expression lhs,\n    Expression rhs\n) \n</code></pre></p> <p>See also: zmbt::expr::Fork. </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#friend-operator_1","title":"friend operator+","text":"<p>Pack expression into an array. without evaluation. <pre><code>Expression zmbt::lang::Expression::operator+ (\n    Expression lhs,\n    Expression rhs\n) \n</code></pre></p> <p>See also: zmbt::expr::Tuple. </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#friend-operator_2","title":"friend operator&lt;&lt;","text":"<p>Inline named function, equivalent to Fn(link + expr) <pre><code>Expression zmbt::lang::Expression::operator&lt;&lt; (\n    Expression link,\n    Expression expr\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#friend-operator_3","title":"friend operator|","text":"<pre><code>Expression zmbt::lang::Expression::operator| (\n    Expression lhs,\n    Expression rhs\n) \n</code></pre> <p>Pipe expressions left-to-right</p> <p>Pipe functional expressions in composition, s.t. <code>a | b</code> is equivalent to <code>Pipe(a, b)</code>. </p> <p>See also: zmbt::expr::Pipe </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression/#friend-operator_4","title":"friend operator~","text":"<p>Flip design-time and eval-time parameters. <pre><code>Expression zmbt::lang::Expression::operator~ (\n    Expression expr\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/expression.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression_1_1Subexpression/","title":"Class zmbt::lang::Expression::Subexpression","text":"<p>ClassList &gt; zmbt &gt; lang &gt; Expression &gt; Subexpression</p> <p>Inherits the following classes: zmbt::lang::Expression</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression_1_1Subexpression/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression_1_1Subexpression/#public-functions","title":"Public Functions","text":"Type Name Subexpression (EncodingView const &amp; ev)"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression_1_1Subexpression/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression_1_1Subexpression/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression_1_1Subexpression/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression_1_1Subexpression/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression_1_1Subexpression/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1Expression_1_1Subexpression/#function-subexpression","title":"function Subexpression","text":"<pre><code>inline zmbt::lang::Expression::Subexpression::Subexpression (\n    EncodingView const &amp; ev\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/subexpression.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/","title":"Struct zmbt::lang::ExpressionGrammar","text":"<p>template &lt;typename OutputIterator&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; ExpressionGrammar</p> <p>Inherits the following classes: boost::spirit::karma::grammar&lt; OutputIterator, ExpressionView()&gt;</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#public-attributes","title":"Public Attributes","text":"Type Name boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; flip boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; fork boost::spirit::karma::rule&lt; OutputIterator, ExpressionView()&gt; keyword boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; link boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; nested_fork boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; nested_link boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; nested_pipe boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; nested_tuple boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; parameters boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; pipe boost::spirit::karma::rule&lt; OutputIterator, ExpressionView()&gt; start boost::spirit::karma::rule&lt; OutputIterator, ExpressionView()&gt; subexpr boost::spirit::karma::rule&lt; OutputIterator, std::list&lt; ExpressionView &gt;()&gt; tuple"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#public-functions","title":"Public Functions","text":"Type Name ExpressionGrammar ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-flip","title":"variable flip","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::flip;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-fork","title":"variable fork","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::fork;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-keyword","title":"variable keyword","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, ExpressionView()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::keyword;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-link","title":"variable link","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::link;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-nested_fork","title":"variable nested_fork","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::nested_fork;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-nested_link","title":"variable nested_link","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::nested_link;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-nested_pipe","title":"variable nested_pipe","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::nested_pipe;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-nested_tuple","title":"variable nested_tuple","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::nested_tuple;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-parameters","title":"variable parameters","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::parameters;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-pipe","title":"variable pipe","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::pipe;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-start","title":"variable start","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, ExpressionView()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::start;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-subexpr","title":"variable subexpr","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, ExpressionView()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::subexpr;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#variable-tuple","title":"variable tuple","text":"<pre><code>boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; zmbt::lang::ExpressionGrammar&lt; OutputIterator &gt;::tuple;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1ExpressionGrammar/#function-expressiongrammar","title":"function ExpressionGrammar","text":"<pre><code>inline zmbt::lang::ExpressionGrammar::ExpressionGrammar () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/expression_grammar.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/","title":"Class zmbt::lang::ExpressionView","text":"<p>ClassList &gt; zmbt &gt; lang &gt; ExpressionView</p> <p>More...</p> <ul> <li><code>#include &lt;expression.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: zmbt::lang::Expression</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#public-types","title":"Public Types","text":"Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#public-functions","title":"Public Functions","text":"Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#protected-attributes","title":"Protected Attributes","text":"Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#detailed-description","title":"Detailed Description","text":"<p>Expression Language implementation class.</p> <p>See also: Expression Language documentation. </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#typedef-keyword","title":"typedef Keyword","text":"<pre><code>using zmbt::lang::ExpressionView::Keyword =  lang::Keyword;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#typedef-v","title":"typedef V","text":"<pre><code>using zmbt::lang::ExpressionView::V =  boost::json::value;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-expressionview-15","title":"function ExpressionView [1/5]","text":"<pre><code>zmbt::lang::ExpressionView::ExpressionView () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-expressionview-25","title":"function ExpressionView [2/5]","text":"<pre><code>zmbt::lang::ExpressionView::ExpressionView (\n    ExpressionView const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-expressionview-35","title":"function ExpressionView [3/5]","text":"<pre><code>zmbt::lang::ExpressionView::ExpressionView (\n    ExpressionView &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-expressionview-45","title":"function ExpressionView [4/5]","text":"<pre><code>inline explicit zmbt::lang::ExpressionView::ExpressionView (\n    EncodingView v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-expressionview-55","title":"function ExpressionView [5/5]","text":"<pre><code>inline explicit zmbt::lang::ExpressionView::ExpressionView (\n    Encoding enc\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-as_array","title":"function as_array","text":"<pre><code>inline boost::json::array const &amp; zmbt::lang::ExpressionView::as_array () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-as_bool","title":"function as_bool","text":"<pre><code>inline bool zmbt::lang::ExpressionView::as_bool () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-as_object","title":"function as_object","text":"<pre><code>inline boost::json::object const &amp; zmbt::lang::ExpressionView::as_object () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-as_string","title":"function as_string","text":"<pre><code>inline boost::json::string const &amp; zmbt::lang::ExpressionView::as_string () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-data","title":"function data","text":"<pre><code>boost::json::value const &amp; zmbt::lang::ExpressionView::data () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-encoding_view","title":"function encoding_view","text":"<pre><code>inline EncodingView zmbt::lang::ExpressionView::encoding_view () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-error_id","title":"function error_id","text":"<pre><code>std::string zmbt::lang::ExpressionView::error_id () const\n</code></pre> <p>Internal error identifier. Returns empty string when is_error() equals false. </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-eval","title":"function eval","text":"<p>Evaluate expression. <pre><code>boost::json::value zmbt::lang::ExpressionView::eval (\n    boost::json::value const &amp; x=nullptr,\n    EvalContext ctx={}\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>x</code> run-time argument </li> <li><code>ctx</code> evaluation context </li> </ul> <p>Returns:</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-eval_as_predicate-12","title":"function eval_as_predicate [1/2]","text":"<pre><code>bool zmbt::lang::ExpressionView::eval_as_predicate (\n    ExpressionView const &amp; x,\n    Expression &amp; err_sts,\n    EvalContext ctx\n) const\n</code></pre> <p>Eval const expressions as Eq(expr), except for Noop, otherwise eval expr. </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-eval_as_predicate-22","title":"function eval_as_predicate [2/2]","text":"<pre><code>bool zmbt::lang::ExpressionView::eval_as_predicate (\n    boost::json::value const &amp; x,\n    Expression &amp; err_sts,\n    EvalContext ctx\n) const\n</code></pre> <p>Eval const expressions as Eq(expr), except for Noop, otherwise eval expr. Store result in arg reference and return error status. </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-eval_e","title":"function eval_e","text":"<p>Evaluate expression. <pre><code>Expression zmbt::lang::ExpressionView::eval_e (\n    ExpressionView const &amp; x,\n    EvalContext ctx\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>x</code> run-time argument </li> <li><code>ctx</code> evaluation context </li> </ul> <p>Returns:</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-eval_maybe_predicate","title":"function eval_maybe_predicate","text":"<pre><code>Expression zmbt::lang::ExpressionView::eval_maybe_predicate (\n    ExpressionView const &amp; x,\n    EvalContext ctx\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-has_subexpr","title":"function has_subexpr","text":"<pre><code>inline bool zmbt::lang::ExpressionView::has_subexpr () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-if_array","title":"function if_array","text":"<pre><code>inline boost::json::array const * zmbt::lang::ExpressionView::if_array () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-if_bool","title":"function if_bool","text":"<pre><code>inline bool const * zmbt::lang::ExpressionView::if_bool () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-if_object","title":"function if_object","text":"<pre><code>inline boost::json::object const * zmbt::lang::ExpressionView::if_object () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-if_string","title":"function if_string","text":"<pre><code>inline boost::json::string const * zmbt::lang::ExpressionView::if_string () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is","title":"function is","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is (\n    Keyword const kwrd\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_boolean","title":"function is_boolean","text":"<pre><code>bool zmbt::lang::ExpressionView::is_boolean () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_complete_flip","title":"function is_complete_flip","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_complete_flip () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_compose","title":"function is_compose","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_compose () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_const","title":"function is_const","text":"<pre><code>bool zmbt::lang::ExpressionView::is_const () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_error","title":"function is_error","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_error () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_fork","title":"function is_fork","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_fork () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_infix_fork","title":"function is_infix_fork","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_infix_fork () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_infix_pipe","title":"function is_infix_pipe","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_infix_pipe () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_infix_tuple","title":"function is_infix_tuple","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_infix_tuple () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_link","title":"function is_link","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_link () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_literal","title":"function is_literal","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_literal () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_noop","title":"function is_noop","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_noop () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_null","title":"function is_null","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_null () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_preproc","title":"function is_preproc","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_preproc () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_tuple","title":"function is_tuple","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_tuple () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-is_valid_link","title":"function is_valid_link","text":"<pre><code>inline bool zmbt::lang::ExpressionView::is_valid_link () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-keyword","title":"function keyword","text":"<pre><code>inline Keyword zmbt::lang::ExpressionView::keyword () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-keyword_to_str","title":"function keyword_to_str","text":"<pre><code>boost::json::string_view zmbt::lang::ExpressionView::keyword_to_str () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-match","title":"function match","text":"<p>Eval and cast to boolean, return false on error. <pre><code>bool zmbt::lang::ExpressionView::match (\n    boost::json::value const &amp; x,\n    Operator const &amp; op={}\n) const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-operator","title":"function operator!=","text":"<pre><code>inline bool zmbt::lang::ExpressionView::operator!= (\n    ExpressionView const &amp; o\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-operator_1","title":"function operator=","text":"<pre><code>ExpressionView &amp; zmbt::lang::ExpressionView::operator= (\n    ExpressionView const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-operator_2","title":"function operator=","text":"<pre><code>ExpressionView &amp; zmbt::lang::ExpressionView::operator= (\n    ExpressionView &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-operator_3","title":"function operator==","text":"<pre><code>inline bool zmbt::lang::ExpressionView::operator== (\n    ExpressionView const &amp; o\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-preprocessing_parameters","title":"function preprocessing_parameters","text":"<p>List of [param, json ptr]. <pre><code>std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; zmbt::lang::ExpressionView::preprocessing_parameters () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-prettify","title":"function prettify","text":"<pre><code>std::string zmbt::lang::ExpressionView::prettify () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-prettify_to-13","title":"function prettify_to [1/3]","text":"<pre><code>std::ostream &amp; zmbt::lang::ExpressionView::prettify_to (\n    std::ostream &amp; os\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-prettify_to-23","title":"function prettify_to [2/3]","text":"<pre><code>template&lt;std::size_t N&gt;\ninline void zmbt::lang::ExpressionView::prettify_to (\n    char(&amp;) buff\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-prettify_to-33","title":"function prettify_to [3/3]","text":"<pre><code>void zmbt::lang::ExpressionView::prettify_to (\n    char * buff,\n    std::size_t n\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-serialize","title":"function serialize","text":"<pre><code>inline std::string zmbt::lang::ExpressionView::serialize () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-subexpressions_list","title":"function subexpressions_list","text":"<p>Subexpressions. <pre><code>std::list&lt; ExpressionView &gt; zmbt::lang::ExpressionView::subexpressions_list () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-to_json","title":"function to_json","text":"<pre><code>boost::json::value zmbt::lang::ExpressionView::to_json () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-tuple_parameters","title":"function tuple_parameters","text":"<pre><code>std::list&lt; ExpressionView &gt; zmbt::lang::ExpressionView::tuple_parameters () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#function-expressionview","title":"function ~ExpressionView","text":"<pre><code>virtual zmbt::lang::ExpressionView::~ExpressionView () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#variable-const_predicate_cache_","title":"variable const_predicate_cache_","text":"<pre><code>std::shared_ptr&lt;Expression&gt; zmbt::lang::ExpressionView::const_predicate_cache_;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#variable-encoding_view_","title":"variable encoding_view_","text":"<pre><code>EncodingView zmbt::lang::ExpressionView::encoding_view_;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#friends-documentation","title":"Friends Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#friend-operator","title":"friend operator*","text":"<p>Evaluate x to lhs expression. <pre><code>V zmbt::lang::ExpressionView::operator* (\n    ExpressionView expr,\n    ExpressionView const &amp; x\n) \n</code></pre></p> <p>Equivalent to expr.eval(x). </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#friend-operator_1","title":"friend operator*","text":"<p>Evaluate expression. <pre><code>V zmbt::lang::ExpressionView::operator* (\n    ExpressionView expr\n) \n</code></pre></p> <p>Equivalent to expr.eval(). </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#friend-operator_2","title":"friend operator&lt;&lt;","text":"<pre><code>std::ostream &amp; zmbt::lang::ExpressionView::operator&lt;&lt; (\n    std::ostream &amp; os,\n    ExpressionView const &amp; expr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1ExpressionView/#friend-operator_3","title":"friend operator&lt;&lt;","text":"<pre><code>zmbt::Logger &amp; zmbt::lang::ExpressionView::operator&lt;&lt; (\n    zmbt::Logger &amp; logger,\n    ExpressionView const &amp; expr\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/expression.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1FixedEvalParams/","title":"Struct zmbt::lang::FixedEvalParams","text":"<p>template &lt;Keyword K&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; FixedEvalParams</p> <p>Inherits the following classes: zmbt::lang::EvalParams,  zmbt::lang::KeywordInfo</p> <p>Inherited by the following classes: zmbt::lang::EvalImplBase</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1FixedEvalParams/#public-functions","title":"Public Functions","text":"Type Name EvalParams (ExpressionView const &amp; e, ExpressionView const &amp; x, EvalContext ctx)"},{"location":"CxxRef/structzmbt_1_1lang_1_1FixedEvalParams/#public-functions-inherited-from-zmbtlangevalparams","title":"Public Functions inherited from zmbt::lang::EvalParams","text":"<p>See zmbt::lang::EvalParams</p> Type Name EvalParams (ExpressionView const &amp; e, ExpressionView const &amp; x, EvalContext ctx)  EvalContext context () const ExpressionView const &amp; lhs () const ExpressionView const &amp; rhs () const ExpressionView const &amp; self () const ExpressionView const &amp; x () const"},{"location":"CxxRef/structzmbt_1_1lang_1_1FixedEvalParams/#public-functions-inherited-from-zmbtlangkeywordinfo","title":"Public Functions inherited from zmbt::lang::KeywordInfo","text":"<p>See zmbt::lang::KeywordInfo</p> Type Name constexpr std::uint32_t attributes ()  constexpr Keyword keyword ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1FixedEvalParams/#public-static-functions-inherited-from-zmbtlangkeywordinfo","title":"Public Static Functions inherited from zmbt::lang::KeywordInfo","text":"<p>See zmbt::lang::KeywordInfo</p> Type Name boost::json::string_view keyword_to_str ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1FixedEvalParams/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1FixedEvalParams/#function-evalparams","title":"function EvalParams","text":"<pre><code>zmbt::lang::FixedEvalParams::EvalParams (\n    ExpressionView const &amp; e,\n    ExpressionView const &amp; x,\n    EvalContext ctx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_params.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordGrammar/","title":"Struct zmbt::lang::KeywordGrammar","text":"<p>ClassList &gt; zmbt &gt; lang &gt; KeywordGrammar</p> <p>Boost.Sirit.Qi Grammar for zmbt::lang::Keyword parsing.</p> <ul> <li><code>#include &lt;keyword_grammar.hpp&gt;</code></li> </ul> <p>Inherits the following classes: boost::spirit::qi::grammar&lt; boost::json::string::const_iterator, Keyword()&gt;</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordGrammar/#public-attributes","title":"Public Attributes","text":"Type Name KeywordSymbol keyword_symbol boost::spirit::qi::rule&lt; boost::json::string::const_iterator, Keyword()&gt; start"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordGrammar/#public-functions","title":"Public Functions","text":"Type Name KeywordGrammar ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordGrammar/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordGrammar/#variable-keyword_symbol","title":"variable keyword_symbol","text":"<pre><code>KeywordSymbol zmbt::lang::KeywordGrammar::keyword_symbol;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordGrammar/#variable-start","title":"variable start","text":"<pre><code>boost::spirit::qi::rule&lt;boost::json::string::const_iterator, Keyword()&gt; zmbt::lang::KeywordGrammar::start;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordGrammar/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordGrammar/#function-keywordgrammar","title":"function KeywordGrammar","text":"<pre><code>zmbt::lang::KeywordGrammar::KeywordGrammar () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/keyword_grammar.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordInfo/","title":"Struct zmbt::lang::KeywordInfo","text":"<p>template &lt;Keyword k&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; KeywordInfo</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordInfo/#public-functions","title":"Public Functions","text":"Type Name constexpr std::uint32_t attributes ()  constexpr Keyword keyword ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordInfo/#public-static-functions","title":"Public Static Functions","text":"Type Name boost::json::string_view keyword_to_str ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordInfo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordInfo/#function-attributes","title":"function attributes","text":"<pre><code>inline constexpr std::uint32_t zmbt::lang::KeywordInfo::attributes () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordInfo/#function-keyword","title":"function keyword","text":"<pre><code>inline constexpr Keyword zmbt::lang::KeywordInfo::keyword () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordInfo/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordInfo/#function-keyword_to_str","title":"function keyword_to_str","text":"<pre><code>static inline boost::json::string_view zmbt::lang::KeywordInfo::keyword_to_str () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/keyword_info.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordSymbol/","title":"Struct zmbt::lang::KeywordSymbol","text":"<p>ClassList &gt; zmbt &gt; lang &gt; KeywordSymbol</p> <p>Boost.Sirit.Qi Symbol for zmbt::lang::Keyword parsing.</p> <ul> <li><code>#include &lt;keyword_grammar.hpp&gt;</code></li> </ul> <p>Inherits the following classes: boost::spirit::qi::symbols&lt; char, Keyword &gt;</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordSymbol/#public-functions","title":"Public Functions","text":"Type Name KeywordSymbol ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordSymbol/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1KeywordSymbol/#function-keywordsymbol","title":"function KeywordSymbol","text":"<pre><code>zmbt::lang::KeywordSymbol::KeywordSymbol () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/keyword_grammar.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/","title":"Class zmbt::lang::LazyParam","text":"<p>ClassList &gt; zmbt &gt; lang &gt; LazyParam</p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#public-types","title":"Public Types","text":"Type Name typedef boost::json::value V"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#public-functions","title":"Public Functions","text":"Type Name LazyParam ()  LazyParam (std::function&lt; V()&gt; getter)  LazyParam (ExpressionView, EvalContext)  LazyParam (V &amp;&amp; v)  LazyParam (V const &amp; v)  LazyParam (std::reference_wrapper&lt; V const &gt; v)  LazyParam (T const &amp; v)  LazyParam (LazyParam const &amp;) = default LazyParam (LazyParam &amp;&amp;) = default operator V () const V operator() () const LazyParam &amp; operator= (LazyParam const &amp;) = default LazyParam &amp; operator= (LazyParam &amp;&amp;) = default ~LazyParam () = default"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#typedef-v","title":"typedef V","text":"<pre><code>using zmbt::lang::LazyParam::V =  boost::json::value;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam-19","title":"function LazyParam [1/9]","text":"<pre><code>zmbt::lang::LazyParam::LazyParam () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam-29","title":"function LazyParam [2/9]","text":"<pre><code>zmbt::lang::LazyParam::LazyParam (\n    std::function&lt; V()&gt; getter\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam-39","title":"function LazyParam [3/9]","text":"<pre><code>zmbt::lang::LazyParam::LazyParam (\n    ExpressionView,\n    EvalContext\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam-49","title":"function LazyParam [4/9]","text":"<pre><code>zmbt::lang::LazyParam::LazyParam (\n    V &amp;&amp; v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam-59","title":"function LazyParam [5/9]","text":"<pre><code>zmbt::lang::LazyParam::LazyParam (\n    V const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam-69","title":"function LazyParam [6/9]","text":"<pre><code>zmbt::lang::LazyParam::LazyParam (\n    std::reference_wrapper&lt; V const &gt; v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam-79","title":"function LazyParam [7/9]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::lang::LazyParam::LazyParam (\n    T const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam-89","title":"function LazyParam [8/9]","text":"<pre><code>zmbt::lang::LazyParam::LazyParam (\n    LazyParam const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam-99","title":"function LazyParam [9/9]","text":"<pre><code>zmbt::lang::LazyParam::LazyParam (\n    LazyParam &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-operator-v","title":"function operator V","text":"<pre><code>zmbt::lang::LazyParam::operator V () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-operator","title":"function operator()","text":"<pre><code>V zmbt::lang::LazyParam::operator() () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-operator_1","title":"function operator=","text":"<pre><code>LazyParam &amp; zmbt::lang::LazyParam::operator= (\n    LazyParam const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-operator_2","title":"function operator=","text":"<pre><code>LazyParam &amp; zmbt::lang::LazyParam::operator= (\n    LazyParam &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1LazyParam/#function-lazyparam","title":"function ~LazyParam","text":"<pre><code>zmbt::lang::LazyParam::~LazyParam () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/lazy_param.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/","title":"Class zmbt::lang::Operator","text":"<p>ClassList &gt; zmbt &gt; lang &gt; Operator</p> <p>Signal transformation and comparison handler. Enables type erasure. </p> <ul> <li><code>#include &lt;operator.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#classes","title":"Classes","text":"Type Name struct operator_error"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#public-types","title":"Public Types","text":"Type Name enum std::uint32_t Config typedef LazyParam LV typedef boost::json::value V"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#public-functions","title":"Public Functions","text":"Type Name Operator () Default operator with generic transforms. Operator (type_tag&lt; T &gt; tag, Config const cfg) Operator with T as type decorator. Operator (type_tag&lt; T &gt; tag) Operator with T as type decorator. Operator (boost::json::string_view annotation) Retrieve registered operator instance if it exists, throw otherwise. Operator (Operator const &amp;) = default Operator (Operator &amp;&amp;) = default boost::json::string annotation () constdecorated type name boost::json::value apply (lang::Keyword const &amp; keyword, LV lhs, LV rhs) constApply operands. boost::json::value decorate (boost::json::value const &amp; a) constReserialize as decorated type. bool is_generic () const Operator &amp; operator= (Operator const &amp;) = default Operator &amp; operator= (Operator &amp;&amp;) = default boost::json::value undecorate (boost::json::value const &amp; a) constReserialize as decorated type. virtual ~Operator () = default"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#public-static-functions","title":"Public Static Functions","text":"Type Name V generic_bit_and (LV, LV)  V generic_bit_or (LV, LV)  V generic_bit_xor (LV, LV)  V generic_complement (LV)  V generic_decorate (LV)  V generic_divides (LV, LV)  V generic_equal_to (LV, LV)  V generic_is_truth (LV)  V generic_left_shift (LV, LV)  V generic_less (LV, LV)  V generic_less_equal (LV, LV)  V generic_log (LV, LV)  V generic_logical_and (LV, LV)  V generic_logical_not (LV)  V generic_logical_or (LV, LV)  V generic_minus (LV, LV)  V generic_modulus (LV, LV)  V generic_multiplies (LV, LV)  V generic_negate (LV)  V generic_plus (LV, LV)  V generic_pow (LV, LV)  V generic_quot (LV, LV)  V generic_right_shift (LV, LV)  V generic_undecorate (LV)"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#enum-config","title":"enum Config","text":"<pre><code>enum zmbt::lang::Operator::Config {\n    Null,\n    Decor = 1U &lt;&lt; 0,\n    Comparison = 1U &lt;&lt; 1,\n    Arithmetics = 1U &lt;&lt; 2,\n    Bitwise = 1U &lt;&lt; 3,\n    Shift = 1U &lt;&lt; 4,\n    Logic = 1U &lt;&lt; 5,\n    Default = Decor|Comparison|Arithmetics|Bitwise|Shift,\n    Full = Default|Logic\n};\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#typedef-lv","title":"typedef LV","text":"<pre><code>using zmbt::lang::Operator::LV =  LazyParam;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#typedef-v","title":"typedef V","text":"<pre><code>using zmbt::lang::Operator::V =  boost::json::value;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-operator-27","title":"function Operator [2/7]","text":"<p>Default operator with generic transforms. <pre><code>zmbt::lang::Operator::Operator () \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-operator-37","title":"function Operator [3/7]","text":"<p>Operator with T as type decorator. <pre><code>template&lt;class T&gt;\ninline zmbt::lang::Operator::Operator (\n    type_tag &lt; T &gt; tag,\n    Config const cfg\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-operator-47","title":"function Operator [4/7]","text":"<p>Operator with T as type decorator. <pre><code>template&lt;class T&gt;\ninline zmbt::lang::Operator::Operator (\n    type_tag &lt; T &gt; tag\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-operator-57","title":"function Operator [5/7]","text":"<p>Retrieve registered operator instance if it exists, throw otherwise. <pre><code>zmbt::lang::Operator::Operator (\n    boost::json::string_view annotation\n) \n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-operator-67","title":"function Operator [6/7]","text":"<pre><code>zmbt::lang::Operator::Operator (\n    Operator const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-operator-77","title":"function Operator [7/7]","text":"<pre><code>zmbt::lang::Operator::Operator (\n    Operator &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-annotation","title":"function annotation","text":"<p>decorated type name <pre><code>inline boost::json::string zmbt::lang::Operator::annotation () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-apply","title":"function apply","text":"<p>Apply operands. <pre><code>boost::json::value zmbt::lang::Operator::apply (\n    lang::Keyword const &amp; keyword,\n    LV lhs,\n    LV rhs\n) const\n</code></pre></p> <p>For unary operators, lhs is nullptr </p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-decorate","title":"function decorate","text":"<p>Reserialize as decorated type. <pre><code>inline boost::json::value zmbt::lang::Operator::decorate (\n    boost::json::value const &amp; a\n) const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-is_generic","title":"function is_generic","text":"<pre><code>inline bool zmbt::lang::Operator::is_generic () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-operator","title":"function operator=","text":"<pre><code>Operator &amp; zmbt::lang::Operator::operator= (\n    Operator const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-operator_1","title":"function operator=","text":"<pre><code>Operator &amp; zmbt::lang::Operator::operator= (\n    Operator &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-undecorate","title":"function undecorate","text":"<p>Reserialize as decorated type. <pre><code>inline boost::json::value zmbt::lang::Operator::undecorate (\n    boost::json::value const &amp; a\n) const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-operator_2","title":"function ~Operator","text":"<pre><code>virtual zmbt::lang::Operator::~Operator () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_bit_and","title":"function generic_bit_and","text":"<pre><code>static V zmbt::lang::Operator::generic_bit_and (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_bit_or","title":"function generic_bit_or","text":"<pre><code>static V zmbt::lang::Operator::generic_bit_or (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_bit_xor","title":"function generic_bit_xor","text":"<pre><code>static V zmbt::lang::Operator::generic_bit_xor (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_complement","title":"function generic_complement","text":"<pre><code>static V zmbt::lang::Operator::generic_complement (\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_decorate","title":"function generic_decorate","text":"<pre><code>static V zmbt::lang::Operator::generic_decorate (\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_divides","title":"function generic_divides","text":"<pre><code>static V zmbt::lang::Operator::generic_divides (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_equal_to","title":"function generic_equal_to","text":"<pre><code>static V zmbt::lang::Operator::generic_equal_to (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_is_truth","title":"function generic_is_truth","text":"<pre><code>static V zmbt::lang::Operator::generic_is_truth (\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_left_shift","title":"function generic_left_shift","text":"<pre><code>static V zmbt::lang::Operator::generic_left_shift (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_less","title":"function generic_less","text":"<pre><code>static V zmbt::lang::Operator::generic_less (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_less_equal","title":"function generic_less_equal","text":"<pre><code>static V zmbt::lang::Operator::generic_less_equal (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_log","title":"function generic_log","text":"<pre><code>static V zmbt::lang::Operator::generic_log (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_logical_and","title":"function generic_logical_and","text":"<pre><code>static V zmbt::lang::Operator::generic_logical_and (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_logical_not","title":"function generic_logical_not","text":"<pre><code>static V zmbt::lang::Operator::generic_logical_not (\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_logical_or","title":"function generic_logical_or","text":"<pre><code>static V zmbt::lang::Operator::generic_logical_or (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_minus","title":"function generic_minus","text":"<pre><code>static V zmbt::lang::Operator::generic_minus (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_modulus","title":"function generic_modulus","text":"<pre><code>static V zmbt::lang::Operator::generic_modulus (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_multiplies","title":"function generic_multiplies","text":"<pre><code>static V zmbt::lang::Operator::generic_multiplies (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_negate","title":"function generic_negate","text":"<pre><code>static V zmbt::lang::Operator::generic_negate (\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_plus","title":"function generic_plus","text":"<pre><code>static V zmbt::lang::Operator::generic_plus (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_pow","title":"function generic_pow","text":"<pre><code>static V zmbt::lang::Operator::generic_pow (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_quot","title":"function generic_quot","text":"<pre><code>static V zmbt::lang::Operator::generic_quot (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_right_shift","title":"function generic_right_shift","text":"<pre><code>static V zmbt::lang::Operator::generic_right_shift (\n    LV,\n    LV\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1lang_1_1Operator/#function-generic_undecorate","title":"function generic_undecorate","text":"<pre><code>static V zmbt::lang::Operator::generic_undecorate (\n    LV\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1operator__error/","title":"Struct zmbt::lang::Operator::operator_error","text":"<p>ClassList &gt; zmbt &gt; lang &gt; Operator &gt; operator_error</p> <p>Inherits the following classes: zmbt::base_error</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1operator__error/#public-functions","title":"Public Functions","text":"Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1operator__error/#public-functions-inherited-from-zmbtbase_error","title":"Public Functions inherited from zmbt::base_error","text":"<p>See zmbt::base_error</p> Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1operator__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1operator__error/#function-base_error","title":"function base_error","text":"<pre><code>template&lt;class... A&gt;\ninline zmbt::lang::Operator::operator_error::base_error (\n    boost::json::string_view fmtstr,\n    A &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBase/","title":"Struct zmbt::lang::SignatureBase","text":"<p>template &lt;Keyword K&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; SignatureBase</p> <p>Inherits the following classes: zmbt::lang::Expression</p> <p>Inherited by the following classes: zmbt::lang::SignatureBinary,  zmbt::lang::SignatureBinary,  zmbt::lang::SignatureBinary,  zmbt::lang::SignatureConst,  zmbt::lang::SignatureUnary,  zmbt::lang::SignatureVariadic</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBase/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBase/#public-functions","title":"Public Functions","text":"Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBase/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBase/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBase/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBase/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBase/#function-signaturebase","title":"function SignatureBase","text":"<pre><code>inline zmbt::lang::SignatureBase::SignatureBase () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/","title":"Struct zmbt::lang::SignatureBinary","text":"<p>template &lt;Keyword K&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; SignatureBinary</p> <p>Binary expression. More...</p> <ul> <li><code>#include &lt;api_signatures.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::lang::SignatureBase</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#public-functions","title":"Public Functions","text":"Type Name Expression operator() (Expression const &amp; param) constMake parametrized expression. Expression operator() (Expression &amp;&amp; param) const Expression operator() (std::initializer_list&lt; Expression &gt; param) constMake parametrized expression with initializer list."},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#public-functions-inherited-from-zmbtlangsignaturebase","title":"Public Functions inherited from zmbt::lang::SignatureBase","text":"<p>See zmbt::lang::SignatureBase</p> Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>K</code> keyword </li> </ul>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#syntactic-forms","title":"Syntactic forms","text":"<p>Syntatic forms over operator <code>*</code>: *    [E    \\mapsto ([x, y] \\mapsto x * y      )]</p> <ul> <li> <p>[E    \\mapsto (x      \\mapsto x * default)]</p> </li> <li> <p>[E(y) \\mapsto (x      \\mapsto x * y      )]</p> </li> </ul> <p>The second form is used in place of first for expressions that have default value defined, see documentation for specific expression.</p> <p>In the third form the expression parameter is used as the right-hand side operand. </p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#function-operator","title":"function operator()","text":"<p>Make parametrized expression. <pre><code>inline Expression zmbt::lang::SignatureBinary::operator() (\n    Expression const &amp; param\n) const\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#function-operator_1","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureBinary::operator() (\n    Expression &amp;&amp; param\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary/#function-operator_2","title":"function operator()","text":"<p>Make parametrized expression with initializer list. <pre><code>inline Expression zmbt::lang::SignatureBinary::operator() (\n    std::initializer_list&lt; Expression &gt; param\n) const\n</code></pre></p> <p>Interpret {x} as single-element array instead of using default boost::json::value ctor </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/","title":"Struct zmbt::lang::SignatureBinary&lt; Keyword::PreProc &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; SignatureBinary&lt; Keyword::PreProc &gt;</p> <p>Inherits the following classes: zmbt::lang::SignatureBase</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#public-functions","title":"Public Functions","text":"Type Name Expression operator() (boost::json::string_view const param) constMake parametrized expression. Expression operator() (std::size_t const param) constMake parametrized expression."},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#public-functions-inherited-from-zmbtlangsignaturebase","title":"Public Functions inherited from zmbt::lang::SignatureBase","text":"<p>See zmbt::lang::SignatureBase</p> Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#function-operator","title":"function operator()","text":"<p>Make parametrized expression. <pre><code>inline Expression zmbt::lang::SignatureBinary&lt; Keyword::PreProc &gt;::operator() (\n    boost::json::string_view const param\n) const\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureBinary_3_01Keyword_1_1PreProc_01_4/#function-operator_1","title":"function operator()","text":"<p>Make parametrized expression. <pre><code>inline Expression zmbt::lang::SignatureBinary&lt; Keyword::PreProc &gt;::operator() (\n    std::size_t const param\n) const\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/","title":"Struct zmbt::lang::SignatureCast","text":"<p>ClassList &gt; zmbt &gt; lang &gt; SignatureCast</p> <p>Inherits the following classes: zmbt::lang::SignatureBinary</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#public-functions","title":"Public Functions","text":"Type Name Expression operator() (type_tag&lt; T &gt; tag) const"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#public-functions-inherited-from-zmbtlangsignaturebinary","title":"Public Functions inherited from zmbt::lang::SignatureBinary","text":"<p>See zmbt::lang::SignatureBinary</p> Type Name Expression operator() (Expression const &amp; param) constMake parametrized expression. Expression operator() (Expression &amp;&amp; param) const Expression operator() (std::initializer_list&lt; Expression &gt; param) constMake parametrized expression with initializer list."},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#public-functions-inherited-from-zmbtlangsignaturebase","title":"Public Functions inherited from zmbt::lang::SignatureBase","text":"<p>See zmbt::lang::SignatureBase</p> Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureCast/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class T&gt;\ninline Expression zmbt::lang::SignatureCast::operator() (\n    type_tag &lt; T &gt; tag\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureConst/","title":"Struct zmbt::lang::SignatureConst","text":"<p>template &lt;Keyword K&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; SignatureConst</p> <p>Const expression. More...</p> <ul> <li><code>#include &lt;api_signatures.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::lang::SignatureBase</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureConst/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureConst/#public-functions-inherited-from-zmbtlangsignaturebase","title":"Public Functions inherited from zmbt::lang::SignatureBase","text":"<p>See zmbt::lang::SignatureBase</p> Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureConst/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureConst/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureConst/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureConst/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureConst/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>K</code> keyword </li> </ul>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureConst/#syntactic-forms","title":"Syntactic forms","text":"<p>Syntatic form over constant C: \\(E \\mapsto (x \\mapsto C)\\) </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/","title":"Struct zmbt::lang::SignatureErr","text":"<p>ClassList &gt; zmbt &gt; lang &gt; SignatureErr</p> <p>Inherits the following classes: zmbt::lang::SignatureBase</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#public-functions","title":"Public Functions","text":"Type Name Expression operator() (boost::json::object payload) const Expression operator() (boost::json::string_view msg, boost::json::string_view ctx=\"\") constError message and context. Expression operator() (type_tag&lt; T &gt;, boost::json::string msg=\"\", boost::json::string ctx=\"\") constError type, message, and context."},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#public-functions-inherited-from-zmbtlangsignaturebase","title":"Public Functions inherited from zmbt::lang::SignatureBase","text":"<p>See zmbt::lang::SignatureBase</p> Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#function-operator","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureErr::operator() (\n    boost::json::object payload\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#function-operator_1","title":"function operator()","text":"<p>Error message and context. <pre><code>inline Expression zmbt::lang::SignatureErr::operator() (\n    boost::json::string_view msg,\n    boost::json::string_view ctx=\"\"\n) const\n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureErr/#function-operator_2","title":"function operator()","text":"<p>Error type, message, and context. <pre><code>template&lt;class T&gt;\ninline Expression zmbt::lang::SignatureErr::operator() (\n    type_tag &lt; T &gt;,\n    boost::json::string msg=\"\",\n    boost::json::string ctx=\"\"\n) const\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/","title":"Struct zmbt::lang::SignatureOp","text":"<p>ClassList &gt; zmbt &gt; lang &gt; SignatureOp</p> <p>Inherits the following classes: zmbt::lang::SignatureBase</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#public-functions","title":"Public Functions","text":"Type Name Expression operator() (Expression const &amp; type, Expression const &amp; expr) const Expression operator() (type_tag&lt; T &gt; tag, Expression const &amp; expr) const"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#public-functions-inherited-from-zmbtlangsignaturebase","title":"Public Functions inherited from zmbt::lang::SignatureBase","text":"<p>See zmbt::lang::SignatureBase</p> Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#function-operator","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureOp::operator() (\n    Expression const &amp; type,\n    Expression const &amp; expr\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureOp/#function-operator_1","title":"function operator()","text":"<pre><code>template&lt;class T&gt;\ninline Expression zmbt::lang::SignatureOp::operator() (\n    type_tag &lt; T &gt; tag,\n    Expression const &amp; expr\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUnary/","title":"Struct zmbt::lang::SignatureUnary","text":"<p>template &lt;Keyword K&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; SignatureUnary</p> <p>Unary expression. More...</p> <ul> <li><code>#include &lt;api_signatures.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::lang::SignatureBase</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUnary/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUnary/#public-functions-inherited-from-zmbtlangsignaturebase","title":"Public Functions inherited from zmbt::lang::SignatureBase","text":"<p>See zmbt::lang::SignatureBase</p> Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUnary/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUnary/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUnary/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUnary/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUnary/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>K</code> keyword </li> </ul>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUnary/#syntactic-forms","title":"Syntactic forms","text":"<p>Syntatic form over function f: \\(E \\mapsto (x \\mapsto f(x))\\) </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/","title":"Struct zmbt::lang::SignatureUncast","text":"<p>ClassList &gt; zmbt &gt; lang &gt; SignatureUncast</p> <p>Inherits the following classes: zmbt::lang::SignatureBinary</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#public-functions","title":"Public Functions","text":"Type Name Expression operator() (type_tag&lt; T &gt; tag) const"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#public-functions-inherited-from-zmbtlangsignaturebinary","title":"Public Functions inherited from zmbt::lang::SignatureBinary","text":"<p>See zmbt::lang::SignatureBinary</p> Type Name Expression operator() (Expression const &amp; param) constMake parametrized expression. Expression operator() (Expression &amp;&amp; param) const Expression operator() (std::initializer_list&lt; Expression &gt; param) constMake parametrized expression with initializer list."},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#public-functions-inherited-from-zmbtlangsignaturebase","title":"Public Functions inherited from zmbt::lang::SignatureBase","text":"<p>See zmbt::lang::SignatureBase</p> Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureUncast/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class T&gt;\ninline Expression zmbt::lang::SignatureUncast::operator() (\n    type_tag &lt; T &gt; tag\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/","title":"Struct zmbt::lang::SignatureVariadic","text":"<p>template &lt;Keyword K&gt;</p> <p>ClassList &gt; zmbt &gt; lang &gt; SignatureVariadic</p> <p>Variadic expression. More...</p> <ul> <li><code>#include &lt;api_signatures.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::lang::SignatureBase</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#public-types","title":"Public Types","text":"Type Name typedef Expression E"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#public-types-inherited-from-zmbtlangexpressionview","title":"Public Types inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name typedef lang::Keyword Keyword typedef boost::json::value V"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#public-functions","title":"Public Functions","text":"Type Name Expression operator() () const Expression operator() (E const &amp; p0) const Expression operator() (E const &amp; p0, E const &amp; p1) const Expression operator() (E const &amp; p0, E const &amp; p1, E const &amp; p2) const Expression operator() (E const &amp; p0, E const &amp; p1, E const &amp; p2, E const &amp; p3) const Expression operator() (E const &amp; p0, E const &amp; p1, E const &amp; p2, E const &amp; p3, E const &amp; p4) const Expression operator() (E const &amp; p0, E const &amp; p1, E const &amp; p2, E const &amp; p3, E const &amp; p4, E const &amp; p5) const Expression operator() (E const &amp; p0, E const &amp; p1, E const &amp; p2, E const &amp; p3, E const &amp; p4, E const &amp; p5, E const &amp; p6) const Expression operator() (E const &amp; p0, E const &amp; p1, E const &amp; p2, E const &amp; p3, E const &amp; p4, E const &amp; p5, E const &amp; p6, E const &amp; p7) const Expression operator() (E const &amp; p0, E const &amp; p1, E const &amp; p2, E const &amp; p3, E const &amp; p4, E const &amp; p5, E const &amp; p6, E const &amp; p7, T &amp;&amp;... rest) const"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#public-functions-inherited-from-zmbtlangsignaturebase","title":"Public Functions inherited from zmbt::lang::SignatureBase","text":"<p>See zmbt::lang::SignatureBase</p> Type Name SignatureBase ()"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#public-functions-inherited-from-zmbtlangexpression","title":"Public Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Expression ()  Expression (Encoding &amp;&amp; encoding)  Expression (Encoding const &amp; encoding)  Expression (boost::json::value const &amp; expr)  Expression (boost::json::value &amp;&amp; expr)  Expression (std::initializer_list&lt; boost::json::value_ref &gt; items)  Expression (T sample)  Expression (Keyword const &amp; keyword)  Expression (ExpressionView const &amp; view)  Expression (Expression const &amp; other)  Expression (Expression &amp;&amp; other)  Encoding encoding () const bool operator!= (Expression v) const Expression &amp; operator= (Expression const &amp; other)  Expression &amp; operator= (Expression &amp;&amp; other)  bool operator== (Expression v) const ~Expression () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#public-functions-inherited-from-zmbtlangexpressionview","title":"Public Functions inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name ExpressionView ()  ExpressionView (ExpressionView const &amp;) = default ExpressionView (ExpressionView &amp;&amp;) = default ExpressionView (EncodingView v)  ExpressionView (Encoding enc)  boost::json::array const &amp; as_array () const bool as_bool () const boost::json::object const &amp; as_object () const boost::json::string const &amp; as_string () const boost::json::value const &amp; data () const EncodingView encoding_view () const std::string error_id () const boost::json::value eval (boost::json::value const &amp; x=nullptr, EvalContext ctx={}) constEvaluate expression. bool eval_as_predicate (ExpressionView const &amp; x, Expression &amp; err_sts, EvalContext ctx) const bool eval_as_predicate (boost::json::value const &amp; x, Expression &amp; err_sts, EvalContext ctx) const Expression eval_e (ExpressionView const &amp; x, EvalContext ctx) constEvaluate expression. Expression eval_maybe_predicate (ExpressionView const &amp; x, EvalContext ctx) const bool has_subexpr () const boost::json::array const * if_array () const bool const * if_bool () const boost::json::object const * if_object () const boost::json::string const * if_string () const bool is (Keyword const kwrd) const bool is_boolean () const bool is_complete_flip () const bool is_compose () const bool is_const () const bool is_error () const bool is_fork () const bool is_infix_fork () const bool is_infix_pipe () const bool is_infix_tuple () const bool is_link () const bool is_literal () const bool is_noop () const bool is_null () const bool is_preproc () const bool is_tuple () const bool is_valid_link () const Keyword keyword () const boost::json::string_view keyword_to_str () const bool match (boost::json::value const &amp; x, Operator const &amp; op={}) constEval and cast to boolean, return false on error. bool operator!= (ExpressionView const &amp; o) const ExpressionView &amp; operator= (ExpressionView const &amp;) = default ExpressionView &amp; operator= (ExpressionView &amp;&amp;) = default bool operator== (ExpressionView const &amp; o) const std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; preprocessing_parameters () constList of [param, json ptr]. std::string prettify () const std::ostream &amp; prettify_to (std::ostream &amp; os) const void prettify_to (char(&amp;) buff) const void prettify_to (char * buff, std::size_t n) const std::string serialize () const std::list&lt; ExpressionView &gt; subexpressions_list () constSubexpressions. boost::json::value to_json () const std::list&lt; ExpressionView &gt; tuple_parameters () const virtual ~ExpressionView () = default"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#public-static-functions-inherited-from-zmbtlangexpression","title":"Public Static Functions inherited from zmbt::lang::Expression","text":"<p>See zmbt::lang::Expression</p> Type Name Encoding encodeLiteral (boost::json::value const &amp; params)  Encoding encodeNested (Keyword const &amp; keyword, std::initializer_list&lt; Expression &gt; subexpressions)  Encoding encodeNested (Keyword const &amp; keyword, std::vector&lt; Expression &gt; &amp;&amp; subexpressions)  Encoding encodePreProc (boost::json::value const &amp; params)  bool to_predicate_if_const (Expression &amp; e)"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#protected-attributes-inherited-from-zmbtlangexpressionview","title":"Protected Attributes inherited from zmbt::lang::ExpressionView","text":"<p>See zmbt::lang::ExpressionView</p> Type Name std::shared_ptr&lt; Expression &gt; const_predicate_cache_ EncodingView encoding_view_"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>K</code> keyword </li> </ul>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#syntactic-forms","title":"Syntactic forms","text":"<p>Syntatic form over function f: \\(E(a,b,c,...) \\mapsto (x \\mapsto f(a,b,c,...)(x))\\) </p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#typedef-e","title":"typedef E","text":"<pre><code>using zmbt::lang::SignatureVariadic&lt; K &gt;::E =  Expression;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureVariadic::operator() () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator_1","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureVariadic::operator() (\n    E const &amp; p0\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator_2","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureVariadic::operator() (\n    E const &amp; p0,\n    E const &amp; p1\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator_3","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureVariadic::operator() (\n    E const &amp; p0,\n    E const &amp; p1,\n    E const &amp; p2\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator_4","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureVariadic::operator() (\n    E const &amp; p0,\n    E const &amp; p1,\n    E const &amp; p2,\n    E const &amp; p3\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator_5","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureVariadic::operator() (\n    E const &amp; p0,\n    E const &amp; p1,\n    E const &amp; p2,\n    E const &amp; p3,\n    E const &amp; p4\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator_6","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureVariadic::operator() (\n    E const &amp; p0,\n    E const &amp; p1,\n    E const &amp; p2,\n    E const &amp; p3,\n    E const &amp; p4,\n    E const &amp; p5\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator_7","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureVariadic::operator() (\n    E const &amp; p0,\n    E const &amp; p1,\n    E const &amp; p2,\n    E const &amp; p3,\n    E const &amp; p4,\n    E const &amp; p5,\n    E const &amp; p6\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator_8","title":"function operator()","text":"<pre><code>inline Expression zmbt::lang::SignatureVariadic::operator() (\n    E const &amp; p0,\n    E const &amp; p1,\n    E const &amp; p2,\n    E const &amp; p3,\n    E const &amp; p4,\n    E const &amp; p5,\n    E const &amp; p6,\n    E const &amp; p7\n) const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1SignatureVariadic/#function-operator_9","title":"function operator()","text":"<pre><code>template&lt;class... T&gt;\ninline Expression zmbt::lang::SignatureVariadic::operator() (\n    E const &amp; p0,\n    E const &amp; p1,\n    E const &amp; p2,\n    E const &amp; p3,\n    E const &amp; p4,\n    E const &amp; p5,\n    E const &amp; p6,\n    E const &amp; p7,\n    T &amp;&amp;... rest\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/","title":"Namespace zmbt::lang::attr","text":"<p>Namespace List &gt; zmbt &gt; lang &gt; attr</p>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#public-attributes","title":"Public Attributes","text":"Type Name constexpr std::uint32_t is_autogen   = <code>1 &amp;lt;&amp;lt; 17</code> constexpr std::uint32_t is_binary   = <code>1 &amp;lt;&amp;lt;  3</code> constexpr std::uint32_t is_const   = <code>1 &amp;lt;&amp;lt;  1</code> constexpr std::uint32_t is_error   = <code>1 &amp;lt;&amp;lt; 12</code> constexpr std::uint32_t is_fork   = <code>1 &amp;lt;&amp;lt; 14</code> constexpr std::uint32_t is_hiord   = <code>1 &amp;lt;&amp;lt;  7</code> constexpr std::uint32_t is_infix_chain   = <code>1 &amp;lt;&amp;lt; 16</code> constexpr std::uint32_t is_literal   = <code>1 &amp;lt;&amp;lt;  9</code> constexpr std::uint32_t is_noop   = <code>1 &amp;lt;&amp;lt;  8</code> constexpr std::uint32_t is_operator   = <code>1 &amp;lt;&amp;lt;  6</code> constexpr std::uint32_t is_overload   = <code>1 &amp;lt;&amp;lt; 15</code> constexpr std::uint32_t is_pipe   = <code>1 &amp;lt;&amp;lt; 13</code> constexpr std::uint32_t is_predicate   = <code>1 &amp;lt;&amp;lt;  5</code> constexpr std::uint32_t is_preproc   = <code>1 &amp;lt;&amp;lt; 11</code> constexpr std::uint32_t is_quote   = <code>1 &amp;lt;&amp;lt; 10</code> constexpr std::uint32_t is_unary   = <code>1 &amp;lt;&amp;lt;  2</code> constexpr std::uint32_t is_variadic   = <code>1 &amp;lt;&amp;lt;  4</code>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_autogen","title":"variable is_autogen","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_autogen;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_binary","title":"variable is_binary","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_binary;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_const","title":"variable is_const","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_const;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_error","title":"variable is_error","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_error;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_fork","title":"variable is_fork","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_fork;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_hiord","title":"variable is_hiord","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_hiord;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_infix_chain","title":"variable is_infix_chain","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_infix_chain;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_literal","title":"variable is_literal","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_literal;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_noop","title":"variable is_noop","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_noop;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_operator","title":"variable is_operator","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_operator;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_overload","title":"variable is_overload","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_overload;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_pipe","title":"variable is_pipe","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_pipe;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_predicate","title":"variable is_predicate","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_predicate;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_preproc","title":"variable is_preproc","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_preproc;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_quote","title":"variable is_quote","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_quote;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_unary","title":"variable is_unary","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_unary;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1lang_1_1attr/#variable-is_variadic","title":"variable is_variadic","text":"<pre><code>constexpr std::uint32_t zmbt::lang::attr::is_variadic;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/attributes.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1mapping/","title":"Namespace zmbt::mapping","text":"<p>Namespace List &gt; zmbt &gt; mapping</p> <p>Signal Mapping model functionality. </p>"},{"location":"CxxRef/namespacezmbt_1_1mapping/#classes","title":"Classes","text":"Type Name class ChannelHandle Channel clause handle for SignalMapping model. class ModelDefinition Mapping model definition machine. class PipeHandle Pipe clause handle for SignalMapping model. class SignalMapping Signal Mapping Test Model. struct TestDiagnostics Test diagnostics for test case execution. class TestParameterResolver Test spec generator that handles parameter resolution. class TestRunner Test runner for SignalMapping model. <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/channel_handle.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/","title":"Class zmbt::mapping::ChannelHandle","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ChannelHandle</p> <p>Channel clause handle for SignalMapping model.</p> <ul> <li><code>#include &lt;channel_handle.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#public-types","title":"Public Types","text":"Type Name typedef std::list&lt; ChannelHandle &gt; ConditionPipe typedef ChannelKind Kind"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#public-functions","title":"Public Functions","text":"Type Name ChannelHandle (JsonNode &amp; model, boost::json::string_view cnl_ptr)  boost::json::value alias () constChannel alias or index if not set. boost::json::array captures () const boost::json::string full_path () const object_id host () const std::size_t index () const Environment::InterfaceHandle inerface_handle () const interface_id interface () const boost::json::string key () const Kind kind () const bool operator== (boost::json::value const &amp; v) const boost::json::string signal_path () const lang::Expression transform () const ~ChannelHandle () = default"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#typedef-conditionpipe","title":"typedef ConditionPipe","text":"<pre><code>using zmbt::mapping::ChannelHandle::ConditionPipe =  std::list&lt;ChannelHandle&gt;;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#typedef-kind","title":"typedef Kind","text":"<pre><code>using zmbt::mapping::ChannelHandle::Kind =  ChannelKind;\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-channelhandle","title":"function ChannelHandle","text":"<pre><code>zmbt::mapping::ChannelHandle::ChannelHandle (\n    JsonNode &amp; model,\n    boost::json::string_view cnl_ptr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-alias","title":"function alias","text":"<p>Channel alias or index if not set. <pre><code>boost::json::value zmbt::mapping::ChannelHandle::alias () const\n</code></pre></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-captures","title":"function captures","text":"<pre><code>boost::json::array zmbt::mapping::ChannelHandle::captures () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-full_path","title":"function full_path","text":"<pre><code>boost::json::string zmbt::mapping::ChannelHandle::full_path () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-host","title":"function host","text":"<pre><code>object_id zmbt::mapping::ChannelHandle::host () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-index","title":"function index","text":"<pre><code>std::size_t zmbt::mapping::ChannelHandle::index () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-inerface_handle","title":"function inerface_handle","text":"<pre><code>Environment::InterfaceHandle zmbt::mapping::ChannelHandle::inerface_handle () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-interface","title":"function interface","text":"<pre><code>interface_id zmbt::mapping::ChannelHandle::interface () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-key","title":"function key","text":"<pre><code>boost::json::string zmbt::mapping::ChannelHandle::key () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-kind","title":"function kind","text":"<pre><code>Kind zmbt::mapping::ChannelHandle::kind () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-operator","title":"function operator==","text":"<pre><code>bool zmbt::mapping::ChannelHandle::operator== (\n    boost::json::value const &amp; v\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-signal_path","title":"function signal_path","text":"<pre><code>boost::json::string zmbt::mapping::ChannelHandle::signal_path () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-transform","title":"function transform","text":"<pre><code>lang::Expression zmbt::mapping::ChannelHandle::transform () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ChannelHandle/#function-channelhandle_1","title":"function ~ChannelHandle","text":"<pre><code>zmbt::mapping::ChannelHandle::~ChannelHandle () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/channel_handle.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition/","title":"Class zmbt::mapping::ModelDefinition","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition</p> <p>Mapping model definition machine. </p> <ul> <li><code>#include &lt;model_definition.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition/#classes","title":"Classes","text":"Type Name class BaseTransition class N_Alias class N_Channel class N_ChannelEnd class N_Decor class N_Descr class N_Filter class N_Main class N_MaybeChannel class N_Param class N_ParamTable class N_Post class N_Pre class N_Repeat class N_Take class N_Term class N_Test class N_TestTable <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/","title":"Class zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::T_Alias,  zmbt::mapping::ModelDefinition::T_As,  zmbt::mapping::ModelDefinition::T_At,  zmbt::mapping::ModelDefinition::T_ContinuePipe,  zmbt::mapping::ModelDefinition::T_CustomParam,  zmbt::mapping::ModelDefinition::T_Description,  zmbt::mapping::ModelDefinition::T_Filter,  zmbt::mapping::ModelDefinition::T_OnTrigger,  zmbt::mapping::ModelDefinition::T_Param,  zmbt::mapping::ModelDefinition::T_ParamRow,  zmbt::mapping::ModelDefinition::T_PostRun,  zmbt::mapping::ModelDefinition::T_PreRun,  zmbt::mapping::ModelDefinition::T_Repeat,  zmbt::mapping::ModelDefinition::T_Take,  zmbt::mapping::ModelDefinition::T_TerminatePipe,  zmbt::mapping::ModelDefinition::T_Test,  zmbt::mapping::ModelDefinition::T_TestRow,  zmbt::mapping::ModelDefinition::N_Term</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#public-functions","title":"Public Functions","text":"Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#protected-functions","title":"Protected Functions","text":"Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#function-basetransition","title":"function ~BaseTransition","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::BaseTransition::~BaseTransition () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#function-basetransition-14","title":"function BaseTransition [1/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::BaseTransition::BaseTransition (\n    detail::DefinitionHelper &amp;&amp; m\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#function-basetransition-24","title":"function BaseTransition [2/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::BaseTransition::BaseTransition () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#function-basetransition-34","title":"function BaseTransition [3/4]","text":"<pre><code>zmbt::mapping::ModelDefinition::BaseTransition::BaseTransition (\n    BaseTransition const &amp;\n) = delete\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#function-basetransition-44","title":"function BaseTransition [4/4]","text":"<pre><code>zmbt::mapping::ModelDefinition::BaseTransition::BaseTransition (\n    BaseTransition &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#function-state","title":"function state","text":"<pre><code>inline detail::DefinitionHelper &amp; zmbt::mapping::ModelDefinition::BaseTransition::state () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1BaseTransition/#function-transit_to","title":"function transit_to","text":"<pre><code>template&lt;class Target&gt;\ninline Target zmbt::mapping::ModelDefinition::BaseTransition::transit_to () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_node.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Alias/","title":"Class zmbt::mapping::ModelDefinition::N_Alias","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Alias</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Decor,  zmbt::mapping::ModelDefinition::T_Alias&lt; ModelDefinition::N_Decor &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Take</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Alias/#public-functions","title":"Public Functions","text":"Type Name N_Alias ()  virtual ~N_Alias ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Alias/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_decor","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Decor","text":"<p>See zmbt::mapping::ModelDefinition::N_Decor</p> Type Name N_Decor ()  virtual ~N_Decor ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Alias/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_channelend","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_ChannelEnd","text":"<p>See zmbt::mapping::ModelDefinition::N_ChannelEnd</p> Type Name N_ChannelEnd ()  virtual ~N_ChannelEnd ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Alias/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Alias/#function-n_alias-44","title":"function N_Alias [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Alias::N_Alias () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Alias/#function-n_alias","title":"function ~N_Alias","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Alias::~N_Alias () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Channel/","title":"Class zmbt::mapping::ModelDefinition::N_Channel","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Channel</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::T_At&lt; ModelDefinition::N_Filter &gt;</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Channel/#public-functions","title":"Public Functions","text":"Type Name N_Channel ()  virtual ~N_Channel ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Channel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Channel/#function-n_channel-44","title":"function N_Channel [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Channel::N_Channel () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Channel/#function-n_channel","title":"function ~N_Channel","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Channel::~N_Channel () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ChannelEnd/","title":"Class zmbt::mapping::ModelDefinition::N_ChannelEnd","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_ChannelEnd</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::T_TerminatePipe&lt; ModelDefinition::N_MaybeChannel &gt;,  zmbt::mapping::ModelDefinition::T_ContinuePipe&lt; ModelDefinition::N_Channel &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Decor</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ChannelEnd/#public-functions","title":"Public Functions","text":"Type Name N_ChannelEnd ()  virtual ~N_ChannelEnd ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ChannelEnd/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ChannelEnd/#function-n_channelend-44","title":"function N_ChannelEnd [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_ChannelEnd::N_ChannelEnd () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ChannelEnd/#function-n_channelend","title":"function ~N_ChannelEnd","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_ChannelEnd::~N_ChannelEnd () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Decor/","title":"Class zmbt::mapping::ModelDefinition::N_Decor","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Decor</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_ChannelEnd,  zmbt::mapping::ModelDefinition::T_As&lt; ModelDefinition::N_ChannelEnd &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Alias</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Decor/#public-functions","title":"Public Functions","text":"Type Name N_Decor ()  virtual ~N_Decor ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Decor/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_channelend","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_ChannelEnd","text":"<p>See zmbt::mapping::ModelDefinition::N_ChannelEnd</p> Type Name N_ChannelEnd ()  virtual ~N_ChannelEnd ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Decor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Decor/#function-n_decor-44","title":"function N_Decor [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Decor::N_Decor () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Decor/#function-n_decor","title":"function ~N_Decor","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Decor::~N_Decor () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Descr/","title":"Class zmbt::mapping::ModelDefinition::N_Descr","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Descr</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Term,  zmbt::mapping::ModelDefinition::T_Description&lt; ModelDefinition::N_Term &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Post</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Descr/#public-functions","title":"Public Functions","text":"Type Name N_Descr ()  virtual ~N_Descr ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Descr/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_term","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Term","text":"<p>See zmbt::mapping::ModelDefinition::N_Term</p> Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Descr/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Descr/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Descr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Descr/#function-n_descr-44","title":"function N_Descr [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Descr::N_Descr () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Descr/#function-n_descr","title":"function ~N_Descr","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Descr::~N_Descr () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Filter/","title":"Class zmbt::mapping::ModelDefinition::N_Filter","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Filter</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Take,  zmbt::mapping::ModelDefinition::T_Filter&lt; ModelDefinition::N_Take &gt;</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Filter/#public-functions","title":"Public Functions","text":"Type Name N_Filter ()  virtual ~N_Filter ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Filter/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_take","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Take","text":"<p>See zmbt::mapping::ModelDefinition::N_Take</p> Type Name N_Take ()  virtual ~N_Take ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Filter/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_alias","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Alias","text":"<p>See zmbt::mapping::ModelDefinition::N_Alias</p> Type Name N_Alias ()  virtual ~N_Alias ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Filter/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_decor","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Decor","text":"<p>See zmbt::mapping::ModelDefinition::N_Decor</p> Type Name N_Decor ()  virtual ~N_Decor ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Filter/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_channelend","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_ChannelEnd","text":"<p>See zmbt::mapping::ModelDefinition::N_ChannelEnd</p> Type Name N_ChannelEnd ()  virtual ~N_ChannelEnd ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Filter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Filter/#function-n_filter-44","title":"function N_Filter [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Filter::N_Filter () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Filter/#function-n_filter","title":"function ~N_Filter","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Filter::~N_Filter () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Main/","title":"Class zmbt::mapping::ModelDefinition::N_Main","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Main</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::T_OnTrigger&lt; ModelDefinition::N_Repeat &gt;</p> <p>Inherited by the following classes: zmbt::mapping::SignalMapping</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Main/#public-functions","title":"Public Functions","text":"Type Name N_Main ()  virtual ~N_Main ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Main/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Main/#function-n_main-44","title":"function N_Main [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Main::N_Main () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Main/#function-n_main","title":"function ~N_Main","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Main::~N_Main () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/","title":"Class zmbt::mapping::ModelDefinition::N_MaybeChannel","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_MaybeChannel</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Test,  zmbt::mapping::ModelDefinition::T_At&lt; ModelDefinition::N_Filter &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Repeat</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#public-functions","title":"Public Functions","text":"Type Name N_MaybeChannel ()  virtual ~N_MaybeChannel ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_test","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Test","text":"<p>See zmbt::mapping::ModelDefinition::N_Test</p> Type Name N_Test ()  virtual ~N_Test ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_param","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Param","text":"<p>See zmbt::mapping::ModelDefinition::N_Param</p> Type Name N_Param ()  virtual ~N_Param ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_pre","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Pre","text":"<p>See zmbt::mapping::ModelDefinition::N_Pre</p> Type Name N_Pre ()  virtual ~N_Pre ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_post","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Post","text":"<p>See zmbt::mapping::ModelDefinition::N_Post</p> Type Name N_Post ()  virtual ~N_Post ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_descr","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Descr","text":"<p>See zmbt::mapping::ModelDefinition::N_Descr</p> Type Name N_Descr ()  virtual ~N_Descr ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_term","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Term","text":"<p>See zmbt::mapping::ModelDefinition::N_Term</p> Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#function-n_maybechannel-44","title":"function N_MaybeChannel [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_MaybeChannel::N_MaybeChannel () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__MaybeChannel/#function-n_maybechannel","title":"function ~N_MaybeChannel","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_MaybeChannel::~N_MaybeChannel () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/","title":"Class zmbt::mapping::ModelDefinition::N_Param","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Param</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Pre,  zmbt::mapping::ModelDefinition::T_Param&lt; ModelDefinition::N_ParamTable &gt;,  zmbt::mapping::ModelDefinition::T_CustomParam&lt; ModelDefinition::N_Param &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_ParamTable,  zmbt::mapping::ModelDefinition::N_Test,  zmbt::mapping::ModelDefinition::N_TestTable</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#public-functions","title":"Public Functions","text":"Type Name N_Param ()  virtual ~N_Param ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_pre","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Pre","text":"<p>See zmbt::mapping::ModelDefinition::N_Pre</p> Type Name N_Pre ()  virtual ~N_Pre ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_post","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Post","text":"<p>See zmbt::mapping::ModelDefinition::N_Post</p> Type Name N_Post ()  virtual ~N_Post ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_descr","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Descr","text":"<p>See zmbt::mapping::ModelDefinition::N_Descr</p> Type Name N_Descr ()  virtual ~N_Descr ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_term","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Term","text":"<p>See zmbt::mapping::ModelDefinition::N_Term</p> Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#function-n_param-44","title":"function N_Param [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Param::N_Param () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Param/#function-n_param","title":"function ~N_Param","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Param::~N_Param () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/","title":"Class zmbt::mapping::ModelDefinition::N_ParamTable","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_ParamTable</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Param,  zmbt::mapping::ModelDefinition::T_ParamRow&lt; ModelDefinition::N_ParamTable &gt;</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#public-functions","title":"Public Functions","text":"Type Name N_ParamTable ()  virtual ~N_ParamTable ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_param","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Param","text":"<p>See zmbt::mapping::ModelDefinition::N_Param</p> Type Name N_Param ()  virtual ~N_Param ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_pre","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Pre","text":"<p>See zmbt::mapping::ModelDefinition::N_Pre</p> Type Name N_Pre ()  virtual ~N_Pre ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_post","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Post","text":"<p>See zmbt::mapping::ModelDefinition::N_Post</p> Type Name N_Post ()  virtual ~N_Post ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_descr","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Descr","text":"<p>See zmbt::mapping::ModelDefinition::N_Descr</p> Type Name N_Descr ()  virtual ~N_Descr ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_term","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Term","text":"<p>See zmbt::mapping::ModelDefinition::N_Term</p> Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#function-n_paramtable-44","title":"function N_ParamTable [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_ParamTable::N_ParamTable () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__ParamTable/#function-n_paramtable","title":"function ~N_ParamTable","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_ParamTable::~N_ParamTable () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Post/","title":"Class zmbt::mapping::ModelDefinition::N_Post","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Post</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Descr,  zmbt::mapping::ModelDefinition::T_PostRun&lt; ModelDefinition::N_Descr &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Pre</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Post/#public-functions","title":"Public Functions","text":"Type Name N_Post ()  virtual ~N_Post ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Post/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_descr","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Descr","text":"<p>See zmbt::mapping::ModelDefinition::N_Descr</p> Type Name N_Descr ()  virtual ~N_Descr ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Post/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_term","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Term","text":"<p>See zmbt::mapping::ModelDefinition::N_Term</p> Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Post/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Post/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Post/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Post/#function-n_post-44","title":"function N_Post [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Post::N_Post () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Post/#function-n_post","title":"function ~N_Post","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Post::~N_Post () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/","title":"Class zmbt::mapping::ModelDefinition::N_Pre","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Pre</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Post,  zmbt::mapping::ModelDefinition::T_PreRun&lt; ModelDefinition::N_Post &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Param</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/#public-functions","title":"Public Functions","text":"Type Name N_Pre ()  virtual ~N_Pre ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_post","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Post","text":"<p>See zmbt::mapping::ModelDefinition::N_Post</p> Type Name N_Post ()  virtual ~N_Post ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_descr","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Descr","text":"<p>See zmbt::mapping::ModelDefinition::N_Descr</p> Type Name N_Descr ()  virtual ~N_Descr ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_term","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Term","text":"<p>See zmbt::mapping::ModelDefinition::N_Term</p> Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/#function-n_pre-44","title":"function N_Pre [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Pre::N_Pre () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Pre/#function-n_pre","title":"function ~N_Pre","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Pre::~N_Pre () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/","title":"Class zmbt::mapping::ModelDefinition::N_Repeat","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Repeat</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_MaybeChannel,  zmbt::mapping::ModelDefinition::T_Repeat&lt; ModelDefinition::N_MaybeChannel &gt;</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions","title":"Public Functions","text":"Type Name N_Repeat ()  virtual ~N_Repeat ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_maybechannel","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_MaybeChannel","text":"<p>See zmbt::mapping::ModelDefinition::N_MaybeChannel</p> Type Name N_MaybeChannel ()  virtual ~N_MaybeChannel ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_test","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Test","text":"<p>See zmbt::mapping::ModelDefinition::N_Test</p> Type Name N_Test ()  virtual ~N_Test ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_param","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Param","text":"<p>See zmbt::mapping::ModelDefinition::N_Param</p> Type Name N_Param ()  virtual ~N_Param ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_pre","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Pre","text":"<p>See zmbt::mapping::ModelDefinition::N_Pre</p> Type Name N_Pre ()  virtual ~N_Pre ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_post","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Post","text":"<p>See zmbt::mapping::ModelDefinition::N_Post</p> Type Name N_Post ()  virtual ~N_Post ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_descr","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Descr","text":"<p>See zmbt::mapping::ModelDefinition::N_Descr</p> Type Name N_Descr ()  virtual ~N_Descr ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_term","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Term","text":"<p>See zmbt::mapping::ModelDefinition::N_Term</p> Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#function-n_repeat-44","title":"function N_Repeat [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Repeat::N_Repeat () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Repeat/#function-n_repeat","title":"function ~N_Repeat","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Repeat::~N_Repeat () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Take/","title":"Class zmbt::mapping::ModelDefinition::N_Take","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Take</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Alias,  zmbt::mapping::ModelDefinition::T_Take&lt; ModelDefinition::N_Alias &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Filter</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Take/#public-functions","title":"Public Functions","text":"Type Name N_Take ()  virtual ~N_Take ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Take/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_alias","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Alias","text":"<p>See zmbt::mapping::ModelDefinition::N_Alias</p> Type Name N_Alias ()  virtual ~N_Alias ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Take/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_decor","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Decor","text":"<p>See zmbt::mapping::ModelDefinition::N_Decor</p> Type Name N_Decor ()  virtual ~N_Decor ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Take/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_channelend","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_ChannelEnd","text":"<p>See zmbt::mapping::ModelDefinition::N_ChannelEnd</p> Type Name N_ChannelEnd ()  virtual ~N_ChannelEnd ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Take/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Take/#function-n_take-44","title":"function N_Take [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Take::N_Take () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Take/#function-n_take","title":"function ~N_Take","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Take::~N_Take () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Term/","title":"Class zmbt::mapping::ModelDefinition::N_Term","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Term</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Descr</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Term/#public-functions","title":"Public Functions","text":"Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Term/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Term/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Term/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Term/#function-n_term-44","title":"function N_Term [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Term::N_Term () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Term/#function-n_term","title":"function ~N_Term","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Term::~N_Term () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_node.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/","title":"Class zmbt::mapping::ModelDefinition::N_Test","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_Test</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Param,  zmbt::mapping::ModelDefinition::T_Test&lt; ModelDefinition::N_TestTable &gt;</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_MaybeChannel</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#public-functions","title":"Public Functions","text":"Type Name N_Test ()  virtual ~N_Test ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_param","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Param","text":"<p>See zmbt::mapping::ModelDefinition::N_Param</p> Type Name N_Param ()  virtual ~N_Param ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_pre","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Pre","text":"<p>See zmbt::mapping::ModelDefinition::N_Pre</p> Type Name N_Pre ()  virtual ~N_Pre ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_post","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Post","text":"<p>See zmbt::mapping::ModelDefinition::N_Post</p> Type Name N_Post ()  virtual ~N_Post ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_descr","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Descr","text":"<p>See zmbt::mapping::ModelDefinition::N_Descr</p> Type Name N_Descr ()  virtual ~N_Descr ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_term","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Term","text":"<p>See zmbt::mapping::ModelDefinition::N_Term</p> Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#function-n_test-44","title":"function N_Test [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_Test::N_Test () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__Test/#function-n_test","title":"function ~N_Test","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_Test::~N_Test () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/","title":"Class zmbt::mapping::ModelDefinition::N_TestTable","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; ModelDefinition &gt; N_TestTable</p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Param,  zmbt::mapping::ModelDefinition::T_TestRow&lt; ModelDefinition::N_TestTable &gt;</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#public-functions","title":"Public Functions","text":"Type Name N_TestTable ()  virtual ~N_TestTable ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_param","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Param","text":"<p>See zmbt::mapping::ModelDefinition::N_Param</p> Type Name N_Param ()  virtual ~N_Param ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_pre","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Pre","text":"<p>See zmbt::mapping::ModelDefinition::N_Pre</p> Type Name N_Pre ()  virtual ~N_Pre ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_post","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Post","text":"<p>See zmbt::mapping::ModelDefinition::N_Post</p> Type Name N_Post ()  virtual ~N_Post ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_descr","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Descr","text":"<p>See zmbt::mapping::ModelDefinition::N_Descr</p> Type Name N_Descr ()  virtual ~N_Descr ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_term","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Term","text":"<p>See zmbt::mapping::ModelDefinition::N_Term</p> Type Name N_Term ()  virtual ~N_Term ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#function-n_testtable-44","title":"function N_TestTable [4/4]","text":"<pre><code>inline zmbt::mapping::ModelDefinition::N_TestTable::N_TestTable () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1ModelDefinition_1_1N__TestTable/#function-n_testtable","title":"function ~N_TestTable","text":"<pre><code>inline virtual zmbt::mapping::ModelDefinition::N_TestTable::~N_TestTable () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/","title":"Class zmbt::mapping::PipeHandle","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; PipeHandle</p> <p>Pipe clause handle for SignalMapping model.</p> <ul> <li><code>#include &lt;pipe_handle.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#public-functions","title":"Public Functions","text":"Type Name PipeHandle (JsonNode &amp; model, std::size_t const pipe_idx)  std::list&lt; ChannelHandle &gt; const &amp; channels () const int column () const lang::Expression expression () const bool has_expression () const boost::json::value index () const void inject (lang::Expression expr) const bool is_input () const bool is_output () const boost::json::value observe () const bool overload (lang::Expression &amp; e) const boost::json::value type () const ~PipeHandle () = default"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-pipehandle","title":"function PipeHandle","text":"<pre><code>zmbt::mapping::PipeHandle::PipeHandle (\n    JsonNode &amp; model,\n    std::size_t const pipe_idx\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-channels","title":"function channels","text":"<pre><code>inline std::list&lt; ChannelHandle &gt; const &amp; zmbt::mapping::PipeHandle::channels () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-column","title":"function column","text":"<pre><code>int zmbt::mapping::PipeHandle::column () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-expression","title":"function expression","text":"<pre><code>lang::Expression zmbt::mapping::PipeHandle::expression () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-has_expression","title":"function has_expression","text":"<pre><code>bool zmbt::mapping::PipeHandle::has_expression () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-index","title":"function index","text":"<pre><code>boost::json::value zmbt::mapping::PipeHandle::index () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-inject","title":"function inject","text":"<pre><code>void zmbt::mapping::PipeHandle::inject (\n    lang::Expression expr\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-is_input","title":"function is_input","text":"<pre><code>bool zmbt::mapping::PipeHandle::is_input () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-is_output","title":"function is_output","text":"<pre><code>bool zmbt::mapping::PipeHandle::is_output () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-observe","title":"function observe","text":"<pre><code>boost::json::value zmbt::mapping::PipeHandle::observe () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-overload","title":"function overload","text":"<pre><code>bool zmbt::mapping::PipeHandle::overload (\n    lang::Expression &amp; e\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-type","title":"function type","text":"<pre><code>boost::json::value zmbt::mapping::PipeHandle::type () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1PipeHandle/#function-pipehandle_1","title":"function ~PipeHandle","text":"<pre><code>zmbt::mapping::PipeHandle::~PipeHandle () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/pipe_handle.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1SignalMapping/","title":"Class zmbt::mapping::SignalMapping","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; SignalMapping</p> <p>Signal Mapping Test Model. More...</p> <ul> <li><code>#include &lt;model_definition_main.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::N_Main</p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1SignalMapping/#public-functions","title":"Public Functions","text":"Type Name SignalMapping (boost::json::string_view name, T &amp;&amp;... args) Begin the model definition. ~SignalMapping ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1SignalMapping/#public-functions-inherited-from-zmbtmappingmodeldefinitionn_main","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::N_Main","text":"<p>See zmbt::mapping::ModelDefinition::N_Main</p> Type Name N_Main ()  virtual ~N_Main ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1SignalMapping/#detailed-description","title":"Detailed Description","text":"<p>See also: Signal Mapping model </p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1SignalMapping/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1SignalMapping/#function-signalmapping","title":"function SignalMapping","text":"<p>Begin the model definition. <pre><code>template&lt;class... T&gt;\ninline zmbt::mapping::SignalMapping::SignalMapping (\n    boost::json::string_view name,\n    T &amp;&amp;... args\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>name</code> model name or format pattern string </li> <li><code>args</code> format arguments </li> </ul>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1SignalMapping/#function-signalmapping_1","title":"function ~SignalMapping","text":"<pre><code>inline zmbt::mapping::SignalMapping::~SignalMapping () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_main.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/","title":"Struct zmbt::mapping::TestDiagnostics","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; TestDiagnostics</p> <p>Test diagnostics for test case execution. </p> <ul> <li><code>#include &lt;test_diagnostics.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#public-types","title":"Public Types","text":"Type Name enum Result"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#public-attributes","title":"Public Attributes","text":"Type Name boost::json::value channel_id   = <code>{}</code> boost::json::string comment   = <code>{}</code> boost::json::string description   = <code>{}</code> boost::json::value error   = <code>{}</code> boost::json::array eval_stack   = <code>{}</code> boost::json::value expected   = <code>{}</code> boost::json::string message   = <code>{}</code> boost::json::string model_name boost::json::value observed   = <code>{}</code> boost::json::value pipe_id   = <code>{}</code> Result result   = <code>{}</code> bool tabular_condition_failure_   = <code>{}</code> size_t tc   = <code>{}</code> size_t tr   = <code>{}</code> boost::json::value vector   = <code>{}</code>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#public-functions","title":"Public Functions","text":"Type Name TestDiagnostics &amp; ChannelId (boost::json::value const &amp; id)  TestDiagnostics &amp; Comment (boost::json::string_view msg)  TestDiagnostics &amp; Description (boost::json::string_view msg)  TestDiagnostics &amp; Error (boost::json::string_view origin, boost::json::value const &amp; err) report test setup or execution error TestDiagnostics &amp; EvalStack (lang::EvalLog const &amp; log)  TestDiagnostics &amp; Fail (lang::Expression const &amp; expected, boost::json::value const &amp; observed) report test expectation failure TestDiagnostics &amp; PipeId (boost::json::value const &amp; id)  TestDiagnostics &amp; TabularConditionFailure (std::size_t const col)  TestDiagnostics (boost::json::string_view model_name)  TestDiagnostics (TestDiagnostics const &amp;) = default TestDiagnostics (TestDiagnostics &amp;&amp;) = default TestDiagnostics &amp; TestRow (std::size_t const r)  TestDiagnostics &amp; Vector (boost::json::value val)  TestDiagnostics &amp; operator= (TestDiagnostics const &amp;) = default TestDiagnostics &amp; operator= (TestDiagnostics &amp;&amp;) = default boost::json::value to_json () const ~TestDiagnostics () = default"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#enum-result","title":"enum Result","text":"<pre><code>enum zmbt::mapping::TestDiagnostics::Result {\n    Success,\n    Fail,\n    Error\n};\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-channel_id","title":"variable channel_id","text":"<pre><code>boost::json::value zmbt::mapping::TestDiagnostics::channel_id;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-comment","title":"variable comment","text":"<pre><code>boost::json::string zmbt::mapping::TestDiagnostics::comment;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-description","title":"variable description","text":"<pre><code>boost::json::string zmbt::mapping::TestDiagnostics::description;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-error","title":"variable error","text":"<pre><code>boost::json::value zmbt::mapping::TestDiagnostics::error;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-eval_stack","title":"variable eval_stack","text":"<pre><code>boost::json::array zmbt::mapping::TestDiagnostics::eval_stack;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-expected","title":"variable expected","text":"<pre><code>boost::json::value zmbt::mapping::TestDiagnostics::expected;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-message","title":"variable message","text":"<pre><code>boost::json::string zmbt::mapping::TestDiagnostics::message;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-model_name","title":"variable model_name","text":"<pre><code>boost::json::string zmbt::mapping::TestDiagnostics::model_name;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-observed","title":"variable observed","text":"<pre><code>boost::json::value zmbt::mapping::TestDiagnostics::observed;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-pipe_id","title":"variable pipe_id","text":"<pre><code>boost::json::value zmbt::mapping::TestDiagnostics::pipe_id;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-result","title":"variable result","text":"<pre><code>Result zmbt::mapping::TestDiagnostics::result;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-tabular_condition_failure_","title":"variable tabular_condition_failure_","text":"<pre><code>bool zmbt::mapping::TestDiagnostics::tabular_condition_failure_;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-tc","title":"variable tc","text":"<pre><code>size_t zmbt::mapping::TestDiagnostics::tc;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-tr","title":"variable tr","text":"<pre><code>size_t zmbt::mapping::TestDiagnostics::tr;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#variable-vector","title":"variable vector","text":"<pre><code>boost::json::value zmbt::mapping::TestDiagnostics::vector;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-channelid","title":"function ChannelId","text":"<pre><code>inline TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::ChannelId (\n    boost::json::value const &amp; id\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-comment","title":"function Comment","text":"<pre><code>inline TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::Comment (\n    boost::json::string_view msg\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-description","title":"function Description","text":"<pre><code>inline TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::Description (\n    boost::json::string_view msg\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-error","title":"function Error","text":"<p>report test setup or execution error <pre><code>TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::Error (\n    boost::json::string_view origin,\n    boost::json::value const &amp; err\n) \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-evalstack","title":"function EvalStack","text":"<pre><code>inline TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::EvalStack (\n    lang::EvalLog const &amp; log\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-fail","title":"function Fail","text":"<p>report test expectation failure <pre><code>TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::Fail (\n    lang::Expression const &amp; expected,\n    boost::json::value const &amp; observed\n) \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-pipeid","title":"function PipeId","text":"<pre><code>inline TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::PipeId (\n    boost::json::value const &amp; id\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-tabularconditionfailure","title":"function TabularConditionFailure","text":"<pre><code>inline TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::TabularConditionFailure (\n    std::size_t const col\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-testdiagnostics-13","title":"function TestDiagnostics [1/3]","text":"<pre><code>inline zmbt::mapping::TestDiagnostics::TestDiagnostics (\n    boost::json::string_view model_name\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-testdiagnostics-23","title":"function TestDiagnostics [2/3]","text":"<pre><code>zmbt::mapping::TestDiagnostics::TestDiagnostics (\n    TestDiagnostics const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-testdiagnostics-33","title":"function TestDiagnostics [3/3]","text":"<pre><code>zmbt::mapping::TestDiagnostics::TestDiagnostics (\n    TestDiagnostics &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-testrow","title":"function TestRow","text":"<pre><code>inline TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::TestRow (\n    std::size_t const r\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-vector","title":"function Vector","text":"<pre><code>inline TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::Vector (\n    boost::json::value val\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-operator","title":"function operator=","text":"<pre><code>TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::operator= (\n    TestDiagnostics const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-operator_1","title":"function operator=","text":"<pre><code>TestDiagnostics &amp; zmbt::mapping::TestDiagnostics::operator= (\n    TestDiagnostics &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-to_json","title":"function to_json","text":"<pre><code>boost::json::value zmbt::mapping::TestDiagnostics::to_json () const\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1TestDiagnostics/#function-testdiagnostics","title":"function ~TestDiagnostics","text":"<pre><code>zmbt::mapping::TestDiagnostics::~TestDiagnostics () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/test_diagnostics.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestParameterResolver/","title":"Class zmbt::mapping::TestParameterResolver","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; TestParameterResolver</p> <p>Test spec generator that handles parameter resolution. </p> <ul> <li><code>#include &lt;test_parameter_resolver.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestParameterResolver/#public-functions","title":"Public Functions","text":"Type Name JsonNode Next ()  TestParameterResolver (JsonNode const &amp; model)"},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestParameterResolver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestParameterResolver/#function-next","title":"function Next","text":"<pre><code>JsonNode zmbt::mapping::TestParameterResolver::Next () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestParameterResolver/#function-testparameterresolver","title":"function TestParameterResolver","text":"<pre><code>zmbt::mapping::TestParameterResolver::TestParameterResolver (\n    JsonNode const &amp; model\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/test_parameter_resolver.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestRunner/","title":"Class zmbt::mapping::TestRunner","text":"<p>ClassList &gt; zmbt &gt; mapping &gt; TestRunner</p> <p>Test runner for SignalMapping model.</p> <ul> <li><code>#include &lt;test_runner.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestRunner/#public-functions","title":"Public Functions","text":"Type Name void Run ()  TestRunner (JsonNode const &amp; model)  ~TestRunner ()"},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestRunner/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestRunner/#function-run","title":"function Run","text":"<pre><code>void zmbt::mapping::TestRunner::Run () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestRunner/#function-testrunner","title":"function TestRunner","text":"<pre><code>zmbt::mapping::TestRunner::TestRunner (\n    JsonNode const &amp; model\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1mapping_1_1TestRunner/#function-testrunner_1","title":"function ~TestRunner","text":"<pre><code>zmbt::mapping::TestRunner::~TestRunner () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/test_runner.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1model__error/","title":"Struct zmbt::model_error","text":"<p>ClassList &gt; zmbt &gt; model_error</p> <p>Model definition error. </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::base_error</p>"},{"location":"CxxRef/structzmbt_1_1model__error/#public-functions","title":"Public Functions","text":"Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1model__error/#public-functions-inherited-from-zmbtbase_error","title":"Public Functions inherited from zmbt::base_error","text":"<p>See zmbt::base_error</p> Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1model__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1model__error/#function-base_error","title":"function base_error","text":"<pre><code>template&lt;class... A&gt;\ninline zmbt::model_error::base_error (\n    boost::json::string_view fmtstr,\n    A &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/exceptions.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1object__id/","title":"Class zmbt::object_id","text":"<p>ClassList &gt; zmbt &gt; object_id</p> <p>Pointer-based object id with type annotation. </p> <ul> <li><code>#include &lt;object_id.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::entity_id</p>"},{"location":"CxxRef/classzmbt_1_1object__id/#classes","title":"Classes","text":"Type Name struct string_key"},{"location":"CxxRef/classzmbt_1_1object__id/#public-functions","title":"Public Functions","text":"Type Name entity_id () = default entity_id (boost::json::string_view key, std::type_index type_index)  entity_id (boost::json::string_view key, std::size_t type_index_hash)  entity_id (boost::json::array const &amp; str)  entity_id (boost::json::value const &amp; val)  entity_id (entity_id const &amp;) = default entity_id (entity_id &amp;&amp;) = default object_id (boost::json::string_view str)  object_id (std::string const &amp; str)  object_id (char const * str)  object_id (T obj)  object_id (std::shared_ptr&lt; T &gt; const &amp; ptr)  object_id (T const &amp; ref)  bool operator!= (entity_id const &amp; other) const bool operator== (entity_id const &amp; other) const"},{"location":"CxxRef/classzmbt_1_1object__id/#public-functions-inherited-from-zmbtentity_id","title":"Public Functions inherited from zmbt::entity_id","text":"<p>See zmbt::entity_id</p> Type Name boost::json::string_view annotation () const entity_id () = default entity_id (boost::json::string_view key, std::type_index type_index)  entity_id (boost::json::string_view key, std::size_t type_index_hash)  entity_id (boost::json::array const &amp; str)  entity_id (boost::json::value const &amp; val)  entity_id (entity_id const &amp;) = default entity_id (entity_id &amp;&amp;) = default boost::json::string_view key () const bool operator!= (entity_id const &amp; other) const entity_id &amp; operator= (entity_id const &amp;) = default entity_id &amp; operator= (entity_id &amp;&amp;) = default entity_id &amp; operator= (boost::json::value const &amp; v)  entity_id &amp; operator= (boost::json::value &amp;&amp; v)  bool operator== (entity_id const &amp; other) const boost::json::string_view str () const virtual ~entity_id () = default"},{"location":"CxxRef/classzmbt_1_1object__id/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1object__id/#function-entity_id-17","title":"function entity_id [1/7]","text":"<pre><code>zmbt::object_id::entity_id () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-entity_id-27","title":"function entity_id [2/7]","text":"<pre><code>zmbt::object_id::entity_id (\n    boost::json::string_view key,\n    std::type_index type_index\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-entity_id-37","title":"function entity_id [3/7]","text":"<pre><code>zmbt::object_id::entity_id (\n    boost::json::string_view key,\n    std::size_t type_index_hash\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-entity_id-47","title":"function entity_id [4/7]","text":"<pre><code>explicit zmbt::object_id::entity_id (\n    boost::json::array const &amp; str\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-entity_id-57","title":"function entity_id [5/7]","text":"<pre><code>explicit zmbt::object_id::entity_id (\n    boost::json::value const &amp; val\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-entity_id-67","title":"function entity_id [6/7]","text":"<pre><code>zmbt::object_id::entity_id (\n    entity_id const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-entity_id-77","title":"function entity_id [7/7]","text":"<pre><code>zmbt::object_id::entity_id (\n    entity_id &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-object_id-16","title":"function object_id [1/6]","text":"<pre><code>inline zmbt::object_id::object_id (\n    boost::json::string_view str\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-object_id-26","title":"function object_id [2/6]","text":"<pre><code>inline zmbt::object_id::object_id (\n    std::string const &amp; str\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-object_id-36","title":"function object_id [3/6]","text":"<pre><code>inline zmbt::object_id::object_id (\n    char const * str\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-object_id-46","title":"function object_id [4/6]","text":"<pre><code>template&lt;class T, is_ptr&lt; T &gt;&gt;\ninline zmbt::object_id::object_id (\n    T obj\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-object_id-56","title":"function object_id [5/6]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::object_id::object_id (\n    std::shared_ptr&lt; T &gt; const &amp; ptr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-object_id-66","title":"function object_id [6/6]","text":"<pre><code>template&lt;class T, is_not_ptr&lt; T &gt;&gt;\ninline zmbt::object_id::object_id (\n    T const &amp; ref\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-operator","title":"function operator!=","text":"<pre><code>inline bool zmbt::object_id::operator!= (\n    entity_id const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool zmbt::object_id::operator== (\n    entity_id const &amp; other\n) const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1object__id/#friends-documentation","title":"Friends Documentation","text":""},{"location":"CxxRef/classzmbt_1_1object__id/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; zmbt::object_id::operator&lt;&lt; (\n    std::ostream &amp; os,\n    object_id const &amp; id\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/object_id.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1object__id_1_1string__key/","title":"Struct zmbt::object_id::string_key","text":"<p>ClassList &gt; zmbt &gt; object_id &gt; string_key</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/object_id.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1output__recorder__error/","title":"Struct zmbt::output_recorder_error","text":"<p>ClassList &gt; zmbt &gt; output_recorder_error</p> <p>Inherits the following classes: zmbt::base_error</p>"},{"location":"CxxRef/structzmbt_1_1output__recorder__error/#public-functions","title":"Public Functions","text":"Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1output__recorder__error/#public-functions-inherited-from-zmbtbase_error","title":"Public Functions inherited from zmbt::base_error","text":"<p>See zmbt::base_error</p> Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1output__recorder__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1output__recorder__error/#function-base_error","title":"function base_error","text":"<pre><code>template&lt;class... A&gt;\ninline zmbt::output_recorder_error::base_error (\n    boost::json::string_view fmtstr,\n    A &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/output_recorder.hpp</code></p>"},{"location":"CxxRef/namespacezmbt_1_1reflect/","title":"Namespace zmbt::reflect","text":"<p>Namespace List &gt; zmbt &gt; reflect</p> <p>Reflection metafunctions. </p>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#classes","title":"Classes","text":"Type Name class Prototypes Interface prototypes in JSON as {\"args\": [...], \"return\": ... }. struct custom_invocation &lt;class T, class E&gt;Customize the interface reflection metafunction. struct custom_serialization &lt;class T, class&gt;User-defined serialization. struct custom_serialization&lt; ChannelKind &gt; &lt;&gt; struct custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt; &lt;class T&gt; struct custom_serialization&lt; lang::Encoding &gt; &lt;&gt; struct custom_serialization&lt; lang::ExpressionView &gt; &lt;&gt; struct custom_signal_traits &lt;class T, class E&gt;Customize signal traits metafunction. struct default_invocation &lt;class S, class E&gt;Interface reflection metafunction. struct default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt; &lt;class S&gt; struct default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt; &lt;class S&gt; struct default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt; &lt;class S&gt; struct has_invocation_for &lt;class T, class E&gt;Trait check for reflect::invocation&lt;T&gt; struct invocation &lt;class T, class E&gt;Interface reflection metafunction. struct invocation&lt; S, detail::enable_custom_invocation&lt; S &gt; &gt; &lt;class S&gt; struct invocation&lt; S, detail::enable_default_invocation&lt; S &gt; &gt; &lt;class S&gt; struct serialization &lt;class T, class&gt;Serialization metafunction. struct serialization&lt; T, detail::enable_for_custom_serialization&lt; T &gt; &gt; &lt;class T&gt; struct serialization&lt; T, detail::enable_for_default_serialization&lt; T &gt; &gt; &lt;class T&gt; struct signal_traits &lt;class T, class E&gt;Signal traits metafunction, providing default values. struct signal_traits&lt; T, detail::enable_custom_signal_traits&lt; T &gt; &gt; &lt;class T&gt; struct signal_traits&lt; T, detail::enable_default_signal_traits&lt; T &gt; &gt; &lt;class T&gt; struct signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt; &lt;class T&gt;Unhandled types catcher. struct signal_traits&lt; void &gt; &lt;&gt;"},{"location":"CxxRef/namespacezmbt_1_1reflect/#public-types","title":"Public Types","text":"Type Name typedef custom_signal_traits&lt; T, E &gt; custom_initialization typedef signal_traits&lt; T, E &gt; initialization typedef typename reflect::invocation&lt; Interface &gt;::type interface_t typedef typename invocation&lt; Interface &gt;::args_t invocation_args_t Interface arguments tuple type. typedef tuple_unqf_t&lt; invocation_args_t&lt; Interface &gt; &gt; invocation_args_unqf_t Interface cv-unqualified arguments tuple type. typedef std::integral_constant&lt; bool, 0==boost::mp11::mp_size&lt; invocation_args_t&lt; Interface &gt; &gt;::value &gt; invocation_has_void_args Interface has no args. typedef std::is_void&lt; invocation_ret_t&lt; Interface &gt; &gt; invocation_has_void_ret Interface has no return. typedef typename invocation&lt; T &gt;::host_t invocation_host_t Interface host object type. typedef typename invocation&lt; Interface &gt;::return_t invocation_ret_t Interface return type. typedef mp_if&lt; invocation_has_void_ret&lt; Interface &gt;, nullptr_t, invocation_ret_unqf_t&lt; Interface &gt; &gt; invocation_ret_unqf_or_nullptr_t typedef remove_cvref_t&lt; invocation_ret_t&lt; Interface &gt; &gt; invocation_ret_unqf_t Interface cv-unqualified return type. typedef remove_cvref_t&lt; invocation_host_t&lt; T &gt; &gt; invocation_unqf_host_t Interface cv-unqualified host object type."},{"location":"CxxRef/namespacezmbt_1_1reflect/#public-functions","title":"Public Functions","text":"Type Name constexpr T init_tuple () Initialize tuple with default values provided by signal_traits . constexpr T init_value () Initialize value of type T with default value provided by signal_traits . detail::enable_hermetic_serialization&lt; T, std::ostream &amp; &gt; operator&lt;&lt; (std::ostream &amp; os, T const &amp; value) ADL injection wrapper enabling operator&lt;&lt;. detail::enable_hermetic_serialization&lt; T, void &gt; tag_invoke (boost::json::value_from_tag const &amp;, boost::json::value &amp; v, T const &amp; t) ADL injection wrapper enabling boost::json::value_from&lt;T&gt; conversion. detail::enable_hermetic_serialization&lt; T, T &gt; tag_invoke (boost::json::value_to_tag&lt; T &gt; const &amp;, boost::json::value const &amp; v) ADL injection wrapper enabling boost::json::value_from&lt;T&gt; conversion."},{"location":"CxxRef/namespacezmbt_1_1reflect/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-custom_initialization","title":"typedef custom_initialization","text":"<pre><code>using zmbt::reflect::custom_initialization = typedef custom_signal_traits&lt;T, E&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-initialization","title":"typedef initialization","text":"<pre><code>using zmbt::reflect::initialization = typedef signal_traits&lt;T, E&gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-interface_t","title":"typedef interface_t","text":"<pre><code>using zmbt::reflect::interface_t = typedef typename reflect::invocation&lt;Interface&gt;::type;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-invocation_args_t","title":"typedef invocation_args_t","text":"<p>Interface arguments tuple type. <pre><code>using zmbt::reflect::invocation_args_t = typedef typename invocation&lt;Interface&gt;::args_t;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Interface</code> Interface pointer type </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-invocation_args_unqf_t","title":"typedef invocation_args_unqf_t","text":"<p>Interface cv-unqualified arguments tuple type. <pre><code>using zmbt::reflect::invocation_args_unqf_t = typedef tuple_unqf_t&lt;invocation_args_t&lt;Interface&gt; &gt;;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Interface</code> Interface pointer type </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-invocation_has_void_args","title":"typedef invocation_has_void_args","text":"<p>Interface has no args. <pre><code>using zmbt::reflect::invocation_has_void_args = typedef std::integral_constant&lt;bool, 0 == boost::mp11::mp_size&lt;invocation_args_t&lt;Interface&gt; &gt;::value &gt;;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Interface</code> </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-invocation_has_void_ret","title":"typedef invocation_has_void_ret","text":"<p>Interface has no return. <pre><code>using zmbt::reflect::invocation_has_void_ret = typedef std::is_void&lt;invocation_ret_t&lt;Interface&gt; &gt;;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Interface</code> </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-invocation_host_t","title":"typedef invocation_host_t","text":"<p>Interface host object type. <pre><code>using zmbt::reflect::invocation_host_t = typedef typename invocation&lt;T&gt;::host_t;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Interface pointer type </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-invocation_ret_t","title":"typedef invocation_ret_t","text":"<p>Interface return type. <pre><code>using zmbt::reflect::invocation_ret_t = typedef typename invocation&lt;Interface&gt;::return_t;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Interface</code> Interface pointer type </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-invocation_ret_unqf_or_nullptr_t","title":"typedef invocation_ret_unqf_or_nullptr_t","text":"<pre><code>using zmbt::reflect::invocation_ret_unqf_or_nullptr_t = typedef mp_if&lt;invocation_has_void_ret&lt;Interface&gt;, nullptr_t, invocation_ret_unqf_t&lt;Interface&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-invocation_ret_unqf_t","title":"typedef invocation_ret_unqf_t","text":"<p>Interface cv-unqualified return type. <pre><code>using zmbt::reflect::invocation_ret_unqf_t = typedef remove_cvref_t&lt;invocation_ret_t&lt;Interface&gt; &gt;;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Interface</code> Interface pointer type </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#typedef-invocation_unqf_host_t","title":"typedef invocation_unqf_host_t","text":"<p>Interface cv-unqualified host object type. <pre><code>using zmbt::reflect::invocation_unqf_host_t = typedef remove_cvref_t&lt;invocation_host_t&lt;T&gt; &gt;;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Interface pointer type </li> </ul>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/namespacezmbt_1_1reflect/#function-init_tuple","title":"function init_tuple","text":"<p>Initialize tuple with default values provided by signal_traits . <pre><code>template&lt;class T&gt;\nconstexpr T zmbt::reflect::init_tuple () \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#function-init_value","title":"function init_value","text":"<p>Initialize value of type T with default value provided by signal_traits . <pre><code>template&lt;class T&gt;\nconstexpr T zmbt::reflect::init_value () \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#function-operator","title":"function operator&lt;&lt;","text":"<p>ADL injection wrapper enabling operator&lt;&lt;. <pre><code>template&lt;class T&gt;\ndetail::enable_hermetic_serialization&lt; T, std::ostream &amp; &gt; zmbt::reflect::operator&lt;&lt; (\n    std::ostream &amp; os,\n    T const &amp; value\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#function-tag_invoke","title":"function tag_invoke","text":"<p>ADL injection wrapper enabling boost::json::value_from&lt;T&gt; conversion. <pre><code>template&lt;class T&gt;\ndetail::enable_hermetic_serialization&lt; T, void &gt; zmbt::reflect::tag_invoke (\n    boost::json::value_from_tag const &amp;,\n    boost::json::value &amp; v,\n    T const &amp; t\n) \n</code></pre></p>"},{"location":"CxxRef/namespacezmbt_1_1reflect/#function-tag_invoke_1","title":"function tag_invoke","text":"<p>ADL injection wrapper enabling boost::json::value_from&lt;T&gt; conversion. <pre><code>template&lt;class T&gt;\ndetail::enable_hermetic_serialization&lt; T, T &gt; zmbt::reflect::tag_invoke (\n    boost::json::value_to_tag&lt; T &gt; const &amp;,\n    boost::json::value const &amp; v\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/precise_real.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1reflect_1_1Prototypes/","title":"Class zmbt::reflect::Prototypes","text":"<p>ClassList &gt; zmbt &gt; reflect &gt; Prototypes</p> <p>Interface prototypes in JSON as {\"args\": [...], \"return\": ... }. </p> <ul> <li><code>#include &lt;prototypes.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/classzmbt_1_1reflect_1_1Prototypes/#public-functions","title":"Public Functions","text":"Type Name Prototypes (boost::json::array &amp;&amp; args, boost::json::value &amp;&amp; ret)  Prototypes ()  Prototypes (T const &amp;)  boost::json::array const &amp; args () const boost::json::value const &amp; ret () const"},{"location":"CxxRef/classzmbt_1_1reflect_1_1Prototypes/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1reflect_1_1Prototypes/#function-prototypes-13","title":"function Prototypes [1/3]","text":"<pre><code>inline zmbt::reflect::Prototypes::Prototypes (\n    boost::json::array &amp;&amp; args,\n    boost::json::value &amp;&amp; ret\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1reflect_1_1Prototypes/#function-prototypes-23","title":"function Prototypes [2/3]","text":"<pre><code>inline zmbt::reflect::Prototypes::Prototypes () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1reflect_1_1Prototypes/#function-prototypes-33","title":"function Prototypes [3/3]","text":"<pre><code>template&lt;class T&gt;\ninline zmbt::reflect::Prototypes::Prototypes (\n    T const &amp;\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1reflect_1_1Prototypes/#function-args","title":"function args","text":"<pre><code>inline boost::json::array const &amp; zmbt::reflect::Prototypes::args () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1reflect_1_1Prototypes/#function-ret","title":"function ret","text":"<pre><code>inline boost::json::value const &amp; zmbt::reflect::Prototypes::ret () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/prototypes.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__invocation/","title":"Struct zmbt::reflect::custom_invocation","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; custom_invocation</p> <p>Customize the interface reflection metafunction. More...</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__invocation/#detailed-description","title":"Detailed Description","text":"<p>Provide custom type definitions and 'apply' method for callables. Required fields: * type: callable type (metafunction template parameter) * host_t: host object type * return_t: callable return type * args_t: callable arguments tuple type * apply: callable invocation method with signature:   * If host_t is nullptr_t:  <pre><code>static return_t apply(nullptr_t, type ifc, args_t args);\n</code></pre></p> <ul> <li>If host_t is class:  <pre><code>template &lt;class H&gt;\nstatic return_t apply(H&amp;&amp; object, type ifc, args_t args);\n</code></pre></li> </ul> <p>For class methods, the <code>apply</code> function must support references and pointers, including smart pointers. Therefore, a templated version of the <code>apply</code> is recommended but can be replaced with a set of overloads if necessary.</p> <p>Template parameters:</p> <ul> <li><code>T</code> callable type </li> <li><code>E</code> SFINAE enabler </li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization/","title":"Struct zmbt::reflect::custom_serialization","text":"<p>template &lt;class T, class&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; custom_serialization</p> <p>User-defined serialization. More...</p> <p>Inherited by the following classes: zmbt::reflect::serialization&lt; T, detail::enable_for_custom_serialization&lt; T &gt; &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/serialization.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01ChannelKind_01_4/","title":"Struct zmbt::reflect::custom_serialization&lt; ChannelKind &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; custom_serialization&lt; ChannelKind &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01ChannelKind_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name ChannelKind dejsonize (boost::json::value const &amp; v)  boost::json::value json_from (ChannelKind const &amp; k)"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01ChannelKind_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01ChannelKind_01_4/#function-dejsonize","title":"function dejsonize","text":"<pre><code>static inline ChannelKind zmbt::reflect::custom_serialization&lt; ChannelKind &gt;::dejsonize (\n    boost::json::value const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01ChannelKind_01_4/#function-json_from","title":"function json_from","text":"<pre><code>static inline boost::json::value zmbt::reflect::custom_serialization&lt; ChannelKind &gt;::json_from (\n    ChannelKind const &amp; k\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/channel_kind.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01T_00_01mp__if_3_01is__base__of_3_01lang_1_1Ex2d769b9dfa1b415c78e21b0b59756cc2/","title":"Struct zmbt::reflect::custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01T_00_01mp__if_3_01is__base__of_3_01lang_1_1Ex2d769b9dfa1b415c78e21b0b59756cc2/#public-static-functions","title":"Public Static Functions","text":"Type Name T dejsonize (boost::json::value const &amp; v)  boost::json::value json_from (T const &amp; t)"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01T_00_01mp__if_3_01is__base__of_3_01lang_1_1Ex2d769b9dfa1b415c78e21b0b59756cc2/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01T_00_01mp__if_3_01is__base__of_3_01lang_1_1Ex2d769b9dfa1b415c78e21b0b59756cc2/#function-dejsonize","title":"function dejsonize","text":"<pre><code>static inline T zmbt::reflect::custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt;::dejsonize (\n    boost::json::value const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01T_00_01mp__if_3_01is__base__of_3_01lang_1_1Ex2d769b9dfa1b415c78e21b0b59756cc2/#function-json_from","title":"function json_from","text":"<pre><code>static inline boost::json::value zmbt::reflect::custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt;::json_from (\n    T const &amp; t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/expression.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01lang_1_1Encoding_01_4/","title":"Struct zmbt::reflect::custom_serialization&lt; lang::Encoding &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; custom_serialization&lt; lang::Encoding &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01lang_1_1Encoding_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name lang::Encoding dejsonize (boost::json::value const &amp; v)  boost::json::value json_from (lang::Encoding const &amp; enc)"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01lang_1_1Encoding_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01lang_1_1Encoding_01_4/#function-dejsonize","title":"function dejsonize","text":"<pre><code>static lang::Encoding zmbt::reflect::custom_serialization&lt; lang::Encoding &gt;::dejsonize (\n    boost::json::value const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01lang_1_1Encoding_01_4/#function-json_from","title":"function json_from","text":"<pre><code>static boost::json::value zmbt::reflect::custom_serialization&lt; lang::Encoding &gt;::json_from (\n    lang::Encoding const &amp; enc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/encoding.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01lang_1_1ExpressionView_01_4/","title":"Struct zmbt::reflect::custom_serialization&lt; lang::ExpressionView &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; custom_serialization&lt; lang::ExpressionView &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01lang_1_1ExpressionView_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name boost::json::value json_from (lang::ExpressionView const &amp; t)"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01lang_1_1ExpressionView_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01lang_1_1ExpressionView_01_4/#function-json_from","title":"function json_from","text":"<pre><code>static inline boost::json::value zmbt::reflect::custom_serialization&lt; lang::ExpressionView &gt;::json_from (\n    lang::ExpressionView const &amp; t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/expression.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__signal__traits/","title":"Struct zmbt::reflect::custom_signal_traits","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; custom_signal_traits</p> <p>Customize signal traits metafunction. More...</p> <p>Inherited by the following classes: zmbt::reflect::signal_traits&lt; T, detail::enable_custom_signal_traits&lt; T &gt; &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__signal__traits/#detailed-description","title":"Detailed Description","text":"<p>Provide static 'init' method for signal initialization with signature:  <pre><code>static constexpr T init();\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> signal type </li> <li><code>E</code> SFINAE enabler </li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/signal_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation/","title":"Struct zmbt::reflect::default_invocation","text":"<p>template &lt;class S, class E&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; default_invocation</p> <p>Interface reflection metafunction. More...</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation/#detailed-description","title":"Detailed Description","text":"<p>Provides type definitions and 'apply' method for generic interfaces</p> <p>Template parameters:</p> <ul> <li><code>S</code> </li> <li><code>E</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/","title":"Struct zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;","text":"<p>template &lt;class S&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/#public-types","title":"Public Types","text":"Type Name typedef ifc_args_t&lt; type &gt; args_t typedef ifc_host_t&lt; type &gt; host_t typedef ifc_return_t&lt; type &gt; return_t typedef S type"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/#public-static-functions","title":"Public Static Functions","text":"Type Name return_t apply (host_t, type ifc, args_t args)"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/#typedef-args_t","title":"typedef args_t","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;::args_t =  ifc_args_t&lt;type&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/#typedef-host_t","title":"typedef host_t","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;::host_t =  ifc_host_t&lt;type&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/#typedef-return_t","title":"typedef return_t","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;::return_t =  ifc_return_t&lt;type&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/#typedef-type","title":"typedef type","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;::type =  S;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__any__t_3_01void_00_01ifc__is_03ee2f30da4b8a63c386d237830e07c9/#function-apply","title":"function apply","text":"<pre><code>static inline return_t zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;::apply (\n    host_t,\n    type ifc,\n    args_t args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/","title":"Struct zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;","text":"<p>template &lt;class S&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ifc_args_t&lt; type &gt; args_t typedef ifc_host_t&lt; type &gt; host_t typedef ifc_return_t&lt; type &gt; return_t typedef S type"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name return_t apply (host_t, type ifc, args_t args)"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/#typedef-args_t","title":"typedef args_t","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;::args_t =  ifc_args_t&lt;type&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/#typedef-host_t","title":"typedef host_t","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;::host_t =  ifc_host_t&lt;type&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/#typedef-return_t","title":"typedef return_t","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;::return_t =  ifc_return_t&lt;type&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;::type =  S;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__functor__ptr_3_01S_01_4_01_4_01_4/#function-apply","title":"function apply","text":"<pre><code>static inline return_t zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;::apply (\n    host_t,\n    type ifc,\n    args_t args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/","title":"Struct zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;","text":"<p>template &lt;class S&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ifc_args_t&lt; type &gt; args_t typedef ifc_host_t&lt; type &gt; host_t typedef ifc_return_t&lt; type &gt; return_t typedef S type"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name return_t apply (H &amp;&amp; object, type ifc, args_t args)"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/#typedef-args_t","title":"typedef args_t","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;::args_t =  ifc_args_t&lt;type&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/#typedef-host_t","title":"typedef host_t","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;::host_t =  ifc_host_t&lt;type&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/#typedef-return_t","title":"typedef return_t","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;::return_t =  ifc_return_t&lt;type&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;::type =  S;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1default__invocation_3_01S_00_01first__if__t_3_01void_00_01ifc__is__member__handle_3_01S_01_4_01_4_01_4/#function-apply","title":"function apply","text":"<pre><code>template&lt;class H&gt;\nstatic inline return_t zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;::apply (\n    H &amp;&amp; object,\n    type ifc,\n    args_t args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1has__invocation__for/","title":"Struct zmbt::reflect::has_invocation_for","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; has_invocation_for</p> <p>Trait check for reflect::invocation&lt;T&gt; </p> <ul> <li><code>#include &lt;invocation.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1invocation/","title":"Struct zmbt::reflect::invocation","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; invocation</p> <p>Interface reflection metafunction. More...</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1invocation/#detailed-description","title":"Detailed Description","text":"<p>Provides type definitions and 'apply' method for callables</p> <p>Template parameters:</p> <ul> <li><code>T</code> callable type </li> <li><code>E</code> SFINAE enabler </li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1invocation_3_01S_00_01detail_1_1enable__custom__invocation_3_01S_01_4_01_4/","title":"Struct zmbt::reflect::invocation&lt; S, detail::enable_custom_invocation&lt; S &gt; &gt;","text":"<p>template &lt;class S&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; invocation&lt; S, detail::enable_custom_invocation&lt; S &gt; &gt;</p> <p>Inherits the following classes: zmbt::reflect::custom_invocation</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1invocation_3_01S_00_01detail_1_1enable__default__invocation_3_01S_01_4_01_4/","title":"Struct zmbt::reflect::invocation&lt; S, detail::enable_default_invocation&lt; S &gt; &gt;","text":"<p>template &lt;class S&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; invocation&lt; S, detail::enable_default_invocation&lt; S &gt; &gt;</p> <p>Inherits the following classes: zmbt::reflect::default_invocation</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1serialization/","title":"Struct zmbt::reflect::serialization","text":"<p>template &lt;class T, class&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; serialization</p> <p>Serialization metafunction. More...</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1serialization/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/serialization.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1serialization_3_01T_00_01detail_1_1enable__for__custom__serialization_3_01T_01_4_01_4/","title":"Struct zmbt::reflect::serialization&lt; T, detail::enable_for_custom_serialization&lt; T &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; serialization&lt; T, detail::enable_for_custom_serialization&lt; T &gt; &gt;</p> <p>Inherits the following classes: zmbt::reflect::custom_serialization</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/serialization.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1serialization_3_01T_00_01detail_1_1enable__for__default__serialization_3_01T_01_4_01_4/","title":"Struct zmbt::reflect::serialization&lt; T, detail::enable_for_default_serialization&lt; T &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; serialization&lt; T, detail::enable_for_default_serialization&lt; T &gt; &gt;</p> <p>Inherits the following classes: zmbt::reflect::detail::default_serialization&lt; T &gt;</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/serialization.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits/","title":"Struct zmbt::reflect::signal_traits","text":"<p>template &lt;class T, class E&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; signal_traits</p> <p>Signal traits metafunction, providing default values. More...</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> signal type </li> <li><code>E</code> SFINAE enabler </li> </ul> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/signal_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01T_00_01detail_1_1enable__custom__signal__traits_3_01T_01_4_01_4/","title":"Struct zmbt::reflect::signal_traits&lt; T, detail::enable_custom_signal_traits&lt; T &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; signal_traits&lt; T, detail::enable_custom_signal_traits&lt; T &gt; &gt;</p> <p>Inherits the following classes: zmbt::reflect::custom_signal_traits</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/signal_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01T_00_01detail_1_1enable__default__signal__traits_3_01T_01_4_01_4/","title":"Struct zmbt::reflect::signal_traits&lt; T, detail::enable_default_signal_traits&lt; T &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; signal_traits&lt; T, detail::enable_default_signal_traits&lt; T &gt; &gt;</p> <p>Inherits the following classes: zmbt::reflect::detail::default_signal_traits&lt; T &gt;</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/signal_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01T_00_01detail_1_1enable__initialization__trap_3_01T_01_4_01_4/","title":"Struct zmbt::reflect::signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt;</p> <p>Unhandled types catcher. More...</p> <ul> <li><code>#include &lt;signal_traits.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01T_00_01detail_1_1enable__initialization__trap_3_01T_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr T init ()"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01T_00_01detail_1_1enable__initialization__trap_3_01T_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01T_00_01detail_1_1enable__initialization__trap_3_01T_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01T_00_01detail_1_1enable__initialization__trap_3_01T_01_4_01_4/#function-init","title":"function init","text":"<pre><code>static inline constexpr T zmbt::reflect::signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt;::init () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/signal_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01void_01_4/","title":"Struct zmbt::reflect::signal_traits&lt; void &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; zmbt &gt; reflect &gt; signal_traits&lt; void &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01void_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name void init ()"},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01void_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1signal__traits_3_01void_01_4/#function-init","title":"function init","text":"<pre><code>static inline void zmbt::reflect::signal_traits&lt; void &gt;::init () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/signal_traits.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1serialization__error/","title":"Struct zmbt::serialization_error","text":"<p>ClassList &gt; zmbt &gt; serialization_error</p> <p>Failed serialization. </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::base_error</p>"},{"location":"CxxRef/structzmbt_1_1serialization__error/#public-functions","title":"Public Functions","text":"Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1serialization__error/#public-functions-inherited-from-zmbtbase_error","title":"Public Functions inherited from zmbt::base_error","text":"<p>See zmbt::base_error</p> Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1serialization__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1serialization__error/#function-base_error","title":"function base_error","text":"<pre><code>template&lt;class... A&gt;\ninline zmbt::serialization_error::base_error (\n    boost::json::string_view fmtstr,\n    A &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/exceptions.hpp</code></p>"},{"location":"CxxRef/classzmbt_1_1shared__resource/","title":"Class zmbt::shared_resource","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; zmbt &gt; shared_resource</p>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#public-functions","title":"Public Functions","text":"Type Name T &amp; operator* ()  T const &amp; operator* () const std::shared_ptr&lt; T &gt; operator-&gt; ()  std::shared_ptr&lt; T &gt; const operator-&gt; () const shared_resource &amp; operator= (shared_resource const &amp;) = default shared_resource &amp; operator= (shared_resource &amp;&amp;) = default std::shared_ptr&lt; T &gt; ptr () const shared_resource (T &amp;&amp; v)  shared_resource (std::function&lt; T()&gt; f)  shared_resource (std::function&lt; std::shared_ptr&lt; T &gt;()&gt; f)  shared_resource (std::shared_ptr&lt; T &gt; ptr)  shared_resource (detail::emplace_shared_tag, A &amp;&amp;... args)  shared_resource () = default shared_resource (shared_resource const &amp;) = default shared_resource (shared_resource &amp;&amp;) = default ~shared_resource () = default"},{"location":"CxxRef/classzmbt_1_1shared__resource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-operator","title":"function operator*","text":"<pre><code>inline T &amp; zmbt::shared_resource::operator* () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-operator_1","title":"function operator*","text":"<pre><code>inline T const &amp; zmbt::shared_resource::operator* () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline std::shared_ptr&lt; T &gt; zmbt::shared_resource::operator-&gt; () \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-operator-_1","title":"function operator-&gt;","text":"<pre><code>inline std::shared_ptr&lt; T &gt; const zmbt::shared_resource::operator-&gt; () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-operator_2","title":"function operator=","text":"<pre><code>shared_resource &amp; zmbt::shared_resource::operator= (\n    shared_resource const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-operator_3","title":"function operator=","text":"<pre><code>shared_resource &amp; zmbt::shared_resource::operator= (\n    shared_resource &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-ptr","title":"function ptr","text":"<pre><code>inline std::shared_ptr&lt; T &gt; zmbt::shared_resource::ptr () const\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-shared_resource-18","title":"function shared_resource [1/8]","text":"<pre><code>inline zmbt::shared_resource::shared_resource (\n    T &amp;&amp; v\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-shared_resource-28","title":"function shared_resource [2/8]","text":"<pre><code>inline zmbt::shared_resource::shared_resource (\n    std::function&lt; T()&gt; f\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-shared_resource-38","title":"function shared_resource [3/8]","text":"<pre><code>inline zmbt::shared_resource::shared_resource (\n    std::function&lt; std::shared_ptr&lt; T &gt;()&gt; f\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-shared_resource-48","title":"function shared_resource [4/8]","text":"<pre><code>inline zmbt::shared_resource::shared_resource (\n    std::shared_ptr&lt; T &gt; ptr\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-shared_resource-58","title":"function shared_resource [5/8]","text":"<pre><code>template&lt;class... A&gt;\ninline zmbt::shared_resource::shared_resource (\n    detail::emplace_shared_tag,\n    A &amp;&amp;... args\n) \n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-shared_resource-68","title":"function shared_resource [6/8]","text":"<pre><code>zmbt::shared_resource::shared_resource () = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-shared_resource-78","title":"function shared_resource [7/8]","text":"<pre><code>zmbt::shared_resource::shared_resource (\n    shared_resource const &amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-shared_resource-88","title":"function shared_resource [8/8]","text":"<pre><code>zmbt::shared_resource::shared_resource (\n    shared_resource &amp;&amp;\n) = default\n</code></pre>"},{"location":"CxxRef/classzmbt_1_1shared__resource/#function-shared_resource","title":"function ~shared_resource","text":"<pre><code>zmbt::shared_resource::~shared_resource () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/shared_resource.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1test__assertion__failure/","title":"Struct zmbt::test_assertion_failure","text":"<p>ClassList &gt; zmbt &gt; test_assertion_failure</p> <p>Failed test assertion. </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: zmbt::base_error</p>"},{"location":"CxxRef/structzmbt_1_1test__assertion__failure/#public-functions","title":"Public Functions","text":"Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1test__assertion__failure/#public-functions-inherited-from-zmbtbase_error","title":"Public Functions inherited from zmbt::base_error","text":"<p>See zmbt::base_error</p> Type Name base_error (boost::json::string_view fmtstr, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1test__assertion__failure/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1test__assertion__failure/#function-base_error","title":"function base_error","text":"<pre><code>template&lt;class... A&gt;\ninline zmbt::test_assertion_failure::base_error (\n    boost::json::string_view fmtstr,\n    A &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/exceptions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1type__tag/","title":"Struct zmbt::type_tag","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; zmbt &gt; type_tag</p> <p>Type tag to pass template parameters as function arguments. </p> <ul> <li><code>#include &lt;type_tag.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/structzmbt_1_1type__tag/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"CxxRef/structzmbt_1_1type__tag/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1type__tag/#typedef-type","title":"typedef type","text":"<pre><code>using zmbt::type_tag&lt; T &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/type_tag.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1Config_1_1PersistentConfig/","title":"Struct zmbt::Config::PersistentConfig","text":"<p>ClassList &gt; PersistentConfig</p>"},{"location":"CxxRef/structzmbt_1_1Config_1_1PersistentConfig/#public-attributes","title":"Public Attributes","text":"Type Name FailureHandler failure_handler   = <code>{&amp;[**zmbt::default\\_test\\_failure**](namespacezmbt.md#function-default_test_failure)}</code>"},{"location":"CxxRef/structzmbt_1_1Config_1_1PersistentConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1Config_1_1PersistentConfig/#variable-failure_handler","title":"variable failure_handler","text":"<pre><code>FailureHandler zmbt::Config::PersistentConfig::failure_handler;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application/config.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/","title":"Struct zmbt::OutputRecorder::Registry","text":"<p>ClassList &gt; Registry</p>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#classes","title":"Classes","text":"Type Name struct FrameBuffs"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#public-types","title":"Public Types","text":"Type Name typedef boost::concurrent_flat_map&lt; std::id, FrameBuffs, std::hash&lt; std::id &gt; &gt; FramesBuffMap typedef std::function&lt; void(Registry &amp;)&gt; consume_fn_t"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#public-attributes","title":"Public Attributes","text":"Type Name std::atomic&lt; std::size_t &gt; count   = <code>{0}</code> std::type_index data_typeid std::bitset&lt; static_cast&lt; unsigned &gt;(ChannelKind::Undefined)&gt; enable_categories_   = <code>{}</code> consume_fn_t extract_fn std::shared_ptr&lt; FramesBuffMap &gt; frame_buff_map boost::json::string interface_name std::atomic&lt; std::size_t &gt; lost_count   = <code>{0}</code> boost::json::array serialized_frames   = <code>{}</code>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#public-functions","title":"Public Functions","text":"Type Name Registry (std::type_index typid, boost::json::string name, consume_fn_t efn, std::shared_ptr&lt; FramesBuffMap &gt; fbm)  ~Registry ()"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; Registry &gt; Make ()"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#typedef-framesbuffmap","title":"typedef FramesBuffMap","text":"<pre><code>using zmbt::OutputRecorder::Registry::FramesBuffMap =  boost::concurrent_flat_map&lt;std::thread::id, FrameBuffs, std::hash&lt;std::thread::id&gt; &gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#typedef-consume_fn_t","title":"typedef consume_fn_t","text":"<pre><code>using zmbt::OutputRecorder::Registry::consume_fn_t =  std::function&lt;void(Registry&amp;)&gt;;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#variable-count","title":"variable count","text":"<pre><code>std::atomic&lt;std::size_t&gt; zmbt::OutputRecorder::Registry::count;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#variable-data_typeid","title":"variable data_typeid","text":"<pre><code>std::type_index zmbt::OutputRecorder::Registry::data_typeid;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#variable-enable_categories_","title":"variable enable_categories_","text":"<pre><code>std::bitset&lt;static_cast&lt;unsigned&gt;(ChannelKind::Undefined)&gt; zmbt::OutputRecorder::Registry::enable_categories_;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#variable-extract_fn","title":"variable extract_fn","text":"<pre><code>consume_fn_t zmbt::OutputRecorder::Registry::extract_fn;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#variable-frame_buff_map","title":"variable frame_buff_map","text":"<pre><code>std::shared_ptr&lt;FramesBuffMap&gt; zmbt::OutputRecorder::Registry::frame_buff_map;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#variable-interface_name","title":"variable interface_name","text":"<pre><code>boost::json::string zmbt::OutputRecorder::Registry::interface_name;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#variable-lost_count","title":"variable lost_count","text":"<pre><code>std::atomic&lt;std::size_t&gt; zmbt::OutputRecorder::Registry::lost_count;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#variable-serialized_frames","title":"variable serialized_frames","text":"<pre><code>boost::json::array zmbt::OutputRecorder::Registry::serialized_frames;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#function-registry","title":"function Registry","text":"<pre><code>inline Registry::Registry (\n    std::type_index typid,\n    boost::json::string name,\n    consume_fn_t efn,\n    std::shared_ptr&lt; FramesBuffMap &gt; fbm\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#function-registry_1","title":"function ~Registry","text":"<pre><code>inline Registry::~Registry () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry/#function-make","title":"function Make","text":"<pre><code>template&lt;class Interface&gt;\nstatic inline std::shared_ptr&lt; Registry &gt; Registry::Make () \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/output_recorder.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry_1_1FrameBuffs/","title":"Struct zmbt::OutputRecorder::Registry::FrameBuffs","text":"<p>ClassList &gt; Registry &gt; FrameBuffs</p>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry_1_1FrameBuffs/#public-attributes","title":"Public Attributes","text":"Type Name std::shared_ptr&lt; void &gt; args   = <code>{}</code> std::shared_ptr&lt; void &gt; err   = <code>{}</code> std::shared_ptr&lt; void &gt; ret   = <code>{}</code>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry_1_1FrameBuffs/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry_1_1FrameBuffs/#variable-args","title":"variable args","text":"<pre><code>std::shared_ptr&lt;void&gt; zmbt::OutputRecorder::Registry::FrameBuffs::args;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry_1_1FrameBuffs/#variable-err","title":"variable err","text":"<pre><code>std::shared_ptr&lt;void&gt; zmbt::OutputRecorder::Registry::FrameBuffs::err;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1OutputRecorder_1_1Registry_1_1FrameBuffs/#variable-ret","title":"variable ret","text":"<pre><code>std::shared_ptr&lt;void&gt; zmbt::OutputRecorder::Registry::FrameBuffs::ret;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/output_recorder.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1Trigger_1_1internal__ctor/","title":"Struct zmbt::Trigger::internal_ctor","text":"<p>ClassList &gt; internal_ctor</p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/trigger.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/","title":"Struct zmbt::lang::Operator::Handle","text":"<p>ClassList &gt; Handle</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#classes","title":"Classes","text":"Type Name struct Handle struct Handle struct Handle struct Handle struct Handle struct Handle"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#public-attributes","title":"Public Attributes","text":"Type Name boost::json::string annotation   = <code>{\"\"}</code> struct zmbt::lang::Operator::Handle::A arithmetics struct zmbt::lang::Operator::Handle::B bitwise struct zmbt::lang::Operator::Handle::C comp struct zmbt::lang::Operator::Handle::D decor struct zmbt::lang::Operator::Handle::L logic struct zmbt::lang::Operator::Handle::S shift"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#variable-annotation","title":"variable annotation","text":"<pre><code>boost::json::string zmbt::lang::Operator::Handle::annotation;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#variable-arithmetics","title":"variable arithmetics","text":"<pre><code>struct zmbt::lang::Operator::Handle::A zmbt::lang::Operator::Handle::arithmetics;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#variable-bitwise","title":"variable bitwise","text":"<pre><code>struct zmbt::lang::Operator::Handle::B zmbt::lang::Operator::Handle::bitwise;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#variable-comp","title":"variable comp","text":"<pre><code>struct zmbt::lang::Operator::Handle::C zmbt::lang::Operator::Handle::comp;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#variable-decor","title":"variable decor","text":"<pre><code>struct zmbt::lang::Operator::Handle::D zmbt::lang::Operator::Handle::decor;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#variable-logic","title":"variable logic","text":"<pre><code>struct zmbt::lang::Operator::Handle::L zmbt::lang::Operator::Handle::logic;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle/#variable-shift","title":"variable shift","text":"<pre><code>struct zmbt::lang::Operator::Handle::S zmbt::lang::Operator::Handle::shift;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1A/","title":"Struct zmbt::lang::Operator::Handle::Handle","text":"<p>ClassList &gt; Handle &gt; Handle</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1A/#public-attributes","title":"Public Attributes","text":"Type Name binary_transform add   = <code>{generic\\_plus}</code> binary_transform div   = <code>{generic\\_divides}</code> binary_transform mod   = <code>{generic\\_modulus}</code> binary_transform mul   = <code>{generic\\_multiplies}</code> unary_transform neg   = <code>{generic\\_negate}</code> binary_transform sub   = <code>{generic\\_minus}</code>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1A/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1A/#variable-add","title":"variable add","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::A::add;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1A/#variable-div","title":"variable div","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::A::div;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1A/#variable-mod","title":"variable mod","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::A::mod;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1A/#variable-mul","title":"variable mul","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::A::mul;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1A/#variable-neg","title":"variable neg","text":"<pre><code>unary_transform zmbt::lang::Operator::Handle::A::neg;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1A/#variable-sub","title":"variable sub","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::A::sub;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1B/","title":"Struct zmbt::lang::Operator::Handle::Handle","text":"<p>ClassList &gt; Handle &gt; Handle</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1B/#public-attributes","title":"Public Attributes","text":"Type Name binary_transform and_   = <code>{generic\\_bit\\_and}</code> unary_transform compl_   = <code>{generic\\_complement}</code> binary_transform or_   = <code>{generic\\_bit\\_or}</code> binary_transform xor_   = <code>{generic\\_bit\\_xor}</code>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1B/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1B/#variable-and_","title":"variable and_","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::B::and_;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1B/#variable-compl_","title":"variable compl_","text":"<pre><code>unary_transform zmbt::lang::Operator::Handle::B::compl_;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1B/#variable-or_","title":"variable or_","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::B::or_;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1B/#variable-xor_","title":"variable xor_","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::B::xor_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1C/","title":"Struct zmbt::lang::Operator::Handle::Handle","text":"<p>ClassList &gt; Handle &gt; Handle</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1C/#public-attributes","title":"Public Attributes","text":"Type Name binary_transform equal_to   = <code>{generic\\_equal\\_to}</code> binary_transform less   = <code>{generic\\_less}</code> binary_transform less_equal   = <code>{generic\\_less\\_equal}</code>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1C/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1C/#variable-equal_to","title":"variable equal_to","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::C::equal_to;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1C/#variable-less","title":"variable less","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::C::less;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1C/#variable-less_equal","title":"variable less_equal","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::C::less_equal;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1D/","title":"Struct zmbt::lang::Operator::Handle::Handle","text":"<p>ClassList &gt; Handle &gt; Handle</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1D/#public-attributes","title":"Public Attributes","text":"Type Name unary_transform decorate   = <code>{generic\\_decorate}</code> unary_transform undecorate   = <code>{generic\\_undecorate}</code>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1D/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1D/#variable-decorate","title":"variable decorate","text":"<pre><code>unary_transform zmbt::lang::Operator::Handle::D::decorate;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1D/#variable-undecorate","title":"variable undecorate","text":"<pre><code>unary_transform zmbt::lang::Operator::Handle::D::undecorate;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1L/","title":"Struct zmbt::lang::Operator::Handle::Handle","text":"<p>ClassList &gt; Handle &gt; Handle</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1L/#public-attributes","title":"Public Attributes","text":"Type Name binary_transform and_   = <code>{generic\\_logical\\_and}</code> unary_transform bool_   = <code>{generic\\_is\\_truth}</code> binary_transform or_   = <code>{generic\\_logical\\_or}</code>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1L/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1L/#variable-and_","title":"variable and_","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::L::and_;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1L/#variable-bool_","title":"variable bool_","text":"<pre><code>unary_transform zmbt::lang::Operator::Handle::L::bool_;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1L/#variable-or_","title":"variable or_","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::L::or_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1S/","title":"Struct zmbt::lang::Operator::Handle::Handle","text":"<p>ClassList &gt; Handle &gt; Handle</p>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1S/#public-attributes","title":"Public Attributes","text":"Type Name binary_transform left   = <code>{generic\\_left\\_shift}</code> binary_transform right   = <code>{generic\\_right\\_shift}</code>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1S/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1S/#variable-left","title":"variable left","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::S::left;\n</code></pre>"},{"location":"CxxRef/structzmbt_1_1lang_1_1Operator_1_1Handle_1_1S/#variable-right","title":"variable right","text":"<pre><code>binary_transform zmbt::lang::Operator::Handle::S::right;\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Alias/","title":"Struct zmbt::mapping::ModelDefinition::T_Alias","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_Alias</p> <p>T_Alias transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Alias</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Alias/#public-functions","title":"Public Functions","text":"Type Name Target Alias (boost::json::string_view alias) Set channel Alias."},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Alias/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Alias/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Alias/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Alias/#function-alias","title":"function Alias","text":"<p>Set channel Alias. <pre><code>inline Target T_Alias::Alias (\n    boost::json::string_view alias\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__As/","title":"Struct zmbt::mapping::ModelDefinition::T_As","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_As</p> <p>T_As transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Decor</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__As/#public-functions","title":"Public Functions","text":"Type Name Target As (boost::json::string_view ref)  Target As (lang::Operator const &amp; op)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__As/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__As/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__As/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__As/#function-as-12","title":"function As [1/2]","text":"<pre><code>inline Target T_As::As (\n    boost::json::string_view ref\n) \n</code></pre> <p>Apply Overload operator and optionally pipe with Cast if expression is non-predicate constant. </p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__As/#function-as-22","title":"function As [2/2]","text":"<pre><code>inline Target T_As::As (\n    lang::Operator const &amp; op\n) \n</code></pre> <p>Apply Overload operator and optionally pipe with Cast if expression is non-predicate constant. </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__At/","title":"Struct zmbt::mapping::ModelDefinition::T_At","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_At</p> <p>T_At transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Channel,  zmbt::mapping::ModelDefinition::N_MaybeChannel</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__At/#public-functions","title":"Public Functions","text":"Type Name require_not_str&lt; Interface, Target &gt; At (Interface &amp;&amp; cal, object_id const &amp; obj) Create input channel with an interface literal. require_not_str&lt; Interface, Target &gt; At (Interface &amp;&amp; cal, Param const &amp; obj)  require_not_str&lt; Interface, Target &gt; At (Interface &amp;&amp; cal) Create input channel. Target At (boost::json::string_view key, T &amp;&amp;... fmtargs)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__At/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__At/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__At/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__At/#function-at-14","title":"function At [1/4]","text":"<p>Create input channel with an interface literal. <pre><code>template&lt;class Interface&gt;\ninline require_not_str&lt; Interface, Target &gt; T_At::At (\n    Interface &amp;&amp; cal,\n    object_id const &amp; obj\n) \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__At/#function-at-24","title":"function At [2/4]","text":"<pre><code>template&lt;class Interface&gt;\ninline require_not_str&lt; Interface, Target &gt; T_At::At (\n    Interface &amp;&amp; cal,\n    Param const &amp; obj\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__At/#function-at-34","title":"function At [3/4]","text":"<p>Create input channel. <pre><code>template&lt;class Interface&gt;\ninline require_not_str&lt; Interface, Target &gt; T_At::At (\n    Interface &amp;&amp; cal\n) \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__At/#function-at-44","title":"function At [4/4]","text":"<pre><code>template&lt;class... T&gt;\ninline Target T_At::At (\n    boost::json::string_view key,\n    T &amp;&amp;... fmtargs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ContinuePipe/","title":"Struct zmbt::mapping::ModelDefinition::T_ContinuePipe","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_ContinuePipe</p> <p>T_ContinuePipe transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_ChannelEnd</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ContinuePipe/#public-functions","title":"Public Functions","text":"Type Name Target Blend ()  Target Group ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ContinuePipe/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ContinuePipe/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ContinuePipe/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ContinuePipe/#function-blend","title":"function Blend","text":"<pre><code>inline Target T_ContinuePipe::Blend () \n</code></pre> <p>Combine channel outputs in time series</p> <p>Combined channels produce a list of pairs [channel alias, requested signal], sorted by timestamp. Use it in combination with Saturate expr for testing strict or partial order on mock calls. </p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ContinuePipe/#function-group","title":"function Group","text":"<pre><code>inline Target T_ContinuePipe::Group () \n</code></pre> <p>Pack channel outputs into an array similarly to Fork keyword X with Y with Z -&gt; [X, Y, Z] </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__CustomParam/","title":"Struct zmbt::mapping::ModelDefinition::T_CustomParam","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_CustomParam</p> <p>T_CustomParam transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Param</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__CustomParam/#public-functions","title":"Public Functions","text":"Type Name Target Parametrize (lang::Expression const &amp;)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__CustomParam/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__CustomParam/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__CustomParam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__CustomParam/#function-parametrize","title":"function Parametrize","text":"<pre><code>inline Target T_CustomParam::Parametrize (\n    lang::Expression const &amp;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Description/","title":"Struct zmbt::mapping::ModelDefinition::T_Description","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_Description</p> <p>T_Description transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Descr</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Description/#public-functions","title":"Public Functions","text":"Type Name Target Description (boost::json::string_view comment, T &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Description/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Description/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Description/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Description/#function-description","title":"function Description","text":"<pre><code>template&lt;class... T&gt;\ninline Target T_Description::Description (\n    boost::json::string_view comment,\n    T &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/","title":"Struct zmbt::mapping::ModelDefinition::T_Filter","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_Filter</p> <p>T_Filter transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Filter</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#public-functions","title":"Public Functions","text":"Type Name Target Args (lang::Expression const &amp; e=\"$(default)\")  Target Args (boost::json::string_view fmt, T &amp;&amp; arg1, Rest &amp;&amp;... args_rest) Interface argument clause with printf-like format. Target CallCount ()  Target Exception () Interface exception. Target Return (lang::Expression const &amp; e=\"\")  Target Return (boost::json::string_view fmt, T &amp;&amp; arg1, Rest &amp;&amp;... args_rest) Interface return clause with printf-like format. Target ThreadId () Output capture thread id. Target Timestamp () Output capture timestamp."},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#function-args-12","title":"function Args [1/2]","text":"<pre><code>inline Target T_Filter::Args (\n    lang::Expression const &amp; e=\"$(default)\"\n) \n</code></pre> <p>Interface argument clause Refers to the arguments subsignal at the given JSON Pointer </p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#function-args-22","title":"function Args [2/2]","text":"<p>Interface argument clause with printf-like format. <pre><code>template&lt;class T, class... Rest&gt;\ninline Target T_Filter::Args (\n    boost::json::string_view fmt,\n    T &amp;&amp; arg1,\n    Rest &amp;&amp;... args_rest\n) \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#function-callcount","title":"function CallCount","text":"<pre><code>inline Target T_Filter::CallCount () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#function-exception","title":"function Exception","text":"<p>Interface exception. <pre><code>inline Target T_Filter::Exception () \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#function-return-12","title":"function Return [1/2]","text":"<pre><code>inline Target T_Filter::Return (\n    lang::Expression const &amp; e=\"\"\n) \n</code></pre> <p>Interface return clause Refers to the return subsignal at the given JSON Pointer </p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#function-return-22","title":"function Return [2/2]","text":"<p>Interface return clause with printf-like format. <pre><code>template&lt;class T, class... Rest&gt;\ninline Target T_Filter::Return (\n    boost::json::string_view fmt,\n    T &amp;&amp; arg1,\n    Rest &amp;&amp;... args_rest\n) \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#function-threadid","title":"function ThreadId","text":"<p>Output capture thread id. <pre><code>inline Target T_Filter::ThreadId () \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Filter/#function-timestamp","title":"function Timestamp","text":"<p>Output capture timestamp. <pre><code>inline Target T_Filter::Timestamp () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/","title":"Struct zmbt::mapping::ModelDefinition::T_OnTrigger","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_OnTrigger</p> <p>T_OnTrigger transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Main</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#public-functions","title":"Public Functions","text":"Type Name Target OnTrigger (boost::json::string_view key, T &amp;&amp;... fmtargs)  Target OnTrigger (Param const &amp; key)  Target OnTrigger (Param const &amp; ifc, Param const &amp; obj)  require_literal&lt; O, Interface, Target &gt; OnTrigger (Interface &amp;&amp; ifc, O &amp;&amp; obj)  require_cal&lt; Interface, Target &gt; OnTrigger (Interface &amp;&amp; ifc)  require_cal&lt; Interface, Target &gt; OnTrigger (Interface &amp;&amp; ifc, Param const &amp; obj)  require_obj&lt; H, Target &gt; OnTrigger (Param const &amp; ifc, H &amp;&amp; obj)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#function-ontrigger-17","title":"function OnTrigger [1/7]","text":"<pre><code>template&lt;class... T&gt;\ninline Target T_OnTrigger::OnTrigger (\n    boost::json::string_view key,\n    T &amp;&amp;... fmtargs\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#function-ontrigger-27","title":"function OnTrigger [2/7]","text":"<pre><code>inline Target T_OnTrigger::OnTrigger (\n    Param const &amp; key\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#function-ontrigger-37","title":"function OnTrigger [3/7]","text":"<pre><code>inline Target T_OnTrigger::OnTrigger (\n    Param const &amp; ifc,\n    Param const &amp; obj\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#function-ontrigger-47","title":"function OnTrigger [4/7]","text":"<pre><code>template&lt;class O, class Interface&gt;\ninline require_literal&lt; O, Interface, Target &gt; T_OnTrigger::OnTrigger (\n    Interface &amp;&amp; ifc,\n    O &amp;&amp; obj\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#function-ontrigger-57","title":"function OnTrigger [5/7]","text":"<pre><code>template&lt;class Interface&gt;\ninline require_cal&lt; Interface, Target &gt; T_OnTrigger::OnTrigger (\n    Interface &amp;&amp; ifc\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#function-ontrigger-67","title":"function OnTrigger [6/7]","text":"<pre><code>template&lt;class Interface&gt;\ninline require_cal&lt; Interface, Target &gt; T_OnTrigger::OnTrigger (\n    Interface &amp;&amp; ifc,\n    Param const &amp; obj\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__OnTrigger/#function-ontrigger-77","title":"function OnTrigger [7/7]","text":"<pre><code>template&lt;class H&gt;\ninline require_obj&lt; H, Target &gt; T_OnTrigger::OnTrigger (\n    Param const &amp; ifc,\n    H &amp;&amp; obj\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/","title":"Struct zmbt::mapping::ModelDefinition::T_Param","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_Param</p> <p>T_Param transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Param</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#public-functions","title":"Public Functions","text":"Type Name Target Pairwise (Param const &amp; p, boost::json::value const &amp; v0)  Target Pairwise (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1)  Target Pairwise (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2)  Target Pairwise (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3)  Target Pairwise (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4)  Target Pairwise (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5)  Target Pairwise (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6)  Target Pairwise (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6, boost::json::value const &amp; v7)  Target Pairwise (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6, boost::json::value const &amp; v7, A &amp;&amp;... args)  Target Pairwise (Param const &amp; p, A &amp;&amp;... args)  Target Prod (Param const &amp; p, boost::json::value const &amp; v0)  Target Prod (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1)  Target Prod (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2)  Target Prod (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3)  Target Prod (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4)  Target Prod (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5)  Target Prod (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6)  Target Prod (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6, boost::json::value const &amp; v7)  Target Prod (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6, boost::json::value const &amp; v7, A &amp;&amp;... args)  Target Prod (Param const &amp; p, A &amp;&amp;... args)  Target Zip (Param const &amp; p, boost::json::value const &amp; v0)  Target Zip (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1)  Target Zip (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2)  Target Zip (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3)  Target Zip (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4)  Target Zip (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5)  Target Zip (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6)  Target Zip (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6, boost::json::value const &amp; v7)  Target Zip (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6, boost::json::value const &amp; v7, A &amp;&amp;... args)  Target Zip (Param const &amp; p, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-110","title":"function Pairwise [1/10]","text":"<pre><code>inline Target T_Param::Pairwise (\n    Param const &amp; p,\n    boost::json::value const &amp; v0\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-210","title":"function Pairwise [2/10]","text":"<pre><code>inline Target T_Param::Pairwise (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-310","title":"function Pairwise [3/10]","text":"<pre><code>inline Target T_Param::Pairwise (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-410","title":"function Pairwise [4/10]","text":"<pre><code>inline Target T_Param::Pairwise (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-510","title":"function Pairwise [5/10]","text":"<pre><code>inline Target T_Param::Pairwise (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-610","title":"function Pairwise [6/10]","text":"<pre><code>inline Target T_Param::Pairwise (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-710","title":"function Pairwise [7/10]","text":"<pre><code>inline Target T_Param::Pairwise (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-810","title":"function Pairwise [8/10]","text":"<pre><code>inline Target T_Param::Pairwise (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6,\n    boost::json::value const &amp; v7\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-910","title":"function Pairwise [9/10]","text":"<pre><code>template&lt;class... A&gt;\ninline Target T_Param::Pairwise (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6,\n    boost::json::value const &amp; v7,\n    A &amp;&amp;... args\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-pairwise-1010","title":"function Pairwise [10/10]","text":"<pre><code>template&lt;class... A&gt;\ninline Target T_Param::Pairwise (\n    Param const &amp; p,\n    A &amp;&amp;... args\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-110","title":"function Prod [1/10]","text":"<pre><code>inline Target T_Param::Prod (\n    Param const &amp; p,\n    boost::json::value const &amp; v0\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-210","title":"function Prod [2/10]","text":"<pre><code>inline Target T_Param::Prod (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-310","title":"function Prod [3/10]","text":"<pre><code>inline Target T_Param::Prod (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-410","title":"function Prod [4/10]","text":"<pre><code>inline Target T_Param::Prod (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-510","title":"function Prod [5/10]","text":"<pre><code>inline Target T_Param::Prod (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-610","title":"function Prod [6/10]","text":"<pre><code>inline Target T_Param::Prod (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-710","title":"function Prod [7/10]","text":"<pre><code>inline Target T_Param::Prod (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-810","title":"function Prod [8/10]","text":"<pre><code>inline Target T_Param::Prod (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6,\n    boost::json::value const &amp; v7\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-910","title":"function Prod [9/10]","text":"<pre><code>template&lt;class... A&gt;\ninline Target T_Param::Prod (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6,\n    boost::json::value const &amp; v7,\n    A &amp;&amp;... args\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-prod-1010","title":"function Prod [10/10]","text":"<pre><code>template&lt;class... A&gt;\ninline Target T_Param::Prod (\n    Param const &amp; p,\n    A &amp;&amp;... args\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-110","title":"function Zip [1/10]","text":"<pre><code>inline Target T_Param::Zip (\n    Param const &amp; p,\n    boost::json::value const &amp; v0\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-210","title":"function Zip [2/10]","text":"<pre><code>inline Target T_Param::Zip (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-310","title":"function Zip [3/10]","text":"<pre><code>inline Target T_Param::Zip (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-410","title":"function Zip [4/10]","text":"<pre><code>inline Target T_Param::Zip (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-510","title":"function Zip [5/10]","text":"<pre><code>inline Target T_Param::Zip (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-610","title":"function Zip [6/10]","text":"<pre><code>inline Target T_Param::Zip (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-710","title":"function Zip [7/10]","text":"<pre><code>inline Target T_Param::Zip (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-810","title":"function Zip [8/10]","text":"<pre><code>inline Target T_Param::Zip (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6,\n    boost::json::value const &amp; v7\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-910","title":"function Zip [9/10]","text":"<pre><code>template&lt;class... A&gt;\ninline Target T_Param::Zip (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6,\n    boost::json::value const &amp; v7,\n    A &amp;&amp;... args\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Param/#function-zip-1010","title":"function Zip [10/10]","text":"<pre><code>template&lt;class... A&gt;\ninline Target T_Param::Zip (\n    Param const &amp; p,\n    A &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/","title":"Struct zmbt::mapping::ModelDefinition::T_ParamRow","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_ParamRow</p> <p>T_ParamRow transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_ParamTable</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#public-functions","title":"Public Functions","text":"Type Name Target operator() (Param const &amp; p, A &amp;&amp;... args)  Target operator() (Param const &amp; p, boost::json::value const &amp; v0)  Target operator() (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1)  Target operator() (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2)  Target operator() (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3)  Target operator() (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4)  Target operator() (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5)  Target operator() (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6)  Target operator() (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6, boost::json::value const &amp; v7)  Target operator() (Param const &amp; p, boost::json::value const &amp; v0, boost::json::value const &amp; v1, boost::json::value const &amp; v2, boost::json::value const &amp; v3, boost::json::value const &amp; v4, boost::json::value const &amp; v5, boost::json::value const &amp; v6, boost::json::value const &amp; v7, A &amp;&amp;... args)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class... A&gt;\ninline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    A &amp;&amp;... args\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator_1","title":"function operator()","text":"<pre><code>inline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    boost::json::value const &amp; v0\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator_2","title":"function operator()","text":"<pre><code>inline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator_3","title":"function operator()","text":"<pre><code>inline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator_4","title":"function operator()","text":"<pre><code>inline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator_5","title":"function operator()","text":"<pre><code>inline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator_6","title":"function operator()","text":"<pre><code>inline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator_7","title":"function operator()","text":"<pre><code>inline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator_8","title":"function operator()","text":"<pre><code>inline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6,\n    boost::json::value const &amp; v7\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__ParamRow/#function-operator_9","title":"function operator()","text":"<pre><code>template&lt;class... A&gt;\ninline Target T_ParamRow::operator() (\n    Param const &amp; p,\n    boost::json::value const &amp; v0,\n    boost::json::value const &amp; v1,\n    boost::json::value const &amp; v2,\n    boost::json::value const &amp; v3,\n    boost::json::value const &amp; v4,\n    boost::json::value const &amp; v5,\n    boost::json::value const &amp; v6,\n    boost::json::value const &amp; v7,\n    A &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PostRun/","title":"Struct zmbt::mapping::ModelDefinition::T_PostRun","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_PostRun</p> <p>T_PostRun transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Post</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PostRun/#public-functions","title":"Public Functions","text":"Type Name Target PostRun (T &amp;&amp;... tasks)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PostRun/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PostRun/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PostRun/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PostRun/#function-postrun","title":"function PostRun","text":"<pre><code>template&lt;class... T&gt;\ninline Target T_PostRun::PostRun (\n    T &amp;&amp;... tasks\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PreRun/","title":"Struct zmbt::mapping::ModelDefinition::T_PreRun","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_PreRun</p> <p>T_PreRun transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Pre</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PreRun/#public-functions","title":"Public Functions","text":"Type Name Target PreRun (T &amp;&amp;... tasks)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PreRun/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PreRun/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PreRun/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__PreRun/#function-prerun","title":"function PreRun","text":"<pre><code>template&lt;class... T&gt;\ninline Target T_PreRun::PreRun (\n    T &amp;&amp;... tasks\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Repeat/","title":"Struct zmbt::mapping::ModelDefinition::T_Repeat","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_Repeat</p> <p>T_Repeat transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Repeat</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Repeat/#public-functions","title":"Public Functions","text":"Type Name Target Repeat (std::size_t N) Run trigger N times. Target Repeat (Param const &amp; N) Run trigger N times."},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Repeat/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Repeat/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Repeat/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Repeat/#function-repeat-12","title":"function Repeat [1/2]","text":"<p>Run trigger N times. <pre><code>inline Target T_Repeat::Repeat (\n    std::size_t N\n) \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Repeat/#function-repeat-22","title":"function Repeat [2/2]","text":"<p>Run trigger N times. <pre><code>inline Target T_Repeat::Repeat (\n    Param const &amp; N\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Take/","title":"Struct zmbt::mapping::ModelDefinition::T_Take","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_Take</p> <p>T_Take transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Take</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Take/#public-functions","title":"Public Functions","text":"Type Name Target Take (lang::Expression const &amp; expr) Set the pre/post transformation on channel signal."},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Take/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Take/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Take/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Take/#function-take","title":"function Take","text":"<p>Set the pre/post transformation on channel signal. <pre><code>inline Target T_Take::Take (\n    lang::Expression const &amp; expr\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TerminatePipe/","title":"Struct zmbt::mapping::ModelDefinition::T_TerminatePipe","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_TerminatePipe</p> <p>T_TerminatePipe transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_ChannelEnd</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TerminatePipe/#public-functions","title":"Public Functions","text":"Type Name Target Expect ()  Target Expect (lang::Expression const &amp; expr) Set fixed output assertion. Target Inject ()  Target Inject (lang::Expression const &amp; expr) Set fixed input condition."},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TerminatePipe/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TerminatePipe/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TerminatePipe/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TerminatePipe/#function-expect-12","title":"function Expect [1/2]","text":"<pre><code>inline Target T_TerminatePipe::Expect () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TerminatePipe/#function-expect-22","title":"function Expect [2/2]","text":"<p>Set fixed output assertion. <pre><code>inline Target T_TerminatePipe::Expect (\n    lang::Expression const &amp; expr\n) \n</code></pre></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TerminatePipe/#function-inject-12","title":"function Inject [1/2]","text":"<pre><code>inline Target T_TerminatePipe::Inject () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TerminatePipe/#function-inject-22","title":"function Inject [2/2]","text":"<p>Set fixed input condition. <pre><code>inline Target T_TerminatePipe::Inject (\n    lang::Expression const &amp; expr\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/","title":"Struct zmbt::mapping::ModelDefinition::T_Test","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_Test</p> <p>T_Test transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_Test</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#public-functions","title":"Public Functions","text":"Type Name Target Test ()  Target Test (lang::Expression const &amp; e0)  Target Test (lang::Expression const &amp; e0, lang::Expression const &amp; e1)  Target Test (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2)  Target Test (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3)  Target Test (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4)  Target Test (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4, lang::Expression const &amp; e5)  Target Test (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4, lang::Expression const &amp; e5, lang::Expression const &amp; e6)  Target Test (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4, lang::Expression const &amp; e5, lang::Expression const &amp; e6, lang::Expression const &amp; e7)  Target Test (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4, lang::Expression const &amp; e5, lang::Expression const &amp; e6, lang::Expression const &amp; e7, Rest &amp;&amp;... rest)"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-110","title":"function Test [1/10]","text":"<pre><code>inline Target T_Test::Test () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-210","title":"function Test [2/10]","text":"<pre><code>inline Target T_Test::Test (\n    lang::Expression const &amp; e0\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-310","title":"function Test [3/10]","text":"<pre><code>inline Target T_Test::Test (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-410","title":"function Test [4/10]","text":"<pre><code>inline Target T_Test::Test (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-510","title":"function Test [5/10]","text":"<pre><code>inline Target T_Test::Test (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-610","title":"function Test [6/10]","text":"<pre><code>inline Target T_Test::Test (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-710","title":"function Test [7/10]","text":"<pre><code>inline Target T_Test::Test (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4,\n    lang::Expression const &amp; e5\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-810","title":"function Test [8/10]","text":"<pre><code>inline Target T_Test::Test (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4,\n    lang::Expression const &amp; e5,\n    lang::Expression const &amp; e6\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-910","title":"function Test [9/10]","text":"<pre><code>inline Target T_Test::Test (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4,\n    lang::Expression const &amp; e5,\n    lang::Expression const &amp; e6,\n    lang::Expression const &amp; e7\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__Test/#function-test-1010","title":"function Test [10/10]","text":"<pre><code>template&lt;class... Rest&gt;\ninline Target T_Test::Test (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4,\n    lang::Expression const &amp; e5,\n    lang::Expression const &amp; e6,\n    lang::Expression const &amp; e7,\n    Rest &amp;&amp;... rest\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/","title":"Struct zmbt::mapping::ModelDefinition::T_TestRow","text":"<p>template &lt;class Target&gt;</p> <p>ClassList &gt; T_TestRow</p> <p>T_TestRow transition. </p> <p>Inherits the following classes: zmbt::mapping::ModelDefinition::BaseTransition</p> <p>Inherited by the following classes: zmbt::mapping::ModelDefinition::N_TestTable</p>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#public-functions","title":"Public Functions","text":"Type Name Target operator() ()  Target operator() (lang::Expression const &amp; e0)  Target operator() (lang::Expression const &amp; e0, lang::Expression const &amp; e1)  Target operator() (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2)  Target operator() (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3)  Target operator() (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4)  Target operator() (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4, lang::Expression const &amp; e5)  Target operator() (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4, lang::Expression const &amp; e5, lang::Expression const &amp; e6)  Target operator() (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4, lang::Expression const &amp; e5, lang::Expression const &amp; e6, lang::Expression const &amp; e7)  Target operator() (lang::Expression const &amp; e0, lang::Expression const &amp; e1, lang::Expression const &amp; e2, lang::Expression const &amp; e3, lang::Expression const &amp; e4, lang::Expression const &amp; e5, lang::Expression const &amp; e6, lang::Expression const &amp; e7, Rest &amp;&amp;... rest)  Target operator[] (boost::json::string_view comment) test comment"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#public-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Public Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name virtual ~BaseTransition ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#protected-functions-inherited-from-zmbtmappingmodeldefinitionbasetransition","title":"Protected Functions inherited from zmbt::mapping::ModelDefinition::BaseTransition","text":"<p>See zmbt::mapping::ModelDefinition::BaseTransition</p> Type Name BaseTransition (detail::DefinitionHelper &amp;&amp; m)  BaseTransition ()  BaseTransition (BaseTransition const &amp;) = delete BaseTransition (BaseTransition &amp;&amp;) = default detail::DefinitionHelper &amp; state ()  Target transit_to ()"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator","title":"function operator()","text":"<pre><code>inline Target T_TestRow::operator() () \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_1","title":"function operator()","text":"<pre><code>inline Target T_TestRow::operator() (\n    lang::Expression const &amp; e0\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_2","title":"function operator()","text":"<pre><code>inline Target T_TestRow::operator() (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_3","title":"function operator()","text":"<pre><code>inline Target T_TestRow::operator() (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_4","title":"function operator()","text":"<pre><code>inline Target T_TestRow::operator() (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_5","title":"function operator()","text":"<pre><code>inline Target T_TestRow::operator() (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_6","title":"function operator()","text":"<pre><code>inline Target T_TestRow::operator() (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4,\n    lang::Expression const &amp; e5\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_7","title":"function operator()","text":"<pre><code>inline Target T_TestRow::operator() (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4,\n    lang::Expression const &amp; e5,\n    lang::Expression const &amp; e6\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_8","title":"function operator()","text":"<pre><code>inline Target T_TestRow::operator() (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4,\n    lang::Expression const &amp; e5,\n    lang::Expression const &amp; e6,\n    lang::Expression const &amp; e7\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_9","title":"function operator()","text":"<pre><code>template&lt;class... Rest&gt;\ninline Target T_TestRow::operator() (\n    lang::Expression const &amp; e0,\n    lang::Expression const &amp; e1,\n    lang::Expression const &amp; e2,\n    lang::Expression const &amp; e3,\n    lang::Expression const &amp; e4,\n    lang::Expression const &amp; e5,\n    lang::Expression const &amp; e6,\n    lang::Expression const &amp; e7,\n    Rest &amp;&amp;... rest\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1mapping_1_1ModelDefinition_1_1T__TestRow/#function-operator_10","title":"function operator[]","text":"<p>test comment <pre><code>inline Target T_TestRow::operator[] (\n    boost::json::string_view comment\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1precise_3_01T_01_4_01_4/","title":"Struct zmbt::reflect::custom_serialization&lt; decor::precise&lt; T &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; custom_serialization&lt; decor::precise&lt; T &gt; &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1precise_3_01T_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name decor::precise&lt; T &gt; dejsonize (boost::json::value const &amp; v)  boost::json::value json_from (decor::precise&lt; T &gt; const t)"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1precise_3_01T_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1precise_3_01T_01_4_01_4/#function-dejsonize","title":"function dejsonize","text":"<pre><code>static inline decor::precise &lt; T &gt; custom_serialization&lt; decor::precise&lt; T &gt; &gt;::dejsonize (\n    boost::json::value const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1precise_3_01T_01_4_01_4/#function-json_from","title":"function json_from","text":"<pre><code>static inline boost::json::value custom_serialization&lt; decor::precise&lt; T &gt; &gt;::json_from (\n    decor::precise &lt; T &gt; const t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/precise_real.hpp</code></p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1underlying_3_01T_01_4_01_4/","title":"Struct zmbt::reflect::custom_serialization&lt; decor::underlying&lt; T &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; custom_serialization&lt; decor::underlying&lt; T &gt; &gt;</p>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1underlying_3_01T_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name decor::underlying&lt; T &gt; dejsonize (boost::json::value const &amp; v)  boost::json::value json_from (decor::underlying&lt; T &gt; const t)"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1underlying_3_01T_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1underlying_3_01T_01_4_01_4/#function-dejsonize","title":"function dejsonize","text":"<pre><code>static inline decor::underlying &lt; T &gt; custom_serialization&lt; decor::underlying&lt; T &gt; &gt;::dejsonize (\n    boost::json::value const &amp; v\n) \n</code></pre>"},{"location":"CxxRef/structzmbt_1_1reflect_1_1custom__serialization_3_01decor_1_1underlying_3_01T_01_4_01_4/#function-json_from","title":"function json_from","text":"<pre><code>static inline boost::json::value custom_serialization&lt; decor::underlying&lt; T &gt; &gt;::json_from (\n    decor::underlying &lt; T &gt; const t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/underlying.hpp</code></p>"},{"location":"CxxRef/namespaces_8dox/","title":"File namespaces.dox","text":"<p>FileList &gt; namespaces.dox</p> <p>Go to the source code of this file</p>"},{"location":"CxxRef/namespaces_8dox/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace api Framework API with fixture classes and entries from main ns. namespace application Test application configuration (work in progress) namespace decor Signal type decorators API. namespace expr Expression Language API. namespace lang Expression Language implementation. namespace mapping Signal Mapping model functionality. namespace reflect Reflection metafunctions. <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/namespaces.dox</code></p>"},{"location":"CxxRef/namespaces_8dox_source/","title":"File namespaces.dox","text":"<p>File List &gt; namespaces.dox</p> <p>Go to the documentation of this file</p> <pre><code>#error Doxygen documentation file, not for include\n</code></pre>"},{"location":"CxxRef/dir_5cc8f6c6cee9c6709f50999cbc2a49c0/","title":"Dir zmbt-framework","text":"<p>FileList &gt; zmbt-framework</p>"},{"location":"CxxRef/dir_5cc8f6c6cee9c6709f50999cbc2a49c0/#directories","title":"Directories","text":"Type Name dir zmbt-framework <p>The documentation for this class was generated from the following file <code>zmbt-framework/</code></p>"},{"location":"CxxRef/dir_bb0a9de190a5c1cb17a41c225c0cd423/","title":"Dir zmbt-framework/zmbt-framework","text":"<p>FileList &gt; zmbt-framework &gt; zmbt-framework</p>"},{"location":"CxxRef/dir_bb0a9de190a5c1cb17a41c225c0cd423/#directories","title":"Directories","text":"Type Name dir backends <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/</code></p>"},{"location":"CxxRef/dir_e0e3bad64fbfd08934d555b945409197/","title":"Dir zmbt-framework/zmbt-framework/backends","text":"<p>FileList &gt; backends</p>"},{"location":"CxxRef/dir_e0e3bad64fbfd08934d555b945409197/#directories","title":"Directories","text":"Type Name dir cxx <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/</code></p>"},{"location":"CxxRef/dir_2a0640ff8f8d193383b3226ce9e70e40/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx","text":"<p>FileList &gt; backends &gt; cxx</p>"},{"location":"CxxRef/dir_2a0640ff8f8d193383b3226ce9e70e40/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/</code></p>"},{"location":"CxxRef/dir_33cabc3ab2bb40d6ea24a24cae2f30b8/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include","text":"<p>FileList &gt; backends &gt; cxx &gt; include</p>"},{"location":"CxxRef/dir_33cabc3ab2bb40d6ea24a24cae2f30b8/#files","title":"Files","text":"Type Name file zenseact-mbt.hpp"},{"location":"CxxRef/dir_33cabc3ab2bb40d6ea24a24cae2f30b8/#directories","title":"Directories","text":"Type Name dir zmbt <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/</code></p>"},{"location":"CxxRef/zenseact-mbt_8hpp/","title":"File zenseact-mbt.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zenseact-mbt.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"zmbt/all.hpp\"</code></li> </ul>"},{"location":"CxxRef/zenseact-mbt_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zenseact-mbt.hpp</code></p>"},{"location":"CxxRef/zenseact-mbt_8hpp_source/","title":"File zenseact-mbt.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zenseact-mbt.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_TEST_HPP_\n#define ZMBT_TEST_HPP_\n\n#include \"zmbt/all.hpp\"\n\n#endif  // ZMBT_TEST_LIB_HPP_\n</code></pre>"},{"location":"CxxRef/dir_2115e3e51895e4107b806d6d2319263e/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include/zmbt","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt</p>"},{"location":"CxxRef/dir_2115e3e51895e4107b806d6d2319263e/#files","title":"Files","text":"Type Name file all.hpp file api.hpp file application.hpp file core.hpp file decor.hpp file expr.hpp file mapping.hpp file model.hpp file reflect.hpp"},{"location":"CxxRef/dir_2115e3e51895e4107b806d6d2319263e/#directories","title":"Directories","text":"Type Name dir api dir application dir core dir decor dir expr dir mapping dir model dir reflect <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/</code></p>"},{"location":"CxxRef/all_8hpp/","title":"File all.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; all.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"core.hpp\"</code></li> <li><code>#include \"reflect.hpp\"</code></li> <li><code>#include \"expr.hpp\"</code></li> <li><code>#include \"model.hpp\"</code></li> <li><code>#include \"mapping.hpp\"</code></li> <li><code>#include \"decor.hpp\"</code></li> <li><code>#include \"api.hpp\"</code></li> <li><code>#include \"application.hpp\"</code></li> </ul>"},{"location":"CxxRef/all_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/all.hpp</code></p>"},{"location":"CxxRef/all_8hpp_source/","title":"File all.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; all.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_ALL_HPP_\n#define ZMBT_ALL_HPP_\n\n#include \"core.hpp\"\n#include \"reflect.hpp\"\n#include \"expr.hpp\"\n#include \"model.hpp\"\n#include \"mapping.hpp\"\n#include \"decor.hpp\"\n#include \"api.hpp\"\n#include \"application.hpp\"\n\n#endif  // ZMBT_ALL_HPP_\n</code></pre>"},{"location":"CxxRef/api_8hpp/","title":"File api.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; api.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"api/ns.hpp\"</code></li> <li><code>#include \"api/model_test.hpp\"</code></li> </ul>"},{"location":"CxxRef/api_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api.hpp</code></p>"},{"location":"CxxRef/api_8hpp_source/","title":"File api.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; api.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_FIXTURE_HPP_\n#define ZMBT_FIXTURE_HPP_\n\n#include \"api/ns.hpp\"\n#include \"api/model_test.hpp\"\n\n#endif // ZMBT_FIXTURE_HPP_\n</code></pre>"},{"location":"CxxRef/application_8hpp/","title":"File application.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; application.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"application/init.hpp\"</code></li> <li><code>#include \"application/config.hpp\"</code></li> <li><code>#include \"application/test_failure.hpp\"</code></li> <li><code>#include \"application/log.hpp\"</code></li> </ul>"},{"location":"CxxRef/application_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application.hpp</code></p>"},{"location":"CxxRef/application_8hpp_source/","title":"File application.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; application.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_APPLICATION_HPP_\n#define ZMBT_APPLICATION_HPP_\n\n\n#include \"application/init.hpp\"\n#include \"application/config.hpp\"\n#include \"application/test_failure.hpp\"\n#include \"application/log.hpp\"\n\n\n#endif // ZMBT_APPLICATION_HPP_\n</code></pre>"},{"location":"CxxRef/core_8hpp/","title":"File core.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"core/aliases.hpp\"</code></li> <li><code>#include \"core/exceptions.hpp\"</code></li> <li><code>#include \"core/file_parser.hpp\"</code></li> <li><code>#include \"core/format_string.hpp\"</code></li> <li><code>#include \"core/generic_traits.hpp\"</code></li> <li><code>#include \"core/get_info.hpp\"</code></li> <li><code>#include \"core/interface_traits.hpp\"</code></li> <li><code>#include \"core/json_iter.hpp\"</code></li> <li><code>#include \"core/json_node.hpp\"</code></li> <li><code>#include \"core/json_number_cast.hpp\"</code></li> <li><code>#include \"core/json_traverse.hpp\"</code></li> <li><code>#include \"core/json_pretty_print.hpp\"</code></li> <li><code>#include \"core/slice.hpp\"</code></li> <li><code>#include \"core/preprocessor.hpp\"</code></li> <li><code>#include \"core/operator_traits.hpp\"</code></li> <li><code>#include \"core/shared_resource.hpp\"</code></li> <li><code>#include \"core/tuple_conversion.hpp\"</code></li> <li><code>#include \"core/tuple_exchange.hpp\"</code></li> <li><code>#include \"core/tuple_indexator.hpp\"</code></li> <li><code>#include \"core/type_info.hpp\"</code></li> <li><code>#include \"core/type_tag.hpp\"</code></li> <li><code>#include \"core/entity_id.hpp\"</code></li> <li><code>#include \"core/interface_id.hpp\"</code></li> <li><code>#include \"core/object_id.hpp\"</code></li> </ul>"},{"location":"CxxRef/core_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core.hpp</code></p>"},{"location":"CxxRef/core_8hpp_source/","title":"File core.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_HPP_\n#define ZMBT_CORE_HPP_\n\n#include \"core/aliases.hpp\"\n#include \"core/exceptions.hpp\"\n#include \"core/file_parser.hpp\"\n#include \"core/format_string.hpp\"\n#include \"core/generic_traits.hpp\"\n#include \"core/get_info.hpp\"\n#include \"core/interface_traits.hpp\"\n#include \"core/json_iter.hpp\"\n#include \"core/json_node.hpp\"\n#include \"core/json_number_cast.hpp\"\n#include \"core/json_traverse.hpp\"\n#include \"core/json_pretty_print.hpp\"\n#include \"core/slice.hpp\"\n#include \"core/preprocessor.hpp\"\n#include \"core/operator_traits.hpp\"\n#include \"core/shared_resource.hpp\"\n#include \"core/tuple_conversion.hpp\"\n#include \"core/tuple_exchange.hpp\"\n#include \"core/tuple_indexator.hpp\"\n#include \"core/type_info.hpp\"\n#include \"core/type_tag.hpp\"\n\n#include \"core/entity_id.hpp\"\n#include \"core/interface_id.hpp\"\n#include \"core/object_id.hpp\"\n\n#endif // ZMBT_CORE_HPP_\n</code></pre>"},{"location":"CxxRef/decor_8hpp/","title":"File decor.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; decor.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"decor/precise_real.hpp\"</code></li> <li><code>#include \"decor/underlying.hpp\"</code></li> </ul>"},{"location":"CxxRef/decor_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor.hpp</code></p>"},{"location":"CxxRef/decor_8hpp_source/","title":"File decor.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; decor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_DECOR_HPP_\n#define ZMBT_DECOR_HPP_\n\n#include \"decor/precise_real.hpp\"\n#include \"decor/underlying.hpp\"\n\n#endif // ZMBT_DECOR_HPP_\n</code></pre>"},{"location":"CxxRef/expr_8hpp/","title":"File expr.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"expr/operator.hpp\"</code></li> <li><code>#include \"expr/keyword.hpp\"</code></li> <li><code>#include \"expr/keyword_grammar.hpp\"</code></li> <li><code>#include \"expr/lazy_param.hpp\"</code></li> <li><code>#include \"expr/attributes.hpp\"</code></li> <li><code>#include \"expr/expression.hpp\"</code></li> <li><code>#include \"expr/eval_log.hpp\"</code></li> <li><code>#include \"expr/eval_context.hpp\"</code></li> <li><code>#include \"expr/expression_grammar.hpp\"</code></li> <li><code>#include \"expr/api.hpp\"</code></li> <li><code>#include \"expr/api_signatures.hpp\"</code></li> <li><code>#include \"expr/encoding.hpp\"</code></li> </ul>"},{"location":"CxxRef/expr_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr.hpp</code></p>"},{"location":"CxxRef/expr_8hpp_source/","title":"File expr.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_HPP_\n#define ZMBT_EXPR_HPP_\n\n#include \"expr/operator.hpp\"\n#include \"expr/keyword.hpp\"\n#include \"expr/keyword_grammar.hpp\"\n#include \"expr/lazy_param.hpp\"\n#include \"expr/attributes.hpp\"\n#include \"expr/expression.hpp\"\n#include \"expr/eval_log.hpp\"\n#include \"expr/eval_context.hpp\"\n#include \"expr/expression_grammar.hpp\"\n#include \"expr/api.hpp\"\n#include \"expr/api_signatures.hpp\"\n#include \"expr/encoding.hpp\"\n\n#endif // ZMBT_EXPR_HPP_\n</code></pre>"},{"location":"CxxRef/mapping_8hpp/","title":"File mapping.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"mapping/channel_handle.hpp\"</code></li> <li><code>#include \"mapping/model_definition_helper.hpp\"</code></li> <li><code>#include \"mapping/model_definition.hpp\"</code></li> <li><code>#include \"mapping/model_definition_transitions.hpp\"</code></li> <li><code>#include \"mapping/model_definition_node.hpp\"</code></li> <li><code>#include \"mapping/model_definition_states.hpp\"</code></li> <li><code>#include \"mapping/model_definition_main.hpp\"</code></li> <li><code>#include \"mapping/pipe_handle.hpp\"</code></li> <li><code>#include \"mapping/test_parameter_resolver.hpp\"</code></li> <li><code>#include \"mapping/test_runner.hpp\"</code></li> <li><code>#include \"mapping/test_diagnostics.hpp\"</code></li> </ul>"},{"location":"CxxRef/mapping_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping.hpp</code></p>"},{"location":"CxxRef/mapping_8hpp_source/","title":"File mapping.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_HPP_\n#define ZMBT_MAPPING_HPP_\n\n#include \"mapping/channel_handle.hpp\"\n#include \"mapping/model_definition_helper.hpp\"\n#include \"mapping/model_definition.hpp\"\n#include \"mapping/model_definition_transitions.hpp\"\n#include \"mapping/model_definition_node.hpp\"\n#include \"mapping/model_definition_states.hpp\"\n#include \"mapping/model_definition_main.hpp\"\n#include \"mapping/pipe_handle.hpp\"\n#include \"mapping/test_parameter_resolver.hpp\"\n#include \"mapping/test_runner.hpp\"\n#include \"mapping/test_diagnostics.hpp\"\n\n#endif // ZMBT_MAPPING_HPP_\n</code></pre>"},{"location":"CxxRef/model_8hpp/","title":"File model.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"model/environment_data.hpp\"</code></li> <li><code>#include \"model/environment.hpp\"</code></li> <li><code>#include \"model/environment_interface_record.hpp\"</code></li> <li><code>#include \"model/error_info.hpp\"</code></li> <li><code>#include \"model/error_or_return.hpp\"</code></li> <li><code>#include \"model/output_recorder.hpp\"</code></li> <li><code>#include \"model/trigger.hpp\"</code></li> <li><code>#include \"model/parameter.hpp\"</code></li> <li><code>#include \"model/param_transform.hpp\"</code></li> </ul>"},{"location":"CxxRef/model_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model.hpp</code></p>"},{"location":"CxxRef/model_8hpp_source/","title":"File model.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_HPP_\n#define ZMBT_MODEL_HPP_\n\n#include \"model/environment_data.hpp\"\n#include \"model/environment.hpp\"\n#include \"model/environment_interface_record.hpp\"\n#include \"model/error_info.hpp\"\n#include \"model/error_or_return.hpp\"\n#include \"model/output_recorder.hpp\"\n#include \"model/trigger.hpp\"\n#include \"model/parameter.hpp\"\n#include \"model/param_transform.hpp\"\n\n\n#endif // ZMBT_MAPPING_HPP_\n</code></pre>"},{"location":"CxxRef/reflect_8hpp/","title":"File reflect.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"reflect/ducktyping_traits_pp.hpp\"</code></li> <li><code>#include \"reflect/signal_traits.hpp\"</code></li> <li><code>#include \"reflect/invocation.hpp\"</code></li> <li><code>#include \"reflect/prototypes.hpp\"</code></li> <li><code>#include \"reflect/serialization.hpp\"</code></li> </ul>"},{"location":"CxxRef/reflect_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect.hpp</code></p>"},{"location":"CxxRef/reflect_8hpp_source/","title":"File reflect.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_REFLECT_HPP_\n#define ZMBT_REFLECT_HPP_\n\n\n#include \"reflect/ducktyping_traits_pp.hpp\"  // IWYU pragma: keep\n#include \"reflect/signal_traits.hpp\"  // IWYU pragma: keep\n#include \"reflect/invocation.hpp\"  // IWYU pragma: keep\n#include \"reflect/prototypes.hpp\"  // IWYU pragma: keep\n#include \"reflect/serialization.hpp\"  // IWYU pragma: keep\n\n#endif  // ZMBT_CORE_HPP_\n</code></pre>"},{"location":"CxxRef/dir_dac1628bc1b9dc0b2ecee59f2dfa09f4/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api","text":"<p>FileList &gt; api</p>"},{"location":"CxxRef/dir_dac1628bc1b9dc0b2ecee59f2dfa09f4/#files","title":"Files","text":"Type Name file model_test.hpp file ns.hpp <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/</code></p>"},{"location":"CxxRef/model__test_8hpp/","title":"File model_test.hpp","text":"<p>FileList &gt; api &gt; model_test.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include \"ns.hpp\"</code></li> </ul>"},{"location":"CxxRef/model__test_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace api Framework API with fixture classes and entries from main ns."},{"location":"CxxRef/model__test_8hpp/#classes","title":"Classes","text":"Type Name struct ModelTestFixture Generic model-driven test fixture."},{"location":"CxxRef/model__test_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/model_test.hpp</code></p>"},{"location":"CxxRef/model__test_8hpp_source/","title":"File model_test.hpp","text":"<p>File List &gt; api &gt; model_test.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_FIXTURE_MODEL_TEST_HPP_\n#define ZMBT_FIXTURE_MODEL_TEST_HPP_\n\n#include &lt;array&gt;\n#include &lt;tuple&gt;\n\n#include \"ns.hpp\"\n\n\nnamespace zmbt {\n\nnamespace api {\n\nstruct ModelTestFixture : public Environment {\n\n    ModelTestFixture() = default;\n    virtual ~ModelTestFixture() = default;\n    ModelTestFixture(ModelTestFixture&amp;&amp;) = default;\n    ModelTestFixture&amp; operator=(ModelTestFixture&amp;&amp;) = default;\n\n    ModelTestFixture(const ModelTestFixture&amp;) = delete;\n    ModelTestFixture&amp; operator=(const ModelTestFixture&amp;) = delete;\n\n}; // class ModelTestFixture\n\n\n}  // namespace api\n}  // namespace zmbt\n\n#endif  // ZMBT_FIXTURE_MODEL_TEST_HPP_\n</code></pre>"},{"location":"CxxRef/ns_8hpp/","title":"File ns.hpp","text":"<p>FileList &gt; api &gt; ns.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> <li><code>#include \"zmbt/model.hpp\"</code></li> <li><code>#include \"zmbt/decor.hpp\"</code></li> <li><code>#include \"zmbt/mapping.hpp\"</code></li> </ul>"},{"location":"CxxRef/ns_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace api Framework API with fixture classes and entries from main ns. namespace decor Signal type decorators API. namespace expr Expression Language API."},{"location":"CxxRef/ns_8hpp/#classes","title":"Classes","text":"Type Name class Environment Alias for zmbt::Environment . class Expression Alias for lang::Expression . class Param Alias for zmbt::Param . class SignalMapping Alias for zmbt::mapping::SignalMapping . class precise Alias for zmbt::precise."},{"location":"CxxRef/ns_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/ns.hpp</code></p>"},{"location":"CxxRef/ns_8hpp_source/","title":"File ns.hpp","text":"<p>File List &gt; api &gt; ns.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_API_NS_HPP_\n#define ZMBT_API_NS_HPP_\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/reflect.hpp\"\n#include \"zmbt/model.hpp\"\n#include \"zmbt/decor.hpp\"\n#include \"zmbt/mapping.hpp\"\n\nnamespace zmbt {\nnamespace api {\n\nusing zmbt::Param;\nusing zmbt::type;\n\nusing zmbt::Environment;\nusing zmbt::InterfaceRecord;\n\nusing lang::Expression;\n\nnamespace decor = zmbt::decor;\nnamespace expr = zmbt::expr;\n\nusing zmbt::mapping::SignalMapping;\n\nstruct ModelTestFixture;\n\n#ifdef _DOXYGEN_\n\nclass Param {};\nconstexpr auto  type;\nclass Environment {};\nauto InterfaceRecord(...);\nclass precise {};\nclass Expression {};\nclass SignalMapping {};\n\nnamespace decor {}\n\nnamespace expr {}\n\n#endif\n\n}\n}\n\n#endif\n</code></pre>"},{"location":"CxxRef/dir_0cc19fbf7340471280b165ed90304d9a/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application","text":"<p>FileList &gt; application</p>"},{"location":"CxxRef/dir_0cc19fbf7340471280b165ed90304d9a/#files","title":"Files","text":"Type Name file config.hpp file init.hpp file log.hpp file test_failure.hpp <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application/</code></p>"},{"location":"CxxRef/config_8hpp/","title":"File config.hpp","text":"<p>FileList &gt; application &gt; config.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"test_failure.hpp\"</code></li> </ul>"},{"location":"CxxRef/config_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/config_8hpp/#classes","title":"Classes","text":"Type Name class Config Global app config."},{"location":"CxxRef/config_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application/config.hpp</code></p>"},{"location":"CxxRef/config_8hpp_source/","title":"File config.hpp","text":"<p>File List &gt; application &gt; config.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_APPLICATION_CONFIG_HPP_\n#define ZMBT_APPLICATION_CONFIG_HPP_\n\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n\n#include \"test_failure.hpp\"\n\n\nnamespace zmbt {\n\nclass Config final\n{\npublic:\n    using FailureHandler = std::function&lt;void(boost::json::value const&amp;)&gt;;\n\n    Config();\n\n    Config(Config const&amp;) = default;\n    Config(Config &amp;&amp;) = default;\n    Config&amp; operator=(Config const&amp;) = default;\n    Config&amp; operator=(Config &amp;&amp;) = default;\n\n    ~Config() = default;\n\n    Config&amp; SetFailureHandler(FailureHandler const&amp; fn);\n\n    Config&amp; ResetFailureHandler();\n\n    Config&amp; HandleTestFailure(boost::json::value const&amp; diagnostics);\n\nprivate:\n    struct PersistentConfig\n    {\n        FailureHandler failure_handler {&amp;zmbt::default_test_failure};\n    };\n\n    std::shared_ptr&lt;PersistentConfig&gt; config_;\n};\n\n}\n\n#endif // ZMBT_APPLICATION_CONFIG_HPP_\n</code></pre>"},{"location":"CxxRef/init_8hpp/","title":"File init.hpp","text":"<p>FileList &gt; application &gt; init.hpp</p> <p>Go to the source code of this file</p> <p>More...</p>"},{"location":"CxxRef/init_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/init_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application/init.hpp</code></p>"},{"location":"CxxRef/init_8hpp_source/","title":"File init.hpp","text":"<p>File List &gt; application &gt; init.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_APPLICATION_INIT_ZMBT_HPP_\n#define ZMBT_APPLICATION_INIT_ZMBT_HPP_\n\nnamespace zmbt {\n\nvoid InitZmbt(int argc, char **argv);\n\n} // namespace zmbt\n\n#endif // ZMBT_APPLICATION_INIT_ZMBT_HPP_\n</code></pre>"},{"location":"CxxRef/log_8hpp/","title":"File log.hpp","text":"<p>FileList &gt; application &gt; log.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;boost/describe.hpp&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"zmbt/core/preprocessor.hpp\"</code></li> <li><code>#include \"zmbt/core/entity_id.hpp\"</code></li> </ul>"},{"location":"CxxRef/log_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/log_8hpp/#classes","title":"Classes","text":"Type Name class Logger struct StubLogger"},{"location":"CxxRef/log_8hpp/#macros","title":"Macros","text":"Type Name define ZMBT_DEBUG <code>[**::zmbt::StubLogger**](structzmbt_1_1StubLogger.md)()</code> define ZMBT_LOG (lvl) <code>[**::zmbt::Logger**](classzmbt_1_1Logger.md)().WithSrcLoc(ZMBT\\_CUR\\_LOC).WithLevel(::zmbt::Logger::lvl)</code> define ZMBT_LOG_CERR (lvl) <code>ZMBT\\_LOG(lvl).WithOutput(::zmbt::Logger::STDERR)</code> define ZMBT_LOG_JSON (lvl) <code>ZMBT\\_LOG(lvl).WithOutput(::zmbt::Logger::JSON)</code>"},{"location":"CxxRef/log_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/log_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/log_8hpp/#define-zmbt_debug","title":"define ZMBT_DEBUG","text":"<pre><code>#define ZMBT_DEBUG `::zmbt::StubLogger ()`\n</code></pre>"},{"location":"CxxRef/log_8hpp/#define-zmbt_log","title":"define ZMBT_LOG","text":"<pre><code>#define ZMBT_LOG (\n    lvl\n) `::zmbt::Logger ().WithSrcLoc(ZMBT_CUR_LOC).WithLevel(::zmbt::Logger::lvl)`\n</code></pre>"},{"location":"CxxRef/log_8hpp/#define-zmbt_log_cerr","title":"define ZMBT_LOG_CERR","text":"<pre><code>#define ZMBT_LOG_CERR (\n    lvl\n) `ZMBT_LOG(lvl).WithOutput(::zmbt::Logger::STDERR)`\n</code></pre>"},{"location":"CxxRef/log_8hpp/#define-zmbt_log_json","title":"define ZMBT_LOG_JSON","text":"<pre><code>#define ZMBT_LOG_JSON (\n    lvl\n) `ZMBT_LOG(lvl).WithOutput(::zmbt::Logger::JSON)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application/log.hpp</code></p>"},{"location":"CxxRef/log_8hpp_source/","title":"File log.hpp","text":"<p>File List &gt; application &gt; log.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_LOGGING_HPP_\n#define ZMBT_LOGGING_HPP_\n\n#include &lt;chrono&gt;\n#include &lt;iomanip&gt;\n#include &lt;string&gt;\n\n#include &lt;boost/describe.hpp&gt;\n#include &lt;boost/json.hpp&gt;\n\n#include \"zmbt/core/preprocessor.hpp\"\n#include \"zmbt/core/entity_id.hpp\"\n\n\n#ifdef NDEBUG\n    #define ZMBT_DEBUG (std::cerr &lt;&lt; ZMBT_CUR_LOC &lt;&lt; \": \")\n#else\n    #define ZMBT_DEBUG ::zmbt::StubLogger()\n#endif\n\n#define ZMBT_LOG(lvl) ::zmbt::Logger().WithSrcLoc(ZMBT_CUR_LOC).WithLevel(::zmbt::Logger::lvl)\n#define ZMBT_LOG_CERR(lvl) ZMBT_LOG(lvl).WithOutput(::zmbt::Logger::STDERR)\n#define ZMBT_LOG_JSON(lvl) ZMBT_LOG(lvl).WithOutput(::zmbt::Logger::JSON)\n\nnamespace zmbt {\n\n#ifndef NDEBUG\nstruct StubLogger\n{\n    StubLogger&amp; operator&lt;&lt;(boost::json::value const&amp;)\n    {\n        return *this;\n    }\n};\n#endif\n\nclass Logger {\n  public:\n\n    enum Output\n    {\n        NIL = 0,\n        STDERR = 1 &lt;&lt; 0,\n        JSON   = 1 &lt;&lt; 1,\n    };\n\n    enum Level\n    {\n        FATAL,\n        ERROR,\n        WARNING,\n        INFO,\n        DEBUG,\n        TRACE\n    };\n\n    static void open_json(const std::string&amp; filename = \"\");\n\n    static void set_max_level(Level const max_level);\n    static Level max_level();\n\n    static void set_notrim(bool const trim_line);\n    static bool is_notrim_enabled();\n\n    static void set_pretty_print(bool const trim_line);\n    static bool is_pretty_print_enabled();\n\n\n    Logger();\n\n    Logger&amp; WithLevel(Level const level);\n    Logger&amp; WithOutput(Output const output);\n    Logger&amp; WithSrcLoc(boost::json::string_view const src_loc);\n\n    Logger&amp; operator&lt;&lt;(boost::json::value const&amp; value);\n    Logger&amp; operator&lt;&lt;(entity_id const&amp; value);\n\n    ~Logger();\n\n  private:\n\n    Level level_{INFO};\n    int output_{STDERR | JSON};\n    boost::json::string_view src_loc_{\"unknown\"};\n    char timestamp_[64];\n    boost::json::array payload_cache_;\n\n    void set_timestamp();\n\n    BOOST_DESCRIBE_NESTED_ENUM(Level,\n        FATAL,\n        ERROR,\n        WARNING,\n        INFO,\n        DEBUG,\n        TRACE\n    )\n};\n\n\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/test__failure_8hpp/","title":"File test_failure.hpp","text":"<p>FileList &gt; application &gt; test_failure.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"zmbt/core/json_pretty_print.hpp\"</code></li> </ul>"},{"location":"CxxRef/test__failure_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/test__failure_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/application/test_failure.hpp</code></p>"},{"location":"CxxRef/test__failure_8hpp_source/","title":"File test_failure.hpp","text":"<p>File List &gt; application &gt; test_failure.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_APPLICATION_TEST_FAILURE_HPP_\n#define ZMBT_APPLICATION_TEST_FAILURE_HPP_\n\n#include &lt;sstream&gt;\n\n#include &lt;boost/json.hpp&gt;\n\n#include \"zmbt/core/json_pretty_print.hpp\"\n\nnamespace zmbt {\n\nvoid format_failure_report(std::ostream&amp; os, boost::json::value const&amp; report);\n\nvoid default_test_failure(boost::json::value const&amp; report);\n\n}\n\n#endif\n</code></pre>"},{"location":"CxxRef/dir_1dfd3566c4a6f6e15f69daa4a04e2d4f/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core</p>"},{"location":"CxxRef/dir_1dfd3566c4a6f6e15f69daa4a04e2d4f/#files","title":"Files","text":"Type Name file aliases.hpp file entity_id.hpp file exceptions.hpp file file_parser.hpp file format_string.hpp file generic_traits.hpp file get_info.hpp file interface_id.hpp file interface_traits.hpp file json_iter.hpp file json_node.hpp file json_number_cast.hpp file json_pretty_print.hpp file json_traverse.hpp file object_id.hpp file operator_traits.hpp file preprocessor.hpp type traits to check serialization compatibility file shared_resource.hpp file slice.hpp file tuple_conversion.hpp file tuple_exchange.hpp file tuple_indexator.hpp file type_info.hpp file type_tag.hpp <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/</code></p>"},{"location":"CxxRef/aliases_8hpp/","title":"File aliases.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; aliases.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;boost/callable_traits.hpp&gt;</code></li> <li><code>#include &lt;boost/mp11.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/aliases_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/aliases_8hpp/#macros","title":"Macros","text":"Type Name define USING_STD_TYPETRAIT (trait) <code>template &amp;lt;class T&amp;gt; using trait = std::trait&amp;lt;T&amp;gt;;</code> define USING_STD_TYPETRAIT_BINARY (trait) <code>/* multi line expression */</code> define USING_STD_TYPETRAIT_PROPERTY (trait) <code>USING\\_STD\\_TYPETRAIT(trait) USING\\_TYPETRAIT\\_V(trait)</code> define USING_STD_TYPETRAIT_TRANSFORM (trait) <code>USING\\_STD\\_TYPETRAIT(trait) USING\\_TYPETRAIT\\_T(trait)</code> define USING_TYPETRAIT_T (trait) <code>template&amp;lt;class T&amp;gt; using trait##\\_t = typename trait&amp;lt;T&amp;gt;::type;</code> define USING_TYPETRAIT_V (trait) <code>template&amp;lt;class T&amp;gt; static constexpr bool trait##\\_v = trait&amp;lt;T&amp;gt;::value;</code>"},{"location":"CxxRef/aliases_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/aliases_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/aliases_8hpp/#define-using_std_typetrait","title":"define USING_STD_TYPETRAIT","text":"<pre><code>#define USING_STD_TYPETRAIT (\n    trait\n) `template &lt;class T&gt; using trait = std::trait&lt;T&gt;;`\n</code></pre>"},{"location":"CxxRef/aliases_8hpp/#define-using_std_typetrait_binary","title":"define USING_STD_TYPETRAIT_BINARY","text":"<pre><code>#define USING_STD_TYPETRAIT_BINARY (\n    trait\n) `/* multi line expression */`\n</code></pre>"},{"location":"CxxRef/aliases_8hpp/#define-using_std_typetrait_property","title":"define USING_STD_TYPETRAIT_PROPERTY","text":"<pre><code>#define USING_STD_TYPETRAIT_PROPERTY (\n    trait\n) `USING_STD_TYPETRAIT(trait) USING_TYPETRAIT_V(trait)`\n</code></pre>"},{"location":"CxxRef/aliases_8hpp/#define-using_std_typetrait_transform","title":"define USING_STD_TYPETRAIT_TRANSFORM","text":"<pre><code>#define USING_STD_TYPETRAIT_TRANSFORM (\n    trait\n) `USING_STD_TYPETRAIT(trait) USING_TYPETRAIT_T(trait)`\n</code></pre>"},{"location":"CxxRef/aliases_8hpp/#define-using_typetrait_t","title":"define USING_TYPETRAIT_T","text":"<pre><code>#define USING_TYPETRAIT_T (\n    trait\n) `template&lt;class T&gt; using trait##_t = typename trait&lt;T&gt;::type;`\n</code></pre>"},{"location":"CxxRef/aliases_8hpp/#define-using_typetrait_v","title":"define USING_TYPETRAIT_V","text":"<pre><code>#define USING_TYPETRAIT_V (\n    trait\n) `template&lt;class T&gt; static constexpr bool trait##_v = trait&lt;T&gt;::value;`\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/aliases.hpp</code></p>"},{"location":"CxxRef/aliases_8hpp_source/","title":"File aliases.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; aliases.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_NS_HPP_\n#define ZMBT_CORE_NS_HPP_\n\n\n#include &lt;type_traits&gt;\n#include &lt;tuple&gt;\n\n#include &lt;boost/callable_traits.hpp&gt;\n#include &lt;boost/mp11.hpp&gt;\n\n\n#define USING_STD_TYPETRAIT(trait) template &lt;class T&gt; using trait = std::trait&lt;T&gt;;\n#define USING_TYPETRAIT_V(trait) template&lt;class T&gt; static constexpr bool trait##_v = trait&lt;T&gt;::value;\n#define USING_TYPETRAIT_T(trait) template&lt;class T&gt; using trait##_t = typename trait&lt;T&gt;::type;\n\n#define USING_STD_TYPETRAIT_BINARY(trait)                                       \\\ntemplate&lt;class A, class B&gt; using trait = std::trait&lt;A, B&gt;;                      \\\ntemplate&lt;class A, class B&gt; static constexpr bool trait##_v = trait&lt;A, B&gt;::value;\n\n#define USING_STD_TYPETRAIT_PROPERTY(trait)  USING_STD_TYPETRAIT(trait) USING_TYPETRAIT_V(trait)\n#define USING_STD_TYPETRAIT_TRANSFORM(trait) USING_STD_TYPETRAIT(trait) USING_TYPETRAIT_T(trait)\n\n\nnamespace zmbt {\n\n\nusing namespace boost::mp11;\nnamespace ct = boost::callable_traits;\n\n\nusing std::nullptr_t;\nusing std::size_t;\n\ntemplate &lt;class...&gt; using void_t = void;\n\ntemplate&lt;class T, T V&gt;\nusing integral_constant = std::integral_constant&lt;T, V&gt;;\n\ntemplate&lt;bool V&gt;\nusing bool_constant = integral_constant&lt;bool, V&gt;;\n\n\ntemplate&lt;class... T&gt;\nusing tuple = std::tuple&lt;T...&gt;;\n\ntemplate&lt; class T &gt;\nusing tuple_size = std::tuple_size&lt;T&gt;;\n\ntemplate&lt; class T &gt;\nstatic constexpr size_t tuple_size_v = tuple_size&lt;T&gt;::value;\n\nusing std::make_tuple;\nusing std::tie;\n\nUSING_STD_TYPETRAIT_PROPERTY(is_void)\nUSING_STD_TYPETRAIT_PROPERTY(is_null_pointer)\nUSING_STD_TYPETRAIT_PROPERTY(is_integral)\nUSING_STD_TYPETRAIT_PROPERTY(is_floating_point)\nUSING_STD_TYPETRAIT_PROPERTY(is_array)\nUSING_STD_TYPETRAIT_PROPERTY(is_enum)\nUSING_STD_TYPETRAIT_PROPERTY(is_union)\nUSING_STD_TYPETRAIT_PROPERTY(is_class)\nUSING_STD_TYPETRAIT_PROPERTY(is_function)\nUSING_STD_TYPETRAIT_PROPERTY(is_pointer)\nUSING_STD_TYPETRAIT_PROPERTY(is_lvalue_reference)\nUSING_STD_TYPETRAIT_PROPERTY(is_rvalue_reference)\nUSING_STD_TYPETRAIT_PROPERTY(is_member_object_pointer)\nUSING_STD_TYPETRAIT_PROPERTY(is_member_function_pointer)\nUSING_STD_TYPETRAIT_PROPERTY(is_fundamental)\nUSING_STD_TYPETRAIT_PROPERTY(is_arithmetic)\nUSING_STD_TYPETRAIT_PROPERTY(is_scalar)\nUSING_STD_TYPETRAIT_PROPERTY(is_object)\nUSING_STD_TYPETRAIT_PROPERTY(is_compound)\nUSING_STD_TYPETRAIT_PROPERTY(is_reference)\nUSING_STD_TYPETRAIT_PROPERTY(is_member_pointer)\nUSING_STD_TYPETRAIT_PROPERTY(is_const)\nUSING_STD_TYPETRAIT_PROPERTY(is_volatile)\nUSING_STD_TYPETRAIT_PROPERTY(is_trivial)\nUSING_STD_TYPETRAIT_PROPERTY(is_trivially_copyable)\nUSING_STD_TYPETRAIT_PROPERTY(is_standard_layout)\nUSING_STD_TYPETRAIT_PROPERTY(is_empty)\nUSING_STD_TYPETRAIT_PROPERTY(is_polymorphic)\nUSING_STD_TYPETRAIT_PROPERTY(is_abstract)\nUSING_STD_TYPETRAIT_PROPERTY(is_final)\nUSING_STD_TYPETRAIT_PROPERTY(is_signed)\nUSING_STD_TYPETRAIT_PROPERTY(is_unsigned)\n\nUSING_STD_TYPETRAIT_PROPERTY(is_default_constructible)\nUSING_STD_TYPETRAIT_PROPERTY(is_trivially_default_constructible)\nUSING_STD_TYPETRAIT_PROPERTY(is_nothrow_default_constructible)\n\nUSING_STD_TYPETRAIT_PROPERTY(is_copy_constructible)\nUSING_STD_TYPETRAIT_PROPERTY(is_trivially_copy_constructible)\nUSING_STD_TYPETRAIT_PROPERTY(is_nothrow_copy_constructible)\n\nUSING_STD_TYPETRAIT_PROPERTY(is_move_constructible)\nUSING_STD_TYPETRAIT_PROPERTY(is_trivially_move_constructible)\nUSING_STD_TYPETRAIT_PROPERTY(is_nothrow_move_constructible)\n\nUSING_STD_TYPETRAIT_PROPERTY(is_destructible)\nUSING_STD_TYPETRAIT_PROPERTY(is_trivially_destructible)\nUSING_STD_TYPETRAIT_PROPERTY(is_nothrow_destructible)\n\nUSING_STD_TYPETRAIT_PROPERTY(has_virtual_destructor)\n\nUSING_STD_TYPETRAIT_PROPERTY(is_copy_assignable)\nUSING_STD_TYPETRAIT_PROPERTY(is_trivially_copy_assignable)\nUSING_STD_TYPETRAIT_PROPERTY(is_nothrow_copy_assignable)\nUSING_STD_TYPETRAIT_PROPERTY(is_move_assignable)\nUSING_STD_TYPETRAIT_PROPERTY(is_trivially_move_assignable)\nUSING_STD_TYPETRAIT_PROPERTY(is_nothrow_move_assignable)\n\n\nUSING_STD_TYPETRAIT_BINARY(is_same)\nUSING_STD_TYPETRAIT_BINARY(is_base_of)\nUSING_STD_TYPETRAIT_BINARY(is_convertible)\n\nUSING_STD_TYPETRAIT_BINARY(is_assignable)\nUSING_STD_TYPETRAIT_BINARY(is_trivially_assignable)\nUSING_STD_TYPETRAIT_BINARY(is_nothrow_assignable)\n\n\nUSING_STD_TYPETRAIT_TRANSFORM(remove_cv)\nUSING_STD_TYPETRAIT_TRANSFORM(remove_const)\nUSING_STD_TYPETRAIT_TRANSFORM(remove_volatile)\nUSING_STD_TYPETRAIT_TRANSFORM(add_cv)\nUSING_STD_TYPETRAIT_TRANSFORM(add_const)\nUSING_STD_TYPETRAIT_TRANSFORM(add_volatile)\nUSING_STD_TYPETRAIT_TRANSFORM(remove_reference)\nUSING_STD_TYPETRAIT_TRANSFORM(add_lvalue_reference)\nUSING_STD_TYPETRAIT_TRANSFORM(add_rvalue_reference)\nUSING_STD_TYPETRAIT_TRANSFORM(remove_pointer)\nUSING_STD_TYPETRAIT_TRANSFORM(add_pointer)\nUSING_STD_TYPETRAIT_TRANSFORM(make_signed)\nUSING_STD_TYPETRAIT_TRANSFORM(make_unsigned)\n\nUSING_STD_TYPETRAIT_TRANSFORM(underlying_type)\n\nUSING_STD_TYPETRAIT_TRANSFORM(decay)\n\n\ntemplate &lt;class T, class... Args&gt;\nusing is_constructible = std::is_constructible&lt;T, Args...&gt;;\n\ntemplate &lt;class T, class... Args&gt;\nusing is_trivially_constructible = std::is_trivially_constructible&lt;T, Args...&gt;;\n\ntemplate &lt;class T, class... Args&gt;\nusing is_nothrow_constructible = std::is_nothrow_constructible&lt;T, Args...&gt;;\n\n\ntemplate &lt;class T&gt;\nusing remove_cvref_t = remove_cv_t&lt;remove_reference_t&lt;T&gt;&gt;;\n\ntemplate &lt;class T&gt;\nusing remove_cvptr_t = remove_cv_t&lt;remove_pointer_t&lt;T&gt;&gt;;\n\n\ntemplate&lt; bool B, class T = void &gt;\nusing enable_if = std::enable_if&lt;B, T&gt;;\n\ntemplate&lt; bool B, class T = void &gt;\nusing enable_if_t = typename enable_if&lt;B, T&gt;::type;\n\ntemplate&lt;bool B, class T, class F&gt;\nusing conditional = std::conditional&lt;B, T, F&gt;;\n\ntemplate&lt;bool B, class T, class F&gt;\nusing conditional_t = typename conditional&lt;B, T, F&gt;::type;\n\ntemplate&lt;class... T&gt;\nusing common_type = std::common_type&lt;T...&gt;;\n\ntemplate&lt;class... T&gt;\nusing common_type_t = typename common_type&lt;T...&gt;::type;\n\n\n\n\n// rank\n// extent\n// remove_extent\n// remove_all_extents\n\n}\n\n#endif\n</code></pre>"},{"location":"CxxRef/entity__id_8hpp/","title":"File entity_id.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; entity_id.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> <li><code>#include \"type_tag.hpp\"</code></li> <li><code>#include \"type_info.hpp\"</code></li> </ul>"},{"location":"CxxRef/entity__id_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/entity__id_8hpp/#classes","title":"Classes","text":"Type Name class entity_id Base class for annotated key objects."},{"location":"CxxRef/entity__id_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/entity_id.hpp</code></p>"},{"location":"CxxRef/entity__id_8hpp_source/","title":"File entity_id.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; entity_id.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_ENTITY_ID_HPP_\n#define ZMBT_CORE_ENTITY_ID_HPP_\n\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;utility&gt;\n#include &lt;typeindex&gt;\n#include &lt;boost/json.hpp&gt;\n\n#include \"aliases.hpp\"\n#include \"type_tag.hpp\"\n#include \"type_info.hpp\"\n\n\nnamespace zmbt {\n\n\nclass entity_id {\n\n    boost::json::string key_;\n    std::size_t type_index_hash_;\n    std::size_t hash_;\n    mutable boost::json::string annotation_;\n    mutable boost::json::string str_;\n\n\n  public:\n\n    entity_id() = default;\n\n\n    entity_id(boost::json::string_view key, std::type_index type_index);\n    entity_id(boost::json::string_view key, std::size_t type_index_hash);\n\n    explicit entity_id(boost::json::array const&amp; str);\n    explicit entity_id(boost::json::value const&amp; val);\n\n    entity_id(entity_id const&amp;) = default;\n    entity_id(entity_id &amp;&amp;) = default;\n    entity_id&amp; operator=(entity_id const&amp;) = default;\n    entity_id&amp; operator=(entity_id &amp;&amp;) = default;\n    virtual ~entity_id() = default;\n\n    entity_id&amp; operator=(boost::json::value const&amp; v)\n    {\n        *this = entity_id(v);\n        return *this;\n    };\n\n    entity_id&amp; operator=(boost::json::value &amp;&amp; v)\n    {\n        *this = entity_id(std::move(v));\n        return *this;\n    };\n\n\n\n    bool operator==(entity_id const&amp; other) const {\n        return (type_index_hash_ == other.type_index_hash_) &amp;&amp; (key_ == other.key_) ;\n    }\n    bool operator!=(entity_id const&amp; other) const {\n        return !this-&gt;operator==(other);\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, entity_id const&amp; id)\n    {\n        os &lt;&lt; id.str();\n        return os;\n    }\n\n    friend inline std::size_t hash_value(entity_id const&amp; v)\n    {\n        return v.hash_;\n    }\n\n    boost::json::string_view key() const\n    {\n        return key_;\n    }\n\n    boost::json::string_view annotation() const;\n\n    boost::json::string_view str() const;\n\n    operator boost::json::value() const\n    {\n        return boost::json::array{key_, type_index_hash_};\n    }\n};\n\n\n} // namespace zmbt\n\ntemplate &lt;&gt;\nstruct std::hash&lt;zmbt::entity_id&gt; {\n    std::size_t operator()(zmbt::entity_id const&amp; k) const\n    {\n        return hash_value(k);\n    }\n};\n\n\n#endif // ZMBT_CORE_INTERFACE_ID_HPP_\n</code></pre>"},{"location":"CxxRef/core_2exceptions_8hpp/","title":"File exceptions.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; exceptions.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/throw_exception.hpp&gt;</code></li> <li><code>#include \"format_string.hpp\"</code></li> <li><code>#include \"type_info.hpp\"</code></li> </ul>"},{"location":"CxxRef/core_2exceptions_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/core_2exceptions_8hpp/#classes","title":"Classes","text":"Type Name struct base_error ZMBT Base exception. struct environment_error Test environment error. struct serialization_error Failed serialization."},{"location":"CxxRef/core_2exceptions_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/exceptions.hpp</code></p>"},{"location":"CxxRef/core_2exceptions_8hpp_source/","title":"File exceptions.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; exceptions.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_EXCEPTIONS_HPP_\n#define ZMBT_CORE_EXCEPTIONS_HPP_\n\n\n#include &lt;boost/throw_exception.hpp&gt;\n\n#include \"format_string.hpp\"\n#include \"type_info.hpp\"\n\nnamespace zmbt {\n\nstruct base_error : public std::runtime_error {\n    using std::runtime_error::runtime_error;\n\n    template &lt;class... A&gt;\n    base_error(boost::json::string_view fmtstr, A&amp;&amp;... args) : std::runtime_error(format(fmtstr, std::forward&lt;A&gt;(args)...))\n    {\n    }\n};\n\n\nstruct serialization_error : public base_error {\n    using base_error::base_error;\n};\n\nstruct environment_error : public base_error {\n    using base_error::base_error;\n};\n\n\n\nnamespace detail\n{\n    void log_exception(char const* type, char const* what);\n}\n\ntemplate &lt;class E&gt;\nvoid throw_exception(E&amp;&amp; e)\n{\n    // auto const dynamic_exception_type = boost::typeindex::type_id_runtime(e).pretty_name();\n    detail::log_exception(type_name(e).c_str(), e.what());\n    boost::throw_exception(std::forward&lt;E&gt;(e));\n}\n\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/file__parser_8hpp/","title":"File file_parser.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; file_parser.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/file__parser_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/file__parser_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/file_parser.hpp</code></p>"},{"location":"CxxRef/file__parser_8hpp_source/","title":"File file_parser.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; file_parser.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_FILE_PARSER_HPP_\n#define ZMBT_CORE_FILE_PARSER_HPP_\n\n#include &lt;array&gt;\n#include &lt;type_traits&gt;\n\n#include \"aliases.hpp\"\n\nnamespace zmbt {\n\n\nenum class FileFormat\n{\n    DeduceFromExtension,\n    JSON,\n    YAML,\n    XML\n};\n\n\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/format__string_8hpp/","title":"File format_string.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; format_string.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"CxxRef/format__string_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/format__string_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/format_string.hpp</code></p>"},{"location":"CxxRef/format__string_8hpp_source/","title":"File format_string.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; format_string.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_FORMAT_STRING_HPP_\n#define ZMBT_CORE_FORMAT_STRING_HPP_\n\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\nnamespace zmbt {\n\n\nnamespace detail\n{\n    std::string format_impl(boost::json::string_view fmtstr, boost::json::array const&amp; args);\n}\n\ntemplate &lt;class... A&gt;\nstd::string format(boost::json::string_view fmtstr, A&amp;&amp;... arg)\n{\n    return detail::format_impl(fmtstr, {std::forward&lt;A&gt;(arg)...});\n}\n\n\n\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/generic__traits_8hpp/","title":"File generic_traits.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; generic_traits.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/generic__traits_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/generic__traits_8hpp/#classes","title":"Classes","text":"Type Name struct is_const_iterable &lt;class, class&gt;Variable template that checks if a type has begin() and end() member functions."},{"location":"CxxRef/generic__traits_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/generic_traits.hpp</code></p>"},{"location":"CxxRef/generic__traits_8hpp_source/","title":"File generic_traits.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; generic_traits.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_GENERIC_TRAITS_HPP_\n#define ZMBT_CORE_GENERIC_TRAITS_HPP_\n\n#include &lt;type_traits&gt;\n#include &lt;array&gt;\n\n#include \"aliases.hpp\"\n\n\nnamespace zmbt {\n\n\ntemplate &lt;class R, class... C&gt;\nusing first_if_t = mp_if&lt;mp_all&lt;C...&gt;, R&gt;;\n\ntemplate &lt;class R, class... C&gt;\nusing first_if_any_t = mp_if&lt;mp_any&lt;C...&gt;, R&gt;;\n\ntemplate &lt;class R, class... C&gt;\nusing first_if_none_t = mp_if&lt;mp_not&lt;mp_any&lt;C...&gt;&gt;, R&gt;;\n\n\ntemplate &lt;class T&gt;\nusing is_tuple = mp_or&lt; mp_similar&lt;tuple&lt;&gt;, T&gt;, mp_similar&lt;std::pair&lt;void, void&gt;, T&gt; &gt;;\n\n\ntemplate &lt;class L&gt;\nusing tuple_unqf_t = mp_transform&lt;remove_cvref_t, L&gt;;\n\n\ntemplate &lt;class, class = void&gt;\nstruct is_const_iterable : std::false_type {};\n\ntemplate &lt;class T&gt;\nstruct is_const_iterable&lt;T, void_t&lt;decltype(std::declval&lt;T&gt;().cbegin()), decltype(std::declval&lt;T&gt;().cend())&gt;&gt; : std::true_type {};\n\n\nnamespace detail\n{\ntemplate &lt;class T, class L, class = void&gt;\nstruct construct_or_default_impl;\n\ntemplate &lt;class T, class L&gt;\nusing is_tuple_constructible = mp_apply&lt;is_constructible, mp_push_front&lt;L, T&gt;&gt;;\n\n\ntemplate &lt;class T, class L&gt;\nstruct construct_or_default_impl&lt;T, L, mp_if&lt;is_tuple_constructible&lt;T, L&gt;,void&gt;&gt;\n{\n    static T construct(mp_apply&lt;std::tuple, L&gt; const &amp; args)\n    {\n        return construct_from_tuple&lt;T&gt;(args);\n    }\n};\n\ntemplate &lt;class T, class L&gt;\nstruct construct_or_default_impl&lt;T, L, mp_if&lt;mp_not&lt;is_tuple_constructible&lt;T, L&gt;&gt;,void&gt;&gt;\n{\n    static T construct(mp_apply&lt;std::tuple, L&gt; const &amp; args)\n    {\n        return T{};\n    }\n};\n} // namespace detail\n\ntemplate &lt;class T, class... A&gt;\nT construct_or_default(A&amp;&amp;... args)\n{\n    return detail::construct_or_default_impl&lt;T, mp_list&lt;A...&gt;&gt;::construct(std::forward_as_tuple(args...));\n}\n\n} // namespace zmbt\n\n#endif // ZMBT_CORE_GENERIC_TRAITS_HPP_\n</code></pre>"},{"location":"CxxRef/get__info_8hpp/","title":"File get_info.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; get_info.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"CxxRef/get__info_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/get__info_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/get_info.hpp</code></p>"},{"location":"CxxRef/get__info_8hpp_source/","title":"File get_info.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; get_info.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_GET_INFO_HPP_\n#define ZMBT_CORE_GET_INFO_HPP_\n\n#include &lt;thread&gt;\n\nnamespace zmbt\n{\n\nstd::string get_tid();\n\nstd::string tid2str(std::thread::id const tid);\n\nstd::size_t get_ts();\n\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/interface__id_8hpp/","title":"File interface_id.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; interface_id.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;typeinfo&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;boost/mp11/tuple.hpp&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> <li><code>#include \"entity_id.hpp\"</code></li> <li><code>#include \"interface_traits.hpp\"</code></li> <li><code>#include \"type_info.hpp\"</code></li> </ul>"},{"location":"CxxRef/interface__id_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/interface__id_8hpp/#classes","title":"Classes","text":"Type Name class interface_id Pointer-based interface id with type annotation."},{"location":"CxxRef/interface__id_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/interface_id.hpp</code></p>"},{"location":"CxxRef/interface__id_8hpp_source/","title":"File interface_id.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; interface_id.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_INTERFACE_ID_HPP_\n#define ZMBT_CORE_INTERFACE_ID_HPP_\n\n#include &lt;iostream&gt;\n\n\n#include &lt;array&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n#include &lt;typeinfo&gt;\n#include &lt;utility&gt;\n\n#include &lt;boost/mp11/tuple.hpp&gt;\n\n#include \"aliases.hpp\"\n\n#include \"entity_id.hpp\"\n#include \"interface_traits.hpp\"\n#include \"type_info.hpp\"\n\nnamespace zmbt {\n\n\nclass interface_id : public entity_id {\n\n\n    template &lt;class Interface&gt;\n    boost::json::string ifc_addr(Interface const&amp; ifc)\n    {\n        struct {\n            ifc_pointer_t&lt;Interface const&amp;&gt; ptr;\n        } wrapper {get_ifc_pointer(ifc)};\n\n        std::array&lt;unsigned char, sizeof(wrapper)&gt; repr {};\n        std::memcpy(repr.data(), &amp;wrapper, repr.size());\n\n        constexpr char digits[] = \"0123456789ABCDEF\";\n\n        boost::json::string encoded;\n        encoded.reserve(repr.size() * 2 + 4);\n\n        std::size_t pending_zero_bytes = 0U;\n        std::size_t emitted_bytes = 0U;\n\n        boost::mp11::tuple_for_each(repr, [&amp;](unsigned char byte){\n            if (byte == 0U)\n            {\n                ++pending_zero_bytes;\n                return;\n            }\n\n            while (pending_zero_bytes &gt; 0U)\n            {\n                encoded.push_back('0');\n                encoded.push_back('0');\n                --pending_zero_bytes;\n                ++emitted_bytes;\n            }\n            encoded.push_back(digits[(byte &gt;&gt; 4U) &amp; 0x0FU]);\n            encoded.push_back(digits[byte &amp; 0x0FU]);\n            ++emitted_bytes;\n        });\n\n        if (emitted_bytes == 0U)\n        {\n            encoded.push_back('0');\n            emitted_bytes = 1U;\n            pending_zero_bytes = 0U;\n        }\n\n        if (pending_zero_bytes &gt; 0U)\n        {\n            // Put num of trailing zero bytes after underscore in decimal\n            encoded.push_back('_');\n            std::array&lt;char, 20U&gt; buffer {};\n            std::size_t idx = buffer.size();\n            std::size_t value = pending_zero_bytes * 2U;\n            do\n            {\n                buffer[--idx] = static_cast&lt;char&gt;('0' + (value % 10U));\n                value /= 10U;\n            }\n            while (value != 0U);\n\n            encoded.append(buffer.data() + idx, buffer.data() + buffer.size());\n        }\n\n        return encoded;\n    }\n\n\n  public:\n\n    using entity_id::entity_id;\n    using entity_id::operator boost::json::value;\n    using entity_id::operator==;\n    using entity_id::operator!=;\n\n    template &lt;class Interface, class = mp_if&lt;is_ifc_handle&lt;Interface const&amp;&gt;, void&gt;&gt;\n    interface_id(Interface const&amp; ifc)\n        : entity_id(\n            ifc_addr(ifc),\n            typeid(remove_pointer_t&lt;remove_cvref_t&lt;ifc_handle_t&lt;Interface const&amp;&gt;&gt;&gt;)\n        )\n    {\n    }\n};\n\n\n} // namespace zmbt\n\ntemplate &lt;&gt;\nstruct std::hash&lt;zmbt::interface_id&gt;\n{\n    std::size_t operator()(const zmbt::interface_id&amp; k) const\n    {\n        return hash_value(k);\n    }\n};\n\n\n#endif // ZMBT_CORE_INTERFACE_ID_HPP_\n</code></pre>"},{"location":"CxxRef/interface__traits_8hpp/","title":"File interface_traits.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; interface_traits.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> <li><code>#include \"generic_traits.hpp\"</code></li> </ul>"},{"location":"CxxRef/interface__traits_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/interface__traits_8hpp/#classes","title":"Classes","text":"Type Name struct ifc_args &lt;class Interface&gt; struct ifc_handle &lt;class Interface&gt; struct ifc_host &lt;class Interface, class&gt; struct ifc_pointer &lt;class Interface&gt; struct ifc_return &lt;class Interface&gt;"},{"location":"CxxRef/interface__traits_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/interface_traits.hpp</code></p>"},{"location":"CxxRef/interface__traits_8hpp_source/","title":"File interface_traits.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; interface_traits.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_INTERFACE_TRAITS_HPP_\n#define ZMBT_CORE_INTERFACE_TRAITS_HPP_\n\n#include &lt;functional&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\n#include \"aliases.hpp\"\n#include \"generic_traits.hpp\"\n\n\n\nnamespace zmbt {\n\n\n\n// PREDICATES\n\ntemplate&lt;class Interface, class DecayedInterface = decay_t&lt;Interface&gt;&gt;\nusing ifc_is_pmf_handle = is_member_function_pointer&lt;DecayedInterface&gt;;\n\ntemplate&lt;class Interface, class DecayedInterface = decay_t&lt;Interface&gt;&gt;\nusing ifc_is_pmd_handle = is_member_object_pointer&lt;DecayedInterface&gt;;\n\ntemplate&lt;class Interface, class DecayedInterface = decay_t&lt;Interface&gt;&gt;\nusing ifc_is_member_handle = is_member_pointer&lt;DecayedInterface&gt;;\n\ntemplate&lt;class Interface, class DecayedInterface = decay_t&lt;Interface&gt;&gt;\nusing ifc_is_fn_ref = mp_all&lt;\n    is_lvalue_reference&lt;Interface&gt;,\n    is_function&lt;remove_pointer_t&lt;DecayedInterface&gt;&gt;\n&gt;;\n\ntemplate&lt;class Interface, class DecayedInterface = decay_t&lt;Interface&gt;&gt;\nusing ifc_is_fn_ptr = mp_all&lt;\n    is_pointer&lt;Interface&gt;,\n    is_function&lt;remove_pointer_t&lt;DecayedInterface&gt;&gt;\n&gt;;\n\ntemplate&lt;class Interface&gt;\nusing ifc_is_fn_handle = mp_any&lt;\n    ifc_is_fn_ref&lt;Interface&gt;, ifc_is_fn_ptr&lt;Interface&gt;\n&gt;;\n\n\nnamespace detail {\ntemplate&lt;class Interface, class = void&gt;\nstruct support_calltraits_function : mp_false {};\n\ntemplate&lt;class Interface&gt;\nstruct support_calltraits_function&lt;Interface, void_t&lt;ct::function_type_t&lt;Interface&gt;&gt;&gt; : mp_true {};\n}\n\n\n\n\ntemplate&lt;class Interface, class InterfacePointer = remove_reference_t&lt;Interface&gt;, class Functor = remove_pointer_t&lt;InterfacePointer&gt;&gt;\nusing ifc_is_functor_ptr = mp_all&lt;\n    is_pointer&lt;InterfacePointer&gt;, is_class&lt;Functor&gt;,\n    detail::support_calltraits_function&lt;Functor&gt;\n&gt;;\n\ntemplate&lt;class Interface, class Functor = remove_reference_t&lt;Interface&gt;&gt;\nusing ifc_is_functor_ref = mp_all&lt;\n    is_reference&lt;Interface&gt;, is_class&lt;Functor&gt;,\n    detail::support_calltraits_function&lt;Functor&gt;\n&gt;;\n\ntemplate &lt;class Interface&gt;\nusing ifc_is_functor_handle = mp_any&lt;\n    ifc_is_functor_ptr&lt;Interface&gt;,\n    ifc_is_functor_ref&lt;Interface&gt;\n&gt;;\n\n\ntemplate&lt;class Interface&gt;\nusing is_ifc_handle = mp_any&lt;\n    ifc_is_pmf_handle&lt;Interface&gt;,\n    ifc_is_pmd_handle&lt;Interface&gt;,\n    ifc_is_fn_handle&lt;Interface&gt;,\n    ifc_is_functor_handle&lt;Interface&gt;\n&gt;;\n\n\n\ntemplate &lt;class Interface, class Result = decay_t&lt;Interface&gt;&gt;\nauto get_ifc_pointer (Interface  x) -&gt; first_if_t&lt;Result,\n    ifc_is_member_handle&lt;Interface&gt;\n&gt;\n{\n    return x;\n}\n\ntemplate &lt;class Interface, class Result = decay_t&lt;Interface&gt;&gt;\nauto get_ifc_pointer (Interface x) -&gt; first_if_t&lt;Result,\n    ifc_is_fn_handle&lt;Interface&gt;\n&gt;\n{\n    return x;\n}\n\ntemplate &lt;class Interface, class Result = add_pointer_t&lt;remove_reference_t&lt;Interface&gt;&gt;&gt;\nauto get_ifc_pointer (Interface*  x) -&gt; first_if_t&lt;Result,\n    ifc_is_functor_ptr&lt;Interface*&gt;\n&gt;\n{\n    return x;\n}\n\ntemplate &lt;class Interface, class Result = add_pointer_t&lt;remove_reference_t&lt;Interface&gt;&gt;&gt;\nauto get_ifc_pointer (Interface&amp;  x) -&gt; first_if_t&lt;Result,\n    ifc_is_functor_ref&lt;Interface&amp;&gt;\n&gt;\n{\n    return &amp;x;\n}\n\n\n\ntemplate &lt;class Interface, class Result = decay_t&lt;Interface&gt; const&gt;\nauto get_ifc_handle (Interface const  x) -&gt; first_if_t&lt;Result,\n    ifc_is_member_handle&lt;Interface&gt;\n&gt;\n{\n    return x;\n}\n\ntemplate &lt;class Interface, class Result = decay_t&lt;Interface&gt; const&gt;\nauto get_ifc_handle (Interface  const x) -&gt; first_if_t&lt;Result,\n    ifc_is_fn_handle&lt;Interface&gt;\n&gt;\n{\n    return x;\n}\n\ntemplate &lt;class Interface, class Result = add_lvalue_reference_t&lt;Interface&gt; const&gt;\nauto get_ifc_handle (Interface *  x) -&gt; first_if_t&lt;Result,\n    ifc_is_functor_ptr&lt;Interface*&gt;\n&gt;\n{\n    return &amp;x;\n}\n\ntemplate &lt;class Interface, class Result = add_lvalue_reference_t&lt;Interface&gt; const&gt;\nauto get_ifc_handle (Interface &amp;  x) -&gt; first_if_t&lt;Result,\n    ifc_is_functor_ref&lt;Interface&amp;&gt;\n&gt;\n{\n    return x;\n}\n\n\nnamespace detail {\ntemplate &lt;class Interface&gt;\nusing ifc_pointer_valid_t = decltype(get_ifc_pointer(std::declval&lt;Interface&gt;()));\n}\n\ntemplate &lt;class Interface&gt;\nstruct ifc_pointer  {\n    using type = mp_eval_or&lt;nullptr_t, detail::ifc_pointer_valid_t, Interface&gt;;\n};\n\ntemplate &lt;class Interface&gt;\nusing ifc_pointer_t = typename ifc_pointer&lt;Interface&gt;::type;\n\n\nnamespace detail {\ntemplate &lt;class Interface&gt;\nusing ifc_handle_valid_t = decltype(get_ifc_handle(std::declval&lt;Interface&gt;()));\n}\n\ntemplate &lt;class Interface&gt;\nstruct ifc_handle  {\n    using type = mp_eval_or&lt;nullptr_t, detail::ifc_handle_valid_t, Interface&gt;;\n};\n\ntemplate &lt;class Interface&gt;\nusing ifc_handle_t = typename ifc_handle&lt;Interface&gt;::type;\n\n\n\n// PART TRAITS\n\nnamespace detail {\ntemplate &lt;class T&gt;\nstruct qualified_class_of {\n    using type = ct::qualified_class_of_t&lt;T&gt;;\n};\n}\n\ntemplate &lt;class Interface, class = void&gt;\nstruct ifc_host {\n    using type = typename mp_if&lt;ifc_is_member_handle&lt;Interface&gt;,  ct::qualified_class_of&lt;Interface&gt;, mp_identity&lt;nullptr_t&gt;&gt;::type;\n};\n\n\ntemplate &lt;class Interface&gt;\nusing ifc_host_t = typename ifc_host&lt;Interface&gt;::type;\n\ntemplate &lt;class Interface&gt;\nconstexpr add_pointer_t&lt;remove_reference_t&lt;ifc_host_t&lt;Interface&gt;&gt;&gt; ifc_host_nullptr {};\n\n\nnamespace detail {\ntemplate &lt;class Interface, class = void&gt;\nstruct ifc_args_impl {\n    using type = ct::args_t&lt;remove_pointer_t&lt;Interface&gt;&gt;;\n};\n\ntemplate &lt;class Interface&gt;\nstruct ifc_args_impl &lt;Interface, first_if_t&lt;void_t&lt;ct::args_t&lt;Interface&gt;&gt;, ifc_is_member_handle&lt;Interface&gt;&gt;&gt; {\n    using type = mp_rest&lt;ct::args_t&lt;Interface&gt;&gt;;\n};\n\ntemplate &lt;class Interface&gt;\nstruct ifc_args_impl &lt;Interface, first_if_none_t&lt;void_t&lt;ct::args_t&lt;Interface&gt;&gt;, ifc_is_member_handle&lt;Interface&gt; &gt;&gt; {\n    using type = ct::args_t&lt;Interface&gt;;\n};\n\n} // namespace detail\n\ntemplate &lt;class Interface&gt;\nstruct ifc_args\n{\n    using type = typename mp_eval_or&lt;mp_identity&lt;void&gt;, detail::ifc_args_impl, ifc_handle_t&lt;Interface&gt;&gt;::type;\n};\n\ntemplate &lt;class Interface&gt;\nusing ifc_args_t = typename ifc_args&lt;Interface&gt;::type;\n\n\ntemplate &lt;class Interface&gt;\nstruct ifc_return : ct::return_type&lt;Interface&gt; {\n    using type = typename mp_eval_or&lt;mp_identity&lt;void&gt;, ct::return_type, ifc_handle_t&lt;Interface&gt;&gt;::type;\n};\n\ntemplate &lt;class Interface&gt;\nusing ifc_return_t = typename ifc_return&lt;Interface&gt;::type;\n\n}  // namespace zmbt\n\n#endif  // ZMBT_CORE_INTERFACE_TRAITS_HPP_\n</code></pre>"},{"location":"CxxRef/json__iter_8hpp/","title":"File json_iter.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_iter.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"aliases.hpp\"</code></li> <li><code>#include \"exceptions.hpp\"</code></li> </ul>"},{"location":"CxxRef/json__iter_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/json__iter_8hpp/#classes","title":"Classes","text":"Type Name class JsonIter Boost JSON array iterator interface. class JsonIterZipProdBase Boost JSON array iterator base for zip or cartesian product. class JsonProdIter Cartesian Product Iterator. class JsonZipIter Zip Iterator."},{"location":"CxxRef/json__iter_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_iter.hpp</code></p>"},{"location":"CxxRef/json__iter_8hpp_source/","title":"File json_iter.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_iter.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_JSON_ITER_HPP_\n#define ZMBT_CORE_JSON_ITER_HPP_\n\n\n#include \"aliases.hpp\"\n\n#include \"exceptions.hpp\"\n\n\nnamespace zmbt {\n\n\n\nclass JsonIter\n{\n    virtual void step() = 0;\npublic:\n\n\n    JsonIter() = default;\n    virtual ~JsonIter() = default;\n    JsonIter(JsonIter const&amp;) = default;\n    JsonIter&amp; operator=(JsonIter const&amp;) = default;\n    JsonIter(JsonIter &amp;&amp;) = default;\n    JsonIter&amp; operator=(JsonIter &amp;&amp;) = default;\n\n    virtual bool halt() const = 0;\n\n    virtual boost::json::array get() = 0;\n\n    JsonIter&amp; operator++(int)\n    {\n        if (!halt())\n        {\n            this-&gt;step();\n        }\n        return *(this);\n    };\n\n    boost::json::array operator*()\n    {\n        return get();\n    }\n};\n\n\nclass JsonIterZipProdBase : public virtual JsonIter\n{\nprotected:\n\n    bool halt_{false};\n    std::vector&lt;boost::json::array::const_iterator&gt; begins_{};\n    std::vector&lt;boost::json::array::const_iterator&gt; ends_{};\n    std::vector&lt;boost::json::array::const_iterator&gt; its_{};\n\n    boost::json::array owned_sequences_; // capture temporaries\n\nprivate:\n\n    void init_iters(boost::json::array const&amp; seqences);\n\npublic:\n\n    bool halt() const final\n    {\n        return halt_;\n    }\n\n    explicit JsonIterZipProdBase(boost::json::array const&amp; sequences) : JsonIter(), owned_sequences_{}\n    {\n        init_iters(sequences);\n    }\n\n    explicit JsonIterZipProdBase(boost::json::array &amp;&amp; seqences) : JsonIter(), owned_sequences_(std::move(seqences))\n    {\n        init_iters(owned_sequences_);\n    }\n\n    JsonIterZipProdBase() : JsonIterZipProdBase([]{\n            boost::json::array arr {};\n            arr.push_back(boost::json::array{});\n            return arr;\n        }()) // default iter yields empty set\n    {\n    }\n\n    virtual ~JsonIterZipProdBase() = default;\n\n    JsonIterZipProdBase(JsonIterZipProdBase const&amp;) = default;\n    JsonIterZipProdBase&amp; operator=(JsonIterZipProdBase const&amp;) = default;\n\n    JsonIterZipProdBase(JsonIterZipProdBase &amp;&amp;) = default;\n    JsonIterZipProdBase&amp; operator=(JsonIterZipProdBase &amp;&amp;) = default;\n\n\n    boost::json::array get() final;\n};\n\n\nclass JsonProdIter : public virtual JsonIterZipProdBase\n{\n    void step() final;\n\n    public:\n    using JsonIterZipProdBase::JsonIterZipProdBase;\n\n};\n\n\nclass JsonZipIter : public virtual JsonIterZipProdBase\n{\n    void step() final;\n    public:\n    using JsonIterZipProdBase::JsonIterZipProdBase;\n};\n\n\n}\n\n#endif\n</code></pre>"},{"location":"CxxRef/json__node_8hpp/","title":"File json_node.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_node.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"format_string.hpp\"</code></li> </ul>"},{"location":"CxxRef/json__node_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/json__node_8hpp/#classes","title":"Classes","text":"Type Name class JsonNode Mutator/accessor wrapper over shared JSON value."},{"location":"CxxRef/json__node_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_node.hpp</code></p>"},{"location":"CxxRef/json__node_8hpp_source/","title":"File json_node.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_node.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_JSON_NODE_HPP_\n#define ZMBT_CORE_JSON_NODE_HPP_\n\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;cstddef&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n\n#include \"format_string.hpp\"\n\nnamespace zmbt {\n\n\n\nclass JsonNode\n{\n    std::shared_ptr&lt;boost::json::value&gt; root_;\n    boost::json::string node_ptr_;\n\n    boost::json::value&amp; get_or_create(boost::json::string_view json_ptr);\n\n    boost::json::string_view validate_jptr(boost::json::string_view query) const;\n\n    boost::json::value&amp; get_or_create_as(boost::json::kind request_kind, boost::json::string_view json_ptr);\n\n    JsonNode(boost::json::string_view node_ptr, std::shared_ptr&lt;boost::json::value&gt; root);\n\n\npublic:\n\n    ~JsonNode() noexcept = default;\n\n    explicit JsonNode(std::shared_ptr&lt;boost::json::value&gt; root)\n        : JsonNode(\"\", root)\n    {\n    }\n\n    JsonNode()\n        : JsonNode(std::make_shared&lt;boost::json::value&gt;())\n    {\n    }\n\n    explicit JsonNode(boost::json::storage_ptr sp)\n        : JsonNode(std::make_shared&lt;boost::json::value&gt;(sp))\n    {\n    }\n\n    JsonNode(JsonNode const&amp; o)\n        : JsonNode(o.node())\n    {\n    }\n\n    JsonNode(JsonNode &amp; o)\n        : JsonNode(o.node_ptr(), o.root())\n    {\n    }\n\n    JsonNode(JsonNode &amp;&amp; o)\n        : JsonNode(std::move(o.node_ptr_), std::move(o.root_))\n    {\n    }\n\n\n    JsonNode(boost::json::value const&amp; v) : JsonNode(std::make_shared&lt;boost::json::value&gt;(v)) {}\n    JsonNode(boost::json::value&amp;&amp; v) : JsonNode(std::make_shared&lt;boost::json::value&gt;(std::move(v))) {}\n\n    std::shared_ptr&lt;boost::json::value&gt; const&amp; root() const { return root_; }\n\n    JsonNode root_node() const { return JsonNode{root()}; }\n\n    boost::json::string_view node_ptr() const { return node_ptr_; }\n\n    JsonNode copy() const\n    {\n        return JsonNode{node()};\n    }\n\n    boost::json::value const* node(boost::json::error_code &amp;ec) const\n    {\n        return root()-&gt;find_pointer(node_ptr(), ec);\n    }\n\n    boost::json::value* node(boost::json::error_code &amp;ec)\n    {\n        JsonNode const&amp; self = *this;\n        return const_cast&lt;boost::json::value*&gt;(self.node(ec));\n    }\n\n    boost::json::value const&amp; node() const {\n        return root()-&gt;at_pointer(node_ptr());\n    }\n\n    boost::json::value&amp; node() {\n        JsonNode const&amp; self = *this;\n        return const_cast&lt;boost::json::value&amp;&gt;(self.node());\n    }\n\n\n    boost::json::array const&amp; as_array() const {\n        return node().as_array();\n    }\n\n    boost::json::array&amp; as_array() {\n        JsonNode const&amp; self = *this;\n        return const_cast&lt;boost::json::array&amp;&gt;(self.as_array());\n    }\n\n\n    boost::json::object const&amp; as_object() const {\n        return node().as_object();\n    }\n\n    boost::json::object&amp; as_object() {\n        JsonNode const&amp; self = *this;\n        return const_cast&lt;boost::json::object&amp;&gt;(self.as_object());\n    }\n\n    JsonNode&amp; operator=(JsonNode const&amp;) = default;\n    JsonNode&amp; operator=(JsonNode &amp;&amp;) = default;\n\n\n    boost::json::value const&amp; at(boost::json::string_view json_ptr) const;\n\n    template &lt;class T, class... A&gt;\n    boost::json::value const&amp; at(boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest) const\n    {\n        return at(format(fmtstr, std::forward&lt;T&gt;(first), std::forward&lt;A&gt;(rest)...));\n    }\n\n    boost::json::value const* find_pointer(boost::json::string_view json_ptr) const\n    {\n        boost::json::error_code ignored;\n        return node().find_pointer(validate_jptr(json_ptr), ignored);\n    }\n\n\n    template &lt;class T, class... A&gt;\n    boost::json::value const* find_pointer(boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest) const\n    {\n        return find_pointer(format(fmtstr, std::forward&lt;T&gt;(first), std::forward&lt;A&gt;(rest)...));\n    }\n\n    template &lt;class T, class... A&gt;\n    boost::json::value* find_pointer(boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest)\n    {\n        JsonNode const&amp; self = *this;\n        return const_cast&lt;boost::json::value*&gt;(self.find_pointer(fmtstr, std::forward&lt;T&gt;(first), std::forward&lt;A&gt;(rest)...));\n    }\n\n    bool contains(boost::json::string_view json_ptr) const\n    {\n        return find_pointer(json_ptr);\n    }\n\n    template &lt;class T, class... A&gt;\n    bool contains(boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest) const\n    {\n        return contains(format(fmtstr, std::forward&lt;T&gt;(first), std::forward&lt;A&gt;(rest)...));\n    }\n\n\n    boost::json::value&amp; operator()(boost::json::string_view json_ptr = \"\")\n    {\n        return this-&gt;get_or_create(validate_jptr(json_ptr));\n    }\n\n    template &lt;class T, class... A&gt;\n    boost::json::value&amp; operator()(boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest)\n    {\n        return this-&gt;operator()(format(fmtstr, first, rest...));\n    }\n\n\n    boost::json::value const&amp; operator()(boost::json::string_view json_ptr = \"\") const\n    {\n        return at(json_ptr);\n    }\n\n    template &lt;class T, class... A&gt;\n    boost::json::value const&amp; operator()(boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest) const\n    {\n        return at(format(fmtstr, first, rest...));\n    }\n\n    boost::json::value get_or_default(boost::json::string_view json_ptr, boost::json::value const&amp; dflt) const\n    {\n        boost::json::value const* ptr;\n        return (ptr = find_pointer(json_ptr)) ? *ptr : dflt;\n    }\n\n    boost::json::array&amp; get_or_create_array(boost::json::string_view json_ptr = \"\")\n    {\n        return get_or_create_as(boost::json::kind::array, json_ptr).as_array();\n    }\n    template &lt;class T, class... A&gt;\n    boost::json::array&amp; get_or_create_array(boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest)\n    {\n        return get_or_create_array(format(fmtstr, first, rest...));\n    }\n\n    boost::json::object&amp; get_or_create_object(boost::json::string_view json_ptr = \"\")\n    {\n        return get_or_create_as(boost::json::kind::object, json_ptr).as_object();\n    }\n\n\n    template &lt;class T, class... A&gt;\n    boost::json::object&amp; get_or_create_object(boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest)\n    {\n        return get_or_create_object(format(fmtstr, first, rest...));\n    }\n\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, JsonNode const&amp; view)\n    {\n        os &lt;&lt; view.node();\n        return os;\n    }\n\n    JsonNode branch(boost::json::kind kind, boost::json::string_view subnode_ptr);\n\n    JsonNode branch(boost::json::string_view subnode_ptr)\n    {\n        return branch(boost::json::kind::null, subnode_ptr);\n    }\n\n    template &lt;class T, class... A&gt;\n    JsonNode branch(boost::json::kind kind, boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest)\n    {\n        return branch(kind, format(fmtstr, std::forward&lt;T&gt;(first), std::forward&lt;A&gt;(rest)...));\n    }\n\n    template &lt;class T, class... A&gt;\n    JsonNode branch(boost::json::string_view fmtstr, T&amp;&amp; first, A&amp;&amp;... rest)\n    {\n        return branch(format(fmtstr, std::forward&lt;T&gt;(first), std::forward&lt;A&gt;(rest)...));\n    }\n\n    bool is_null() const\n    {\n        return node().is_null();\n    }\n\n    std::size_t size() const\n    {\n        switch (node().kind())\n        {\n        case boost::json::kind::array:\n            return as_array().size();\n            break;\n        case boost::json::kind::object:\n            return as_object().size();\n            break;\n        default:\n            return 0;\n            break;\n        }\n    }\n};\n\n}\n\n#endif\n</code></pre>"},{"location":"CxxRef/json__number__cast_8hpp/","title":"File json_number_cast.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_number_cast.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/json__number__cast_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/json__number__cast_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_number_cast.hpp</code></p>"},{"location":"CxxRef/json__number__cast_8hpp_source/","title":"File json_number_cast.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_number_cast.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_JSON_NUMBER_CAST_HPP_\n#define ZMBT_CORE_JSON_NUMBER_CAST_HPP_\n\n#include &lt;boost/json.hpp&gt;\n\nnamespace zmbt\n{\n\nboost::json::value real_to_number(double value);\n\nboost::json::value real_to_number(std::int64_t value);\n\nboost::json::value maybe_real_to_number(boost::json::value const&amp; value);\n\nbool maybe_real_to_number_inplace(boost::json::value&amp; value);\n\n\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/json__pretty__print_8hpp/","title":"File json_pretty_print.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_pretty_print.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/json__pretty__print_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/json__pretty__print_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_pretty_print.hpp</code></p>"},{"location":"CxxRef/json__pretty__print_8hpp_source/","title":"File json_pretty_print.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_pretty_print.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_JSON_PRETTY_PRINT_HPP_\n#define ZMBT_CORE_JSON_PRETTY_PRINT_HPP_\n\n#include \"aliases.hpp\"\n\n\nnamespace zmbt {\n\n\nstd::ostream&amp; pretty_print(std::ostream&amp; os, boost::json::value const&amp; jv, int const indent = 0);\n\n\n\n} // namespace zmbt\n\n#endif // ZMBT_CORE_JSON_PRETTY_PRINT_HPP_\n</code></pre>"},{"location":"CxxRef/json__traverse_8hpp/","title":"File json_traverse.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_traverse.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"boost/json.hpp\"</code></li> </ul>"},{"location":"CxxRef/json__traverse_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/json__traverse_8hpp/#classes","title":"Classes","text":"Type Name class JsonTraverse Boost JSON value depth-first traverser."},{"location":"CxxRef/json__traverse_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/json_traverse.hpp</code></p>"},{"location":"CxxRef/json__traverse_8hpp_source/","title":"File json_traverse.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; json_traverse.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_JSON_TRAVERSE_HPP_\n#define ZMBT_CORE_JSON_TRAVERSE_HPP_\n\n#include &lt;functional&gt;\n#include &lt;string&gt;\n#include \"boost/json.hpp\"\n\n\n\nnamespace zmbt {\n\n\n\nclass JsonTraverse\n{\n    void traverse(boost::json::value const&amp; v, std::string const jptr) const;\npublic:\n\n    typedef std::function&lt;bool(boost::json::value const&amp;, std::string const)&gt; visitor_fn;\n\n    JsonTraverse(visitor_fn visit) : visit_{visit} {}\n\n    void operator()(boost::json::value const&amp; v) const\n    {\n        return traverse(v, \"\");\n    }\nprivate:\n    visitor_fn const visit_;\n};\n\n}\n\n#endif // ZMBT_CORE_JSON_TRAVERSE_HPP_\n</code></pre>"},{"location":"CxxRef/object__id_8hpp/","title":"File object_id.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; object_id.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> <li><code>#include \"entity_id.hpp\"</code></li> <li><code>#include \"type_info.hpp\"</code></li> </ul>"},{"location":"CxxRef/object__id_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/object__id_8hpp/#classes","title":"Classes","text":"Type Name class object_id Pointer-based object id with type annotation. struct string_key"},{"location":"CxxRef/object__id_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/object_id.hpp</code></p>"},{"location":"CxxRef/object__id_8hpp_source/","title":"File object_id.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; object_id.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_OBJECT_ID_HPP_\n#define ZMBT_CORE_OBJECT_ID_HPP_\n\n#include &lt;cstdint&gt;\n#include &lt;memory&gt;\n\n#include \"aliases.hpp\"\n#include \"entity_id.hpp\"\n#include \"type_info.hpp\"\n\n\nnamespace zmbt {\n\n\n\nclass object_id : public entity_id {\n\n    static boost::json::string to_string(void const* ptr);\n\n    static boost::json::string to_string(boost::json::string_view str);\n\n    template &lt;class T&gt;\n    using is_ptr = mp_if&lt;is_convertible&lt;T, void const*&gt;, bool&gt;;\n\n    template &lt;class T&gt;\n    using is_not_ptr = mp_if&lt;mp_not&lt;is_convertible&lt;T, void const*&gt;&gt;, bool&gt;;\n\n\n  public:\n\n    struct string_key final {};\n\n    using entity_id::entity_id;\n    using entity_id::operator boost::json::value;\n    using entity_id::operator==;\n    using entity_id::operator!=;\n\n\n    object_id(boost::json::string_view str) : entity_id(to_string(str), typeid(string_key))\n    {\n    }\n    object_id(std::string const&amp; str) : entity_id(str, typeid(string_key))\n    {\n    }\n    // required to bypass is_ptr&lt;T&gt; overload\n    object_id(char const* str) : object_id(boost::json::string_view(str))\n    {\n    }\n\n    template&lt;class T, is_ptr&lt;T&gt; = true&gt;\n    object_id(T obj)\n        : entity_id(\n            to_string(static_cast&lt;void const*&gt;(obj)),\n            typeid(remove_cvptr_t&lt;T&gt;)\n        )\n    {\n    }\n\n    template &lt;class T&gt;\n    object_id(std::shared_ptr&lt;T&gt; const&amp; ptr)\n        : object_id{ptr.get()}\n    {\n    }\n\n    template&lt;class T, is_not_ptr&lt;T&gt; = true&gt;\n    object_id(T const&amp; ref)\n        : object_id(std::addressof(ref))\n    {\n    }\n\n\n    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, object_id const&amp; id)\n    {\n        os &lt;&lt; id.str();\n        return os;\n    }\n\n};\n\n\n} // namespace zmbt\n\n\ntemplate &lt;&gt;\nstruct std::hash&lt;zmbt::object_id&gt;\n{\n    std::size_t operator()(const zmbt::object_id&amp; k) const\n    {\n        return hash_value(k);\n    }\n};\n\n\n#endif // ZMBT_CORE_INTERFACE_ID_HPP_\n</code></pre>"},{"location":"CxxRef/operator__traits_8hpp/","title":"File operator_traits.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; operator_traits.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;boost/type_traits.hpp&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/operator__traits_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/operator__traits_8hpp/#macros","title":"Macros","text":"Type Name define ZMBT_WRAP_BOOST_TRAIT (has_operator) <code>/* multi line expression */</code>expand boost::has_operator to containers and tuples"},{"location":"CxxRef/operator__traits_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/operator__traits_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/operator__traits_8hpp/#define-zmbt_wrap_boost_trait","title":"define ZMBT_WRAP_BOOST_TRAIT","text":"<p>expand boost::has_operator to containers and tuples <pre><code>#define ZMBT_WRAP_BOOST_TRAIT (\n    has_operator\n) `/* multi line expression */`\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/operator_traits.hpp</code></p>"},{"location":"CxxRef/operator__traits_8hpp_source/","title":"File operator_traits.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; operator_traits.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_OPERATOR_TRAITS_HPP_\n#define ZMBT_CORE_OPERATOR_TRAITS_HPP_\n\n#include &lt;array&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;type_traits&gt;\n#include &lt;tuple&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\n\n#include &lt;boost/type_traits.hpp&gt;\n\n\n#include \"aliases.hpp\"\n\nnamespace zmbt {\n\n\n#define ZMBT_WRAP_BOOST_TRAIT(has_operator) \\\ntemplate &lt;class T, class E = void&gt; struct has_operator; \\\ntemplate &lt;class T&gt; \\\nstruct has_operator&lt;T, enable_if_t&lt;not is_const_iterable&lt;T&gt;::value and not is_tuple&lt;T&gt;::value&gt;&gt; : boost::has_operator&lt;T&gt; {}; \\\ntemplate &lt;class T&gt; \\\nstruct has_operator&lt;T, enable_if_t&lt;is_const_iterable&lt;T&gt;::value&gt;&gt; : has_operator&lt;typename T::value_type&gt; {}; \\\ntemplate &lt;class T&gt; \\\nstruct has_operator&lt;T, enable_if_t&lt;is_tuple&lt;T&gt;::value&gt;&gt; : mp_all_of&lt;T, has_operator&gt; {};\n\nZMBT_WRAP_BOOST_TRAIT(has_bit_and)\nZMBT_WRAP_BOOST_TRAIT(has_bit_or)\nZMBT_WRAP_BOOST_TRAIT(has_bit_xor)\nZMBT_WRAP_BOOST_TRAIT(has_complement)\nZMBT_WRAP_BOOST_TRAIT(has_divides)\nZMBT_WRAP_BOOST_TRAIT(has_equal_to)\nZMBT_WRAP_BOOST_TRAIT(has_greater)\nZMBT_WRAP_BOOST_TRAIT(has_greater_equal)\nZMBT_WRAP_BOOST_TRAIT(has_left_shift)\nZMBT_WRAP_BOOST_TRAIT(has_right_shift)\nZMBT_WRAP_BOOST_TRAIT(has_less)\nZMBT_WRAP_BOOST_TRAIT(has_less_equal)\nZMBT_WRAP_BOOST_TRAIT(has_logical_and)\nZMBT_WRAP_BOOST_TRAIT(has_logical_not)\nZMBT_WRAP_BOOST_TRAIT(has_logical_or)\nZMBT_WRAP_BOOST_TRAIT(has_minus)\nZMBT_WRAP_BOOST_TRAIT(has_modulus)\nZMBT_WRAP_BOOST_TRAIT(has_multiplies)\nZMBT_WRAP_BOOST_TRAIT(has_negate)\nZMBT_WRAP_BOOST_TRAIT(has_not_equal_to)\nZMBT_WRAP_BOOST_TRAIT(has_plus)\n\n\n#undef ZMBT_WRAP_BOOST_TRAIT\n\n}\n\n#endif // ZMBT_CORE_OPERATOR_TRAITS_HPP_\n</code></pre>"},{"location":"CxxRef/preprocessor_8hpp/","title":"File preprocessor.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; preprocessor.hpp</p> <p>Go to the source code of this file</p> <p>type traits to check serialization compatibility More...</p> <ul> <li><code>#include &lt;boost/preprocessor.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/preprocessor_8hpp/#macros","title":"Macros","text":"Type Name define ZMBT_CUR_LOC <code>\\_\\_FILE\\_\\_ \"#\" ZMBT\\_STRINGIFY(\\_\\_LINE\\_\\_)</code> define ZMBT_PP_INJECT_CODE_INTO_NS (code, ...) <code>/* multi line expression */</code> define ZMBT_PP_NS_CLOSE (s, state, ns) <code>}</code> define ZMBT_PP_NS_CLOSE_ALL (...) <code>BOOST\\_PP\\_SEQ\\_FOR\\_EACH(ZMBT\\_PP\\_NS\\_CLOSE, , BOOST\\_PP\\_VARIADIC\\_TO\\_SEQ(\\_\\_VA\\_ARGS\\_\\_))</code> define ZMBT_PP_NS_OPEN (s, state, ns) <code>namespace ns {</code> define ZMBT_PP_NS_OPEN_ALL (...) <code>BOOST\\_PP\\_SEQ\\_FOR\\_EACH(ZMBT\\_PP\\_NS\\_OPEN, , BOOST\\_PP\\_VARIADIC\\_TO\\_SEQ(\\_\\_VA\\_ARGS\\_\\_))</code> define ZMBT_STRINGIFY (x) <code>ZMBT\\_STRINGIFY\\_IMPL(x)</code> define ZMBT_STRINGIFY_IMPL (x) <code>#x</code>"},{"location":"CxxRef/preprocessor_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/preprocessor_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/preprocessor_8hpp/#define-zmbt_cur_loc","title":"define ZMBT_CUR_LOC","text":"<pre><code>#define ZMBT_CUR_LOC `__FILE__ \"#\" ZMBT_STRINGIFY(__LINE__)`\n</code></pre>"},{"location":"CxxRef/preprocessor_8hpp/#define-zmbt_pp_inject_code_into_ns","title":"define ZMBT_PP_INJECT_CODE_INTO_NS","text":"<pre><code>#define ZMBT_PP_INJECT_CODE_INTO_NS (\n    code,\n    ...\n) `/* multi line expression */`\n</code></pre>"},{"location":"CxxRef/preprocessor_8hpp/#define-zmbt_pp_ns_close","title":"define ZMBT_PP_NS_CLOSE","text":"<pre><code>#define ZMBT_PP_NS_CLOSE (\n    s,\n    state,\n    ns\n) `}`\n</code></pre>"},{"location":"CxxRef/preprocessor_8hpp/#define-zmbt_pp_ns_close_all","title":"define ZMBT_PP_NS_CLOSE_ALL","text":"<pre><code>#define ZMBT_PP_NS_CLOSE_ALL (\n    ...\n) `BOOST_PP_SEQ_FOR_EACH(ZMBT_PP_NS_CLOSE, , BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))`\n</code></pre>"},{"location":"CxxRef/preprocessor_8hpp/#define-zmbt_pp_ns_open","title":"define ZMBT_PP_NS_OPEN","text":"<pre><code>#define ZMBT_PP_NS_OPEN (\n    s,\n    state,\n    ns\n) `namespace ns {`\n</code></pre>"},{"location":"CxxRef/preprocessor_8hpp/#define-zmbt_pp_ns_open_all","title":"define ZMBT_PP_NS_OPEN_ALL","text":"<pre><code>#define ZMBT_PP_NS_OPEN_ALL (\n    ...\n) `BOOST_PP_SEQ_FOR_EACH(ZMBT_PP_NS_OPEN, , BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))`\n</code></pre>"},{"location":"CxxRef/preprocessor_8hpp/#define-zmbt_stringify","title":"define ZMBT_STRINGIFY","text":"<pre><code>#define ZMBT_STRINGIFY (\n    x\n) `ZMBT_STRINGIFY_IMPL(x)`\n</code></pre>"},{"location":"CxxRef/preprocessor_8hpp/#define-zmbt_stringify_impl","title":"define ZMBT_STRINGIFY_IMPL","text":"<pre><code>#define ZMBT_STRINGIFY_IMPL (\n    x\n) `#x`\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/preprocessor.hpp</code></p>"},{"location":"CxxRef/preprocessor_8hpp_source/","title":"File preprocessor.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; preprocessor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_PREPROCESSOR_HPP_\n#define ZMBT_CORE_PREPROCESSOR_HPP_\n\n#include &lt;boost/preprocessor.hpp&gt; // IWYU pragma: export\n\n#define ZMBT_STRINGIFY(x) ZMBT_STRINGIFY_IMPL(x)\n#define ZMBT_STRINGIFY_IMPL(x) #x\n#define ZMBT_CUR_LOC __FILE__ \"#\" ZMBT_STRINGIFY(__LINE__)\n\n#define ZMBT_PP_NS_OPEN(s, state, ns) namespace ns {\n#define ZMBT_PP_NS_CLOSE(s, state, ns) }\n#define ZMBT_PP_NS_OPEN_ALL(...) BOOST_PP_SEQ_FOR_EACH(ZMBT_PP_NS_OPEN, , BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))\n#define ZMBT_PP_NS_CLOSE_ALL(...) BOOST_PP_SEQ_FOR_EACH(ZMBT_PP_NS_CLOSE, , BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))\n\n#define ZMBT_PP_INJECT_CODE_INTO_NS(code, ...) \\\nZMBT_PP_NS_OPEN_ALL(__VA_ARGS__)               \\\ncode                                            \\\nZMBT_PP_NS_CLOSE_ALL(__VA_ARGS__)\n\n\n#endif // ZMBT_CORE_PREPROCESSOR_HPP_\n</code></pre>"},{"location":"CxxRef/shared__resource_8hpp/","title":"File shared_resource.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; shared_resource.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"CxxRef/shared__resource_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/shared__resource_8hpp/#classes","title":"Classes","text":"Type Name class shared_resource &lt;class T&gt;"},{"location":"CxxRef/shared__resource_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/shared_resource.hpp</code></p>"},{"location":"CxxRef/shared__resource_8hpp_source/","title":"File shared_resource.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; shared_resource.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_SHARED_EMPLACER_HPP_\n#define ZMBT_CORE_SHARED_EMPLACER_HPP_\n\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\nnamespace zmbt {\n\nnamespace detail\n{\nstruct emplace_shared_tag {};\n}\n\nstatic constexpr detail::emplace_shared_tag emplace_shared;\n\ntemplate &lt;class T&gt;\nclass shared_resource\n{\n    std::shared_ptr&lt;T&gt; ptr_;\n\n  public:\n\n    shared_resource(T&amp;&amp; v)\n        : ptr_{std::make_shared&lt;T&gt;(std::forward&lt;T&gt;(v))}\n    {\n    }\n\n    shared_resource(std::function&lt;T()&gt; f)\n        : ptr_{std::make_shared&lt;T&gt;(f())}\n    {\n    }\n\n    shared_resource(std::function&lt;std::shared_ptr&lt;T&gt;()&gt; f)\n        : ptr_{f()}\n    {\n    }\n\n    shared_resource(std::shared_ptr&lt;T&gt; ptr)\n        : ptr_{ptr}\n    {\n    }\n\n    template &lt;class... A&gt;\n    shared_resource(detail::emplace_shared_tag, A&amp;&amp;... args)\n        : ptr_{std::make_shared&lt;T&gt;(std::forward&lt;A&gt;(args)...)}\n    {\n    }\n\n    shared_resource() = default;\n    shared_resource(shared_resource const&amp;) = default;\n    shared_resource(shared_resource&amp;&amp;) = default;\n\n    shared_resource&amp; operator=(shared_resource const&amp;) = default;\n    shared_resource&amp; operator=(shared_resource&amp;&amp;) = default;\n\n    ~shared_resource() = default;\n\n    std::shared_ptr&lt;T&gt; ptr() const\n    {\n        return ptr_;\n    }\n\n    T&amp;       operator*()       { return *ptr_; }\n    T const&amp; operator*() const { return *ptr_; }\n\n    std::shared_ptr&lt;T&gt;       operator-&gt;()       { return  ptr_; }\n    std::shared_ptr&lt;T&gt; const operator-&gt;() const { return  ptr_; }\n\n    operator std::shared_ptr&lt;T&gt;()\n    {\n        return ptr_;\n    }\n};\n\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/slice_8hpp/","title":"File slice.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; slice.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/slice_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/slice_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/slice.hpp</code></p>"},{"location":"CxxRef/slice_8hpp_source/","title":"File slice.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; slice.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_SLICE_ARRAY_HPP_\n#define ZMBT_MODEL_SLICE_ARRAY_HPP_\n\n#include &lt;array&gt;\n#include &lt;functional&gt;\n#include \"aliases.hpp\"\n\nnamespace zmbt {\n\nboost::json::array slice(boost::json::array const&amp; src, boost::json::string_view jp, std::int64_t const start = 0, std::int64_t const stop = -1, std::int64_t const step = 1);\n\nboost::json::array slice(boost::json::array const&amp; src, std::int64_t const start = 0, std::int64_t const stop = -1, std::int64_t const step = 1);\n\nboost::json::string slice(boost::json::string_view const src, std::int64_t const start = 0, std::int64_t const stop = -1, std::int64_t const step = 1);\n\nusing js_array_slice_gen = std::function&lt;boost::json::array::iterator()&gt;;\nusing js_array_slice_const_gen = std::function&lt;boost::json::array::const_iterator()&gt;;\nusing js_string_slice_gen = std::function&lt;boost::json::string_view::const_iterator()&gt;;\n\njs_array_slice_gen             make_slice_generator(boost::json::array&amp; src           , std::int64_t const start = 0, std::int64_t const stop = -1, std::int64_t const step = 1);\njs_array_slice_const_gen make_slice_const_generator(boost::json::array const&amp; src     , std::int64_t const start = 0, std::int64_t const stop = -1, std::int64_t const step = 1);\njs_string_slice_gen      make_slice_const_generator(boost::json::string_view const src, std::int64_t const start = 0, std::int64_t const stop = -1, std::int64_t const step = 1);\n\n\nnamespace detail\n{\n    std::array&lt;std::int64_t, 3&gt; str_to_slice_idx(boost::json::string_view slice_expr);\n} // namespace detail\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/tuple__conversion_8hpp/","title":"File tuple_conversion.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; tuple_conversion.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/tuple__conversion_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/tuple__conversion_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/tuple_conversion.hpp</code></p>"},{"location":"CxxRef/tuple__conversion_8hpp_source/","title":"File tuple_conversion.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; tuple_conversion.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_TUPLE_CONVERSION_HPP_\n#define ZMBT_CORE_TUPLE_CONVERSION_HPP_\n\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\n#include \"aliases.hpp\"\n\nnamespace zmbt {\n\nnamespace detail {\n\ntemplate &lt;class T, class... A&gt;\nstruct tuple_conversion_handler {\n\n    T target;\n    tuple_conversion_handler(tuple&lt;A...&gt;&amp; source) : tuple_conversion_handler{source, std::make_index_sequence&lt;sizeof...(A)&gt;()}\n    {\n    }\n\n  private:\n\n    template &lt;size_t... I&gt;\n    tuple_conversion_handler(tuple&lt;A...&gt;&amp; source, std::index_sequence&lt;I...&gt;)\n    // TODO: refactor with static_cast\n    : target{std::get&lt;I&gt;(source)...}\n    {\n    }\n};\n\n}  // namespace detail\n\n\ntemplate &lt;class T, class... A&gt;\ninline T convert_tuple_to(tuple&lt;A...&gt; &amp;source) {\n    return detail::tuple_conversion_handler&lt;T, A...&gt; (source).target;\n}\n\n}  // namespace zmbt\n\n#endif  // ZMBT_CORE_TUPLE_CONVERSION_HPP_\n</code></pre>"},{"location":"CxxRef/tuple__exchange_8hpp/","title":"File tuple_exchange.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; tuple_exchange.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/tuple__exchange_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/tuple__exchange_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/tuple_exchange.hpp</code></p>"},{"location":"CxxRef/tuple__exchange_8hpp_source/","title":"File tuple_exchange.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; tuple_exchange.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_TUPLE_EXCHANGE_HPP_\n#define ZMBT_CORE_TUPLE_EXCHANGE_HPP_\n\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\n#include \"aliases.hpp\"\n\nnamespace zmbt {\n\nnamespace detail {\n\nstruct tuple_exchange_helper\n{\n    template &lt;class T&gt;\n    using is_assignable_reference = mp_and&lt;std::is_lvalue_reference&lt;T&gt;, mp_not&lt;std::is_const&lt;T&gt;&gt;&gt;;\n\n    template &lt;class A, class B&gt;\n    static void assign(A &amp; a, B const&amp; b)\n    {\n        a = b;\n    }\n\n    template &lt;class A, class B&gt;\n    static void assign(A const&amp;, B const&amp;) {}\n};\n\n}\n\n\ntemplate &lt;class T1, class T2&gt;\nvoid tuple_exchange(T1 &amp; target, T2 const&amp; src)\n{\n    static_assert(mp_same&lt;mp_size&lt;T1&gt;, mp_size&lt;T2&gt;&gt;::value, \"tuples shall be of equal size\");\n\n    using helper = detail::tuple_exchange_helper;\n    mp_for_each&lt;mp_iota&lt;mp_size&lt;T1&gt;&gt;&gt;([&amp;](auto N){\n        using A = mp_at_c&lt;T1, N&gt;;\n        if (helper::is_assignable_reference&lt;A&gt;::value) {\n            helper::assign(\n                std::forward&lt;A&gt;(std::get&lt;N&gt;(target)),\n                std::get&lt;N&gt;(src)\n            );\n        }\n    });\n}\n\n}  // namespace zmbt\n\n#endif  // ZMBT_CORE_TUPLE_CONVERSION_HPP_\n</code></pre>"},{"location":"CxxRef/tuple__indexator_8hpp/","title":"File tuple_indexator.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; tuple_indexator.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/tuple__indexator_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/tuple__indexator_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/tuple_indexator.hpp</code></p>"},{"location":"CxxRef/tuple__indexator_8hpp_source/","title":"File tuple_indexator.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; tuple_indexator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_TUPLE_INDEXATOR_HPP_\n#define ZMBT_CORE_TUPLE_INDEXATOR_HPP_\n\n#include &lt;type_traits&gt;\n\n#include \"aliases.hpp\"\n\nnamespace zmbt {\n\nnamespace detail\n{\n\ntemplate &lt;class I&gt;\nstruct tuple_indexator;\n\ntemplate &lt;size_t... I&gt;\nstruct tuple_indexator&lt;std::index_sequence&lt;I...&gt;&gt; {\n    using type = tuple&lt;std::integral_constant&lt;size_t, I&gt;...&gt;;\n    using sequence = std::index_sequence&lt;I...&gt;;\n};\ntemplate &lt;class... A&gt;\nstruct tuple_indexator&lt;tuple&lt;A...&gt;&gt; {\n    using type = typename tuple_indexator&lt;std::make_index_sequence&lt;sizeof...(A)&gt;&gt;::type;\n    using sequence = typename tuple_indexator&lt;std::make_index_sequence&lt;sizeof...(A)&gt;&gt;::sequence;\n};\n\n} // namespace detail\n\ntemplate &lt;class T&gt;\nusing  indexator_for = typename detail::tuple_indexator&lt;T&gt;::type;\n\n\n\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/type__info_8hpp/","title":"File type_info.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; type_info.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;boost/type_index.hpp&gt;</code></li> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/type__info_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/type__info_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/type_info.hpp</code></p>"},{"location":"CxxRef/type__info_8hpp_source/","title":"File type_info.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; type_info.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_TYPE_INFO_HPP_\n#define ZMBT_CORE_TYPE_INFO_HPP_\n\n\n#include &lt;type_traits&gt;\n#include &lt;boost/type_index.hpp&gt;\n\n\n#include \"aliases.hpp\"\n\nnamespace zmbt {\n\n\ntemplate &lt;class T&gt;\ninline std::string type_name()\n{\n    return boost::typeindex::type_id_with_cvr&lt;T&gt;().pretty_name();\n}\n\ntemplate &lt;class T&gt;\ninline std::string type_name(T)\n{\n    return type_name&lt;T&gt;();\n}\n\n\n}  // namespace zmbt\n\n#endif  // ZMBT_CORE_TYPE_INFO_HPP_\n</code></pre>"},{"location":"CxxRef/type__tag_8hpp/","title":"File type_tag.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; type_tag.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"aliases.hpp\"</code></li> </ul>"},{"location":"CxxRef/type__tag_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/type__tag_8hpp/#classes","title":"Classes","text":"Type Name struct type_tag &lt;class T&gt;Type tag to pass template parameters as function arguments."},{"location":"CxxRef/type__tag_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/core/type_tag.hpp</code></p>"},{"location":"CxxRef/type__tag_8hpp_source/","title":"File type_tag.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; core &gt; type_tag.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_TYPE_TAG_HPP_\n#define ZMBT_CORE_TYPE_TAG_HPP_\n\n#include \"aliases.hpp\"\n\nnamespace zmbt {\n\ntemplate &lt;class T&gt;\nstruct type_tag {\n    using type = T;\n};\n\ntemplate &lt;class T = void&gt;\nconstexpr type_tag&lt;T&gt; const type{};\n\ntemplate &lt;class T&gt;\nusing is_type_tag = mp_similar&lt;decay_t&lt;T&gt;, type_tag&lt;void&gt;&gt;;\n\n\n\n}  // namespace zmbt\n\n#endif  // ZMBT_CORE_TYPE_TAG_HPP_\n</code></pre>"},{"location":"CxxRef/dir_23db209f70f961198fdaea8adff9f278/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; decor</p>"},{"location":"CxxRef/dir_23db209f70f961198fdaea8adff9f278/#files","title":"Files","text":"Type Name file precise_real.hpp file underlying.hpp <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/</code></p>"},{"location":"CxxRef/precise__real_8hpp/","title":"File precise_real.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; decor &gt; precise_real.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> </ul>"},{"location":"CxxRef/precise__real_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace decor Signal type decorators API. namespace reflect Reflection metafunctions."},{"location":"CxxRef/precise__real_8hpp/#classes","title":"Classes","text":"Type Name struct precise &lt;class VT&gt;Type decorator for floating point numbers. Throws on precision loss in runtime. struct precision_loss_error Exception thrown by decor::precise ."},{"location":"CxxRef/precise__real_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/precise_real.hpp</code></p>"},{"location":"CxxRef/precise__real_8hpp_source/","title":"File precise_real.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; decor &gt; precise_real.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_DECORATOR_PRECISE_REAL_HPP_\n#define ZMBT_DECORATOR_PRECISE_REAL_HPP_\n\n#include &lt;cstdlib&gt;\n#include &lt;cmath&gt;\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/reflect.hpp\"\n\n\nnamespace zmbt {\n\nnamespace decor {\nstruct precision_loss_error : public std::runtime_error {\n    using std::runtime_error::runtime_error;\n};\n\n\nnamespace detail {\n\n\n\ntemplate&lt;class T&gt;\nT strto (boost::json::string_view, boost::json::string_view::pointer*);\n\ntemplate&lt;&gt;\ninline float strto&lt;float&gt;(boost::json::string_view str, boost::json::string_view::pointer* end)\n{\n    return std::strtof(str.cbegin(), end);\n}\n\ntemplate&lt;&gt;\ninline double strto&lt;double&gt;(boost::json::string_view str, boost::json::string_view::pointer* end)\n{\n    return std::strtod(str.cbegin(), end);\n}\ntemplate&lt;&gt;\ninline long double strto&lt;long double&gt;(boost::json::string_view str, boost::json::string_view::pointer* end)\n{\n    return std::strtold(str.cbegin(), end);\n}\n\n} // namespace detail\n\n\ntemplate &lt;class VT&gt;\nstruct precise\n{\n    // TODO: document the decoration API\n    using decorated_type = VT;\n\n    static_assert(std::is_floating_point&lt;decorated_type&gt;::value, \"template paremeter is not a floating number type\");\n\n\n    ~precise() = default;\n\n    precise() : value_ {0} {}\n    precise(precise const&amp;) = default;\n    precise(precise &amp;&amp;) = default;\n    precise&amp; operator=(precise const&amp;) = default;\n    precise&amp; operator=(precise &amp;&amp;) = default;\n\n\n  private:\n\n    template &lt;class T&gt;\n    static decorated_type validate(T init_value)\n    {\n        decorated_type value = static_cast&lt;decorated_type&gt;(init_value);\n        if (std::isnormal(init_value) and (T {value} !=  init_value)) {\n            throw_exception(precision_loss_error(\"precision loss when creating zmbt::decor::precise&lt;T&gt;\"));\n        }\n        return value;\n    }\n\n    template &lt;class T&gt;\n    static decorated_type validate_str_as(boost::json::string_view str)\n    {\n        char* end {nullptr};\n\n        auto const value_as_t = detail::strto&lt;T&gt;(str, &amp;end);\n\n        if (end == str.cbegin() ) {\n            throw_exception(std::invalid_argument(\"zmbt::decor::precise&lt;T&gt; string parsing error\"));\n        }\n\n        // test reverse\n        if (std::isnormal(value_as_t) and (value_as_t != detail::strto&lt;decorated_type&gt;(str, nullptr))) {\n            throw_exception(precision_loss_error(\"precision loss when creating zmbt::decor::precise&lt;T&gt;\"));\n        }\n\n        return validate(value_as_t);\n    }\n\n\n    static decorated_type validate_str(boost::json::string_view str)\n    {\n        // hex notation shall be precise\n        if (0 == (std::strncmp(str.cbegin(), \"0x\", 2) &amp; std::strncmp(str.cbegin(), \"0X\", 2)))\n        {\n            return validate_str_as&lt;long double&gt;(str);\n        }\n        else if (auto const N = str.size())\n        {\n            switch (str[N-1])\n            {\n                case 'f':\n                case 'F':\n                    return validate_str_as&lt;float&gt;(str);\n                    break;\n                case 'l':\n                case 'L':\n                    return validate_str_as&lt;long double&gt;(str);\n                    break;\n                default:\n                    return validate_str_as&lt;double&gt;(str);\n                    break;\n            }\n        }\n        else {\n            throw_exception(std::invalid_argument(\"zmbt::decor::precise&lt;T&gt; string parsing error\"));\n            return {};\n        }\n    }\n\n  public:\n\n    explicit precise(decorated_type v) : value_{v} {}\n\n    template&lt;class T, class = std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;&gt;\n    precise(T const v) : value_{validate(v)}\n    {\n    }\n\n    template &lt;class T , class = std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;&gt;\n    precise&amp; operator=(T const v)\n    {\n        value_ = validate(v);\n        return *this;\n    }\n\n\n    template&lt;class T&gt;\n    precise(precise&lt;T&gt; other) : value_{validate(other.value())}\n    {\n    }\n\n    template &lt;class T&gt;\n    precise&amp; operator=(precise&lt;T&gt; other)\n    {\n        value_ = validate(other.value());\n        return *this;\n    }\n\n    precise(boost::json::string_view str) : value_{validate_str(str)}\n    {\n    }\n\n    precise&amp; operator=(boost::json::string_view str)\n    {\n        value_ = validate_str(str);\n        return *this;\n    }\n\n    decorated_type value() const\n    {\n        return value_;\n    }\n\n    bool operator&lt;(precise other) const\n    {\n        return value() &lt; other.value();\n    }\n\n    bool operator&lt;(boost::json::string_view str) const\n    {\n        return value() &lt; validate_str(str);\n    }\n\n    bool operator==(precise other) const\n    {\n        return value() == other.value();\n    }\n\n    bool operator==(boost::json::string_view str) const\n    {\n        return value() == validate_str(str);\n    }\n\n\n    operator decorated_type() const\n    {\n        return value();\n    }\n\n    std::string stringify() const\n    {\n        char buff[256] {};\n        std::snprintf(buff, 256, \"%a\", value());\n        return std::string(buff);\n    }\n\n  private:\n    decorated_type value_;\n};\n\ntemplate &lt;class T&gt;\nconstexpr zmbt::type_tag&lt;precise&lt;T&gt;&gt; Precise;\n\n} // namespace decor\n\nnamespace reflect {\n\ntemplate &lt;class T&gt;\nstruct custom_serialization&lt;decor::precise&lt;T&gt;&gt; {\n\n\n    static boost::json::value json_from(decor::precise&lt;T&gt; const t)\n    {\n        return t.stringify().c_str();\n    }\n\n    static decor::precise&lt;T&gt;\n    dejsonize(boost::json::value const&amp; v)\n    {\n        decor::precise&lt;T&gt; result;\n        switch (v.kind()) {\n            case boost::json::kind::string:\n                result = v.get_string().data();\n                break;\n            case boost::json::kind::double_:\n                result = v.get_double();\n                break;\n            case boost::json::kind::int64:\n                result = v.get_int64();\n                break;\n            case boost::json::kind::uint64:\n                result = v.get_uint64();\n                break;\n            default:\n                throw_exception(std::invalid_argument(\"zmbt::decor::precise&lt;T&gt; conversion failure\"));\n                break;\n        }\n        return result;\n    }\n\n};\n\n\n} // namespace reflect\n} // namespace zmbt\n\n#endif  // ZMBT_MAPPING_PRECISE_REAL_HPP_\n</code></pre>"},{"location":"CxxRef/underlying_8hpp/","title":"File underlying.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; decor &gt; underlying.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> </ul>"},{"location":"CxxRef/underlying_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace decor Signal type decorators API. namespace reflect Reflection metafunctions."},{"location":"CxxRef/underlying_8hpp/#classes","title":"Classes","text":"Type Name struct underlying &lt;class E&gt;"},{"location":"CxxRef/underlying_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/decor/underlying.hpp</code></p>"},{"location":"CxxRef/underlying_8hpp_source/","title":"File underlying.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; decor &gt; underlying.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_DECORATOR_UNDERLYING_HPP_\n#define ZMBT_DECORATOR_UNDERLYING_HPP_\n\n#include &lt;type_traits&gt;\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/reflect.hpp\"\n\n\nnamespace zmbt {\n\nnamespace decor {\n\n\n\ntemplate &lt;class E&gt;\nstruct underlying\n{\n    static_assert(std::is_enum&lt;E&gt;::value, \"\");\n    using decorated_type = std::underlying_type_t&lt;E&gt;;\n\n\n    ~underlying() = default;\n    underlying() = default;\n    underlying(underlying const&amp;) = default;\n    underlying(underlying &amp;&amp;) = default;\n    underlying&amp; operator=(underlying const&amp;) = default;\n    underlying&amp; operator=(underlying &amp;&amp;) = default;\n\n\n    underlying(decorated_type const v) : value_{v} {}\n    underlying&amp; operator=(decorated_type const v) { value_ = v; return *this; }\n\n    underlying(E const v) : value_{static_cast&lt;decorated_type&gt;(v)} {}\n    underlying&amp; operator=(E const v) { value_ = static_cast&lt;decorated_type&gt;(v); return *this; }\n\n\n    underlying(boost::json::string_view v) : value_{static_cast&lt;decorated_type&gt;(dejsonize&lt;E&gt;(v))} {}\n    underlying&amp; operator=(boost::json::string_view v) { value_ = static_cast&lt;decorated_type&gt;(dejsonize&lt;E&gt;(v)); return *this; }\n\n\n    decorated_type value() const\n    {\n        return value_;\n    }\n\n    std::string stringify() const\n    {\n        return json_from(static_cast&lt;E&gt;(value())).as_string().c_str();\n    }\n\n    operator decorated_type() const\n    {\n        return value();\n    }\n\n    auto operator!()  const { return !value(); }\n    auto operator~()  const { return ~value(); }\n    auto operator-()  const { return -value(); }\n\n    template &lt;class T&gt; auto operator==(T const&amp; other) const { return value() == other; }\n    template &lt;class T&gt; auto operator!=(T const&amp; other) const { return value() != other; }\n    template &lt;class T&gt; auto operator&gt;&gt;(T const&amp; other) const { return value() &gt;&gt; other; }\n    template &lt;class T&gt; auto operator&lt;&lt;(T const&amp; other) const { return value() &lt;&lt; other; }\n    template &lt;class T&gt; auto operator&lt;=(T const&amp; other) const { return value() &lt;= other; }\n    template &lt;class T&gt; auto operator&gt;=(T const&amp; other) const { return value() &gt;= other; }\n    template &lt;class T&gt; auto operator&lt;(T const&amp; other)  const { return value() &lt;  other; }\n    template &lt;class T&gt; auto operator&gt;(T const&amp; other)  const { return value() &gt;  other; }\n    template &lt;class T&gt; auto operator+(T const&amp; other)  const { return value() +  other; }\n    template &lt;class T&gt; auto operator-(T const&amp; other)  const { return value() -  other; }\n    template &lt;class T&gt; auto operator*(T const&amp; other)  const { return value() *  other; }\n    template &lt;class T&gt; auto operator/(T const&amp; other)  const { return value() /  other; }\n    template &lt;class T&gt; auto operator%(T const&amp; other)  const { return value() %  other; }\n    template &lt;class T&gt; auto operator&amp;(T const&amp; other)  const { return value() &amp;  other; }\n    template &lt;class T&gt; auto operator|(T const&amp; other)  const { return value() |  other; }\n    template &lt;class T&gt; auto operator^(T const&amp; other)  const { return value() ^  other; }\n    template &lt;class T&gt; auto operator&amp;&amp;(T const&amp; other) const { return value() &amp;&amp; other; }\n    template &lt;class T&gt; auto operator||(T const&amp; other) const { return value() || other; }\n\nprivate:\n    decorated_type value_;\n};\n\n\ntemplate &lt;class T&gt;\nconstexpr zmbt::type_tag&lt;underlying&lt;T&gt;&gt; Underlying;\n\n} // namespace decor\n\nnamespace reflect {\n\ntemplate &lt;class T&gt;\nstruct custom_serialization&lt;decor::underlying&lt;T&gt;&gt; {\n\n\n    static boost::json::value json_from(decor::underlying&lt;T&gt; const t)\n    {\n        boost::json::value v;\n        v.emplace_string() = t.stringify();\n        return v;\n    }\n\n    static decor::underlying&lt;T&gt;\n    dejsonize(boost::json::value const&amp; v)\n    {\n        decor::underlying&lt;T&gt; result;\n        switch (v.kind()) {\n            case boost::json::kind::string:\n                result = v.get_string().data();\n                break;\n            case boost::json::kind::int64:\n                result = v.get_int64();\n                break;\n            case boost::json::kind::uint64:\n                result = v.get_uint64();\n                break;\n            default:\n                throw_exception(zmbt::serialization_error(\"can't construct zmbt::decor::underlying&lt;T&gt; from `%s`\", v));\n                break;\n        }\n        return result;\n    }\n\n};\n\n} // namespace reflect\n} // namespace zmbt\n\n#endif  // ZMBT_DECORATOR_UNDERLYING_HPP_\n</code></pre>"},{"location":"CxxRef/dir_5ca6873c4d246ae1a35f5fe5ff3edd5d/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr</p>"},{"location":"CxxRef/dir_5ca6873c4d246ae1a35f5fe5ff3edd5d/#files","title":"Files","text":"Type Name file api.hpp file api_signatures.hpp file attributes.hpp file encoding.hpp file eval_context.hpp file eval_impl.hpp file eval_impl_pp.hpp file eval_log.hpp file eval_params.hpp file eval_validator.hpp file expression.hpp file expression_grammar.hpp file keyword.hpp file keyword_grammar.hpp file keyword_info.hpp file lazy_param.hpp file operator.hpp file subexpression.hpp <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/</code></p>"},{"location":"CxxRef/expr_2api_8hpp/","title":"File api.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; api.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"api_signatures.hpp\"</code></li> </ul>"},{"location":"CxxRef/expr_2api_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace expr Expression Language API."},{"location":"CxxRef/expr_2api_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024-2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0</p> <p>Autogenerated file - do not change!</p> <p>app: codegen.expr template: codegen/expr/templates/zmbt-framework/backends/cxx/include/zmbt/expr/api.hpp</p> <p>How to update: * Update the template * Run <code>python -m codegen</code> in the project root * Commit changes </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api.hpp</code></p>"},{"location":"CxxRef/expr_2api_8hpp_source/","title":"File api.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; api.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_EXPRESSION_API_HPP_\n#define ZMBT_EXPR_EXPRESSION_API_HPP_\n\n#include \"api_signatures.hpp\"\n\nnamespace zmbt {\nnamespace expr {\n\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::Noop&gt; const Noop;\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::Noop&gt; const _;\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::Null&gt; const Null;\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::True&gt; const True;\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::False&gt; const False;\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::Pi&gt; const Pi;\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::E&gt; const E;\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::Inf&gt; const Inf;\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::Eps&gt; const Eps;\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::NaN&gt; const NaN;\n\nextern lang::SignatureConst&lt;::zmbt::lang::Keyword::Thread&gt; const Thread;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sin&gt; const Sin;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Cos&gt; const Cos;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Tan&gt; const Tan;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Asin&gt; const Asin;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Acos&gt; const Acos;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Atan&gt; const Atan;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sinh&gt; const Sinh;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Cosh&gt; const Cosh;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Tanh&gt; const Tanh;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Asinh&gt; const Asinh;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Acosh&gt; const Acosh;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Atanh&gt; const Atanh;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Exp&gt; const Exp;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Erf&gt; const Erf;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Erfc&gt; const Erfc;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Gamma&gt; const Gamma;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Abs&gt; const Abs;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Ceil&gt; const Ceil;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Floor&gt; const Floor;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Round&gt; const Round;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sqrt&gt; const Sqrt;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sign&gt; const Sign;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Neg&gt; const Neg;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Add&gt; const Add;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Sub&gt; const Sub;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Mul&gt; const Mul;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Div&gt; const Div;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Pow&gt; const Pow;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Log&gt; const Log;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Mod&gt; const Mod;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Quot&gt; const Quot;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::BitNot&gt; const BitNot;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::BitAnd&gt; const BitAnd;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::BitOr&gt; const BitOr;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::BitXor&gt; const BitXor;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Lshift&gt; const Lshift;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Rshift&gt; const Rshift;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Eq&gt; const Eq;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ne&gt; const Ne;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Lt&gt; const Lt;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Le&gt; const Le;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Gt&gt; const Gt;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ge&gt; const Ge;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Near&gt; const Near;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Near&gt; const Approx;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Union&gt; const Union;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Intersect&gt; const Intersect;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Diff&gt; const Diff;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::SetEq&gt; const SetEq;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Subset&gt; const Subset;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Superset&gt; const Superset;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::PSubset&gt; const PSubset;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::PSuperset&gt; const PSuperset;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::In&gt; const In;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::NotIn&gt; const NotIn;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ni&gt; const Ni;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Ni&gt; const Contains;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::NotNi&gt; const NotNi;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Bool&gt; const Bool;\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Bool&gt; const Truthy;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Not&gt; const Not;\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Not&gt; const Falsy;\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Not&gt; const Nil;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::And&gt; const And;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Or&gt; const Or;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Id&gt; const Id;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Transp&gt; const Transp;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Cartesian&gt; const Cartesian;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Reverse&gt; const Reverse;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Uniques&gt; const Uniques;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Items&gt; const Items;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Keys&gt; const Keys;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Values&gt; const Values;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Enumerate&gt; const Enumerate;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Flatten&gt; const Flatten;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::ToList&gt; const ToList;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::First&gt; const First;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Last&gt; const Last;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Arange&gt; const Arange;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Parse&gt; const Parse;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Str&gt; const Str;\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Str&gt; const Serialize;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Re&gt; const Re;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Re&gt; const Regex;\n\nextern lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Fmt&gt; const Fmt;\nextern lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Fmt&gt; const Format;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Capitalize&gt; const Capitalize;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::LowerCase&gt; const LowerCase;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::UpperCase&gt; const UpperCase;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Card&gt; const Card;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Size&gt; const Size;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Sum&gt; const Sum;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Prod&gt; const Prod;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Avg&gt; const Avg;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Slide&gt; const Slide;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Stride&gt; const Stride;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Chunks&gt; const Chunks;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Repeat&gt; const Repeat;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Cat&gt; const Cat;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Cat&gt; const Concat;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Push&gt; const Push;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::At&gt; const At;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Del&gt; const Del;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Del&gt; const Delete;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Lookup&gt; const Lookup;\n\nextern lang::SignatureCast const Cast;\nextern lang::SignatureCast const Decorate;\n\nextern lang::SignatureUncast const Uncast;\nextern lang::SignatureUncast const Undecorate;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Fold&gt; const Fold;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Fold&gt; const Reduce;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Map&gt; const Map;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Filter&gt; const Filter;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Count&gt; const Count;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Each&gt; const Each;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Sort&gt; const Sort;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Find&gt; const Find;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::FindPtr&gt; const FindPtr;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::FindIdx&gt; const FindIdx;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Min&gt; const Min;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Max&gt; const Max;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Argmin&gt; const Argmin;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Argmax&gt; const Argmax;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Recur&gt; const Recur;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Unfold&gt; const Unfold;\n\nextern lang::SignatureOp const Op;\nextern lang::SignatureOp const Overload;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Bind&gt; const Bind;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Fn&gt; const Fn;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Link&gt; const Link;\n\nextern lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Any&gt; const Any;\n\nextern lang::SignatureVariadic&lt;::zmbt::lang::Keyword::All&gt; const All;\n\nextern lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Saturate&gt; const Saturate;\n\nextern lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Pipe&gt; const Pipe;\n\nextern lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Tuple&gt; const Tuple;\n\nextern lang::SignatureVariadic&lt;::zmbt::lang::Keyword::Fork&gt; const Fork;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Flip&gt; const Flip;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Dbg&gt; const Dbg;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Dbg&gt; const Debug;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Eval&gt; const Eval;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Try&gt; const Try;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Kwrd&gt; const Kwrd;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Prms&gt; const Prms;\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::Prms&gt; const Parameters;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Q&gt; const Q;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Q&gt; const C;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Q&gt; const Const;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::D&gt; const D;\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::D&gt; const Default;\n\nextern lang::SignatureErr const Err;\nextern lang::SignatureErr const Error;\n\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::IsErr&gt; const IsErr;\nextern lang::SignatureUnary&lt;::zmbt::lang::Keyword::IsErr&gt; const Iserror;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Assert&gt; const Assert;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::Trace&gt; const Trace;\n\nextern lang::SignatureBinary&lt;::zmbt::lang::Keyword::PreProc&gt; const PreProc;\n\n} // namespace expr\n} // namespace zmbt\n\n#endif // ZMBT_MAPPING_EXPRESSION_HPP_\n</code></pre>"},{"location":"CxxRef/api__signatures_8hpp/","title":"File api_signatures.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; api_signatures.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;initializer_list&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"zmbt/reflect/serialization.hpp\"</code></li> <li><code>#include \"keyword.hpp\"</code></li> <li><code>#include \"expression.hpp\"</code></li> </ul>"},{"location":"CxxRef/api__signatures_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/api__signatures_8hpp/#classes","title":"Classes","text":"Type Name struct SignatureBase &lt;K&gt; struct SignatureBinary &lt;K&gt;Binary expression. struct SignatureBinary&lt; Keyword::PreProc &gt; &lt;&gt; struct SignatureCast struct SignatureConst &lt;K&gt;Const expression. struct SignatureErr struct SignatureOp struct SignatureUnary &lt;K&gt;Unary expression. struct SignatureUncast struct SignatureVariadic &lt;K&gt;Variadic expression."},{"location":"CxxRef/api__signatures_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024-2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api_signatures.hpp</code></p>"},{"location":"CxxRef/api__signatures_8hpp_source/","title":"File api_signatures.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; api_signatures.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_EXPRESSION_API_SIGNATURES_HPP_\n#define ZMBT_EXPR_EXPRESSION_API_SIGNATURES_HPP_\n\n#include &lt;cstddef&gt;\n#include &lt;initializer_list&gt;\n#include &lt;boost/json.hpp&gt;\n#include \"zmbt/reflect/serialization.hpp\"\n#include \"keyword.hpp\"\n#include \"expression.hpp\"\n\n\n\nnamespace zmbt {\nnamespace lang {\nnamespace detail {\n    boost::json::value handle_list_init(std::initializer_list&lt;Expression&gt; set);\n}\n\ntemplate &lt;Keyword K&gt;\nstruct SignatureBase : public Expression\n{\n    SignatureBase() : Expression(encodeNested(K, {}))\n    {}\n\n    operator boost::json::value() const // allowing implicit on expr::*\n    {\n        return Expression::operator boost::json::value();\n    }\n};\n\ntemplate &lt;Keyword K&gt;\nstruct SignatureConst : public SignatureBase&lt;K&gt;\n{\n    using SignatureBase&lt;K&gt;::SignatureBase;\n\n};\n\ntemplate &lt;Keyword K&gt;\nstruct SignatureUnary : public SignatureBase&lt;K&gt;\n{\n    using SignatureBase&lt;K&gt;::SignatureBase;\n};\n\ntemplate &lt;Keyword K&gt;\nstruct SignatureBinary : public SignatureBase&lt;K&gt;\n{\n    using SignatureBase&lt;K&gt;::SignatureBase;\n\n    Expression operator()(Expression const&amp; param) const\n    {\n        return Expression(Expression::encodeNested(K, {param}));\n    }\n\n    Expression operator()(Expression &amp;&amp; param) const\n    {\n        return Expression(Expression::encodeNested(K, {std::move(param)}));\n    }\n\n    Expression operator()(std::initializer_list&lt;Expression&gt; param) const\n    {\n        return Expression(Expression::encodeNested(K, {detail::handle_list_init(param)}));\n    }\n};\n\ntemplate &lt;&gt;\nstruct SignatureBinary&lt;Keyword::PreProc&gt; : public SignatureBase&lt;Keyword::PreProc&gt;\n{\n    using SignatureBase&lt;Keyword::PreProc&gt;::SignatureBase;\n\n    Expression operator()(boost::json::string_view const param) const\n    {\n        return Expression(Expression::encodePreProc(zmbt::format(\"$[%s]\", param).c_str()));\n    }\n\n    Expression operator()(std::size_t const param) const\n    {\n        return Expression(Expression::encodePreProc(zmbt::format(\"$[%s]\", param).c_str()));\n    }\n};\n\n\ntemplate &lt;Keyword K&gt;\nstruct SignatureVariadic : public SignatureBase&lt;K&gt;\n{\n  private:\n    static Expression encodeVariadic(std::initializer_list&lt;zmbt::lang::Expression&gt; params)\n    {\n        return Expression(Expression::encodeNested(K,  params));\n    }\n\n  public:\n    using SignatureBase&lt;K&gt;::SignatureBase;\n\n    using E = Expression;\n    Expression operator()() const {\n        return encodeVariadic({});\n    }\n    Expression operator()(E const&amp; p0) const {\n        return encodeVariadic({p0});\n    }\n    Expression operator()(E const&amp; p0, E const&amp; p1) const {\n        return encodeVariadic({p0, p1});\n    }\n    Expression operator()(E const&amp; p0, E const&amp; p1, E const&amp; p2) const {\n        return encodeVariadic({p0, p1, p2});\n    }\n    Expression operator()(E const&amp; p0, E const&amp; p1, E const&amp; p2, E const&amp; p3) const {\n        return encodeVariadic({p0, p1, p2, p3});\n    }\n    Expression operator()(E const&amp; p0, E const&amp; p1, E const&amp; p2, E const&amp; p3, E const&amp; p4) const {\n        return encodeVariadic({p0, p1, p2, p3, p4});\n    }\n    Expression operator()(E const&amp; p0, E const&amp; p1, E const&amp; p2, E const&amp; p3, E const&amp; p4, E const&amp; p5) const {\n        return encodeVariadic({p0, p1, p2, p3, p4, p5});\n    }\n    Expression operator()(E const&amp; p0, E const&amp; p1, E const&amp; p2, E const&amp; p3, E const&amp; p4, E const&amp; p5, E const&amp; p6) const {\n        return encodeVariadic({p0, p1, p2, p3, p4, p5, p6});\n    }\n    Expression operator()(E const&amp; p0, E const&amp; p1, E const&amp; p2, E const&amp; p3, E const&amp; p4, E const&amp; p5, E const&amp; p6, E const&amp; p7) const {\n        return encodeVariadic({p0, p1, p2, p3, p4, p5, p6, p7});\n    }\n    template &lt;class... T&gt;\n    Expression operator()(E const&amp; p0, E const&amp; p1, E const&amp; p2, E const&amp; p3, E const&amp; p4, E const&amp; p5, E const&amp; p6, E const&amp; p7, T&amp;&amp;... rest) const {\n        return encodeVariadic({p0, p1, p2, p3, p4, p5, p6, p7, zmbt::json_from(rest)...});\n    }\n};\n\n\n\n\nstruct SignatureOp : public SignatureBase&lt;Keyword::Op&gt;\n{\n    using SignatureBase&lt;Keyword::Op&gt;::SignatureBase;\n\n\n    Expression operator()(Expression const&amp; type, Expression const&amp; expr) const\n    {\n        return Expression(Expression::encodeNested(Keyword::Op, {type + expr}));\n    }\n\n    template &lt;class T&gt;\n    Expression operator()(type_tag&lt;T&gt; tag, Expression const&amp; expr) const\n    {\n        Operator const op{tag};\n        return Expression(Expression::encodeNested(Keyword::Op, {op.annotation() + expr}));\n    }\n};\n\nstruct SignatureCast : public SignatureBinary&lt;Keyword::Cast&gt;\n{\n    using SignatureBinary&lt;Keyword::Cast&gt;::SignatureBinary;\n    using SignatureBinary&lt;Keyword::Cast&gt;::operator();\n\n\n    template &lt;class T&gt;\n    Expression operator()(type_tag&lt;T&gt; tag) const\n    {\n        Operator const op{tag};\n        return Expression(Expression::encodeNested(Keyword::Cast, {op.annotation()}));\n    }\n};\n\nstruct SignatureUncast : public SignatureBinary&lt;Keyword::Uncast&gt;\n{\n    using SignatureBinary&lt;Keyword::Uncast&gt;::SignatureBinary;\n    using SignatureBinary&lt;Keyword::Uncast&gt;::operator();\n\n    template &lt;class T&gt;\n    Expression operator()(type_tag&lt;T&gt; tag) const\n    {\n        Operator const op{tag};\n        return Expression(Expression::encodeNested(Keyword::Uncast, {op.annotation()}));\n    }\n};\n\nstruct SignatureErr : public SignatureBase&lt;Keyword::Err&gt;\n{\n    using SignatureBase&lt;Keyword::Err&gt;::SignatureBase;\n\n    Expression operator()(boost::json::object payload) const\n    {\n        return Expression(Expression::encodeNested(Keyword::Err, {payload}));\n    }\n\n    Expression operator()(boost::json::string_view msg, boost::json::string_view ctx = \"\") const\n    {\n        return make_error(\"\", msg, ctx);\n    }\n\n\n    template &lt;class T&gt;\n    Expression operator()(type_tag&lt;T&gt;, boost::json::string msg = \"\", boost::json::string ctx = \"\") const\n    {\n        static_assert(std::is_base_of&lt;std::exception, T&gt;::value, \"Error type is not supported\");\n        Expression e = make_error(zmbt::type_name&lt;T&gt;(), msg, ctx);\n        make_throw_action(e.error_id(), [msg]{\n            throw T(msg.c_str());\n        });\n        return std::move(e);\n    }\n\n    private:\n        void make_throw_action(std::string const key, std::function&lt;void()&gt; f) const;\n        Expression make_error(boost::json::string_view type, boost::json::string_view msg, boost::json::string_view ctx) const;\n};\n\n\n} // namespace lang\n} // namespace zmbt\n\n#endif // ZMBT_EXPR_EXPRESSION_API_SIGNATURES_HPP_\n</code></pre>"},{"location":"CxxRef/attributes_8hpp/","title":"File attributes.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; attributes.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"zmbt/expr/keyword.hpp\"</code></li> </ul>"},{"location":"CxxRef/attributes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation. namespace attr"},{"location":"CxxRef/attributes_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024-2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0</p> <p>Autogenerated file - do not change!</p> <p>app: codegen.expr template: codegen/expr/templates/zmbt-framework/backends/cxx/include/zmbt/expr/keyword.hpp</p> <p>How to update: * Update the template * Run <code>python -m codegen</code> in the project root * Commit changes </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/attributes.hpp</code></p>"},{"location":"CxxRef/attributes_8hpp_source/","title":"File attributes.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; attributes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_KEYWORD_ATTR_HPP_\n#define ZMBT_EXPR_KEYWORD_ATTR_HPP_\n\n#include &lt;cstdint&gt;\n#include \"zmbt/expr/keyword.hpp\"\n\nnamespace zmbt {\nnamespace lang {\n\n\nnamespace attr\n{\nconstexpr std::uint32_t is_const       = 1 &lt;&lt;  1;\nconstexpr std::uint32_t is_unary       = 1 &lt;&lt;  2;\nconstexpr std::uint32_t is_binary      = 1 &lt;&lt;  3;\nconstexpr std::uint32_t is_variadic    = 1 &lt;&lt;  4;\nconstexpr std::uint32_t is_predicate   = 1 &lt;&lt;  5;\nconstexpr std::uint32_t is_operator    = 1 &lt;&lt;  6;\nconstexpr std::uint32_t is_hiord       = 1 &lt;&lt;  7;\nconstexpr std::uint32_t is_noop        = 1 &lt;&lt;  8;\nconstexpr std::uint32_t is_literal     = 1 &lt;&lt;  9;\nconstexpr std::uint32_t is_quote       = 1 &lt;&lt; 10;\nconstexpr std::uint32_t is_preproc     = 1 &lt;&lt; 11;\nconstexpr std::uint32_t is_error       = 1 &lt;&lt; 12;\nconstexpr std::uint32_t is_pipe        = 1 &lt;&lt; 13;\nconstexpr std::uint32_t is_fork        = 1 &lt;&lt; 14;\nconstexpr std::uint32_t is_overload    = 1 &lt;&lt; 15;\nconstexpr std::uint32_t is_infix_chain = 1 &lt;&lt; 16;\nconstexpr std::uint32_t is_autogen     = 1 &lt;&lt; 17;\n}\n\n\nconstexpr std::uint32_t attributes(Keyword const&amp; k)\n{\n    using namespace attr;\n    switch (k)\n    {\n    case Keyword::Literal: return is_unary | is_literal;\n    case Keyword::Void: return is_unary;\n    case Keyword::LazyToken: return is_unary;\n    case Keyword::Noop: return is_const | is_autogen | is_noop;\n    case Keyword::Null: return is_const | is_autogen;\n    case Keyword::True: return is_const | is_predicate | is_autogen;\n    case Keyword::False: return is_const | is_predicate | is_autogen;\n    case Keyword::Pi: return is_const | is_autogen;\n    case Keyword::E: return is_const | is_autogen;\n    case Keyword::Inf: return is_const | is_autogen;\n    case Keyword::Eps: return is_const | is_autogen;\n    case Keyword::NaN: return is_const | is_autogen;\n    case Keyword::Thread: return is_const | is_autogen;\n    case Keyword::Sin: return is_unary | is_autogen;\n    case Keyword::Cos: return is_unary | is_autogen;\n    case Keyword::Tan: return is_unary | is_autogen;\n    case Keyword::Asin: return is_unary | is_autogen;\n    case Keyword::Acos: return is_unary | is_autogen;\n    case Keyword::Atan: return is_unary | is_autogen;\n    case Keyword::Sinh: return is_unary | is_autogen;\n    case Keyword::Cosh: return is_unary | is_autogen;\n    case Keyword::Tanh: return is_unary | is_autogen;\n    case Keyword::Asinh: return is_unary | is_autogen;\n    case Keyword::Acosh: return is_unary | is_autogen;\n    case Keyword::Atanh: return is_unary | is_autogen;\n    case Keyword::Exp: return is_unary | is_autogen;\n    case Keyword::Erf: return is_unary | is_autogen;\n    case Keyword::Erfc: return is_unary | is_autogen;\n    case Keyword::Gamma: return is_unary | is_autogen;\n    case Keyword::Abs: return is_unary | is_autogen;\n    case Keyword::Ceil: return is_unary | is_autogen;\n    case Keyword::Floor: return is_unary | is_autogen;\n    case Keyword::Round: return is_unary | is_autogen;\n    case Keyword::Sqrt: return is_unary | is_autogen;\n    case Keyword::Sign: return is_unary | is_autogen;\n    case Keyword::Neg: return is_unary | is_operator;\n    case Keyword::Add: return is_binary | is_operator;\n    case Keyword::Sub: return is_binary | is_operator;\n    case Keyword::Mul: return is_binary | is_operator;\n    case Keyword::Div: return is_binary | is_operator;\n    case Keyword::Pow: return is_binary | is_operator;\n    case Keyword::Log: return is_binary | is_operator;\n    case Keyword::Mod: return is_binary | is_operator;\n    case Keyword::Quot: return is_binary | is_operator;\n    case Keyword::BitNot: return is_unary | is_operator;\n    case Keyword::BitAnd: return is_binary | is_operator;\n    case Keyword::BitOr: return is_binary | is_operator;\n    case Keyword::BitXor: return is_binary | is_operator;\n    case Keyword::Lshift: return is_binary | is_operator;\n    case Keyword::Rshift: return is_binary | is_operator;\n    case Keyword::Eq: return is_binary | is_predicate | is_operator;\n    case Keyword::Ne: return is_binary | is_predicate | is_operator;\n    case Keyword::Lt: return is_binary | is_predicate | is_operator;\n    case Keyword::Le: return is_binary | is_predicate | is_operator;\n    case Keyword::Gt: return is_binary | is_predicate | is_operator;\n    case Keyword::Ge: return is_binary | is_predicate | is_operator;\n    case Keyword::Near: return is_binary | is_predicate;\n    case Keyword::Union: return is_binary;\n    case Keyword::Intersect: return is_binary;\n    case Keyword::Diff: return is_binary;\n    case Keyword::SetEq: return is_binary | is_predicate | is_operator;\n    case Keyword::Subset: return is_binary | is_predicate | is_operator;\n    case Keyword::Superset: return is_binary | is_predicate | is_operator;\n    case Keyword::PSubset: return is_binary | is_predicate | is_operator;\n    case Keyword::PSuperset: return is_binary | is_predicate | is_operator;\n    case Keyword::In: return is_binary | is_predicate | is_operator;\n    case Keyword::NotIn: return is_binary | is_predicate | is_operator;\n    case Keyword::Ni: return is_binary | is_predicate | is_operator;\n    case Keyword::NotNi: return is_binary | is_predicate | is_operator;\n    case Keyword::Bool: return is_unary | is_predicate | is_operator;\n    case Keyword::Not: return is_unary | is_predicate | is_operator;\n    case Keyword::And: return is_binary | is_operator;\n    case Keyword::Or: return is_binary | is_operator;\n    case Keyword::Id: return is_unary | is_autogen;\n    case Keyword::Transp: return is_unary;\n    case Keyword::Cartesian: return is_unary;\n    case Keyword::Reverse: return is_unary;\n    case Keyword::Uniques: return is_unary;\n    case Keyword::Items: return is_unary;\n    case Keyword::Keys: return is_unary;\n    case Keyword::Values: return is_unary;\n    case Keyword::Enumerate: return is_unary;\n    case Keyword::Flatten: return is_unary;\n    case Keyword::ToList: return is_unary | is_autogen;\n    case Keyword::First: return is_unary;\n    case Keyword::Last: return is_unary;\n    case Keyword::Arange: return is_unary;\n    case Keyword::Parse: return is_unary | is_autogen;\n    case Keyword::Str: return is_unary | is_autogen;\n    case Keyword::Re: return is_binary | is_predicate;\n    case Keyword::Fmt: return is_variadic;\n    case Keyword::Capitalize: return is_unary;\n    case Keyword::LowerCase: return is_unary;\n    case Keyword::UpperCase: return is_unary;\n    case Keyword::Card: return is_unary;\n    case Keyword::Size: return is_unary;\n    case Keyword::Sum: return is_unary;\n    case Keyword::Prod: return is_unary;\n    case Keyword::Avg: return is_unary;\n    case Keyword::Slide: return is_binary;\n    case Keyword::Stride: return is_binary;\n    case Keyword::Chunks: return is_binary;\n    case Keyword::Repeat: return is_binary;\n    case Keyword::Cat: return is_binary;\n    case Keyword::Push: return is_binary;\n    case Keyword::At: return is_binary;\n    case Keyword::Del: return is_binary;\n    case Keyword::Lookup: return is_binary;\n    case Keyword::Cast: return is_unary;\n    case Keyword::Uncast: return is_unary;\n    case Keyword::Fold: return is_binary | is_hiord;\n    case Keyword::Map: return is_binary | is_hiord;\n    case Keyword::Filter: return is_binary | is_hiord;\n    case Keyword::Count: return is_binary | is_hiord;\n    case Keyword::Each: return is_binary | is_predicate | is_hiord;\n    case Keyword::Sort: return is_binary | is_hiord;\n    case Keyword::Find: return is_binary | is_hiord;\n    case Keyword::FindPtr: return is_binary | is_hiord;\n    case Keyword::FindIdx: return is_binary | is_hiord;\n    case Keyword::Min: return is_binary | is_hiord;\n    case Keyword::Max: return is_binary | is_hiord;\n    case Keyword::Argmin: return is_binary | is_hiord;\n    case Keyword::Argmax: return is_binary | is_hiord;\n    case Keyword::Recur: return is_binary | is_hiord;\n    case Keyword::Unfold: return is_binary | is_hiord;\n    case Keyword::Op: return is_unary | is_hiord | is_overload;\n    case Keyword::Bind: return is_binary | is_hiord;\n    case Keyword::Fn: return is_binary | is_hiord;\n    case Keyword::Link: return is_binary | is_hiord;\n    case Keyword::Any: return is_variadic | is_predicate | is_hiord;\n    case Keyword::All: return is_variadic | is_predicate | is_hiord;\n    case Keyword::Saturate: return is_variadic | is_predicate | is_hiord;\n    case Keyword::Pipe: return is_variadic | is_hiord | is_pipe;\n    case Keyword::Tuple: return is_variadic | is_hiord;\n    case Keyword::Fork: return is_variadic | is_hiord | is_fork;\n    case Keyword::Flip: return is_binary | is_hiord;\n    case Keyword::Dbg: return is_binary | is_hiord;\n    case Keyword::Eval: return is_binary | is_hiord;\n    case Keyword::Try: return is_binary | is_hiord;\n    case Keyword::Kwrd: return is_unary | is_hiord;\n    case Keyword::Prms: return is_unary | is_hiord;\n    case Keyword::Q: return is_binary | is_autogen | is_quote;\n    case Keyword::D: return is_binary | is_autogen;\n    case Keyword::Err: return is_unary | is_autogen | is_error;\n    case Keyword::IsErr: return is_unary | is_autogen;\n    case Keyword::Assert: return is_binary;\n    case Keyword::Trace: return is_binary;\n    case Keyword::PreProc: return is_binary | is_autogen | is_preproc;\n    default:\n        return 0U;\n    }\n}\n\n} // namespace lang\n} // namespace zmbt\n\n\n\n#endif // ZMBT_MODEL_KEYWORD_HPP_\n</code></pre>"},{"location":"CxxRef/encoding_8hpp/","title":"File encoding.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; encoding.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> <li><code>#include \"keyword.hpp\"</code></li> <li><code>#include \"attributes.hpp\"</code></li> <li><code>#include \"keyword_grammar.hpp\"</code></li> </ul>"},{"location":"CxxRef/encoding_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/encoding_8hpp/#classes","title":"Classes","text":"Type Name struct Encoding class EncodingView struct ExprRow class Iterator struct custom_serialization&lt; lang::Encoding &gt; &lt;&gt;"},{"location":"CxxRef/encoding_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/encoding.hpp</code></p>"},{"location":"CxxRef/encoding_8hpp_source/","title":"File encoding.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; encoding.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_ENCODING_HPP_\n#define ZMBT_EXPR_ENCODING_HPP_\n\n#include &lt;algorithm&gt;\n#include &lt;list&gt;\n#include &lt;ostream&gt;\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/reflect.hpp\"\n#include \"keyword.hpp\"\n#include \"attributes.hpp\"\n#include \"keyword_grammar.hpp\"\n\n\nnamespace zmbt {\nnamespace lang {\n\nstruct Encoding\n{\n    using K = Keyword;\n    using V = boost::json::value;\n    std::vector&lt;K&gt; keywords;\n    std::vector&lt;std::size_t&gt; depth;\n    std::vector&lt;V&gt; data;\n\n    static bool is_preproc_token(boost::json::value const&amp; value);\n    static bool is_link_token(boost::json::value const&amp; value);\n\n    Encoding() = default;\n    explicit Encoding(boost::json::value const&amp; value);\n    explicit Encoding(boost::json::value &amp;&amp; value);\n\n    std::size_t size() const;\n\n    bool operator==(Encoding const&amp; o) const;\n\n    bool operator!=(Encoding const&amp; o) const;\n\n\n    void push_back(K const&amp; k, std::size_t const d, V const&amp; v);\n    void push_back(K const&amp; k, std::size_t const d, V &amp;&amp; v);\n\n    void append_to_root(Encoding const&amp; tail);\n    void append_to_root(Encoding&amp;&amp; tail);\n\n    bool preprocess();\n};\n\n\n\n\nclass EncodingView {\npublic:\n    using K = Keyword;\n    using V = boost::json::value;\n\n    struct ExprRow {\n        K keyword;\n        std::size_t depth;\n        V const* data;\n        std::size_t index;\n    };\n\n    class Iterator {\n    public:\n        using iterator_category = std::random_access_iterator_tag;\n        using value_type        = ExprRow;\n        using difference_type   = std::ptrdiff_t;\n        using pointer           = void;\n        using reference         = ExprRow;\n\n        Iterator(K const* k, std::size_t const* d, V const* v, std::size_t index, std::size_t offset)\n            : k_(k)\n            , d_(d)\n            , v_(v)\n            , i_(index)\n            , index_offset_(offset)\n        {\n        }\n\n        reference operator*() const {\n            return {k_[i_], d_[i_] - d_[0], &amp;v_[i_], i_ + index_offset_};\n        }\n\n        Iterator&amp; operator++() { ++i_; return *this; }\n        Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\n        Iterator&amp; operator--() { --i_; return *this; }\n        Iterator operator--(int) { Iterator tmp = *this; --(*this); return tmp; }\n\n        Iterator&amp; operator+=(difference_type n) { i_ += n; return *this; }\n        Iterator&amp; operator-=(difference_type n) { i_ -= n; return *this; }\n\n        reference operator[](difference_type n) const { return *(*this + n); }\n\n        Iterator operator+(difference_type n) const { return Iterator{k_, d_, v_, i_ + n, index_offset_}; }\n        Iterator operator-(difference_type n) const { return Iterator{k_, d_, v_, i_ - n, index_offset_}; }\n\n        difference_type operator-(Iterator const&amp; other) const { return i_ - other.i_; }\n\n        bool operator==(Iterator const&amp; other) const { return i_ == other.i_; }\n        bool operator!=(Iterator const&amp; other) const { return !(*this == other); }\n        bool operator&lt;(Iterator const&amp; other) const  { return i_ &lt; other.i_; }\n        bool operator&lt;=(Iterator const&amp; other) const { return i_ &lt;= other.i_; }\n        bool operator&gt;(Iterator const&amp; other) const  { return i_ &gt; other.i_; }\n        bool operator&gt;=(Iterator const&amp; other) const { return i_ &gt;= other.i_; }\n\n    private:\n        K const* k_;\n        std::size_t const* d_;\n        V const* v_;\n        std::size_t index_offset_;\n        std::size_t i_;\n    };\n\n    using       iterator = Iterator;\n    using const_iterator = Iterator;\n    using       reverse_iterator = std::reverse_iterator&lt;      iterator&gt;;\n    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;\n\n    const_iterator begin()  const { return {keywords_, depth_, data_, 0    , index_offset_}; }\n    const_iterator end()    const { return {keywords_, depth_, data_, size_, index_offset_}; }\n    const_iterator cbegin() const { return begin(); }\n    const_iterator cend()   const { return end(); }\n\n    const_reverse_iterator rbegin()  const { return const_reverse_iterator{end()}; }\n    const_reverse_iterator rend()    const { return const_reverse_iterator{begin()}; }\n    const_reverse_iterator crbegin() const { return rbegin(); }\n    const_reverse_iterator crend()   const { return rend(); }\n\n    EncodingView(Encoding&amp;&amp; root) = delete;\n\n    EncodingView() = default;\n\n\n    EncodingView(K const* k, std::size_t const* d, V const* v,\n                 std::size_t sz, std::size_t index_offset);\n\n    EncodingView(Encoding const&amp; root);\n\n    std::size_t size() const;\n    bool empty() const;\n\n    std::size_t index_offset() const;\n    std::size_t depth_offset() const;\n\n\n    ExprRow front() const;\n    ExprRow back() const;\n\n    ExprRow at(std::size_t i) const;\n\n\n    ExprRow operator[](std::size_t i) const\n    {\n        return at(i);\n    }\n\n    bool operator==(EncodingView const&amp; o) const;\n\n    bool operator!=(EncodingView const&amp; o) const;\n\n    Encoding freeze() const;\n\n    boost::json::value to_json() const;\n\n    EncodingView slice(std::size_t start, std::size_t count) const noexcept;\n\n    EncodingView subtree(std::size_t const node) const noexcept;\n\n    EncodingView traverse_subtrees(std::size_t const node, std::size_t&amp; next) const noexcept;\n\n    std::list&lt;EncodingView&gt; children() const;\n\n    std::size_t arity() const;\n\n    Keyword head() const noexcept;\n\n    std::size_t child_idx(int ord) const noexcept;\n\n    EncodingView child(int ord) const noexcept;\n\n    bool is_const() const;\n    bool is_boolean() const;\n\n    K const*  if_keywords() const { return keywords_; }\n    std::size_t const* if_depth() const { return depth_; }\n    V const* if_data() const { return data_; }\n\nprivate:\n\n    K const* keywords_ = nullptr;\n    std::size_t const* depth_ = nullptr;\n    V const* data_ = nullptr;\n    std::size_t size_ = 0U;\n    std::size_t index_offset_ = 0U;\n};\n\n\n}  // namespace lang\n\n\ntemplate&lt;&gt;\nstruct reflect::custom_serialization&lt;lang::Encoding&gt;\n{\n\n    static boost::json::value\n    json_from(lang::Encoding const&amp; enc);\n\n    static lang::Encoding\n    dejsonize(boost::json::value const&amp; v);\n};\n\nZMBT_INJECT_SERIALIZATION\n\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/eval__context_8hpp/","title":"File eval_context.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_context.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"operator.hpp\"</code></li> <li><code>#include \"eval_log.hpp\"</code></li> </ul>"},{"location":"CxxRef/eval__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/eval__context_8hpp/#classes","title":"Classes","text":"Type Name struct EvalContext Expression evaluation context."},{"location":"CxxRef/eval__context_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_context.hpp</code></p>"},{"location":"CxxRef/eval__context_8hpp_source/","title":"File eval_context.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_EVAL_CONTEXT_HPP_\n#define ZMBT_EXPR_EVAL_CONTEXT_HPP_\n\n#include &lt;memory&gt;\n#include &lt;boost/json.hpp&gt;\n\n#include \"operator.hpp\"\n#include \"eval_log.hpp\"\n\n\n\nnamespace zmbt {\nnamespace lang {\n\nclass ExpressionView;\nstruct EvalContext\n{\n    static EvalContext make(Operator const&amp; op = {});\n    Operator op;\n    EvalLog log;\n    std::shared_ptr&lt;boost::json::object&gt; captures;\n    std::shared_ptr&lt;std::map&lt;boost::json::string, ExpressionView&gt;&gt; links;\n    // boost::json::object captures;\n    std::uint64_t depth;\n\n    EvalContext();\n\n    EvalContext operator++() const;\n};\n\n}  // namespace lang\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/eval__impl_8hpp/","title":"File eval_impl.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_impl.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"expression.hpp\"</code></li> <li><code>#include \"eval_context.hpp\"</code></li> <li><code>#include \"eval_params.hpp\"</code></li> <li><code>#include \"eval_validator.hpp\"</code></li> <li><code>#include \"keyword.hpp\"</code></li> <li><code>#include \"keyword_info.hpp\"</code></li> </ul>"},{"location":"CxxRef/eval__impl_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/eval__impl_8hpp/#classes","title":"Classes","text":"Type Name class EvalImplBase &lt;K, class Validator&gt;"},{"location":"CxxRef/eval__impl_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024-2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0</p> <p>Autogenerated file - do not change!</p> <p>app: codegen.expr template: codegen/expr/templates/zmbt-framework/backends/cxx/include/zmbt/expr/eval_impl.hpp</p> <p>How to update: * Update the template * Run <code>python -m codegen</code> in the project root * Commit changes </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_impl.hpp</code></p>"},{"location":"CxxRef/eval__impl_8hpp_source/","title":"File eval_impl.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_impl.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_EVAL_IMPL_HPP_\n#define ZMBT_EXPR_EVAL_IMPL_HPP_\n\n\n#include \"expression.hpp\"\n#include \"eval_context.hpp\"\n#include \"eval_params.hpp\"\n#include \"eval_validator.hpp\"\n#include \"keyword.hpp\"\n#include \"keyword_info.hpp\"\n\nnamespace zmbt {\nnamespace lang {\n\ntemplate &lt;Keyword K&gt;\nstruct EvalImpl; // specializations shall use CRTP : public EvalImplBase&lt;K&gt;\n// {\n    // Expression impl() const;\n// };\n\n\ntemplate &lt;Keyword K, class Validator = EvalValidator&lt;K&gt;&gt;\nclass EvalImplBase : public FixedEvalParams&lt;K&gt;\n{\n    EvalContext curr_ctx_;\n  public:\n\n    EvalContext curr_ctx() const { return curr_ctx_; }\n\n    EvalImplBase(ExpressionView const&amp; e, ExpressionView const&amp; x, EvalContext ctx)\n        : FixedEvalParams&lt;K&gt;(e, x, ctx)\n        , curr_ctx_{++ctx}\n    {\n    }\n\n    Expression operator()() &amp;&amp;\n    {\n        auto const v = Validator{this-&gt;lhs(), this-&gt;rhs()};\n        if (v.is_invalid()) return v.status();\n\n        auto ctx = this-&gt;context();\n        auto const result = static_cast&lt;EvalImpl&lt;K&gt; const*&gt;(this)-&gt;impl();\n        ctx.log.push(this-&gt;self(), this-&gt;x(), result, ctx.depth);\n        return result;\n    }\n};\n\ntemplate &lt;Keyword K&gt;\nExpression dispatch_eval(ExpressionView const&amp; self, ExpressionView const&amp; x, EvalContext context);\n\n\n}  // namespace lang\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/eval__impl__pp_8hpp/","title":"File eval_impl_pp.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_impl_pp.hpp</p> <p>Go to the source code of this file</p>"},{"location":"CxxRef/eval__impl__pp_8hpp/#macros","title":"Macros","text":"Type Name define ASSERT (cond, msg) <code>if (!(cond)) { return ::zmbt::lang::detail::make\\_error\\_expr(msg, keyword\\_to\\_str());}</code> define ZMBT_DEFINE_EVALUATE_IMPL (K) <code>/* multi line expression */</code>"},{"location":"CxxRef/eval__impl__pp_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/eval__impl__pp_8hpp/#define-assert","title":"define ASSERT","text":"<pre><code>#define ASSERT (\n    cond,\n    msg\n) `if (!(cond)) { return ::zmbt::lang::detail::make_error_expr(msg, keyword_to_str());}`\n</code></pre>"},{"location":"CxxRef/eval__impl__pp_8hpp/#define-zmbt_define_evaluate_impl","title":"define ZMBT_DEFINE_EVALUATE_IMPL","text":"<pre><code>#define ZMBT_DEFINE_EVALUATE_IMPL (\n    K\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_impl_pp.hpp</code></p>"},{"location":"CxxRef/eval__impl__pp_8hpp_source/","title":"File eval_impl_pp.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_impl_pp.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#define ZMBT_DEFINE_EVALUATE_IMPL(K)                                            \\\ntemplate &lt;&gt; struct EvalImpl&lt;Keyword::K&gt;                                         \\\n    : public EvalImplBase&lt;Keyword::K&gt;                                           \\\n{                                                                               \\\n    using EvalImplBase&lt;Keyword::K&gt;::EvalImplBase;                               \\\n    using EvalImplBase&lt;Keyword::K&gt;::operator();                                 \\\n    Expression impl() const;                                                    \\\n};                                                                              \\\n                                                                                \\\ntemplate &lt;&gt; Expression dispatch_eval&lt;Keyword::K&gt;(                               \\\n    ExpressionView const&amp; self, ExpressionView const&amp; x, EvalContext context)   \\\n{                                                                               \\\n    return EvalImpl&lt;Keyword::K&gt;(self, x, context)();                            \\\n}                                                                               \\\n                                                                                \\\nExpression EvalImpl&lt;Keyword::K&gt;::impl() const                                   \\\n\n\n#define ASSERT(cond, msg) if (!(cond)) { return ::zmbt::lang::detail::make_error_expr(msg, keyword_to_str());}\n</code></pre>"},{"location":"CxxRef/eval__log_8hpp/","title":"File eval_log.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_log.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/eval__log_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/eval__log_8hpp/#classes","title":"Classes","text":"Type Name struct EvalLog Expression evaluation log."},{"location":"CxxRef/eval__log_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_log.hpp</code></p>"},{"location":"CxxRef/eval__log_8hpp_source/","title":"File eval_log.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_log.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_EVAL_LOG_HPP_\n#define ZMBT_EXPR_EVAL_LOG_HPP_\n\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;boost/json.hpp&gt;\n\nnamespace zmbt {\nnamespace lang {\n\nclass Expression;\n\nstruct EvalLog\n{\n    mutable std::shared_ptr&lt;boost::json::array&gt; stack;\n\n    EvalLog() = default;\n\n    boost::json::string str(int const indent = 0) const;\n\n    void push(Expression const&amp; expr, Expression const&amp; x, Expression const&amp; result, std::uint64_t const depth) const;\n\n\n    static void format(std::ostream&amp; os, boost::json::array const&amp; log, int const indent = 0);\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, EvalLog const&amp; log);\n\n    static EvalLog make();\n};\n\n}  // namespace lang\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/eval__params_8hpp/","title":"File eval_params.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_params.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"expression.hpp\"</code></li> <li><code>#include \"keyword_info.hpp\"</code></li> <li><code>#include \"eval_context.hpp\"</code></li> </ul>"},{"location":"CxxRef/eval__params_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/eval__params_8hpp/#classes","title":"Classes","text":"Type Name class EvalParams struct FixedEvalParams &lt;K&gt;"},{"location":"CxxRef/eval__params_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_params.hpp</code></p>"},{"location":"CxxRef/eval__params_8hpp_source/","title":"File eval_params.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_params.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_EVAL_PARAMS_HPP_\n#define ZMBT_EXPR_EVAL_PARAMS_HPP_\n\n#include \"expression.hpp\"\n#include \"keyword_info.hpp\"\n#include \"eval_context.hpp\"\n\n\nnamespace zmbt {\nnamespace lang {\n\nclass EvalParams\n{\n    Expression lhs_maybe_owned_;\n    Expression rhs_maybe_owned_;\n    ExpressionView lhs_;\n    ExpressionView rhs_;\n    ExpressionView const&amp; self_;\n    ExpressionView const&amp; x_;\n    EvalContext ctx_;\n\n    bool has_default_rhs() const;\n\n  public:\n\n    EvalParams(ExpressionView const&amp; e, ExpressionView const&amp; x, EvalContext ctx);\n\n    ExpressionView const&amp; self() const { return self_; }\n    ExpressionView const&amp; x()    const { return x_; }\n    ExpressionView const&amp; lhs()  const { return lhs_; }\n    ExpressionView const&amp; rhs()  const { return rhs_; }\n    EvalContext context()  const { return ctx_; }\n\n};\n\ntemplate &lt;Keyword K&gt;\nstruct FixedEvalParams : public EvalParams, public KeywordInfo&lt;K&gt;\n{\n    using EvalParams::EvalParams;\n};\n\n\n}  // namespace lang\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/eval__validator_8hpp/","title":"File eval_validator.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_validator.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"expression.hpp\"</code></li> <li><code>#include \"keyword.hpp\"</code></li> </ul>"},{"location":"CxxRef/eval__validator_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/eval__validator_8hpp/#classes","title":"Classes","text":"Type Name struct EvalValidator &lt;K&gt;"},{"location":"CxxRef/eval__validator_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/eval_validator.hpp</code></p>"},{"location":"CxxRef/eval__validator_8hpp_source/","title":"File eval_validator.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; eval_validator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_EVAL_VALIDATOR_HPP_\n#define ZMBT_EXPR_EVAL_VALIDATOR_HPP_\n\n#include \"expression.hpp\"\n#include \"keyword.hpp\"\n\n\nnamespace zmbt {\nnamespace lang {\n\ntemplate &lt;Keyword K&gt;\nstruct EvalValidator\n{\n\n    EvalValidator(ExpressionView const&amp; lhs, ExpressionView const&amp; rhs) {}\n\n    bool is_invalid() const\n    {\n        return false;\n    }\n\n    Expression status() const\n    {\n        return Expression();\n    }\n};\n\n}  // namespace lang\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/expression_8hpp/","title":"File expression.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; expression.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include \"zmbt/application/log.hpp\"</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> <li><code>#include \"operator.hpp\"</code></li> <li><code>#include \"keyword.hpp\"</code></li> <li><code>#include \"keyword_grammar.hpp\"</code></li> <li><code>#include \"encoding.hpp\"</code></li> <li><code>#include \"eval_context.hpp\"</code></li> </ul>"},{"location":"CxxRef/expression_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/expression_8hpp/#classes","title":"Classes","text":"Type Name class Expression class ExpressionView struct custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt; &lt;class T&gt; struct custom_serialization&lt; lang::ExpressionView &gt; &lt;&gt;"},{"location":"CxxRef/expression_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/expression.hpp</code></p>"},{"location":"CxxRef/expression_8hpp_source/","title":"File expression.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; expression.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_EXPRESSION_V2_HPP_\n#define ZMBT_EXPR_EXPRESSION_V2_HPP_\n\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n\n#include \"zmbt/application/log.hpp\"\n#include \"zmbt/core.hpp\"\n#include \"zmbt/reflect.hpp\"\n#include \"operator.hpp\"\n#include \"keyword.hpp\"\n#include \"keyword_grammar.hpp\"\n#include \"encoding.hpp\"\n#include \"eval_context.hpp\"\n\n\nnamespace zmbt {\nnamespace lang {\n\nclass Expression;\n\nclass ExpressionView\n{\npublic:\n\n    using V = boost::json::value;\n    using Keyword = lang::Keyword;\n\n    // CTORS\n\n    ExpressionView();\n\n    ExpressionView(ExpressionView const&amp;) = default;\n    ExpressionView(ExpressionView&amp;&amp;) = default;\n    ExpressionView&amp; operator=(ExpressionView const&amp;) = default;\n    ExpressionView&amp; operator=(ExpressionView&amp;&amp;) = default;\n\n    explicit ExpressionView(EncodingView v)\n        : encoding_view_{v}\n    {\n    }\n\n    explicit ExpressionView(Encoding enc)\n        : encoding_view_{EncodingView(enc)}\n    {\n    }\n\n    virtual ~ExpressionView() = default;\n\n    EncodingView encoding_view() const\n    {\n        return encoding_view_;\n    }\n\n    boost::json::value to_json() const;\n\n\n    // OPERATORS\n\n\n    bool operator==(ExpressionView const&amp; o) const\n    {\n        return (this == &amp;o) || (encoding_view() == o.encoding_view());\n    }\n\n    bool operator!=(ExpressionView const&amp; o) const\n    {\n        return !operator==(o);\n    }\n\n    // ENCODING OBSERVERS\n\n\n\n    bool has_subexpr() const\n    {\n        return encoding_view().size() &gt; 1;\n    }\n\n    std::list&lt;ExpressionView&gt; subexpressions_list() const;\n\n    std::list&lt;ExpressionView&gt; tuple_parameters() const;\n\n\n    // DATA OBSERVERS\n\n    boost::json::value const&amp; data() const;\n\n    boost::json::string const&amp; as_string() const\n    {\n        return data().as_string();\n    }\n\n    boost::json::array const&amp; as_array() const\n    {\n        return data().as_array();\n    }\n\n    boost::json::object const&amp; as_object() const\n    {\n        return data().as_object();\n    }\n\n    bool as_bool() const\n    {\n        return data().as_bool();\n    }\n\n    boost::json::string const* if_string() const\n    {\n        return data().if_string();\n    }\n\n    boost::json::array const* if_array() const\n    {\n        return data().if_array();\n    }\n\n    boost::json::object const* if_object() const\n    {\n        return data().if_object();\n    }\n\n    bool const* if_bool() const\n    {\n        return data().if_bool();\n    }\n\n    bool is_null() const\n    {\n        return data().is_null();\n    }\n\n\n    std::string serialize() const\n    {\n        return boost::json::serialize(to_json());\n    }\n\n    boost::json::string_view keyword_to_str() const;\n\n    // KEYWORD OBSERVERS\n\n\n    Keyword keyword() const\n    {\n        return encoding_view().head();\n    }\n\n    bool is(Keyword const kwrd) const\n    {\n        return kwrd == keyword();\n    }\n\n    bool is_compose() const\n    {\n        return is(Keyword::Pipe);\n    }\n\n    bool is_fork() const\n    {\n        return is(Keyword::Fork);\n    }\n\n    bool is_tuple() const\n    {\n        return is(Keyword::Tuple);\n    }\n\n    bool is_literal() const\n    {\n        return is(Keyword::Literal);\n    }\n\n    bool is_preproc() const\n    {\n        return is(Keyword::PreProc);\n    }\n\n    bool is_link() const\n    {\n        return is(Keyword::Link);\n    }\n\n    bool is_noop() const\n    {\n        return is(Keyword::Noop);\n    }\n\n    bool is_error() const\n    {\n        return is(Keyword::Err);\n    }\n\n    std::string error_id() const;\n\n    bool is_complete_flip() const\n    {\n        return is(Keyword::Flip) &amp;&amp; encoding_view().size() &gt; 1;\n    }\n\n\n    // ATTR-BASED OBSERVERS\n\n    bool is_const() const;\n\n    bool is_boolean() const;\n\n    bool is_valid_link() const\n    {\n        auto const child = encoding_view().child(0);\n        return is(Keyword::Fn) &amp;&amp; (child.head() == Keyword::Tuple) &amp;&amp; (child.arity() == 2);\n    }\n\n    bool is_infix_pipe() const\n    {\n        return is_compose() &amp;&amp; (encoding_view().arity() &gt; 1);\n    }\n\n    bool is_infix_tuple() const\n    {\n        return is_tuple() &amp;&amp; (encoding_view().arity() &gt; 1);\n    }\n\n    bool is_infix_fork() const\n    {\n        return is_fork() &amp;&amp; encoding_view().arity() == 2;\n    }\n\n    explicit operator boost::json::value() const\n    {\n        return to_json();\n    }\n\n    // Boost.Spirit Karma generator\n\n    std::string prettify() const;\n    std::ostream&amp; prettify_to(std::ostream&amp; os) const;\n\n    template &lt;std::size_t N&gt;\n    void prettify_to(char (&amp;buff)[N]) const\n    {\n        return prettify_to(buff, N);\n    }\n\n    void prettify_to(char* buff, std::size_t n) const;\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ExpressionView const&amp; expr);\n    friend zmbt::Logger&amp; operator&lt;&lt;(zmbt::Logger&amp; logger, ExpressionView const&amp; expr);\n\n\n\n    // PREPROCESSING\n\n    std::list&lt;std::pair&lt;std::string, std::string&gt;&gt; preprocessing_parameters() const;\n\n\n    // EVALUATORS\n\n    Expression eval_e(ExpressionView const&amp; x, EvalContext ctx) const;\n\n\n    bool eval_as_predicate(ExpressionView const&amp; x, Expression&amp; err_sts, EvalContext ctx) const;\n\n    bool eval_as_predicate(boost::json::value const&amp; x, Expression&amp; err_sts, EvalContext ctx) const;\n\n    Expression eval_maybe_predicate(ExpressionView const&amp; x, EvalContext ctx) const;\n\n    boost::json::value eval(boost::json::value const&amp; x = nullptr, EvalContext ctx = {}) const;\n\n    bool match(boost::json::value const&amp; x, Operator const&amp; op = {}) const;\n\n    friend V operator*(ExpressionView expr, ExpressionView const&amp; x);\n\n    friend V operator*(ExpressionView expr);\n\n  protected:\n    EncodingView encoding_view_;\n    mutable std::shared_ptr&lt;Expression&gt; const_predicate_cache_;\n};\n\n\nclass Expression : public ExpressionView\n{\n    static Expression unfold_left_assoc(Keyword const keyword, Expression&amp;&amp; lhs, Expression&amp;&amp; rhs);\n    template &lt;class T&gt;\n    static Encoding encodeNested(Keyword const&amp; keyword, std::move_iterator&lt;T&gt; begin, std::move_iterator&lt;T&gt; const end);\n\n  public:\n    // STATIC FUNCS\n\n    // using ExpressionView::operator==;\n    // using ExpressionView::operator!=;\n\n    bool operator==(Expression v) const\n    {\n        return ExpressionView::operator==(v);\n    }\n\n    bool operator!=(Expression v) const\n    {\n        return ExpressionView::operator!=(v);\n    }\n\n\n    // Terminal expression\n    static Encoding encodeLiteral(boost::json::value const&amp; params);\n    // Terminal expression\n    static Encoding encodePreProc(boost::json::value const&amp; params);\n\n    // Non-terminal expression\n    static Encoding encodeNested(Keyword const&amp; keyword, std::initializer_list&lt;Expression&gt; subexpressions);\n    static Encoding encodeNested(Keyword const&amp; keyword, std::vector&lt;Expression&gt;&amp;&amp; subexpressions);\n\n    static bool to_predicate_if_const(Expression&amp; e);\n\n    // CTORS\n\n    Expression();\n\n    explicit Expression(Encoding &amp;&amp; encoding);\n    explicit Expression(Encoding const&amp; encoding);\n\n    // Deserialize JSON\n    Expression(boost::json::value const&amp; expr);\n    Expression(boost::json::value &amp;&amp; expr);\n\n    // construct Literal from JSON init list\n    Expression(std::initializer_list&lt;boost::json::value_ref&gt; items);\n\n    template &lt;class T&gt;\n    Expression(T sample) : Expression(json_from(std::move(sample))) {}\n\n    // construct from keyword\n    explicit Expression(Keyword const&amp; keyword);\n    explicit Expression(ExpressionView const&amp; view);\n\n    Expression(Expression const&amp; other);\n    Expression(Expression&amp;&amp; other);\n    Expression&amp; operator=(Expression const&amp; other);\n    Expression&amp; operator=(Expression&amp;&amp; other);\n    ~Expression() = default;\n\n    Encoding encoding() const { return encoding_; }\n\n    // SUGAR SYNTAX OPERATORS\n\n    friend Expression operator|(Expression lhs, Expression rhs);\n\n    friend Expression operator&amp;(Expression lhs, Expression rhs);\n\n    friend Expression operator+(Expression lhs, Expression rhs);\n\n    friend Expression operator&lt;&lt;(Expression link, Expression expr);\n\n    friend Expression operator~(Expression expr);\n\n  private:\n    Encoding encoding_;\n};\n\n\nZMBT_INJECT_SERIALIZATION\n}  // namespace lang\n\ntemplate&lt;&gt;\nstruct reflect::custom_serialization&lt;lang::ExpressionView&gt; {\n\n    static boost::json::value\n    json_from(lang::ExpressionView const&amp; t)\n    {\n        return t.to_json();\n    }\n};\n\ntemplate&lt;class T&gt;\nstruct reflect::custom_serialization&lt;T, mp_if&lt;is_base_of&lt;lang::Expression, T&gt;, void&gt;&gt; {\n\n    static boost::json::value\n    json_from(T const&amp; t)\n    {\n        return t.to_json();\n    }\n\n    static T\n    dejsonize(boost::json::value const&amp; v)\n    {\n        return static_cast&lt;T&gt;(lang::Expression(v));\n    }\n};\n\n}  // namespace zmbt\n\n\n#endif\n</code></pre>"},{"location":"CxxRef/expression__grammar_8hpp/","title":"File expression_grammar.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; expression_grammar.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/phoenix/phoenix.hpp&gt;</code></li> <li><code>#include &lt;boost/spirit/include/karma.hpp&gt;</code></li> <li><code>#include \"expression.hpp\"</code></li> <li><code>#include \"keyword_grammar.hpp\"</code></li> </ul>"},{"location":"CxxRef/expression__grammar_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/expression__grammar_8hpp/#classes","title":"Classes","text":"Type Name struct ExpressionGrammar &lt;typename OutputIterator&gt;"},{"location":"CxxRef/expression__grammar_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/expression_grammar.hpp</code></p>"},{"location":"CxxRef/expression__grammar_8hpp_source/","title":"File expression_grammar.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; expression_grammar.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_EXPRESSION_GRAMMAR_HPP_\n#define ZMBT_EXPR_EXPRESSION_GRAMMAR_HPP_\n\n#include &lt;boost/phoenix/phoenix.hpp&gt;\n#include &lt;boost/spirit/include/karma.hpp&gt;\n\n#include \"expression.hpp\"\n#include \"keyword_grammar.hpp\"\n\nnamespace zmbt {\nnamespace lang {\n\n\ntemplate &lt;typename OutputIterator&gt;\nstruct ExpressionGrammar : boost::spirit::karma::grammar&lt;OutputIterator, ExpressionView()&gt; {\n    ExpressionGrammar() : ExpressionGrammar::base_type(start)\n    {\n        namespace karma = boost::spirit::karma;\n        namespace phoenix = boost::phoenix;\n\n        using karma::_1;\n        using karma::_val;\n        using karma::eps;\n        using karma::lit;\n        using karma::string;\n\n        auto const is_literal          = boost::phoenix::bind(&amp;ExpressionView::is_literal, _val);\n        auto const is_preproc          = boost::phoenix::bind(&amp;ExpressionView::is_preproc, _val);\n        auto const is_link          = boost::phoenix::bind(&amp;ExpressionView::is_link, _val);\n        auto const is_valid_link       = boost::phoenix::bind(&amp;ExpressionView::is_valid_link, _val);\n        auto const has_subexpr         = boost::phoenix::bind(&amp;ExpressionView::has_subexpr, _val);\n        auto const serialize           = boost::phoenix::bind(&amp;ExpressionView::serialize, _val);\n        auto const keyword_to_str      = boost::phoenix::bind(&amp;ExpressionView::keyword_to_str, _val);\n        auto const subexpressions_list = boost::phoenix::bind(&amp;ExpressionView::subexpressions_list, _val);\n        auto const tuple_parameters    = boost::phoenix::bind(&amp;ExpressionView::tuple_parameters, _val);\n        auto const is_infix_pipe       = boost::phoenix::bind(&amp;ExpressionView::is_infix_pipe, _val);\n        auto const is_infix_fork       = boost::phoenix::bind(&amp;ExpressionView::is_infix_fork, _val);\n        auto const is_infix_tuple      = boost::phoenix::bind(&amp;ExpressionView::is_infix_tuple, _val);\n        auto const is_complete_flip    = boost::phoenix::bind(&amp;ExpressionView::is_complete_flip, _val);\n\n        start\n            = eps(is_literal)      &lt;&lt; karma::lazy(serialize)\n            | eps(is_preproc)      &lt;&lt; karma::lazy(serialize)\n            | eps(is_link)      &lt;&lt; karma::lazy(serialize)\n            | eps(is_valid_link)   &lt;&lt; link[_1 = tuple_parameters]\n            | eps(is_infix_pipe)   &lt;&lt; pipe[_1 = subexpressions_list]\n            | eps(is_infix_fork)   &lt;&lt; fork[_1 = subexpressions_list]\n            | eps(is_infix_tuple)  &lt;&lt; tuple[_1 = subexpressions_list]\n            | eps(is_complete_flip)&lt;&lt; flip[_1 = subexpressions_list]\n            | keyword;\n\n        subexpr\n            = eps(is_literal)       &lt;&lt; karma::lazy(serialize)\n            | eps(is_preproc)       &lt;&lt; karma::lazy(serialize)\n            | eps(is_link)       &lt;&lt; karma::lazy(serialize)\n            | eps(is_valid_link)    &lt;&lt; nested_link[_1 = tuple_parameters]\n            | eps(is_infix_pipe)    &lt;&lt; nested_pipe[_1 = subexpressions_list]\n            | eps(is_infix_fork)    &lt;&lt; nested_fork[_1 = subexpressions_list]\n            | eps(is_infix_tuple)   &lt;&lt; nested_tuple[_1 = subexpressions_list]\n            | eps(is_complete_flip) &lt;&lt; flip[_1 = subexpressions_list]\n            | keyword;\n\n        pipe    = subexpr % lit(\" | \");\n        fork    = subexpr % lit(\" &amp; \");\n        tuple   = subexpr % lit(\" + \");\n        link    = subexpr % lit(\" &lt;&lt; \");\n        flip    = lit('~') &lt;&lt; subexpr;\n        nested_link = lit('(') &lt;&lt; subexpr % lit(\" &lt;&lt; \") &lt;&lt; ')';\n        nested_pipe  = lit('(') &lt;&lt; subexpr % lit(\" | \") &lt;&lt; ')';\n        nested_fork  = lit('(') &lt;&lt; subexpr % lit(\" &amp; \") &lt;&lt; ')';\n        nested_tuple = lit('(') &lt;&lt; subexpr % lit(\" + \") &lt;&lt; ')';\n        parameters   = lit('(') &lt;&lt; -(start % lit(\", \"))  &lt;&lt; ')';\n\n        keyword = string[_1 = keyword_to_str] &lt;&lt; -(eps(has_subexpr)  &lt;&lt; parameters[_1 = subexpressions_list]);\n    }\n\n    boost::spirit::karma::rule&lt;OutputIterator, ExpressionView()&gt; start, subexpr, keyword;\n    boost::spirit::karma::rule&lt;OutputIterator, std::list&lt;ExpressionView&gt;()&gt; parameters, fork, pipe, tuple, link, flip, nested_pipe, nested_fork, nested_tuple, nested_link;\n};\n\n}  // namespace lang\n}  // namespace zmbt\n\n#endif  // ZMBT_MAPPING_EXPRESSION_HPP_\n</code></pre>"},{"location":"CxxRef/keyword_8hpp/","title":"File keyword.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; keyword.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> </ul>"},{"location":"CxxRef/keyword_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/keyword_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024-2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0</p> <p>Autogenerated file - do not change!</p> <p>app: codegen.expr template: codegen/expr/templates/zmbt-framework/backends/cxx/include/zmbt/expr/keyword.hpp</p> <p>How to update: * Update the template * Run <code>python -m codegen</code> in the project root * Commit changes </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/keyword.hpp</code></p>"},{"location":"CxxRef/keyword_8hpp_source/","title":"File keyword.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; keyword.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_KEYWORD_HPP_\n#define ZMBT_EXPR_KEYWORD_HPP_\n\n#include &lt;boost/json.hpp&gt;\n\n#include \"zmbt/reflect.hpp\"\n\n\nnamespace zmbt {\nnamespace lang {\n\n\nenum class Keyword : std::uint64_t\n{\n    Undefined,\n\n    Literal,\n\n    Void,\n\n    LazyToken,\n\n    Noop,\n\n    Null,\n\n    True,\n\n    False,\n\n    Pi,\n\n    E,\n\n    Inf,\n\n    Eps,\n\n    NaN,\n\n    Thread,\n\n    Sin,\n\n    Cos,\n\n    Tan,\n\n    Asin,\n\n    Acos,\n\n    Atan,\n\n    Sinh,\n\n    Cosh,\n\n    Tanh,\n\n    Asinh,\n\n    Acosh,\n\n    Atanh,\n\n    Exp,\n\n    Erf,\n\n    Erfc,\n\n    Gamma,\n\n    Abs,\n\n    Ceil,\n\n    Floor,\n\n    Round,\n\n    Sqrt,\n\n    Sign,\n\n    Neg,\n\n    Add,\n\n    Sub,\n\n    Mul,\n\n    Div,\n\n    Pow,\n\n    Log,\n\n    Mod,\n\n    Quot,\n\n    BitNot,\n\n    BitAnd,\n\n    BitOr,\n\n    BitXor,\n\n    Lshift,\n\n    Rshift,\n\n    Eq,\n\n    Ne,\n\n    Lt,\n\n    Le,\n\n    Gt,\n\n    Ge,\n\n    Near,\n\n    Union,\n\n    Intersect,\n\n    Diff,\n\n    SetEq,\n\n    Subset,\n\n    Superset,\n\n    PSubset,\n\n    PSuperset,\n\n    In,\n\n    NotIn,\n\n    Ni,\n\n    NotNi,\n\n    Bool,\n\n    Not,\n\n    And,\n\n    Or,\n\n    Id,\n\n    Transp,\n\n    Cartesian,\n\n    Reverse,\n\n    Uniques,\n\n    Items,\n\n    Keys,\n\n    Values,\n\n    Enumerate,\n\n    Flatten,\n\n    ToList,\n\n    First,\n\n    Last,\n\n    Arange,\n\n    Parse,\n\n    Str,\n\n    Re,\n\n    Fmt,\n\n    Capitalize,\n\n    LowerCase,\n\n    UpperCase,\n\n    Card,\n\n    Size,\n\n    Sum,\n\n    Prod,\n\n    Avg,\n\n    Slide,\n\n    Stride,\n\n    Chunks,\n\n    Repeat,\n\n    Cat,\n\n    Push,\n\n    At,\n\n    Del,\n\n    Lookup,\n\n    Cast,\n\n    Uncast,\n\n    Fold,\n\n    Map,\n\n    Filter,\n\n    Count,\n\n    Each,\n\n    Sort,\n\n    Find,\n\n    FindPtr,\n\n    FindIdx,\n\n    Min,\n\n    Max,\n\n    Argmin,\n\n    Argmax,\n\n    Recur,\n\n    Unfold,\n\n    Op,\n\n    Bind,\n\n    Fn,\n\n    Link,\n\n    Any,\n\n    All,\n\n    Saturate,\n\n    Pipe,\n\n    Tuple,\n\n    Fork,\n\n    Flip,\n\n    Dbg,\n\n    Eval,\n\n    Try,\n\n    Kwrd,\n\n    Prms,\n\n    Q,\n\n    D,\n\n    Err,\n\n    IsErr,\n\n    Assert,\n\n    Trace,\n\n    PreProc,\n\n    _count\n};\n\nnamespace detail\n{\nbool isBinary(Keyword const&amp; k);\nbool isBoolean(Keyword const&amp; k);\n} // namespace detail\n\n\n} // namespace lang\n} // namespace zmbt\n\n\n\n#endif // ZMBT_MODEL_KEYWORD_HPP_\n</code></pre>"},{"location":"CxxRef/keyword__grammar_8hpp/","title":"File keyword_grammar.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; keyword_grammar.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/spirit/include/qi.hpp&gt;</code></li> <li><code>#include &lt;boost/phoenix/operator.hpp&gt;</code></li> <li><code>#include \"keyword.hpp\"</code></li> </ul>"},{"location":"CxxRef/keyword__grammar_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/keyword__grammar_8hpp/#classes","title":"Classes","text":"Type Name struct KeywordGrammar Boost.Sirit.Qi Grammar for zmbt::lang::Keyword parsing. struct KeywordSymbol Boost.Sirit.Qi Symbol for zmbt::lang::Keyword parsing."},{"location":"CxxRef/keyword__grammar_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/keyword_grammar.hpp</code></p>"},{"location":"CxxRef/keyword__grammar_8hpp_source/","title":"File keyword_grammar.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; keyword_grammar.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_KEYWORD_GRAMMAR_HPP_\n#define ZMBT_EXPR_KEYWORD_GRAMMAR_HPP_\n\n#include &lt;boost/spirit/include/qi.hpp&gt;\n#include &lt;boost/phoenix/operator.hpp&gt;\n\n#include \"keyword.hpp\"\n\n\nnamespace zmbt {\nnamespace lang {\n\nstruct KeywordSymbol : public boost::spirit::qi::symbols&lt;char, Keyword&gt;\n{\n    KeywordSymbol();\n};\n\nstruct KeywordGrammar : public boost::spirit::qi::grammar&lt;boost::json::string::const_iterator, Keyword()&gt;\n{\n    KeywordGrammar();\n\n    KeywordSymbol keyword_symbol;\n    boost::spirit::qi::rule&lt;boost::json::string::const_iterator, Keyword()&gt; start;\n};\n\nboost::json::string_view keyword_to_str(Keyword const&amp;);\n\n\n// Boost JSON conversion from Keyword\nvoid tag_invoke(boost::json::value_from_tag const&amp;, boost::json::value&amp;, Keyword const&amp; t);\n\n// Boost JSON conversion to Keyword\nKeyword tag_invoke(boost::json::value_to_tag&lt;Keyword&gt; const&amp;, boost::json::value const&amp;);\n\n\n} // namespace lang\n} // namespace zmbt\n\n\n#endif // ZMBT_MAPPING_EXPRESSION_HPP_\n</code></pre>"},{"location":"CxxRef/keyword__info_8hpp/","title":"File keyword_info.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; keyword_info.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"keyword.hpp\"</code></li> <li><code>#include \"attributes.hpp\"</code></li> </ul>"},{"location":"CxxRef/keyword__info_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/keyword__info_8hpp/#classes","title":"Classes","text":"Type Name struct KeywordInfo &lt;k&gt;"},{"location":"CxxRef/keyword__info_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/keyword_info.hpp</code></p>"},{"location":"CxxRef/keyword__info_8hpp_source/","title":"File keyword_info.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; keyword_info.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_KEYWORD_INFO_HPP_\n#define ZMBT_EXPR_KEYWORD_INFO_HPP_\n\n#include \"keyword.hpp\"\n#include \"attributes.hpp\"\n\n\nnamespace zmbt {\nnamespace lang {\n\ntemplate &lt;Keyword k&gt;\nstruct KeywordInfo\n{\n    constexpr Keyword keyword() { return k; }\n    constexpr std::uint32_t attributes() { constexpr std::uint32_t a = ::zmbt::lang::attributes(k); return a; }\n    static boost::json::string_view keyword_to_str() { return ::zmbt::lang::keyword_to_str(k); }\n};\n\n}  // namespace lang\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/lazy__param_8hpp/","title":"File lazy_param.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; lazy_param.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;boost/optional.hpp&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> </ul>"},{"location":"CxxRef/lazy__param_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/lazy__param_8hpp/#classes","title":"Classes","text":"Type Name class LazyParam"},{"location":"CxxRef/lazy__param_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/lazy_param.hpp</code></p>"},{"location":"CxxRef/lazy__param_8hpp_source/","title":"File lazy_param.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; lazy_param.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_LAZY_PARAM_HPP_\n#define ZMBT_EXPR_LAZY_PARAM_HPP_\n\n#include &lt;functional&gt;\n#include &lt;boost/optional.hpp&gt;\n\n#include &lt;boost/json.hpp&gt;\n\n#include \"zmbt/reflect.hpp\"\n\nnamespace zmbt {\nnamespace lang {\n\nclass ExpressionView;\nclass EvalContext;\n\nclass LazyParam\n{\n  public:\n    using V = boost::json::value;\n\n    LazyParam();\n\n    LazyParam(std::function&lt;V()&gt; getter);\n\n    LazyParam(ExpressionView, EvalContext);\n\n    LazyParam(V &amp;&amp; v);\n\n    LazyParam(V const&amp; v);\n\n    LazyParam(std::reference_wrapper&lt;V const&gt; v);\n\n    template &lt;class T&gt;\n    LazyParam(T const&amp; v)\n        : LazyParam(json_from(v))\n    {\n    }\n\n    ~LazyParam() = default;\n\n    LazyParam(LazyParam const&amp;) = default;\n    LazyParam(LazyParam &amp;&amp;) = default;\n    LazyParam&amp; operator=(LazyParam const&amp;) = default;\n    LazyParam&amp; operator=(LazyParam &amp;&amp;) = default;\n\n    [[nodiscard]] V operator()() const;\n\n    operator V() const;\n\n  private:\n\n    std::function&lt;V()&gt; getter_;\n    mutable boost::optional&lt;V&gt; cache_;\n};\n\n} // namespace lang\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/operator_8hpp/","title":"File operator.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; operator.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> <li><code>#include \"keyword.hpp\"</code></li> <li><code>#include \"lazy_param.hpp\"</code></li> <li><code>#include &lt;boost/current_function.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/operator_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/operator_8hpp/#classes","title":"Classes","text":"Type Name class Operator Signal transformation and comparison handler. Enables type erasure. struct Handle struct Handle struct Handle struct Handle struct Handle struct Handle struct operator_error"},{"location":"CxxRef/operator_8hpp/#macros","title":"Macros","text":"Type Name define ZMBT_SOH_HANDLE_BIN_TRANSFORM (OP, TRAIT) <code>/* multi line expression */</code> define ZMBT_SOH_HANDLE_UNARY_TRANSFORM (OP, TRAIT) <code>/* multi line expression */</code>"},{"location":"CxxRef/operator_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/operator_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/operator_8hpp/#define-zmbt_soh_handle_bin_transform","title":"define ZMBT_SOH_HANDLE_BIN_TRANSFORM","text":"<pre><code>#define ZMBT_SOH_HANDLE_BIN_TRANSFORM (\n    OP,\n    TRAIT\n) `/* multi line expression */`\n</code></pre>"},{"location":"CxxRef/operator_8hpp/#define-zmbt_soh_handle_unary_transform","title":"define ZMBT_SOH_HANDLE_UNARY_TRANSFORM","text":"<pre><code>#define ZMBT_SOH_HANDLE_UNARY_TRANSFORM (\n    OP,\n    TRAIT\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/operator.hpp</code></p>"},{"location":"CxxRef/operator_8hpp_source/","title":"File operator.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; operator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_SIGNAL_OPERATOR_HANDLER_HPP_\n#define ZMBT_EXPR_SIGNAL_OPERATOR_HANDLER_HPP_\n\n#include &lt;limits&gt;\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/reflect.hpp\"\n#include \"keyword.hpp\"\n#include \"lazy_param.hpp\"\n#include &lt;boost/current_function.hpp&gt;\n\n\n\n#define ZMBT_SOH_HANDLE_UNARY_TRANSFORM(OP, TRAIT)       \\\ntemplate &lt;class T&gt;                                       \\\nstatic auto handle_##TRAIT(LV val)                       \\\n-&gt; mp_if&lt;has_##TRAIT&lt;T&gt;, V&gt;                              \\\ntry {                                                    \\\n    return json_from(OP dejsonize&lt;T&gt;(val));              \\\n}                                                        \\\ncatch(const std::exception&amp; e)                           \\\n{                                                        \\\n    return detail::make_error_expr(                      \\\n        e.what(), BOOST_CURRENT_FUNCTION);               \\\n}                                                        \\\ntemplate &lt;class T&gt;                                       \\\nstatic auto handle_##TRAIT(LV)                           \\\n-&gt; mp_if&lt;mp_not&lt;has_##TRAIT&lt;T&gt;&gt;, V&gt;                      \\\ntry {                                                    \\\n    return detail::make_error_expr(                      \\\n        \"invalid operand\", BOOST_CURRENT_FUNCTION);      \\\n}                                                        \\\ncatch(const std::exception&amp; e)                           \\\n{                                                        \\\n    return detail::make_error_expr(                      \\\n        e.what(), BOOST_CURRENT_FUNCTION);               \\\n}\n\n#define ZMBT_SOH_HANDLE_BIN_TRANSFORM(OP, TRAIT)                 \\\ntemplate &lt;class T&gt;                                               \\\nstatic auto handle_##TRAIT(LV lhs, LV rhs)                       \\\n-&gt; mp_if&lt;has_##TRAIT&lt;T&gt;, V&gt;                                      \\\ntry {                                                            \\\n    return json_from(dejsonize&lt;T&gt;(lhs) OP dejsonize&lt;T&gt;(rhs));    \\\n}                                                                \\\ncatch(const std::exception&amp; e)                                   \\\n{                                                                \\\n    return detail::make_error_expr(                              \\\n        e.what(), BOOST_CURRENT_FUNCTION);                       \\\n}                                                                \\\ntemplate &lt;class T&gt;                                               \\\nstatic auto handle_##TRAIT(LV, LV)                               \\\n-&gt; mp_if&lt;mp_not&lt;has_##TRAIT&lt;T&gt;&gt;, V&gt;                              \\\ntry {                                                            \\\n    return detail::make_error_expr(                              \\\n        \"invalid operands\", BOOST_CURRENT_FUNCTION);             \\\n}                                                                \\\ncatch(const std::exception&amp; e)                                   \\\n{                                                                \\\n    return detail::make_error_expr(                              \\\n        e.what(), BOOST_CURRENT_FUNCTION);                       \\\n}\n\nnamespace zmbt {\nnamespace lang {\n\nnamespace detail\n{\nZMBT_HAS_TYPE(decorated_type)\n\nboost::json::value make_error_expr(boost::json::string_view msg, boost::json::string_view ctx);\n\n}\n\nclass Operator\n{\n  public:\n\n    struct operator_error : public base_error {\n        using base_error::base_error;\n    };\n\n    using V = boost::json::value;\n    using LV = LazyParam;\n\n    enum Config : std::uint32_t\n    {\n        Null,\n        Decor       = 1U &lt;&lt; 0,\n        Comparison  = 1U &lt;&lt; 1,\n        Arithmetics = 1U &lt;&lt; 2,\n        Bitwise     = 1U &lt;&lt; 3,\n        Shift       = 1U &lt;&lt; 4,\n        Logic       = 1U &lt;&lt; 5,\n        Default     = Decor|Comparison|Arithmetics|Bitwise|Shift,\n        Full        = Default|Logic,\n    };\n\n    static V generic_is_truth   (LV);\n    static V generic_decorate   (LV);\n    static V generic_undecorate (LV);\n    static V generic_negate     (LV);\n    static V generic_complement (LV);\n    static V generic_logical_not(LV);\n    static V generic_equal_to   (LV, LV);\n    static V generic_less       (LV, LV);\n    static V generic_less_equal (LV, LV);\n    static V generic_plus       (LV, LV);\n    static V generic_minus      (LV, LV);\n    static V generic_multiplies (LV, LV);\n    static V generic_divides    (LV, LV);\n    static V generic_modulus    (LV, LV);\n    static V generic_bit_and    (LV, LV);\n    static V generic_bit_or     (LV, LV);\n    static V generic_bit_xor    (LV, LV);\n    static V generic_left_shift (LV, LV);\n    static V generic_right_shift(LV, LV);\n    static V generic_logical_and(LV, LV);\n    static V generic_logical_or (LV, LV);\n\n    static V generic_pow (LV, LV);\n    static V generic_log (LV, LV);\n    static V generic_quot(LV, LV);\n\n\n  private:\n\n    using unary_transform = std::function&lt;V(LV)&gt;;\n    using binary_transform = std::function&lt;V(LV, LV)&gt;;\n\n    ZMBT_SOH_HANDLE_UNARY_TRANSFORM(-, negate)\n    ZMBT_SOH_HANDLE_UNARY_TRANSFORM(~, complement)\n    ZMBT_SOH_HANDLE_UNARY_TRANSFORM(!, logical_not)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(==, equal_to)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(&lt;, less)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(&lt;=, less_equal)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(+, plus)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(-, minus)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(*, multiplies)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(/, divides)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(%, modulus)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(&amp;, bit_and)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(|, bit_or)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(^, bit_xor)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(&lt;&lt;, left_shift)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(&gt;&gt;, right_shift)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(&amp;&amp;, logical_and)\n    ZMBT_SOH_HANDLE_BIN_TRANSFORM(||, logical_or)\n\n#undef ZMBT_SOH_HANDLE_UNARY_TRANSFORM\n#undef ZMBT_SOH_HANDLE_BIN_TRANSFORM\n\n\n    template &lt;class T&gt;\n    static auto handle_decorate(LV v)\n        -&gt; mp_if&lt;detail::has_type_decorated_type&lt;T&gt;, boost::json::value&gt;\n    try\n    {\n        using Decorated = typename T::decorated_type;\n        return json_from(static_cast&lt;Decorated&gt;(dejsonize&lt;T&gt;(v)));\n    }\n    catch(const std::exception&amp; e)\n    {\n        return detail::make_error_expr(e.what(), BOOST_CURRENT_FUNCTION);\n    }\n\n    template &lt;class T&gt;\n    static auto handle_decorate(boost::json::value const&amp; a)\n        -&gt; mp_if&lt;mp_not&lt;detail::has_type_decorated_type&lt;T&gt;&gt;, boost::json::value&gt;\n    try\n    {\n        return json_from(dejsonize&lt;T&gt;(a));\n    }\n    catch(const std::exception&amp; e)\n    {\n        return detail::make_error_expr(e.what(), BOOST_CURRENT_FUNCTION);\n    }\n\n    template &lt;class T&gt;\n    static auto handle_undecorate(LV const&amp; a)\n        -&gt; mp_if&lt;detail::has_type_decorated_type&lt;T&gt;, boost::json::value&gt;\n    try\n    {\n        using Decorated = typename T::decorated_type;\n        return json_from(static_cast&lt;T&gt;(dejsonize&lt;Decorated&gt;(a)));\n    }\n    catch(const std::exception&amp; e)\n    {\n        return detail::make_error_expr(e.what(), BOOST_CURRENT_FUNCTION);\n    }\n\n    template &lt;class T&gt;\n    static auto handle_undecorate(LV const&amp; a)\n        -&gt; mp_if&lt;mp_not&lt;detail::has_type_decorated_type&lt;T&gt;&gt;, boost::json::value&gt;\n    try\n    {\n        return json_from(dejsonize&lt;T&gt;(a));\n    }\n    catch(const std::exception&amp; e)\n    {\n        return detail::make_error_expr(e.what(), BOOST_CURRENT_FUNCTION);\n    }\n\n    template &lt;class T&gt;\n    static auto handle_is_truth(LV const&amp; val) -&gt; mp_if&lt;is_convertible&lt;T, bool&gt;, boost::json::value&gt;\n    try\n    {\n        return static_cast&lt;bool&gt;(dejsonize&lt;T&gt;(val));\n    }\n    catch(const std::exception&amp; e)\n    {\n        return detail::make_error_expr(e.what(), BOOST_CURRENT_FUNCTION);\n    }\n\n    template &lt;class T&gt;\n    static auto handle_is_truth(LV const&amp;) -&gt; mp_if&lt;mp_not&lt;is_convertible&lt;T, bool&gt;&gt;, boost::json::value&gt;\n    {\n        return detail::make_error_expr(\"invalid operand\", BOOST_CURRENT_FUNCTION);\n    }\n\n\n\n    struct Handle {\n\n        boost::json::string annotation{\"\"};\n        struct D {\n            unary_transform     decorate{generic_decorate};\n            unary_transform     undecorate{generic_undecorate};\n        } decor;\n\n        struct C {\n            binary_transform equal_to{generic_equal_to};\n            binary_transform less{generic_less};\n            binary_transform less_equal{generic_less_equal};\n        } comp;\n\n        struct A {\n            unary_transform neg{generic_negate};\n            binary_transform add{generic_plus};\n            binary_transform sub{generic_minus};\n            binary_transform mul{generic_multiplies};\n            binary_transform div{generic_divides};\n            binary_transform mod{generic_modulus};\n        } arithmetics;\n\n        struct B {\n            unary_transform compl_{generic_complement};\n            binary_transform and_{generic_bit_and};\n            binary_transform or_{generic_bit_or};\n            binary_transform xor_{generic_bit_xor};\n        } bitwise;\n\n        struct S {\n            binary_transform left{generic_left_shift};\n            binary_transform right{generic_right_shift};\n        } shift;\n\n        struct L {\n            unary_transform  bool_{generic_is_truth};\n            binary_transform and_{generic_logical_and};\n            binary_transform or_{generic_logical_or};\n        } logic;\n    };\n\n    template &lt;class T&gt;\n    static Handle makeHandle(type_tag&lt;T&gt;, Config const cfg = Default) {\n        return {\n            format(\"%s#%d\", type_name&lt;T&gt;(), cfg).c_str(),\n            Decor &amp; cfg ? Handle::D{\n                handle_decorate&lt;T&gt;,\n                handle_undecorate&lt;T&gt;\n            } : Handle::D{},\n            Comparison &amp; cfg ? Handle::C{\n                handle_equal_to&lt;T&gt;,\n                handle_less&lt;T&gt;,\n                handle_less_equal&lt;T&gt;\n            } : Handle::C{},\n            Arithmetics &amp; cfg ? Handle::A{\n                handle_negate&lt;T&gt;,\n                handle_plus&lt;T&gt;,\n                handle_minus&lt;T&gt;,\n                handle_multiplies&lt;T&gt;,\n                handle_divides&lt;T&gt;,\n                handle_modulus&lt;T&gt;\n            } : Handle::A{},\n            Bitwise &amp; cfg ? Handle::B{\n                handle_complement&lt;T&gt;,\n                handle_bit_and&lt;T&gt;,\n                handle_bit_or&lt;T&gt;,\n                handle_bit_xor&lt;T&gt;\n            } : Handle::B{},\n            Shift &amp; cfg ? Handle::S{\n                handle_left_shift&lt;T&gt;,\n                handle_right_shift&lt;T&gt;\n            } : Handle::S{},\n            Logic &amp; cfg ? Handle::L{\n                handle_is_truth&lt;T&gt;,\n                handle_logical_and&lt;T&gt;,\n                handle_logical_or&lt;T&gt;\n            } : Handle::L{},\n        };\n    }\n\n    Handle handle_;\n\n    explicit Operator(\n        Handle const handle\n    );\n\n    static bool exchangeHandle(Handle&amp; handle, bool const retrieve);\n\npublic:\n\n    Operator();\n\n    template &lt;class T&gt;\n    Operator(type_tag&lt;T&gt; tag, Config const cfg)\n    : Operator{makeHandle(tag, cfg)}\n    {\n    }\n\n    template &lt;class T&gt;\n    Operator(type_tag&lt;T&gt; tag)\n    : Operator{tag, Config::Default}\n    {\n    }\n\n    Operator(boost::json::string_view annotation);\n\n    Operator(Operator const&amp;) = default;\n    Operator(Operator &amp;&amp;) = default;\n    virtual ~Operator() = default;\n    Operator&amp; operator=(Operator const&amp;) = default;\n    Operator&amp; operator=(Operator &amp;&amp;) = default;\n\n    bool is_generic() const\n    {\n        return annotation().empty();\n    }\n\n    boost::json::string annotation() const\n    {\n        return handle_.annotation;\n    }\n\n    boost::json::value decorate(boost::json::value const&amp; a) const\n    {\n        return handle_.decor.decorate(a);\n    }\n\n    boost::json::value undecorate(boost::json::value const&amp; a) const\n    {\n        return handle_.decor.undecorate(a);\n    }\n\n\n    boost::json::value apply(lang::Keyword const&amp; keyword, LV lhs, LV rhs) const;\n\n\nprivate:\n\n    V is_subset(LV const&amp; lhs, LV const&amp; rhs) const;\n\n    V contains(LV const&amp; set, LV const&amp; element) const;\n\n};\n\n} // namespace lang\n} // namespace zmbt\n\n#endif // ZMBT_EXPR_SIGNAL_OPERATOR_HANDLER_HPP_\n</code></pre>"},{"location":"CxxRef/subexpression_8hpp/","title":"File subexpression.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; subexpression.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include \"expression.hpp\"</code></li> </ul>"},{"location":"CxxRef/subexpression_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace lang Expression Language implementation."},{"location":"CxxRef/subexpression_8hpp/#classes","title":"Classes","text":"Type Name class Subexpression"},{"location":"CxxRef/subexpression_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/subexpression.hpp</code></p>"},{"location":"CxxRef/subexpression_8hpp_source/","title":"File subexpression.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; expr &gt; subexpression.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_EXPR_SUBEXPRESSION_HPP_\n#define ZMBT_EXPR_SUBEXPRESSION_HPP_\n\n#include &lt;ostream&gt;\n\n#include \"expression.hpp\"\n\n\nnamespace zmbt {\nnamespace lang {\n\n\nclass Expression::Subexpression : Expression\n{\n    EncodingView ev_;\npublic:\n    Subexpression(EncodingView const&amp; ev)\n        : ev_{ev}\n    {\n    }\n};\n\n}  // namespace lang\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/dir_84d9d905044f75949470ced2679fed92/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping</p>"},{"location":"CxxRef/dir_84d9d905044f75949470ced2679fed92/#files","title":"Files","text":"Type Name file channel_handle.hpp file model_definition.hpp file model_definition_helper.hpp file model_definition_main.hpp file model_definition_node.hpp file model_definition_states.hpp file model_definition_transitions.hpp file pipe_handle.hpp file test_diagnostics.hpp file test_parameter_resolver.hpp file test_runner.hpp <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/</code></p>"},{"location":"CxxRef/channel__handle_8hpp/","title":"File channel_handle.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; channel_handle.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/model/environment.hpp\"</code></li> <li><code>#include \"zmbt/expr.hpp\"</code></li> </ul>"},{"location":"CxxRef/channel__handle_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/channel__handle_8hpp/#classes","title":"Classes","text":"Type Name class ChannelHandle Channel clause handle for SignalMapping model."},{"location":"CxxRef/channel__handle_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/channel_handle.hpp</code></p>"},{"location":"CxxRef/channel__handle_8hpp_source/","title":"File channel_handle.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; channel_handle.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_CHANNEL_HANDLE_HPP_\n#define ZMBT_MAPPING_CHANNEL_HANDLE_HPP_\n\n#include &lt;list&gt;\n#include &lt;boost/json.hpp&gt;\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/model/environment.hpp\"\n#include \"zmbt/expr.hpp\"\n\nnamespace zmbt {\nnamespace mapping {\n\n\nclass ChannelHandle\n{\n    JsonNode data_;\n    Environment env;\n\npublic:\n    using ConditionPipe = std::list&lt;ChannelHandle&gt;;\n    using Kind = ChannelKind;\n\n    ~ChannelHandle() = default;\n    ChannelHandle(JsonNode&amp; model, boost::json::string_view cnl_ptr);\n\n    boost::json::string key() const;\n\n    object_id host() const;\n    interface_id interface() const;\n    boost::json::string full_path() const;\n    boost::json::string signal_path() const;\n    Kind kind() const;\n\n    bool operator==(boost::json::value const&amp; v) const;\n\n    operator boost::json::value() const\n    {\n        return data_.node();\n    }\n\n    std::size_t index() const;\n    boost::json::value alias() const;\n\n    boost::json::array captures() const;\n\n    lang::Expression transform() const;\n\n    Environment::InterfaceHandle inerface_handle() const;\n\n};\n\n\n\n} // namespace mapping\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/model__definition_8hpp/","title":"File model_definition.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"model_definition_helper.hpp\"</code></li> </ul>"},{"location":"CxxRef/model__definition_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/model__definition_8hpp/#classes","title":"Classes","text":"Type Name class ModelDefinition Mapping model definition machine."},{"location":"CxxRef/model__definition_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024-2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0</p> <p>Autogenerated file - do not change!</p> <p>app: codegen.expr template: codegen/mdm/templates/model_definition.hpp</p> <p>How to update: * Update the template * Run <code>python -m codegen</code> in the project root * Commit changes </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition.hpp</code></p>"},{"location":"CxxRef/model__definition_8hpp_source/","title":"File model_definition.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_MODEL_DEFINITION_HPP_\n#define ZMBT_MAPPING_MODEL_DEFINITION_HPP_\n\n#include \"model_definition_helper.hpp\"\n\n\n\nnamespace zmbt {\nnamespace mapping {\n\nclass ModelDefinition\n{\n\n\n    class BaseTransition;\n\n    friend class SignalMapping;\n\n    struct N_Term;\n\n    // Transition templates\n    template &lt;class Target&gt;\n    struct T_Alias;\n    template &lt;class Target&gt;\n    struct T_As;\n    template &lt;class Target&gt;\n    struct T_At;\n    template &lt;class Target&gt;\n    struct T_ContinuePipe;\n    template &lt;class Target&gt;\n    struct T_CustomParam;\n    template &lt;class Target&gt;\n    struct T_Description;\n    template &lt;class Target&gt;\n    struct T_Filter;\n    template &lt;class Target&gt;\n    struct T_OnTrigger;\n    template &lt;class Target&gt;\n    struct T_Param;\n    template &lt;class Target&gt;\n    struct T_ParamRow;\n    template &lt;class Target&gt;\n    struct T_PostRun;\n    template &lt;class Target&gt;\n    struct T_PreRun;\n    template &lt;class Target&gt;\n    struct T_Repeat;\n    template &lt;class Target&gt;\n    struct T_Take;\n    template &lt;class Target&gt;\n    struct T_TerminatePipe;\n    template &lt;class Target&gt;\n    struct T_Test;\n    template &lt;class Target&gt;\n    struct T_TestRow;\n\n// NODES forward declarations\n    class N_Descr;\n    class N_Post;\n    class N_Pre;\n    class N_Param;\n    class N_ParamTable;\n    class N_Test;\n    class N_TestTable;\n    class N_Channel;\n    class N_MaybeChannel;\n    class N_ChannelEnd;\n    class N_Decor;\n    class N_Alias;\n    class N_Take;\n    class N_Filter;\n    class N_Repeat;\n    class N_Main;\n\n};\n\n\n}  // namespace mapping\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/model__definition__helper_8hpp/","title":"File model_definition_helper.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_helper.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/interface_id.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/json_node.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/object_id.hpp&gt;</code></li> <li><code>#include &lt;zmbt/model/parameter.hpp&gt;</code></li> <li><code>#include &lt;zmbt/model/environment.hpp&gt;</code></li> <li><code>#include &lt;zmbt/expr/expression.hpp&gt;</code></li> <li><code>#include &lt;zmbt/model/traits.hpp&gt;</code></li> <li><code>#include &lt;zmbt/model/param_transform.hpp&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"CxxRef/model__definition__helper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/model__definition__helper_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_helper.hpp</code></p>"},{"location":"CxxRef/model__definition__helper_8hpp_source/","title":"File model_definition_helper.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_helper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_DEFINITION_HELPER_HPP_\n#define ZMBT_MAPPING_DEFINITION_HELPER_HPP_\n\n\n#include &lt;stdint.h&gt;\n#include &lt;boost/json.hpp&gt;\n#include &lt;zmbt/core/interface_id.hpp&gt;\n#include &lt;zmbt/core/json_node.hpp&gt;\n#include &lt;zmbt/core/object_id.hpp&gt;\n#include &lt;zmbt/model/parameter.hpp&gt;\n#include &lt;zmbt/model/environment.hpp&gt;\n#include &lt;zmbt/expr/expression.hpp&gt;\n#include &lt;zmbt/model/traits.hpp&gt;\n#include &lt;zmbt/model/param_transform.hpp&gt;\n#include &lt;functional&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace zmbt {\nnamespace mapping {\n\nnamespace detail {\nclass DefinitionHelper {\n\n  public:\n\n    std::size_t pipe_count_{0};\n    std::size_t channel_abs_count_{0}; // channels per model\n    std::size_t channel_rel_count_{0}; // channels per pipe\n    int test_column_count_{0};\n\n    boost::json::value head_pipe_type_ {};\n    std::string head_pointer_{};\n    Environment env;\n    JsonNode model;\n    JsonNode params;\n\n\n    void execute();\n\n    boost::json::array const&amp; pointers_for(Param const&amp; p);\n\n    std::string head_pointer() const\n    {\n        return head_pointer_;\n    }\n\n    boost::json::object&amp; cur_channel();\n    boost::json::object&amp; cur_pipe();\n\n\n    void set_deferred_param(boost::json::string_view node_ptr, lang::Expression const&amp; param);\n    void set_description(boost::json::string_view comment);\n    void set_comment(boost::json::string_view comment);\n    void add_task(boost::json::string_view ref, bool const pre);\n    void add_task(std::function&lt;void()&gt; fn, bool const pre);\n    void add_param_values(Param const&amp; p, boost::json::array const&amp; values);\n\n\n    template &lt;class... A&gt;\n    void add_param_values_with_transform(Param const&amp; p, A&amp;&amp;... args)\n    {\n        auto const&amp; pointers = pointers_for(p);\n        boost::json::array values {param_transform(p, pointers, std::forward&lt;A&gt;(args))...};\n        add_param_values(p, values);\n    }\n\n    void init_zip();\n\n    void init_prod();\n\n    void init_pairwise();\n    void init_parametrize();\n\n\n    enum cnl_param : uint32_t {\n        cnl_prm_none = 0,\n        cnl_prm_cal = 1U &lt;&lt; 0,\n        cnl_prm_obj = 1U &lt;&lt; 1,\n        cnl_prm_key = 1U &lt;&lt; 2,\n        cnl_prm_defer_key = 1U &lt;&lt; 3\n    };\n\n    boost::json::value handle_obj_p(object_id const&amp; obj, uint32_t&amp;)\n    {\n        return {obj};\n    }\n\n    boost::json::value handle_obj_p(Param const&amp; obj, uint32_t&amp; param_type)\n    {\n        param_type |= cnl_prm_obj;\n        return obj.to_json();\n    }\n\n    boost::json::value handle_obj_p(boost::json::string_view obj, uint32_t&amp;)\n    {\n        return {obj};\n    }\n\n    template &lt;class P&gt;\n    require_cal&lt;P, boost::json::value&gt;\n    handle_cal_p(P&amp;&amp; cal, uint32_t&amp;)\n    {\n        env.InitializeInterfaceHandlers(std::forward&lt;P&gt;(cal));\n        return {interface_id(cal)};\n    }\n\n    boost::json::value handle_cal_p(Param const&amp; cal, uint32_t&amp; param_type)\n    {\n        param_type |= cnl_prm_cal;\n        return cal.to_json();\n    }\n\n\n    boost::json::value handle_key_p(boost::json::value const node, uint32_t&amp; param_type)\n    {\n        if (Param::isParam(node))\n        {\n            param_type |= cnl_prm_key;\n        }\n        else if (!lang::Expression(node).is_literal())\n        {\n            param_type |= cnl_prm_defer_key;\n        }\n        return {node};\n    }\n\n    void continue_pipe(boost::json::string_view combo);\n\n    void add_channel_impl(boost::json::value const&amp; ifc, uint32_t const param_type);\n\n\n    template &lt;class O&gt;\n    void add_channel(O&amp;&amp; obj, Param cal)\n    {\n        uint32_t param_type = cnl_prm_none;\n        boost::json::value obj_node(handle_obj_p(obj, param_type));\n        boost::json::value cal_node(handle_cal_p(cal, param_type));\n\n        add_channel_impl({\n            {\"obj\", obj_node},\n            {\"ifc\", cal_node},\n        }, param_type);\n\n        if (cnl_prm_none == param_type) {\n            env.RegisterAnonymousInterface(interface_id(cal_node), object_id(obj_node));\n        }\n    }\n\n    template &lt;class O, class C&gt;\n    void add_channel(O&amp;&amp; obj, C&amp;&amp; cal)\n    {\n        uint32_t param_type = cnl_prm_none;\n        boost::json::value obj_node(handle_obj_p(obj, param_type));\n        boost::json::value cal_node(handle_cal_p(cal, param_type));\n\n        add_channel_impl({\n            {\"obj\", obj_node},\n            {\"ifc\", cal_node},\n        }, param_type);\n\n        if (cnl_prm_none == param_type) {\n            env.RegisterAnonymousInterface(std::forward&lt;C&gt;(cal), object_id(obj_node));\n        }\n    }\n\n    template &lt;class T&gt;\n    require_cal&lt;T&gt;\n    add_channel(T&amp;&amp; cal)\n    {\n        uint32_t param_type = cnl_prm_none;\n        boost::json::value cal_node(handle_cal_p(cal, param_type));\n\n        add_channel_impl({\n            {\"obj\", \"$(default)\"},\n            {\"ifc\", cal_node},\n        }, param_type);\n\n        if (cnl_prm_none == param_type) {\n            env.RegisterAnonymousInterface(std::forward&lt;T&gt;(cal), ifc_host_nullptr&lt;T&gt;);\n        }\n    }\n\n    template &lt;class T&gt;\n    require_not_cal&lt;T&gt;\n    add_channel(T&amp;&amp; key)\n    {\n        uint32_t param_type {cnl_prm_none};\n        boost::json::value key_node(handle_key_p(json_from(key), param_type));\n        add_channel_impl(key_node, param_type);\n    }\n\n    void set_channel_sp(boost::json::string_view kind, lang::Expression const&amp; sp);\n\n    void add_test_case(std::vector&lt;lang::Expression&gt; const&amp; tv);\n\n    void set_expr(lang::Expression const&amp; expr);\n\n    DefinitionHelper();\n\n    DefinitionHelper(DefinitionHelper const&amp;) = default;\n    DefinitionHelper(DefinitionHelper &amp;&amp;) = default;\n    DefinitionHelper(DefinitionHelper &amp;) = default;\n    DefinitionHelper&amp; operator=(DefinitionHelper const&amp;) = default;\n    DefinitionHelper&amp; operator=(DefinitionHelper &amp;&amp;) = default;\n    ~DefinitionHelper();\n\n\n};  // DefinitionHelper\n\n}  // namespace detail\n}  // namespace mapping\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/model__definition__main_8hpp/","title":"File model_definition_main.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_main.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"zmbt/expr/api.hpp\"</code></li> <li><code>#include \"zmbt/mapping/model_definition.hpp\"</code></li> <li><code>#include \"zmbt/mapping/model_definition_states.hpp\"</code></li> <li><code>#include \"zmbt/mapping/model_definition_transitions.hpp\"</code></li> </ul>"},{"location":"CxxRef/model__definition__main_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/model__definition__main_8hpp/#classes","title":"Classes","text":"Type Name class SignalMapping Signal Mapping Test Model."},{"location":"CxxRef/model__definition__main_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_main.hpp</code></p>"},{"location":"CxxRef/model__definition__main_8hpp_source/","title":"File model_definition_main.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_main.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_MODEL_DEFINITION_MAIN_HPP_\n#define ZMBT_MAPPING_MODEL_DEFINITION_MAIN_HPP_\n\n#include \"zmbt/expr/api.hpp\"\n#include \"zmbt/mapping/model_definition.hpp\"\n#include \"zmbt/mapping/model_definition_states.hpp\"\n#include \"zmbt/mapping/model_definition_transitions.hpp\"\n\n\nnamespace zmbt {\nnamespace mapping {\n\nclass SignalMapping : public ModelDefinition::N_Main\n{\n  public:\n\n    template &lt;class... T&gt;\n    SignalMapping(boost::json::string_view name, T&amp;&amp;... args) : N_Main()\n    {\n        this-&gt;state().set_deferred_param(\"/name\", name | expr::Fmt(args...));\n    }\n\n    ~SignalMapping()\n    {\n        this-&gt;state().execute();\n    }\n};\n\n\n}  // namespace mapping\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/model__definition__node_8hpp/","title":"File model_definition_node.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_node.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"zmbt/mapping/model_definition.hpp\"</code></li> </ul>"},{"location":"CxxRef/model__definition__node_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/model__definition__node_8hpp/#classes","title":"Classes","text":"Type Name class BaseTransition class N_Term"},{"location":"CxxRef/model__definition__node_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_node.hpp</code></p>"},{"location":"CxxRef/model__definition__node_8hpp_source/","title":"File model_definition_node.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_node.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_MODEL_DEFINITION_NODE_HPP_\n#define ZMBT_MAPPING_MODEL_DEFINITION_NODE_HPP_\n\n#include \"zmbt/mapping/model_definition.hpp\"\n\n\nnamespace zmbt {\nnamespace mapping {\n\n\nclass ModelDefinition::BaseTransition\n{\n  detail::DefinitionHelper mapping_;\n\n  public:\n    virtual ~BaseTransition() { };\n\n  protected:\n\n    BaseTransition(detail::DefinitionHelper &amp;&amp; m) : mapping_{m} {}\n    BaseTransition() : BaseTransition(detail::DefinitionHelper{}) {}\n    BaseTransition(BaseTransition const&amp;) = delete;\n    BaseTransition(BaseTransition&amp;&amp;) = default;\n\n    detail::DefinitionHelper&amp; state()\n    {\n        return mapping_;\n    }\n\n    template &lt;class Target&gt;\n    Target transit_to()\n    {\n        return Target(std::move(mapping_));\n    }\n};\n\n\nclass ModelDefinition::N_Term : protected virtual ModelDefinition::BaseTransition\n{\n  private:\n    friend class ModelDefinition;\n    N_Term(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Term(N_Term const&amp;) = delete;\n    N_Term(N_Term&amp;&amp;) = default;\n\n  public:\n  N_Term() : N_Term(detail::DefinitionHelper{}) {}\n    virtual ~N_Term()\n    {\n    }\n};\n\n}  // namespace mapping\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/model__definition__states_8hpp/","title":"File model_definition_states.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_states.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"zmbt/mapping/model_definition.hpp\"</code></li> <li><code>#include \"zmbt/mapping/model_definition_node.hpp\"</code></li> <li><code>#include \"zmbt/mapping/model_definition_transitions.hpp\"</code></li> </ul>"},{"location":"CxxRef/model__definition__states_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/model__definition__states_8hpp/#classes","title":"Classes","text":"Type Name class N_Alias class N_Channel class N_ChannelEnd class N_Decor class N_Descr class N_Filter class N_Main class N_MaybeChannel class N_Param class N_ParamTable class N_Post class N_Pre class N_Repeat class N_Take class N_Test class N_TestTable"},{"location":"CxxRef/model__definition__states_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024-2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0</p> <p>Autogenerated file - do not change!</p> <p>app: codegen.expr template: codegen/mdm/templates/model_definition_states.hpp</p> <p>How to update: * Update the template * Run <code>python -m codegen</code> in the project root * Commit changes </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_states.hpp</code></p>"},{"location":"CxxRef/model__definition__states_8hpp_source/","title":"File model_definition_states.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_states.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_MODEL_DEFINITION_STATES_HPP_\n#define ZMBT_MAPPING_MODEL_DEFINITION_STATES_HPP_\n\n#include \"zmbt/mapping/model_definition.hpp\"\n#include \"zmbt/mapping/model_definition_node.hpp\"\n#include \"zmbt/mapping/model_definition_transitions.hpp\"\n\nnamespace zmbt {\nnamespace mapping {\n\nclass ModelDefinition::N_Descr \n    : public ModelDefinition::N_Term\n    , public ModelDefinition::T_Description&lt;ModelDefinition::N_Term&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Descr(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Descr(N_Descr const&amp;) = delete;\n    N_Descr(N_Descr&amp;&amp;) = default;\n\n  public:\n    N_Descr() : N_Descr(detail::DefinitionHelper{}) {}\n    virtual ~N_Descr()\n    {\n    }\n};\n\nclass ModelDefinition::N_Post \n    : public ModelDefinition::N_Descr\n    , public ModelDefinition::T_PostRun&lt;ModelDefinition::N_Descr&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Post(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Post(N_Post const&amp;) = delete;\n    N_Post(N_Post&amp;&amp;) = default;\n\n  public:\n    N_Post() : N_Post(detail::DefinitionHelper{}) {}\n    virtual ~N_Post()\n    {\n    }\n};\n\nclass ModelDefinition::N_Pre \n    : public ModelDefinition::N_Post\n    , public ModelDefinition::T_PreRun&lt;ModelDefinition::N_Post&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Pre(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Pre(N_Pre const&amp;) = delete;\n    N_Pre(N_Pre&amp;&amp;) = default;\n\n  public:\n    N_Pre() : N_Pre(detail::DefinitionHelper{}) {}\n    virtual ~N_Pre()\n    {\n    }\n};\n\nclass ModelDefinition::N_Param \n    : public ModelDefinition::N_Pre\n    , public ModelDefinition::T_Param&lt;ModelDefinition::N_ParamTable&gt;\n    , public ModelDefinition::T_CustomParam&lt;ModelDefinition::N_Param&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Param(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Param(N_Param const&amp;) = delete;\n    N_Param(N_Param&amp;&amp;) = default;\n\n  public:\n    N_Param() : N_Param(detail::DefinitionHelper{}) {}\n    virtual ~N_Param()\n    {\n    }\n};\n\nclass ModelDefinition::N_ParamTable \n    : public ModelDefinition::N_Param\n    , public ModelDefinition::T_ParamRow&lt;ModelDefinition::N_ParamTable&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_ParamTable(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_ParamTable(N_ParamTable const&amp;) = delete;\n    N_ParamTable(N_ParamTable&amp;&amp;) = default;\n\n  public:\n    N_ParamTable() : N_ParamTable(detail::DefinitionHelper{}) {}\n    virtual ~N_ParamTable()\n    {\n    }\n};\n\nclass ModelDefinition::N_Test \n    : public ModelDefinition::N_Param\n    , public ModelDefinition::T_Test&lt;ModelDefinition::N_TestTable&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Test(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Test(N_Test const&amp;) = delete;\n    N_Test(N_Test&amp;&amp;) = default;\n\n  public:\n    N_Test() : N_Test(detail::DefinitionHelper{}) {}\n    virtual ~N_Test()\n    {\n    }\n};\n\nclass ModelDefinition::N_TestTable \n    : public ModelDefinition::N_Param\n    , public ModelDefinition::T_TestRow&lt;ModelDefinition::N_TestTable&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_TestTable(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_TestTable(N_TestTable const&amp;) = delete;\n    N_TestTable(N_TestTable&amp;&amp;) = default;\n\n  public:\n    N_TestTable() : N_TestTable(detail::DefinitionHelper{}) {}\n    virtual ~N_TestTable()\n    {\n    }\n};\n\nclass ModelDefinition::N_Channel \n    : public ModelDefinition::T_At&lt;ModelDefinition::N_Filter&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Channel(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Channel(N_Channel const&amp;) = delete;\n    N_Channel(N_Channel&amp;&amp;) = default;\n\n  public:\n    N_Channel() : N_Channel(detail::DefinitionHelper{}) {}\n    virtual ~N_Channel()\n    {\n    }\n};\n\nclass ModelDefinition::N_MaybeChannel \n    : public ModelDefinition::N_Test\n    , public ModelDefinition::T_At&lt;ModelDefinition::N_Filter&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_MaybeChannel(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_MaybeChannel(N_MaybeChannel const&amp;) = delete;\n    N_MaybeChannel(N_MaybeChannel&amp;&amp;) = default;\n\n  public:\n    N_MaybeChannel() : N_MaybeChannel(detail::DefinitionHelper{}) {}\n    virtual ~N_MaybeChannel()\n    {\n    }\n};\n\nclass ModelDefinition::N_ChannelEnd \n    : public ModelDefinition::T_TerminatePipe&lt;ModelDefinition::N_MaybeChannel&gt;\n    , public ModelDefinition::T_ContinuePipe&lt;ModelDefinition::N_Channel&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_ChannelEnd(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_ChannelEnd(N_ChannelEnd const&amp;) = delete;\n    N_ChannelEnd(N_ChannelEnd&amp;&amp;) = default;\n\n  public:\n    N_ChannelEnd() : N_ChannelEnd(detail::DefinitionHelper{}) {}\n    virtual ~N_ChannelEnd()\n    {\n    }\n};\n\nclass ModelDefinition::N_Decor \n    : public ModelDefinition::N_ChannelEnd\n    , public ModelDefinition::T_As&lt;ModelDefinition::N_ChannelEnd&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Decor(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Decor(N_Decor const&amp;) = delete;\n    N_Decor(N_Decor&amp;&amp;) = default;\n\n  public:\n    N_Decor() : N_Decor(detail::DefinitionHelper{}) {}\n    virtual ~N_Decor()\n    {\n    }\n};\n\nclass ModelDefinition::N_Alias \n    : public ModelDefinition::N_Decor\n    , public ModelDefinition::T_Alias&lt;ModelDefinition::N_Decor&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Alias(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Alias(N_Alias const&amp;) = delete;\n    N_Alias(N_Alias&amp;&amp;) = default;\n\n  public:\n    N_Alias() : N_Alias(detail::DefinitionHelper{}) {}\n    virtual ~N_Alias()\n    {\n    }\n};\n\nclass ModelDefinition::N_Take \n    : public ModelDefinition::N_Alias\n    , public ModelDefinition::T_Take&lt;ModelDefinition::N_Alias&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Take(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Take(N_Take const&amp;) = delete;\n    N_Take(N_Take&amp;&amp;) = default;\n\n  public:\n    N_Take() : N_Take(detail::DefinitionHelper{}) {}\n    virtual ~N_Take()\n    {\n    }\n};\n\nclass ModelDefinition::N_Filter \n    : public ModelDefinition::N_Take\n    , public ModelDefinition::T_Filter&lt;ModelDefinition::N_Take&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Filter(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Filter(N_Filter const&amp;) = delete;\n    N_Filter(N_Filter&amp;&amp;) = default;\n\n  public:\n    N_Filter() : N_Filter(detail::DefinitionHelper{}) {}\n    virtual ~N_Filter()\n    {\n    }\n};\n\nclass ModelDefinition::N_Repeat \n    : public ModelDefinition::N_MaybeChannel\n    , public ModelDefinition::T_Repeat&lt;ModelDefinition::N_MaybeChannel&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Repeat(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Repeat(N_Repeat const&amp;) = delete;\n    N_Repeat(N_Repeat&amp;&amp;) = default;\n\n  public:\n    N_Repeat() : N_Repeat(detail::DefinitionHelper{}) {}\n    virtual ~N_Repeat()\n    {\n    }\n};\n\nclass ModelDefinition::N_Main \n    : public ModelDefinition::T_OnTrigger&lt;ModelDefinition::N_Repeat&gt;\n{\n  private:\n    friend class ModelDefinition;\n    N_Main(detail::DefinitionHelper&amp;&amp; m) : ModelDefinition::BaseTransition(std::move(m))\n    {\n    }\n    N_Main(N_Main const&amp;) = delete;\n    N_Main(N_Main&amp;&amp;) = default;\n\n  public:\n    N_Main() : N_Main(detail::DefinitionHelper{}) {}\n    virtual ~N_Main()\n    {\n    }\n};\n\n\nextern template class ModelDefinition::T_Description&lt;ModelDefinition::N_Term&gt;;\nextern template class ModelDefinition::T_PostRun&lt;ModelDefinition::N_Descr&gt;;\nextern template class ModelDefinition::T_PreRun&lt;ModelDefinition::N_Post&gt;;\nextern template class ModelDefinition::T_Param&lt;ModelDefinition::N_ParamTable&gt;;\nextern template class ModelDefinition::T_CustomParam&lt;ModelDefinition::N_Param&gt;;\nextern template class ModelDefinition::T_ParamRow&lt;ModelDefinition::N_ParamTable&gt;;\nextern template class ModelDefinition::T_Test&lt;ModelDefinition::N_TestTable&gt;;\nextern template class ModelDefinition::T_TestRow&lt;ModelDefinition::N_TestTable&gt;;\nextern template class ModelDefinition::T_At&lt;ModelDefinition::N_Filter&gt;;\nextern template class ModelDefinition::T_TerminatePipe&lt;ModelDefinition::N_MaybeChannel&gt;;\nextern template class ModelDefinition::T_ContinuePipe&lt;ModelDefinition::N_Channel&gt;;\nextern template class ModelDefinition::T_As&lt;ModelDefinition::N_ChannelEnd&gt;;\nextern template class ModelDefinition::T_Alias&lt;ModelDefinition::N_Decor&gt;;\nextern template class ModelDefinition::T_Take&lt;ModelDefinition::N_Alias&gt;;\nextern template class ModelDefinition::T_Filter&lt;ModelDefinition::N_Take&gt;;\nextern template class ModelDefinition::T_Repeat&lt;ModelDefinition::N_MaybeChannel&gt;;\nextern template class ModelDefinition::T_OnTrigger&lt;ModelDefinition::N_Repeat&gt;;\n\n}  // namespace mapping\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/model__definition__transitions_8hpp/","title":"File model_definition_transitions.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_transitions.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;boost/mp11.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/aliases.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/format_string.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/json_node.hpp&gt;</code></li> <li><code>#include &lt;zmbt/expr/expression.hpp&gt;</code></li> <li><code>#include &lt;zmbt/expr/api.hpp&gt;</code></li> <li><code>#include &lt;zmbt/expr/operator.hpp&gt;</code></li> <li><code>#include &lt;zmbt/model/parameter.hpp&gt;</code></li> <li><code>#include &lt;zmbt/model/traits.hpp&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"model_definition_helper.hpp\"</code></li> <li><code>#include \"zmbt/mapping/model_definition.hpp\"</code></li> <li><code>#include \"zmbt/mapping/model_definition_node.hpp\"</code></li> </ul>"},{"location":"CxxRef/model__definition__transitions_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/model__definition__transitions_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/model_definition_transitions.hpp</code></p>"},{"location":"CxxRef/model__definition__transitions_8hpp_source/","title":"File model_definition_transitions.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; model_definition_transitions.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_MODEL_DEFINITION_TRANSITIONS_HPP_\n#define ZMBT_MAPPING_MODEL_DEFINITION_TRANSITIONS_HPP_\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;boost/mp11.hpp&gt;\n#include &lt;zmbt/core/aliases.hpp&gt;\n#include &lt;zmbt/core/format_string.hpp&gt;\n#include &lt;zmbt/core/json_node.hpp&gt;\n#include &lt;zmbt/expr/expression.hpp&gt;\n#include &lt;zmbt/expr/api.hpp&gt;\n#include &lt;zmbt/expr/operator.hpp&gt;\n#include &lt;zmbt/model/parameter.hpp&gt;\n#include &lt;zmbt/model/traits.hpp&gt;\n#include &lt;cstddef&gt;\n#include &lt;tuple&gt;\n#include &lt;utility&gt;\n\n#include \"model_definition_helper.hpp\"\n#include \"zmbt/mapping/model_definition.hpp\"\n#include \"zmbt/mapping/model_definition_node.hpp\"\n\n\n\nnamespace zmbt {\nnamespace mapping {\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_OnTrigger : protected virtual ModelDefinition::BaseTransition\n{\n\n    template &lt;class... T&gt;\n    Target OnTrigger(boost::json::string_view key, T&amp;&amp;... fmtargs)\n    {\n        state().set_deferred_param(\"/trigger\", key | expr::Fmt(fmtargs...));\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target OnTrigger(Param const&amp; key)\n    {\n        state().params.get_or_create_array(\"/%s/pointers\", key).push_back(\"/trigger\");\n        state().model(\"/trigger\") = key;\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target OnTrigger(Param const&amp; ifc, Param const&amp; obj)\n    {\n        state().model(\"/trigger\") = {\n            {\"obj\", obj},\n            {\"ifc\", ifc},\n        };\n        state().params.get_or_create_array(\"/%s/pointers\", obj).push_back(\"/trigger/obj\");\n        state().params.get_or_create_array(\"/%s/pointers\", ifc).push_back(\"/trigger/ifc\");\n        return transit_to&lt;Target&gt;();\n    }\n\n\n    template &lt;class O, class Interface&gt;\n    require_literal&lt;O, Interface, Target&gt;\n    OnTrigger(Interface&amp;&amp; ifc, O&amp;&amp; obj) {\n        auto key = state().env.RegisterAnonymousTrigger(ifc, obj);\n        return OnTrigger(key);\n    }\n\n    template &lt;class Interface&gt;\n    require_cal&lt;Interface, Target&gt;\n    OnTrigger(Interface&amp;&amp; ifc) {\n        static_assert(!is_member_pointer&lt;Interface&gt;::value, \"\");\n        return OnTrigger(std::forward&lt;Interface&gt;(ifc), ifc_host_nullptr&lt;Interface&gt;);\n    }\n\n\n    template &lt;class Interface&gt;\n    require_cal&lt;Interface, Target&gt;\n    OnTrigger(Interface&amp;&amp; ifc, Param const&amp; obj)\n    {\n        state().model(\"/trigger\") = {\n            {\"ifc\", state().env.RegisterParametricTriggerIfc(ifc)}\n        };\n        state().params.get_or_create_array(\"/%s/pointers\", obj).push_back(\"/trigger/obj\");\n        return transit_to&lt;Target&gt;();\n    }\n\n    template &lt;class H&gt;\n    require_obj&lt;H, Target&gt;\n    OnTrigger(Param const&amp; ifc, H&amp;&amp; obj)\n    {\n        state().model(\"/trigger\") = {\n            {\"obj\", state().env.RegisterParametricTriggerObj(obj)}\n        };\n        state().params.get_or_create_array(\"/%s/pointers\", ifc).push_back(\"/trigger/ifc\");\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_Repeat : protected virtual ModelDefinition::BaseTransition\n{\n    Target Repeat(std::size_t N)\n    {\n        state().model(\"/repeat_trigger\") = N;\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target Repeat(Param const&amp; N)\n    {\n        state().model(\"/repeat_trigger\") = N;\n        state().params.get_or_create_array(\"/%s/pointers\", N).push_back(\"/repeat_trigger\");\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_Filter : protected virtual ModelDefinition::BaseTransition\n{\n\n    Target Return(lang::Expression const&amp; e = \"\")\n    {\n        state().set_channel_sp(\"return\", e);\n        return transit_to&lt;Target&gt;();\n    }\n\n    template &lt;class T, class... Rest&gt;\n    Target Return(boost::json::string_view fmt, T&amp;&amp; arg1, Rest&amp;&amp;... args_rest)\n    {\n        return Return(fmt | expr::Fmt(arg1, args_rest...));\n    }\n\n    Target Args(lang::Expression const&amp; e = \"$(default)\")\n    {\n        state().set_channel_sp(\"args\", e);\n        return transit_to&lt;Target&gt;();\n    }\n\n    template &lt;class T, class... Rest&gt;\n    Target Args(boost::json::string_view fmt, T&amp;&amp; arg1, Rest&amp;&amp;... args_rest)\n    {\n        return Args(fmt | expr::Fmt(arg1, args_rest...));\n    }\n\n    Target Exception()\n    {\n        state().cur_channel()[\"kind\"] = \"exception\";\n        state().cur_channel()[\"signal_path\"] = \"\";\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target Timestamp()\n    {\n        state().cur_channel()[\"kind\"] = \"ts\";\n        state().cur_channel()[\"signal_path\"] = \"\";\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target ThreadId()\n    {\n        state().cur_channel()[\"kind\"] = \"tid\";\n        state().cur_channel()[\"signal_path\"] = \"\";\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target CallCount()\n    {\n        state().cur_channel()[\"kind\"] = \"call_count\";\n        state().cur_channel()[\"signal_path\"] = \"\";\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_As : protected virtual ModelDefinition::BaseTransition\n{\n    Target As(boost::json::string_view ref)\n    {\n        state().cur_pipe()[\"overload\"] = ref;\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target As(lang::Operator const&amp; op)\n    {\n        return As(op.annotation());\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_Take : protected virtual ModelDefinition::BaseTransition\n{\n    Target Take(lang::Expression const&amp; expr)\n    {\n        state().set_deferred_param(format(\"%s/transform\", state().head_pointer()), expr);\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_Alias : protected virtual ModelDefinition::BaseTransition\n{\n    Target Alias(boost::json::string_view alias)\n    {\n        state().cur_channel()[\"alias\"] = alias;\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_At : protected virtual ModelDefinition::BaseTransition\n{\n    template &lt;class Interface&gt;\n    require_not_str&lt;Interface, Target&gt;\n    At(Interface&amp;&amp; cal, object_id const&amp; obj)\n    {\n        state().add_channel(obj, std::forward&lt;Interface&gt;(cal));\n        return transit_to&lt;Target&gt;();\n    }\n\n    template &lt;class Interface&gt;\n    require_not_str&lt;Interface, Target&gt;\n    At(Interface&amp;&amp; cal, Param const&amp; obj)\n    {\n        state().add_channel(obj, std::forward&lt;Interface&gt;(cal));\n        return transit_to&lt;Target&gt;();\n    }\n\n\n    template &lt;class Interface&gt;\n    require_not_str&lt;Interface, Target&gt;\n    At(Interface&amp;&amp; cal)\n    {\n        state().add_channel(std::forward&lt;Interface&gt;(cal));\n        return transit_to&lt;Target&gt;();\n    }\n\n    template &lt;class... T&gt;\n    Target\n    At(boost::json::string_view key, T&amp;&amp;... fmtargs)\n    {\n        state().add_channel(key | expr::Fmt(fmtargs...));\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_ContinuePipe : protected virtual ModelDefinition::BaseTransition\n{\n    Target Blend()\n    {\n        state().continue_pipe(\"blend\");\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target Group()\n    {\n        state().continue_pipe(\"group\");\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_TerminatePipe : protected virtual ModelDefinition::BaseTransition\n{\n    Target Inject()\n    {\n        state().head_pipe_type_.emplace_null();\n        state().cur_pipe()[\"column\"] = state().test_column_count_++;\n        state().cur_pipe()[\"role\"] = \"inject\";\n        return transit_to&lt;Target&gt;();\n    }\n    Target Inject(lang::Expression const&amp; expr)\n    {\n        state().head_pipe_type_.emplace_null();\n        state().cur_pipe()[\"role\"] = \"inject\";\n        state().set_expr(expr);\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target Expect()\n    {\n        state().head_pipe_type_.emplace_null();\n        state().cur_pipe()[\"column\"] = state().test_column_count_++;\n        state().cur_pipe()[\"role\"] = \"expect\";\n        return transit_to&lt;Target&gt;();\n    }\n    Target Expect(lang::Expression const&amp; expr)\n    {\n        state().head_pipe_type_.emplace_null();\n        state().cur_pipe()[\"role\"] = \"expect\";\n        state().set_expr(expr);\n        return transit_to&lt;Target&gt;();\n    }\n\n    // TODO: add Assert* clauses\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_Test : protected virtual ModelDefinition::BaseTransition\n{\n    Target Test()\n    {\n        return transit_to&lt;Target&gt;()();\n    }\n    Target Test(lang::Expression const&amp; e0)\n    {\n        return transit_to&lt;Target&gt;()(e0);\n    }\n    Target Test(lang::Expression const&amp; e0, lang::Expression const&amp; e1)\n    {\n        return transit_to&lt;Target&gt;()(e0, e1);\n    }\n    Target Test(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2)\n    {\n        return transit_to&lt;Target&gt;()(e0, e1, e2);\n    }\n    Target Test(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3)\n    {\n        return transit_to&lt;Target&gt;()(e0, e1, e2, e3);\n    }\n    Target Test(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                    lang::Expression const&amp; e4)\n    {\n        return transit_to&lt;Target&gt;()(e0, e1, e2, e3, e4);\n    }\n    Target Test(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                    lang::Expression const&amp; e4, lang::Expression const&amp; e5)\n    {\n        return transit_to&lt;Target&gt;()(e0, e1, e2, e3, e4, e5);\n    }\n    Target Test(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                    lang::Expression const&amp; e4, lang::Expression const&amp; e5, lang::Expression const&amp; e6)\n    {\n        return transit_to&lt;Target&gt;()(e0, e1, e2, e3, e4, e5, e6);\n    }\n    Target Test(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                    lang::Expression const&amp; e4, lang::Expression const&amp; e5, lang::Expression const&amp; e6, lang::Expression const&amp; e7)\n    {\n        return transit_to&lt;Target&gt;()(e0, e1, e2, e3, e4, e5, e6, e7);\n    }\n\n    template &lt;class... Rest&gt;\n    Target Test(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                    lang::Expression const&amp; e4, lang::Expression const&amp; e5, lang::Expression const&amp; e6, lang::Expression const&amp; e7,\n                    Rest&amp;&amp;... rest)\n    {\n        return transit_to&lt;Target&gt;()(e0, e1, e2, e3, e4, e5, e6, e7, lang::Expression(rest)...);\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_TestRow : protected virtual ModelDefinition::BaseTransition\n{\n    Target operator[](boost::json::string_view comment)\n    {\n        state().set_comment(comment);\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target operator()()\n    {\n        state().add_test_case({});\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target operator()(lang::Expression const&amp; e0)\n    {\n        state().add_test_case({e0});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(lang::Expression const&amp; e0, lang::Expression const&amp; e1)\n    {\n        state().add_test_case({e0, e1});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2)\n    {\n        state().add_test_case({e0, e1, e2});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3)\n    {\n        state().add_test_case({e0, e1, e2, e3});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                          lang::Expression const&amp; e4)\n    {\n        state().add_test_case({e0, e1, e2, e3, e4});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                          lang::Expression const&amp; e4, lang::Expression const&amp; e5)\n    {\n        state().add_test_case({e0, e1, e2, e3, e4, e5});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                          lang::Expression const&amp; e4, lang::Expression const&amp; e5, lang::Expression const&amp; e6)\n    {\n        state().add_test_case({e0, e1, e2, e3, e4, e5, e6});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                          lang::Expression const&amp; e4, lang::Expression const&amp; e5, lang::Expression const&amp; e6, lang::Expression const&amp; e7)\n    {\n        state().add_test_case({e0, e1, e2, e3, e4, e5, e6, e7});\n        return transit_to&lt;Target&gt;();\n    }\n\n    template &lt;class... Rest&gt;\n    Target operator()(lang::Expression const&amp; e0, lang::Expression const&amp; e1, lang::Expression const&amp; e2, lang::Expression const&amp; e3,\n                          lang::Expression const&amp; e4, lang::Expression const&amp; e5, lang::Expression const&amp; e6, lang::Expression const&amp; e7,\n                          Rest&amp;&amp;... rest)\n    {\n        state().add_test_case({e0, e1, e2, e3, e4, e5, e6, e7, lang::Expression(rest)...});\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_Description : protected virtual ModelDefinition::BaseTransition\n{\n    template &lt;class... T&gt;\n    Target Description(boost::json::string_view comment, T&amp;&amp;... args)\n    {\n        state().set_deferred_param(\"/description\", comment | expr::Fmt(args...));\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_Param : protected virtual ModelDefinition::BaseTransition\n{\n\n    Target Zip(Param const&amp; p, boost::json::value const&amp; v0)\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, v0);\n    }\n    Target Zip(Param const&amp; p, boost::json::value const&amp; v0, boost::json::value const&amp; v1)\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, v0, v1);\n    }\n\n    Target Zip(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2\n    )\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2);\n    }\n    Target Zip(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3\n    )\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3);\n    }\n    Target Zip(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4\n    )\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4);\n    }\n    Target Zip(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5\n    )\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5);\n    }\n    Target Zip(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6\n    )\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5, v6);\n    }\n    Target Zip(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6,\n        boost::json::value const&amp; v7\n    )\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5, v6, v7);\n    }\n\n    template &lt;class... A&gt;\n    Target Zip(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6,\n        boost::json::value const&amp; v7,\n        A&amp;&amp;... args\n    )\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5, v6, v7, std::forward&lt;A&gt;(args)...);\n    }\n    template &lt;class... A&gt;\n    Target Zip(Param const&amp; p, A&amp;&amp;... args)\n    {\n        state().init_zip();\n        return transit_to&lt;Target&gt;()(p, std::forward&lt;A&gt;(args)...);\n    }\n\n    Target Prod(Param const&amp; p, boost::json::value const&amp; v0)\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, v0);\n    }\n    Target Prod(Param const&amp; p, boost::json::value const&amp; v0, boost::json::value const&amp; v1)\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, v0, v1);\n    }\n\n    Target Prod(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2\n    )\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2);\n    }\n    Target Prod(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3\n    )\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3);\n    }\n    Target Prod(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4\n    )\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4);\n    }\n    Target Prod(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5\n    )\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5);\n    }\n    Target Prod(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6\n    )\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5, v6);\n    }\n    Target Prod(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6,\n        boost::json::value const&amp; v7\n    )\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5, v6, v7);\n    }\n\n    template &lt;class... A&gt;\n    Target Prod(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6,\n        boost::json::value const&amp; v7,\n        A&amp;&amp;... args\n    )\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5, v6, v7, std::forward&lt;A&gt;(args)...);\n    }\n    template &lt;class... A&gt;\n    Target Prod(Param const&amp; p, A&amp;&amp;... args)\n    {\n        state().init_prod();\n        return transit_to&lt;Target&gt;()(p, std::forward&lt;A&gt;(args)...);\n    }\n\n    Target Pairwise(Param const&amp; p, boost::json::value const&amp; v0)\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, v0);\n    }\n    Target Pairwise(Param const&amp; p, boost::json::value const&amp; v0, boost::json::value const&amp; v1)\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, v0, v1);\n    }\n\n    Target Pairwise(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2\n    )\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2);\n    }\n    Target Pairwise(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3\n    )\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3);\n    }\n    Target Pairwise(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4\n    )\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4);\n    }\n    Target Pairwise(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5\n    )\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5);\n    }\n    Target Pairwise(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6\n    )\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5, v6);\n    }\n    Target Pairwise(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6,\n        boost::json::value const&amp; v7\n    )\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5, v6, v7);\n    }\n\n    template &lt;class... A&gt;\n    Target Pairwise(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6,\n        boost::json::value const&amp; v7,\n        A&amp;&amp;... args\n    )\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, v0, v1, v2, v3, v4, v5, v6, v7, std::forward&lt;A&gt;(args)...);\n    }\n    template &lt;class... A&gt;\n    Target Pairwise(Param const&amp; p, A&amp;&amp;... args)\n    {\n        state().init_pairwise();\n        return transit_to&lt;Target&gt;()(p, std::forward&lt;A&gt;(args)...);\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_CustomParam : protected virtual ModelDefinition::BaseTransition\n{\n    Target Parametrize(lang::Expression const&amp;)\n    {\n        state().init_parametrize();\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_ParamRow : protected virtual ModelDefinition::BaseTransition\n{\n    template &lt;class... A&gt;\n    Target operator()(Param const&amp; p, A&amp;&amp;... args)\n    {\n        state().add_param_values_with_transform(p, args...);\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target operator()(Param const&amp; p, boost::json::value const&amp; v0)\n    {\n        state().add_param_values(p, boost::json::array{v0});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(Param const&amp; p, boost::json::value const&amp; v0, boost::json::value const&amp; v1)\n    {\n        state().add_param_values(p, {v0, v1});\n        return transit_to&lt;Target&gt;();\n    }\n\n    Target operator()(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2\n    )\n    {\n        state().add_param_values(p, {v0, v1, v2});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3\n    )\n    {\n        state().add_param_values(p, {v0, v1, v2, v3});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4\n    )\n    {\n        state().add_param_values(p, {v0, v1, v2, v3, v4});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5\n    )\n    {\n        state().add_param_values(p, {v0, v1, v2, v3, v4, v5});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6\n    )\n    {\n        state().add_param_values(p, {v0, v1, v2, v3, v4, v5, v6});\n        return transit_to&lt;Target&gt;();\n    }\n    Target operator()(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6,\n        boost::json::value const&amp; v7\n    )\n    {\n        state().add_param_values(p, {v0, v1, v2, v3, v4, v5, v6, v7});\n        return transit_to&lt;Target&gt;();\n    }\n    template &lt;class... A&gt;\n    Target operator()(Param const&amp; p,\n        boost::json::value const&amp; v0,\n        boost::json::value const&amp; v1,\n        boost::json::value const&amp; v2,\n        boost::json::value const&amp; v3,\n        boost::json::value const&amp; v4,\n        boost::json::value const&amp; v5,\n        boost::json::value const&amp; v6,\n        boost::json::value const&amp; v7,\n        A&amp;&amp;... args\n    )\n    {\n        state().add_param_values_with_transform(p, v0, v1, v2, v3, v4, v5, v6, v7, std::forward&lt;A&gt;(args)...);\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_PreRun : protected virtual ModelDefinition::BaseTransition\n{\n    template &lt;class... T&gt;\n    Target PreRun(T&amp;&amp;... tasks)\n    {\n        boost::mp11::tuple_for_each(std::forward_as_tuple(tasks...), [&amp;](auto&amp;&amp; task) { state().add_task(task, true); });\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n\ntemplate &lt;class Target&gt;\nstruct ModelDefinition::T_PostRun : protected virtual ModelDefinition::BaseTransition\n{\n    template &lt;class... T&gt;\n    Target PostRun(T&amp;&amp;... tasks)\n    {\n        boost::mp11::tuple_for_each(std::forward_as_tuple(tasks...), [&amp;](auto&amp;&amp; task) { state().add_task(task, false); });\n        return transit_to&lt;Target&gt;();\n    }\n};\n\n}  // namespace mapping\n}  // namespace zmbt\n\n\n#endif\n</code></pre>"},{"location":"CxxRef/pipe__handle_8hpp/","title":"File pipe_handle.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; pipe_handle.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/model/environment.hpp\"</code></li> <li><code>#include \"zmbt/expr.hpp\"</code></li> <li><code>#include \"channel_handle.hpp\"</code></li> </ul>"},{"location":"CxxRef/pipe__handle_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/pipe__handle_8hpp/#classes","title":"Classes","text":"Type Name class PipeHandle Pipe clause handle for SignalMapping model."},{"location":"CxxRef/pipe__handle_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/pipe_handle.hpp</code></p>"},{"location":"CxxRef/pipe__handle_8hpp_source/","title":"File pipe_handle.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; pipe_handle.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_PIPE_HANDLE_HPP_\n#define ZMBT_MAPPING_PIPE_HANDLE_HPP_\n\n#include &lt;list&gt;\n#include &lt;boost/json.hpp&gt;\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/model/environment.hpp\"\n#include \"zmbt/expr.hpp\"\n#include \"channel_handle.hpp\"\n\n\nnamespace zmbt {\nnamespace mapping {\n\n\nclass PipeHandle\n{\n    JsonNode data_;\n    Environment env;\n    bool should_flatten_;\n\n    std::list&lt;ChannelHandle&gt; channels_;\n    boost::json::value observe_blend() const;\n\n\npublic:\n\n\n    PipeHandle(JsonNode&amp; model, std::size_t const pipe_idx);\n\n    ~PipeHandle() = default;\n\n    boost::json::value type() const;\n    bool is_input() const;\n    bool is_output() const;\n    bool has_expression() const;\n    lang::Expression expression() const;\n    bool overload(lang::Expression&amp; e) const;\n\n    void inject(lang::Expression expr) const;\n    boost::json::value observe() const;\n\n    int column() const;\n    boost::json::value index() const;\n\n    std::list&lt;ChannelHandle&gt; const&amp; channels() const\n    {\n        return channels_;\n    }\n\n};\n\n\n} // namespace mapping\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/test__diagnostics_8hpp/","title":"File test_diagnostics.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; test_diagnostics.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;zmbt/expr/expression.hpp&gt;</code></li> <li><code>#include &lt;zmbt/expr/eval_log.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/test__diagnostics_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/test__diagnostics_8hpp/#classes","title":"Classes","text":"Type Name struct TestDiagnostics Test diagnostics for test case execution."},{"location":"CxxRef/test__diagnostics_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/test_diagnostics.hpp</code></p>"},{"location":"CxxRef/test__diagnostics_8hpp_source/","title":"File test_diagnostics.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; test_diagnostics.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_TEST_DIAGNOSTICS_HPP_\n#define ZMBT_MAPPING_TEST_DIAGNOSTICS_HPP_\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;zmbt/expr/expression.hpp&gt;\n#include &lt;zmbt/expr/eval_log.hpp&gt;\n\nnamespace zmbt {\nnamespace mapping {\n\nstruct TestDiagnostics\n{\n    enum class Result\n    {\n        Success,\n        Fail,\n        Error\n    };\n\n    // print_string(\"model\");\n    // print_string(\"message\");\n    // print_js_section(\"expected\");\n    // print_js_section(\"observed\");\n\n    // os &lt;&lt; prefix &lt;&lt; \"condition: [\" &lt;&lt; sts.at(\"test\") &lt;&lt; \",\" &lt;&lt; sts.at(\"channel\") &lt;&lt; \"]\";\n\n    // print_string(\"description\");\n    // print_string(\"comment\");\n\n    // print_js_section(\"test vector\");\n\n    // auto const&amp; eval_stack = sts.at(\"eval_stack\").as_array();\n\n\n    boost::json::string model_name;\n    boost::json::string message    {};\n    boost::json::string description{};\n    boost::json::string comment    {};\n\n    boost::json::value expected    {};\n    boost::json::value observed    {};\n    boost::json::value vector      {};\n    boost::json::value error      {};\n    size_t tr  {};\n    size_t tc  {};\n\n    boost::json::value channel_id  {};\n    boost::json::value pipe_id  {};\n\n    boost::json::array eval_stack  {};\n    Result result                  {};\n    bool tabular_condition_failure_{};\n\n\n    TestDiagnostics(boost::json::string_view model_name) : model_name{model_name} {}\n\n    TestDiagnostics(TestDiagnostics const&amp;) = default;\n    TestDiagnostics(TestDiagnostics &amp;&amp;) = default;\n\n    TestDiagnostics&amp; operator=(TestDiagnostics const&amp;) = default;\n    TestDiagnostics&amp; operator=(TestDiagnostics &amp;&amp;) = default;\n    ~TestDiagnostics() = default;\n\n    TestDiagnostics&amp; Description(boost::json::string_view msg)\n    {\n        this-&gt;description = msg; return *this;\n    }\n\n    TestDiagnostics&amp; Comment(boost::json::string_view msg)\n    {\n        this-&gt;comment = msg; return *this;\n    }\n\n    TestDiagnostics&amp; Vector(boost::json::value val)\n    {\n        this-&gt;vector = val; return *this;\n    }\n    TestDiagnostics&amp; TabularConditionFailure(std::size_t const col)\n    {\n        tabular_condition_failure_ = true;\n        this-&gt;tc = col; return *this;\n    }\n    TestDiagnostics&amp; TestRow(std::size_t const r)\n    {\n        this-&gt;tr = r; return *this;\n    }\n    TestDiagnostics&amp; ChannelId(boost::json::value const&amp; id)\n    {\n        this-&gt;channel_id = id; return *this;\n    }\n    TestDiagnostics&amp; PipeId(boost::json::value const&amp; id)\n    {\n        this-&gt;pipe_id = id; return *this;\n    }\n    TestDiagnostics&amp; EvalStack(lang::EvalLog const&amp; log)\n    {\n        if (log.stack)\n        {\n            this-&gt;eval_stack = *log.stack;\n        }\n        return *this;\n    }\n\n    TestDiagnostics&amp; Error(boost::json::string_view origin, boost::json::value const&amp; err);\n\n    TestDiagnostics&amp; Fail(lang::Expression const&amp; expected, boost::json::value const&amp; observed);\n\n    boost::json::value to_json() const;\n};\n\n} // namespace mapping\n} // namespace zmbt\n\n#endif // ZMBT_MAPPING_EXPECT_VARIANTS_HPP_\n</code></pre>"},{"location":"CxxRef/test__parameter__resolver_8hpp/","title":"File test_parameter_resolver.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; test_parameter_resolver.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;zmbt/core/json_iter.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/json_node.hpp&gt;</code></li> <li><code>#include &lt;zmbt/model/environment.hpp&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"CxxRef/test__parameter__resolver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/test__parameter__resolver_8hpp/#classes","title":"Classes","text":"Type Name class TestParameterResolver Test spec generator that handles parameter resolution."},{"location":"CxxRef/test__parameter__resolver_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/test_parameter_resolver.hpp</code></p>"},{"location":"CxxRef/test__parameter__resolver_8hpp_source/","title":"File test_parameter_resolver.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; test_parameter_resolver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_TEST_PARAMETER_RESOLVER_HPP_\n#define ZMBT_MAPPING_TEST_PARAMETER_RESOLVER_HPP_\n\n#include &lt;zmbt/core/json_iter.hpp&gt;\n#include &lt;zmbt/core/json_node.hpp&gt;\n#include &lt;zmbt/model/environment.hpp&gt;\n#include &lt;list&gt;\n#include &lt;memory&gt;\n\nnamespace zmbt {\nnamespace mapping {\n\nclass TestParameterResolver\n{\n    JsonNode model_;\n    std::list&lt;std::shared_ptr&lt;JsonIter&gt;&gt; iterators_{};\n    Environment env{};\n\n    void log_debug(JsonNode next_model);\n    void resolve_deferred_params(JsonNode&amp; next_model);\n    void init_param_iters();\n\npublic:\n\n    TestParameterResolver(JsonNode const&amp; model);\n    JsonNode Next();\n};\n\n\n} // namespace mapping\n} // namespace zmbt\n\n#endif // ZMBT_MAPPING_RESOLVER_HPP_\n</code></pre>"},{"location":"CxxRef/test__runner_8hpp/","title":"File test_runner.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; test_runner.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> </ul>"},{"location":"CxxRef/test__runner_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace mapping Signal Mapping model functionality."},{"location":"CxxRef/test__runner_8hpp/#classes","title":"Classes","text":"Type Name class TestRunner Test runner for SignalMapping model."},{"location":"CxxRef/test__runner_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/mapping/test_runner.hpp</code></p>"},{"location":"CxxRef/test__runner_8hpp_source/","title":"File test_runner.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; mapping &gt; test_runner.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MAPPING_TEST_RUNNER_HPP_\n#define ZMBT_MAPPING_TEST_RUNNER_HPP_\n\n#include &lt;memory&gt;\n#include \"zmbt/core.hpp\"\n\nnamespace zmbt {\nnamespace mapping {\n\nclass TestRunner\n{\n    class Impl;\n\n    std::unique_ptr&lt;Impl&gt; impl_;\n\npublic:\n    TestRunner(JsonNode const&amp; model);\n    void Run();\n    ~TestRunner();\n};\n\n} // namespace mapping\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/dir_b97e8e9bc83032fe6d4e26779db64c76/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model</p>"},{"location":"CxxRef/dir_b97e8e9bc83032fe6d4e26779db64c76/#files","title":"Files","text":"Type Name file channel_kind.hpp file environment.hpp file environment_data.hpp file environment_interface_record.hpp file error_info.hpp file error_or_return.hpp file exceptions.hpp file generator.hpp file global_flags.hpp file global_stats.hpp file injection_table.hpp file output_recorder.hpp file param_transform.hpp file parameter.hpp file permanent_data.hpp file traits.hpp file trigger.hpp <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/</code></p>"},{"location":"CxxRef/channel__kind_8hpp/","title":"File channel_kind.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; channel_kind.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"zmbt/reflect.hpp\"</code></li> </ul>"},{"location":"CxxRef/channel__kind_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/channel__kind_8hpp/#classes","title":"Classes","text":"Type Name struct custom_serialization&lt; ChannelKind &gt; &lt;&gt;"},{"location":"CxxRef/channel__kind_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/channel_kind.hpp</code></p>"},{"location":"CxxRef/channel__kind_8hpp_source/","title":"File channel_kind.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; channel_kind.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_CHANNEL_KIND_HPP_\n#define ZMBT_MODEL_CHANNEL_KIND_HPP_\n\n\n#include \"zmbt/reflect.hpp\"\n\nnamespace zmbt {\n\nenum class ChannelKind : unsigned\n{\n    // Injectable and observable channels\n\n    Args, Return, Exception,\n\n    // Observable-only channels\n\n    Timestamp, ThreadId, CallCount,\n    Undefined\n};\n\n\n\ntemplate&lt;&gt;\nstruct reflect::custom_serialization&lt;ChannelKind&gt; {\n\n    static boost::json::value\n    json_from(ChannelKind const&amp; k)\n    {\n        switch(k)\n        {\n            case ChannelKind::Args:       return \"args\";\n            case ChannelKind::Return:     return \"return\";\n            case ChannelKind::CallCount:  return \"call_count\";\n            case ChannelKind::Exception:  return \"exception\";\n            case ChannelKind::Timestamp:  return \"ts\";\n            case ChannelKind::ThreadId:   return \"tid\";\n            default:\n                return nullptr;\n        }\n    }\n\n    static ChannelKind\n    dejsonize(boost::json::value const&amp; v)\n    {\n        if(\"args\"       == v) return ChannelKind::Args;\n        if(\"return\"     == v) return ChannelKind::Return;\n        if(\"call_count\" == v) return ChannelKind::CallCount;\n        if(\"exception\"  == v) return ChannelKind::Exception;\n        if(\"ts\"         == v) return ChannelKind::Timestamp;\n        if(\"tid\"        == v) return ChannelKind::ThreadId;\n        return ChannelKind::Undefined;\n    }\n};\n\n}  // namespace zmbt\n\n#endif  // ZMBT_MODEL_CHANNEL_KIND_HPP_\n</code></pre>"},{"location":"CxxRef/environment_8hpp/","title":"File environment.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; environment.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;boost/mp11.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/aliases.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/format_string.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/interface_id.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/interface_traits.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/json_node.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/object_id.hpp&gt;</code></li> <li><code>#include &lt;zmbt/reflect/signal_traits.hpp&gt;</code></li> <li><code>#include &lt;zmbt/reflect/invocation.hpp&gt;</code></li> <li><code>#include &lt;zmbt/reflect/prototypes.hpp&gt;</code></li> <li><code>#include &lt;zmbt/reflect/serialization.hpp&gt;</code></li> <li><code>#include &lt;zmbt/expr.hpp&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iosfwd&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"environment_data.hpp\"</code></li> <li><code>#include \"exceptions.hpp\"</code></li> <li><code>#include \"trigger.hpp\"</code></li> <li><code>#include \"permanent_data.hpp\"</code></li> </ul>"},{"location":"CxxRef/environment_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/environment_8hpp/#classes","title":"Classes","text":"Type Name class Environment Controlled environment data storage."},{"location":"CxxRef/environment_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/environment.hpp</code></p>"},{"location":"CxxRef/environment_8hpp_source/","title":"File environment.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; environment.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_ENVIRONMENT_HPP_\n#define ZMBT_MODEL_ENVIRONMENT_HPP_\n\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;boost/mp11.hpp&gt;\n#include &lt;zmbt/core/aliases.hpp&gt;\n#include &lt;zmbt/core/format_string.hpp&gt;\n#include &lt;zmbt/core/interface_id.hpp&gt;\n#include &lt;zmbt/core/interface_traits.hpp&gt;\n#include &lt;zmbt/core/json_node.hpp&gt;\n#include &lt;zmbt/core/object_id.hpp&gt;\n#include &lt;zmbt/reflect/signal_traits.hpp&gt;\n#include &lt;zmbt/reflect/invocation.hpp&gt;\n#include &lt;zmbt/reflect/prototypes.hpp&gt;\n#include &lt;zmbt/reflect/serialization.hpp&gt;\n#include &lt;zmbt/expr.hpp&gt;\n#include &lt;exception&gt;\n#include &lt;functional&gt;\n#include &lt;iosfwd&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;typeindex&gt;\n#include &lt;utility&gt;\n\n#include \"environment_data.hpp\"\n#include \"exceptions.hpp\"\n#include \"trigger.hpp\"\n\n#include \"permanent_data.hpp\"\n\nnamespace zmbt {\n\n\nclass Environment {\n\n    friend class OutputRecorder;\n  protected:\n\n    using lock_t = typename EnvironmentData::lock_t;\n\n    template &lt;class Interface&gt;\n    using return_t = reflect::invocation_ret_t&lt;ifc_pointer_t&lt;Interface&gt;&gt;;\n\n    template &lt;class Interface&gt;\n    using unqf_args_t = reflect::invocation_args_unqf_t&lt;ifc_pointer_t&lt;Interface&gt;&gt;;\n\n\n    template &lt;class Interface&gt;\n    using argsref_t = reflect::invocation_args_t&lt;ifc_pointer_t&lt;Interface&gt;&gt;;\n\n    template &lt;class T&gt;\n    using rvref_to_val = mp_if&lt;std::is_rvalue_reference&lt;T&gt;, std::remove_reference_t&lt;T&gt;, T&gt;;\n\n    template &lt;class Interface&gt;\n    using hookout_args_t = mp_transform&lt;rvref_to_val, argsref_t&lt;Interface&gt;&gt;;\n\n    std::shared_ptr&lt;EnvironmentData&gt; data_;\n    std::shared_ptr&lt;PermanentEnvData&gt; permanent_data_;\n\n    void SetTestError(boost::json::value&amp;&amp; msg);\n\n  public:\n    class InterfaceHandle;\n\n    template &lt;class Interface&gt;\n    class TypedInterfaceHandle;\n\n    boost::json::value const&amp; TestError();\n\n    bool HasTestError();\n\n    JsonNode&amp; json_data()\n    {\n        return data_-&gt;json_data;\n    }\n\n    reflect::Prototypes GetPrototypes(interface_id const&amp; id) const\n    {\n        auto const maybe_proto = permanent_data_-&gt;get_prototypes(id);\n        if (!maybe_proto.has_value())\n        {\n            throw_exception(environment_error(\"accessing unregistered prototypes for `%s`\", id));\n        }\n        return maybe_proto.value();\n    }\n\n    JsonNode const&amp; json_data() const\n    {\n        return data_-&gt;json_data;\n    }\n\n    lock_t Lock() const;\n\n    lock_t TryLock() const;\n\n    lock_t DeferLock() const;\n\n    Environment();\n\n    Environment(Environment &amp;&amp;) = default;\n\n    Environment(Environment const&amp;) = default;\n\n    Environment&amp; operator=(Environment &amp;&amp;) = default;\n\n    Environment&amp; operator=(Environment const&amp;) = default;\n\n\n    virtual ~Environment()\n    {\n    }\n\n    void DumpToJsonLog();\n\n\n    void SetVar(lang::Expression const&amp; key_expr, boost::json::value var);\n\n    template &lt;class T&gt;\n    void SetVar(lang::Expression const&amp; key_expr, T var)\n    {\n        return SetVar(key_expr, json_from(var));\n    }\n\n\n    boost::json::value GetVarOrUpdate(lang::Expression const&amp; key_expr, boost::json::value update_value);\n\n    template &lt;class T&gt;\n    T GetVarOrUpdate(lang::Expression const&amp; key_expr, T update_value)\n    {\n        return dejsonize&lt;T&gt;(GetVarOrUpdate(key_expr, json_from(update_value)));\n    }\n\n\n    boost::json::value GetVarOrDefault(lang::Expression const&amp; key_expr, boost::json::value default_value = {});\n\n    template &lt;class T&gt;\n    T GetVarOrDefault(lang::Expression const&amp; key_expr, T default_value = reflect::signal_traits&lt;T&gt;::init())\n    {\n        return dejsonize&lt;T&gt;(GetVarOrDefault(key_expr, json_from(default_value)));\n    }\n\n\n    boost::json::value GetVar(lang::Expression const&amp; key_expr);\n\n    template &lt;class T&gt;\n    T GetVar(lang::Expression const&amp; key_expr)\n    {\n        return dejsonize&lt;T&gt;(GetVar(key_expr));\n    }\n\n\n    template &lt;class T&gt;\n    void SetShared(lang::Expression const&amp; key_expr, std::shared_ptr&lt;T&gt; data)\n    {\n        boost::json::string const key = key_expr.eval().as_string();\n        EnvironmentData::shared_data_record const record { typeid(T), data };\n\n        auto lock = Lock();\n\n        if (data_-&gt;shared.count(key)){\n            data_-&gt;shared.at(key) = record;\n        }\n        else {\n            data_-&gt;shared.emplace(key, record);\n        }\n    }\n\n\n    template &lt;class T&gt;\n    std::shared_ptr&lt;T&gt; GetShared(lang::Expression const&amp; key_expr) const\n    {\n        boost::json::string const key = key_expr.eval().as_string();\n        auto found = data_-&gt;shared.cend();\n        {\n            auto lock = Lock();\n            found = data_-&gt;shared.find(key);\n        }\n        if (found == data_-&gt;shared.cend())\n        {\n            return nullptr;\n        }\n\n        auto const record = found-&gt;second;\n        if (std::type_index(typeid(T)) != record.first)\n        {\n            throw_exception(environment_error(\"GetShared invoked with incompatible type for `%s`\", key));\n        }\n\n        return std::static_pointer_cast&lt;T&gt;(record.second);\n    }\n\n    template &lt;class T, class... A&gt;\n    T&amp; GetSharedRef(lang::Expression const&amp; key_expr, A&amp;&amp;... args)\n    {\n        boost::json::string const key = key_expr.eval().as_string();\n        auto lock = Lock();\n        auto found = data_-&gt;shared.find(key);\n        if (found == data_-&gt;shared.cend())\n        {\n            auto const shared = std::make_shared&lt;T&gt;(std::forward&lt;A&gt;(args)...);\n            EnvironmentData::shared_data_record const record { typeid(T), shared };\n\n            if (not data_-&gt;shared.emplace(key, record).second)\n            {\n                throw_exception(environment_error(\"GetSharedRef failed to create shared object at `%s`\", key));\n            }\n            return *shared;\n        }\n\n        auto const record = found-&gt;second;\n        if (std::type_index(typeid(T)) != record.first)\n        {\n            throw_exception(environment_error(\"GetSharedRef invoked with incompatible type for `%s`\", key));\n        }\n\n        return *std::static_pointer_cast&lt;T&gt;(record.second);\n    }\n\n    bool ContainsShared(lang::Expression const&amp; key_expr) const;\n\n\n    void ResetInterfaceData();\n\n\n    void ResetAll();\n\n\n    Environment&amp; RegisterAction(lang::Expression const&amp; key_expr, std::function&lt;void()&gt; action);\n\n\n    Environment&amp; RunAction(lang::Expression const&amp; key_expr);\n    Environment&amp; RunActionNoCatch(lang::Expression const&amp; key_expr);\n\n\n    template &lt;class Interface&gt;\n    interface_id RegisterParametricTriggerIfc(Interface&amp;&amp; interface)\n    {\n        InitializeInterfaceHandlers(std::forward&lt;Interface&gt;(interface));\n        TriggerIfc trigger_ifc{std::forward&lt;Interface&gt;(interface)};\n        interface_id ifc_id{trigger_ifc.id()};\n        auto key = format(\"/trigger_ifcs/%s\", ifc_id);\n        auto lock = Lock();\n        data_-&gt;trigger_ifcs.emplace(ifc_id, std::move(trigger_ifc));\n        data_-&gt;json_data(key) = 0; // TODO: timestamp\n        return ifc_id;\n    }\n\n    template &lt;class T&gt;\n    object_id RegisterParametricTriggerObj(T&amp;&amp; obj)\n    {\n        TriggerObj trigger_obj{std::forward&lt;T&gt;(obj)};\n        object_id obj_id{trigger_obj.id()};\n        auto key = format(\"/trigger_objs/%s\", obj_id);\n\n        auto lock = Lock();\n        data_-&gt;trigger_objs.emplace(obj_id, std::move(trigger_obj));\n        data_-&gt;json_data(key) = 0; // TODO: timestamp\n        return obj_id;\n    }\n\n    static boost::json::string autokey(object_id const&amp; obj_id, interface_id const&amp; ifc_id)\n    {\n        return {format(\"%s:%s\", obj_id.key(), ifc_id.key())};\n    }\n\n\n    template &lt;class Interface&gt;\n    std::shared_ptr&lt;OutputRecorder&gt; GetRecorder(Interface&amp;&amp; interface)\n    {\n        return GetRecorder(std::forward&lt;Interface&gt;(interface), ifc_host_nullptr&lt;Interface&gt;);\n    }\n\n    std::shared_ptr&lt;OutputRecorder&gt; GetRecorder(interface_id const&amp; ifc_id, object_id const&amp; obj_id)\n    {\n        std::shared_ptr&lt;OutputRecorder&gt; recorder;\n\n        data_-&gt;output_recorders.try_emplace_or_visit(std::make_pair(ifc_id, obj_id),\n            [&amp;recorder, &amp;ifc_id, &amp;obj_id]() -&gt; std::shared_ptr&lt;OutputRecorder&gt; {\n                recorder = std::make_shared&lt;OutputRecorder&gt;(ifc_id, obj_id);\n                return recorder;\n            },\n            [&amp;recorder](auto&amp; record){\n                recorder = record.second;\n            }\n        );\n        return recorder;\n    }\n\n    boost::json::string GetOrRegisterParametricTrigger(object_id const&amp; obj_id, interface_id const&amp; ifc_id);\n\n    template &lt;class Interface, class H&gt;\n    Environment&amp; RegisterTrigger(boost::json::string_view key, Interface&amp;&amp; interface, H&amp;&amp; host)\n    {\n\n        interface_id const ifc_id{std::forward&lt;Interface&gt;(interface)};\n        object_id const obj_id{host};\n\n        auto recorder = GetRecorder(ifc_id, obj_id);\n\n        Trigger trigger{std::forward&lt;H&gt;(host), interface, recorder};\n        auto const json_data_key = format(\"/triggers/%s\", key);\n        auto const err_msg = format(\"Trigger registering failed: key \\\"%s\\\" is taken\", key);\n        auto lock = Lock();\n        auto const trigger_found =  data_-&gt;triggers.find(key);\n        if (trigger_found != data_-&gt;triggers.cend())\n        {\n            if (trigger_found-&gt;second != trigger)\n            {\n                throw_exception(environment_error(err_msg));\n            }\n            return *this;\n        }\n        data_-&gt;triggers.emplace(key, trigger);\n        data_-&gt;json_data(json_data_key) = 0; // TODO: timestamp\n        RegisterInterface(key, interface, trigger.obj_id());\n        return *this;\n    }\n\n\n    template &lt;class Interface&gt;\n    Environment&amp; RegisterTrigger(boost::json::string_view key, Interface&amp;&amp; interface)\n    {\n        return RegisterTrigger(key, std::forward&lt;Interface&gt;(interface), ifc_host_nullptr&lt;Interface&gt;);\n    }\n\n    template &lt;class Interface, class H&gt;\n    boost::json::string RegisterAnonymousTrigger(Interface&amp;&amp; interface, H&amp;&amp; host)\n    {\n        auto key = autokey(host, interface);\n        RegisterTrigger(key, interface, host);\n        return key;\n    }\n\n\n    bool HasTrigger(boost::json::string_view key) const;\n\n    bool HasAction(boost::json::string_view key) const;\n\n\n    template &lt;class Interface&gt;\n    Environment&amp; InitializeInterfaceHandlers(Interface&amp;&amp; interface)\n    {\n        static_assert(is_ifc_handle&lt;Interface&gt;::value, \"\");\n        auto const ifc_id = interface_id(std::forward&lt;Interface&gt;(interface));\n\n        permanent_data_-&gt;prototypes.emplace(ifc_id, interface);\n        permanent_data_-&gt;default_objects.emplace(ifc_id, ifc_host_nullptr&lt;Interface&gt;);\n        permanent_data_-&gt;output_recorder_factories.emplace(ifc_id, [](OutputRecorder&amp; rec){\n            rec.setup_handlers&lt;Interface&gt;();\n        });\n        return *this;\n    }\n\n    Environment&amp; RegisterInterface(boost::json::string_view key, interface_id const&amp; ifc_id, object_id const&amp; obj_id);\n\n    Environment&amp; RegisterAnonymousInterface(interface_id const&amp; ifc_id, object_id const&amp; obj_id)\n    {\n        return RegisterInterface(autokey(obj_id, ifc_id), ifc_id, obj_id);\n    }\n\n\n    template &lt;class Interface&gt;\n    enable_if_t&lt;is_ifc_handle&lt;Interface&gt;::value, Environment&amp;&gt;\n    RegisterInterface(boost::json::string_view key, Interface&amp;&amp; interface, object_id const&amp; obj_id = object_id{ifc_host_nullptr&lt;Interface&gt;})\n    {\n        InitializeInterfaceHandlers(std::forward&lt;Interface&gt;(interface));\n        return RegisterInterface(key, interface_id(std::forward&lt;Interface&gt;(interface)), obj_id);\n    }\n\n    template &lt;class Interface&gt;\n    enable_if_t&lt;is_ifc_handle&lt;Interface&gt;::value, Environment&amp;&gt;\n    RegisterAnonymousInterface(Interface&amp;&amp; interface, object_id const&amp; obj_id = object_id{ifc_host_nullptr&lt;Interface&gt;})\n    {\n        return RegisterInterface(autokey(obj_id, std::forward&lt;Interface&gt;(interface)), std::forward&lt;Interface&gt;(interface), obj_id);\n    }\n\n\n\n    object_id ObjectId(boost::json::string_view interface_key) const;\n\n    interface_id InterfaceId(boost::json::string_view interface_key) const;\n\n    boost::json::string GetOrRegisterInterface(object_id const&amp; obj_id, interface_id const&amp; ifc_id);\n\n    object_id DefaultObjectId(interface_id const&amp; ifc_id) const;\n\n};\n\n}  // namespace zmbt\n\n#endif  // ZMBT_FIXTURE_ENVIRONMENT_STORE_HPP_\n</code></pre>"},{"location":"CxxRef/environment__data_8hpp/","title":"File environment_data.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; environment_data.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;boost/unordered/concurrent_flat_map.hpp&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"trigger.hpp\"</code></li> <li><code>#include \"generator.hpp\"</code></li> <li><code>#include \"channel_kind.hpp\"</code></li> <li><code>#include \"injection_table.hpp\"</code></li> <li><code>#include \"output_recorder.hpp\"</code></li> </ul>"},{"location":"CxxRef/environment__data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/environment__data_8hpp/#classes","title":"Classes","text":"Type Name struct EnvironmentData Data container for the Environment ."},{"location":"CxxRef/environment__data_8hpp/#macros","title":"Macros","text":"Type Name define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK"},{"location":"CxxRef/environment__data_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/environment__data_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/environment__data_8hpp/#define-boost_unordered_disable_reentrancy_check","title":"define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK","text":"<pre><code>#define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/environment_data.hpp</code></p>"},{"location":"CxxRef/environment__data_8hpp_source/","title":"File environment_data.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; environment_data.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_ENVIRONMENT_DATA_HPP_\n#define ZMBT_MODEL_ENVIRONMENT_DATA_HPP_\n\n#include &lt;atomic&gt;\n#include &lt;cstdint&gt;\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n#include &lt;memory&gt;\n#include &lt;tuple&gt;\n#include &lt;mutex&gt;\n#include &lt;typeindex&gt;\n#include &lt;type_traits&gt;\n\n#define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK\n#include &lt;boost/unordered/concurrent_flat_map.hpp&gt;\n\n\n#include \"zmbt/core.hpp\"\n#include \"trigger.hpp\"\n#include \"generator.hpp\"\n#include \"channel_kind.hpp\"\n#include \"injection_table.hpp\"\n#include \"output_recorder.hpp\"\n\n\nnamespace zmbt {\n\n\n\n\nstruct EnvironmentData final {\n\n    using mutex_t = std::recursive_mutex;\n    using lock_t = std::unique_lock&lt;mutex_t&gt;;\n\n    using shared_data_record = std::pair&lt;std::type_index, std::shared_ptr&lt;void&gt;&gt;;\n    using shared_data_table = std::map&lt;boost::json::string, shared_data_record&gt;;\n    using FailureHandler = std::function&lt;void(boost::json::value const&amp;)&gt;;\n\n\n    static boost::json::value init_json_data();\n\n    shared_data_table shared;\n    JsonNode json_data {init_json_data()};\n\n    std::map&lt;boost::json::string, std::function&lt;void()&gt;&gt; callbacks;\n    std::map&lt;boost::json::string, Trigger&gt; triggers;\n    std::unordered_map&lt;interface_id, TriggerIfc&gt; trigger_ifcs;\n    std::unordered_map&lt;object_id, TriggerObj&gt; trigger_objs;\n\n\n    boost::concurrent_flat_map&lt;\n        std::pair&lt;interface_id, object_id&gt;,\n            shared_resource&lt;InjectionTable&gt;&gt; injection_tables{};\n\n    boost::concurrent_flat_map&lt;\n        std::pair&lt;interface_id, object_id&gt;,\n            shared_resource&lt;OutputRecorder&gt;&gt; output_recorders{};\n\n    std::atomic_bool has_test_error{false};\n\n\n    mutex_t mutable mutex;\n\n    EnvironmentData();\n\n    EnvironmentData(EnvironmentData &amp;&amp;o) = delete;\n    EnvironmentData(EnvironmentData const&amp; o) = delete;\n    EnvironmentData&amp; operator=(EnvironmentData &amp;&amp;o) = delete;\n    EnvironmentData&amp; operator=(EnvironmentData const&amp; o) = delete;\n\n    ~EnvironmentData();\n};\n\n\n\n}  // namespace zmbt\n\n#endif  // ZMBT_MAPPING_ENVIRONMENT_DATA_HPP_\n</code></pre>"},{"location":"CxxRef/environment__interface__record_8hpp/","title":"File environment_interface_record.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; environment_interface_record.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"environment.hpp\"</code></li> <li><code>#include \"zmbt/expr/expression.hpp\"</code></li> </ul>"},{"location":"CxxRef/environment__interface__record_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/environment__interface__record_8hpp/#classes","title":"Classes","text":"Type Name class InterfaceHandle Environment extension handling the interface data. class TypedInterfaceHandle &lt;class Interface&gt;Environment API handler for specific interface."},{"location":"CxxRef/environment__interface__record_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/environment_interface_record.hpp</code></p>"},{"location":"CxxRef/environment__interface__record_8hpp_source/","title":"File environment_interface_record.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; environment_interface_record.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_ENVIRONMENT_INTERFACE_RECORD_HPP_\n#define ZMBT_MODEL_ENVIRONMENT_INTERFACE_RECORD_HPP_\n\n\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n#include &lt;tuple&gt;\n#include &lt;typeindex&gt;\n#include &lt;type_traits&gt;\n\n#include \"environment.hpp\"\n#include \"zmbt/expr/expression.hpp\"\n\n\n\n\nnamespace zmbt {\n\n\n\nclass Environment::InterfaceHandle\n{\n\nprivate:\n    object_id refobj_;\n    interface_id interface_;\n\nprotected:\n\n    mutable zmbt::Environment env;\n    std::shared_ptr&lt;OutputRecorder&gt; output_recorder_;\npublic:\n\n\n    interface_id interface() const\n    {\n        return interface_;\n    }\n\n    object_id refobj() const\n    {\n        return refobj_;\n    }\n\n    InterfaceHandle(Environment const&amp; e, interface_id const&amp; interface, object_id refobj);\n    InterfaceHandle(Environment const&amp; e, boost::json::string_view ref);\n\n  public:\n\n    InterfaceHandle(interface_id const&amp; interface, object_id refobj);\n\n    InterfaceHandle(interface_id const&amp; interface, nullptr_t);\n\n    InterfaceHandle(boost::json::string_view ref);\n\n\n    template&lt;class H, class E = mp_if&lt;mp_not&lt;is_pointer&lt;H&gt;&gt;, void&gt;&gt;\n    InterfaceHandle(interface_id const&amp; interface, H const&amp; obj)\n        : InterfaceHandle(interface, std::addressof(obj))\n    {\n    }\n\n    InterfaceHandle(InterfaceHandle const&amp;) = default;\n    InterfaceHandle(InterfaceHandle &amp;&amp; o) = default;\n    InterfaceHandle&amp; operator=(InterfaceHandle const&amp;) = default;\n    InterfaceHandle&amp; operator=(InterfaceHandle &amp;&amp;) = default;\n    ~InterfaceHandle() = default;\n\n    Environment&amp; Env() const\n    {\n        return env;\n    }\n\n    boost::json::value PrototypeReturn() const;\n\n    boost::json::array PrototypeArgs() const;\n\n    void EnableOutputRecordFor(ChannelKind const kind);\n\n    void MaybeThrowException();\n\n    boost::json::value YieldInjection(ChannelKind const kind);\n\n    boost::json::value YieldInjectionArgs()\n    {\n        return YieldInjection(ChannelKind::Args);\n    }\n\n    boost::json::value YieldInjectionReturn()\n    {\n        return YieldInjection(ChannelKind::Return);\n    }\n\n    void Inject(std::shared_ptr&lt;Generator&gt; gen, lang::Expression const&amp; tf, ChannelKind const kind, boost::json::string_view jp = \"\");\n\n\n\n    void InjectReturn(lang::Expression const&amp; e, boost::json::string_view jp = \"\")\n    {\n        return Inject(std::make_shared&lt;Generator&gt;(e), expr::Noop, ChannelKind::Return, jp);\n    }\n\n    void InjectArgs(lang::Expression const&amp; e, boost::json::string_view jp = \"\")\n    {\n        return Inject(std::make_shared&lt;Generator&gt;(e), expr::Noop, ChannelKind::Args, jp);\n    }\n\n\n    std::size_t ObservedCalls() const;\n\n\n\n    boost::json::array CaptureSlice(boost::json::string_view signal_path) const;\n\n    boost::json::array const&amp; Captures() const;\n\n    boost::json::string const&amp; key() const;\n\n    InterfaceHandle&amp; RunAsAction();\n\n    InterfaceHandle&amp; RunAsTrigger(std::size_t const repeats = 1);\n};\n\ntemplate &lt;class Interface&gt;\nclass Environment::TypedInterfaceHandle : public Environment::InterfaceHandle\n{\n\n    using reflection  =  reflect::invocation&lt;Interface const&amp;&gt;;\n    using return_t    = typename reflection::return_t;\n    using args_t      = typename reflection::args_t;\n    using unqf_args_t = tuple_unqf_t&lt;args_t&gt;;\n\n    using return_or_nullptr_t = reflect::invocation_ret_unqf_or_nullptr_t&lt;Interface const&amp;&gt;;\n\n\n    template &lt;class T&gt;\n    using rvalue_reference_to_value = mp_if&lt;std::is_rvalue_reference&lt;T&gt;, std::remove_reference_t&lt;T&gt;, T&gt;;\n\n    using hookout_args_t = mp_transform&lt;rvalue_reference_to_value, args_t&gt;;\n\n    void HookArgsImpl(hookout_args_t &amp; args)\n    try\n    {\n        output_recorder_-&gt;push(convert_tuple_to&lt;unqf_args_t&gt;(args), ErrorOr&lt;return_or_nullptr_t&gt;());\n\n\n        auto const injection = YieldInjection(ChannelKind::Args).as_array();\n\n        if (injection.size() != std::tuple_size&lt;unqf_args_t&gt;())\n        {\n            env.SetTestError({\n                {\"error\"    , \"invalid inject arguments arity\"},\n                {\"injection\", injection},\n                {\"interface\", interface().str()               },\n                {\"context\"  , \"Hook\"                          },\n                {\"injection\", injection                       },\n            });\n        }\n        else\n        {\n            auto args_out = dejsonize&lt;unqf_args_t&gt;(injection);\n            tuple_exchange(args, args_out);\n        }\n    }\n    catch(const std::exception&amp; e)\n    {\n        env.SetTestError({\n            {\"error\"    , \"exception thrown at args evaluation\"},\n            {\"interface\", interface().str()                    },\n            {\"context\"  , \"Hook\"                               },\n            {\"what\"     , e.what()                             },\n        });\n    }\n\n\n    void HookReturnImpl(type_tag&lt;void&gt;)\n    {\n    }\n\n    template &lt;class T&gt;\n    auto HookReturnImpl(type_tag&lt;T&gt;) -&gt; mp_if&lt;mp_not&lt;is_reference&lt;T&gt;&gt;, T&gt;\n    try\n    {\n        boost::json::value result(YieldInjection(ChannelKind::Return));\n        return dejsonize&lt;T&gt;(result);\n    }\n    catch(const std::exception&amp; e)\n    {\n        env.SetTestError({\n            {\"error\"    , \"exception thrown at return evaluation\"},\n            {\"interface\", interface().str()                      },\n            {\"context\"  , \"Hook\"                                 },\n            {\"what\"     , e.what()                               },\n        });\n        return dejsonize&lt;T&gt;(PrototypeReturn());\n    }\n\n    template &lt;class T&gt;\n    auto HookReturnImpl(type_tag&lt;T&gt;) -&gt; mp_if&lt;is_reference&lt;T&gt;, T&gt;\n    {\n        using TT = remove_cvref_t&lt;T&gt;;\n\n        TT value = HookReturnImpl(type&lt;TT&gt;);\n        auto const key = format(\"$(ret-ref-%s-%s)\", interface().key(), refobj().key());\n        TT&amp; ref = Env().template GetSharedRef&lt;TT&gt;(key, reflect::signal_traits&lt;TT&gt;::init());\n        ref = value;\n        return ref;\n    }\n\n\n\n    public:\n\n\n    template &lt;class H&gt;\n    TypedInterfaceHandle(interface_id const&amp; interface, H const&amp; refobj)\n        : Environment::InterfaceHandle(interface, refobj)\n    {\n    }\n\n    TypedInterfaceHandle(TypedInterfaceHandle const&amp;) = default;\n    TypedInterfaceHandle(TypedInterfaceHandle &amp;&amp;) = default;\n    ~TypedInterfaceHandle() = default;\n\n    return_t Hook(hookout_args_t args)\n    {\n        std::size_t nofcall;\n        boost::json::value result;\n        HookArgsImpl(args);\n        MaybeThrowException();\n        return HookReturnImpl(type&lt;return_t&gt;);\n    }\n\n    template &lt;class... A&gt;\n    return_t Hook(A&amp;&amp;... arg)\n    {\n        hookout_args_t args {arg...};\n        return Hook(args);\n    }\n};\n\n\ntemplate &lt;class Interface&gt;\nEnvironment::TypedInterfaceHandle&lt;Interface&gt; InterfaceRecord(Interface const&amp; interface, object_id const&amp; obj = {ifc_host_nullptr&lt;Interface&gt;})\n{\n    Environment env {};\n    env.InitializeInterfaceHandlers(interface);\n    return {interface, obj};\n}\n\n\n}  // namespace zmbt\n\n#endif  // ZMBT_MAPPING_ENVIRONMENT_INTERFACE_RECORD_HPP_\n</code></pre>"},{"location":"CxxRef/error__info_8hpp/","title":"File error_info.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; error_info.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/error__info_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/error__info_8hpp/#classes","title":"Classes","text":"Type Name struct ErrorInfo"},{"location":"CxxRef/error__info_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/error_info.hpp</code></p>"},{"location":"CxxRef/error__info_8hpp_source/","title":"File error_info.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; error_info.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_ERROR_INFO_HPP_\n#define ZMBT_MODEL_ERROR_INFO_HPP_\n\n#include &lt;boost/json.hpp&gt;\n\n\nnamespace zmbt\n{\n\nstruct ErrorInfo\n{\n    boost::json::string type;\n    boost::json::string what;\n    boost::json::string context;\n\n    boost::json::value to_json() const\n    {\n        return boost::json::object {\n            {\"type\"   , type   },\n            {\"what\"   , what   },\n            {\"context\", context},\n        };\n    }\n};\n\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/error__or__return_8hpp/","title":"File error_or_return.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; error_or_return.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;boost/variant2.hpp&gt;</code></li> <li><code>#include &lt;boost/optional.hpp&gt;</code></li> <li><code>#include \"error_info.hpp\"</code></li> </ul>"},{"location":"CxxRef/error__or__return_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/error__or__return_8hpp/#classes","title":"Classes","text":"Type Name class ErrorOr &lt;class Return&gt;"},{"location":"CxxRef/error__or__return_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/error_or_return.hpp</code></p>"},{"location":"CxxRef/error__or__return_8hpp_source/","title":"File error_or_return.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; error_or_return.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_ERROR_OR_RETURN_HPP_\n#define ZMBT_MODEL_ERROR_OR_RETURN_HPP_\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;boost/variant2.hpp&gt;\n#include &lt;boost/optional.hpp&gt;\n\n#include \"error_info.hpp\"\n\n\nnamespace zmbt\n{\n\ntemplate &lt;class Return&gt;\nclass ErrorOr\n{\n    using variant_t = boost::variant2::variant&lt;ErrorInfo, Return&gt;;\n\n    variant_t error_or_return;\n\n  public:\n    ErrorOr() = default;\n\n    static ErrorOr&lt;Return&gt; MakeError(ErrorInfo err)\n    {\n        using boost::variant2::in_place_index;\n        ErrorOr&lt;Return&gt; e{};\n        e.error_or_return = variant_t{in_place_index&lt;0&gt;, err};\n        return e;\n    }\n\n    static ErrorOr&lt;Return&gt; MakeValue(Return ret)\n    {\n        using boost::variant2::in_place_index;\n        ErrorOr&lt;Return&gt; e{};\n        e.error_or_return = variant_t{in_place_index&lt;1&gt;, ret};\n        return e;\n    }\n\n    ErrorInfo const&amp; as_error() const\n    {\n        return boost::variant2::get&lt;0&gt;(error_or_return);\n    }\n\n    Return const&amp; as_return() const\n    {\n        return boost::variant2::get&lt;1&gt;(error_or_return);\n    }\n\n    bool is_null() const\n    {\n        return (error_or_return.index() == 0) &amp;&amp; as_error().type.empty();\n    }\n\n    bool is_error() const\n    {\n        return (error_or_return.index() == 0) &amp;&amp; !as_error().type.empty();\n    }\n\n    bool is_return() const\n    {\n        return (error_or_return.index() == 1);\n    }\n\n    void dump_to(boost::json::object&amp; obj) const\n    {\n        if (is_error())\n        {\n            obj[\"exception\"] = boost::variant2::get&lt;0&gt;(error_or_return).to_json();\n        }\n        else if (is_return())\n        {\n            obj[\"return\"] = json_from(boost::variant2::get&lt;1&gt;(error_or_return));\n        }\n        else\n        {\n            // noop\n        }\n    }\n};\n\n\n\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/model_2exceptions_8hpp/","title":"File exceptions.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; exceptions.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"zmbt/core/exceptions.hpp\"</code></li> </ul>"},{"location":"CxxRef/model_2exceptions_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/model_2exceptions_8hpp/#classes","title":"Classes","text":"Type Name struct model_error Model definition error. struct test_assertion_failure Failed test assertion."},{"location":"CxxRef/model_2exceptions_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/exceptions.hpp</code></p>"},{"location":"CxxRef/model_2exceptions_8hpp_source/","title":"File exceptions.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; exceptions.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_EXCEPTIONS_HPP_\n#define ZMBT_MODEL_EXCEPTIONS_HPP_\n\n#include \"zmbt/core/exceptions.hpp\"\n\nnamespace zmbt {\n\n\nstruct test_assertion_failure : public base_error {\n    using base_error::base_error;\n};\n\nstruct model_error : public base_error {\n    using base_error::base_error;\n};\n\n\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/generator_8hpp/","title":"File generator.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; generator.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"zmbt/expr.hpp\"</code></li> </ul>"},{"location":"CxxRef/generator_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/generator_8hpp/#classes","title":"Classes","text":"Type Name class Generator"},{"location":"CxxRef/generator_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/generator.hpp</code></p>"},{"location":"CxxRef/generator_8hpp_source/","title":"File generator.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; generator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_GENERATOR_EXPR_HPP_\n#define ZMBT_MODEL_GENERATOR_EXPR_HPP_\n\n#include &lt;atomic&gt;\n\n#include &lt;boost/json.hpp&gt;\n\n#include \"zmbt/expr.hpp\"\n\n\nnamespace zmbt {\n\n// Index family expression wrapper with bound atomic counter\nclass Generator\n{\n    std::atomic_uint64_t counter_;\n    lang::Expression expr_;\npublic:\n    explicit Generator(boost::json::array const&amp; serialized);\n    explicit Generator(lang::Expression const&amp; expr);\n\n    bool is_noop() const;\n\n    std::uint64_t operator()(boost::json::value&amp; value);\n\n    void reset();\n\n    lang::Expression const&amp; expression() const;\n\n\n    Generator&amp; operator=(Generator const&amp;) = default;\n    Generator(Generator const&amp;) = default;\n    Generator(Generator &amp;&amp;) = default;\n    Generator&amp; operator=(Generator&amp;&amp;) = default;\n    ~Generator() = default;\n\n    using Shared = std::shared_ptr&lt;Generator&gt;;\n\n};\n\n\n}  // namespace zmbt\n\n#endif  // ZMBT_MODEL_GENERATOR_EXPR_HPP_\n</code></pre>"},{"location":"CxxRef/global__flags_8hpp/","title":"File global_flags.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; global_flags.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"CxxRef/global__flags_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace flags"},{"location":"CxxRef/global__flags_8hpp/#classes","title":"Classes","text":"Type Name class TestIsRunning"},{"location":"CxxRef/global__flags_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/global_flags.hpp</code></p>"},{"location":"CxxRef/global__flags_8hpp_source/","title":"File global_flags.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; global_flags.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_GLOBAL_FLAGS_HPP_\n#define ZMBT_MODEL_GLOBAL_FLAGS_HPP_\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n\nnamespace zmbt\n{\nnamespace flags\n{\n\nclass TestIsRunning\n{\n  public:\n    static void set() noexcept\n    {\n        flag().store(true, std::memory_order_release);\n    }\n\n    static void clear() noexcept\n    {\n        flag().store(false, std::memory_order_release);\n    }\n\n    static bool status() noexcept\n    {\n        return flag().load(std::memory_order_acquire);\n    }\n\n    static bool exchange(bool const sts) noexcept\n    {\n        return flag().exchange(sts, std::memory_order_acquire);\n    }\n\nprivate:\n    static std::atomic&lt;bool&gt;&amp; flag() noexcept;\n};\n\n} // namespace flags\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/global__stats_8hpp/","title":"File global_stats.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; global_stats.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"CxxRef/global__stats_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace flags"},{"location":"CxxRef/global__stats_8hpp/#classes","title":"Classes","text":"Type Name class ConversionTime class InjectionTime class RecordingTime"},{"location":"CxxRef/global__stats_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2025 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/global_stats.hpp</code></p>"},{"location":"CxxRef/global__stats_8hpp_source/","title":"File global_stats.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; global_stats.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_GLOBAL_STATS_HPP_\n#define ZMBT_MODEL_GLOBAL_STATS_HPP_\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n\nnamespace zmbt\n{\nnamespace flags\n{\n\nclass InjectionTime\n{\n  public:\n    static void add(std::chrono::nanoseconds const duration) noexcept\n    {\n        counter().fetch_add(static_cast&lt;std::uint64_t&gt;(duration.count()), std::memory_order_relaxed);\n    }\n\n    static std::uint64_t value() noexcept\n    {\n        return counter().load(std::memory_order_relaxed);\n    }\n\n    static void reset() noexcept\n    {\n        counter().store(0, std::memory_order_relaxed);\n    }\n\n  private:\n    static std::atomic&lt;std::uint64_t&gt;&amp; counter() noexcept;\n};\n\nclass RecordingTime\n{\n  public:\n    static void add(std::chrono::nanoseconds const duration) noexcept\n    {\n        counter().fetch_add(static_cast&lt;std::uint64_t&gt;(duration.count()), std::memory_order_relaxed);\n    }\n\n    static std::uint64_t value() noexcept\n    {\n        return counter().load(std::memory_order_relaxed);\n    }\n\n    static void reset() noexcept\n    {\n        counter().store(0, std::memory_order_relaxed);\n    }\n\n  private:\n    static std::atomic&lt;std::uint64_t&gt;&amp; counter() noexcept;\n};\n\nclass ConversionTime\n{\n  public:\n    static void add(std::chrono::nanoseconds const duration) noexcept\n    {\n        counter().fetch_add(static_cast&lt;std::uint64_t&gt;(duration.count()), std::memory_order_relaxed);\n    }\n\n    static std::uint64_t value() noexcept\n    {\n        return counter().load(std::memory_order_relaxed);\n    }\n\n    static void reset() noexcept\n    {\n        counter().store(0, std::memory_order_relaxed);\n    }\n\n  private:\n    static std::atomic&lt;std::uint64_t&gt;&amp; counter() noexcept;\n};\n\n} // namespace flags\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/injection__table_8hpp/","title":"File injection_table.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; injection_table.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/expr.hpp\"</code></li> <li><code>#include \"generator.hpp\"</code></li> <li><code>#include \"channel_kind.hpp\"</code></li> </ul>"},{"location":"CxxRef/injection__table_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/injection__table_8hpp/#classes","title":"Classes","text":"Type Name class InjectionTable struct Record"},{"location":"CxxRef/injection__table_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/injection_table.hpp</code></p>"},{"location":"CxxRef/injection__table_8hpp_source/","title":"File injection_table.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; injection_table.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_INJECTION_TABLE_HPP_\n#define ZMBT_MODEL_INJECTION_TABLE_HPP_\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/expr.hpp\"\n#include \"generator.hpp\"\n#include \"channel_kind.hpp\"\n\n\nnamespace zmbt {\n\n\nclass InjectionTable\n{\n  public:\n\n    struct Record\n    {\n        boost::json::string jptr;\n        Generator::Shared generator;\n        lang::Expression transform;\n        boost::optional&lt;boost::json::value&gt; maybe_constant;\n\n        Record(\n            boost::json::string_view jp,\n            Generator::Shared gen,\n            lang::Expression const&amp; tf\n        );\n    };\n\n  private:\n    interface_id ifc_id_;\n    object_id obj_id_;\n    reflect::Prototypes prototypes_;\n\n    std::vector&lt;Record&gt; args_;\n    std::vector&lt;Record&gt; ret_;\n    std::vector&lt;Record&gt; exception_;\n\n    boost::optional&lt;boost::json::value&gt; maybe_constant_args_;\n    boost::optional&lt;boost::json::value&gt; maybe_constant_ret_;\n    boost::optional&lt;boost::json::value&gt; maybe_constant_exception_;\n\n\n    std::vector&lt;Record&gt;&amp; get_records(ChannelKind const&amp; ck) &amp;;\n    boost::optional&lt;boost::json::value&gt;&amp; get_maybe_const(ChannelKind const&amp; ck) &amp;;\n\n  public:\n\n    InjectionTable(interface_id const&amp; ifc_id, object_id const&amp; obj_id);\n    void add_record(ChannelKind const&amp; ck, Record&amp;&amp; rec);\n    Record&amp; last_record(ChannelKind const&amp; ck) &amp;;\n\n    boost::json::value yield(ChannelKind const&amp; ck, boost::json::value&amp; result_value);\n\n    static std::shared_ptr&lt;InjectionTable&gt; Make(interface_id const&amp; ifc_id, object_id const&amp; obj_id);\n};\n\n} // namespace\n\n#endif\n</code></pre>"},{"location":"CxxRef/output__recorder_8hpp/","title":"File output_recorder.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; output_recorder.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;typeinfo&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;boost/unordered/concurrent_flat_map.hpp&gt;</code></li> <li><code>#include &lt;boost/core/demangle.hpp&gt;</code></li> <li><code>#include \"zmbt/application/log.hpp\"</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> <li><code>#include \"channel_kind.hpp\"</code></li> <li><code>#include \"global_flags.hpp\"</code></li> <li><code>#include \"global_stats.hpp\"</code></li> <li><code>#include \"error_or_return.hpp\"</code></li> </ul>"},{"location":"CxxRef/output__recorder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/output__recorder_8hpp/#classes","title":"Classes","text":"Type Name class OutputRecorder struct Frame &lt;class T&gt; struct FrameBuffs struct output_recorder_error"},{"location":"CxxRef/output__recorder_8hpp/#macros","title":"Macros","text":"Type Name define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK"},{"location":"CxxRef/output__recorder_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/output__recorder_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/output__recorder_8hpp/#define-boost_unordered_disable_reentrancy_check","title":"define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK","text":"<pre><code>#define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/output_recorder.hpp</code></p>"},{"location":"CxxRef/output__recorder_8hpp_source/","title":"File output_recorder.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; output_recorder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_ENV_OUTPUT_RECORDER_HPP_\n#define ZMBT_ENV_OUTPUT_RECORDER_HPP_\n\n#include &lt;atomic&gt;\n#include &lt;bitset&gt;\n#include &lt;chrono&gt;\n#include &lt;deque&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;typeindex&gt;\n#include &lt;typeinfo&gt;\n\n#include &lt;boost/json.hpp&gt;\n#define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK\n#include &lt;boost/unordered/concurrent_flat_map.hpp&gt;\n\n#include &lt;boost/core/demangle.hpp&gt;\n\n#include \"zmbt/application/log.hpp\"\n#include \"zmbt/core.hpp\"\n#include \"zmbt/reflect.hpp\"\n\n#include \"channel_kind.hpp\"\n#include \"global_flags.hpp\"\n#include \"global_stats.hpp\"\n#include \"error_or_return.hpp\"\n\n\nnamespace zmbt {\n\nstruct output_recorder_error : public base_error {\n    using base_error::base_error;\n};\n\nclass OutputRecorder\n{\n  public:\n\n    template &lt;class T&gt;\n    struct Frame\n    {\n        std::size_t ts;\n        T data {reflect::signal_traits&lt;T&gt;::init()};\n    };\n\n  private:\n    class Registry;\n\n\n    template &lt;class Interface&gt;\n    static std::type_index get_args_typeid(Interface const&amp;)\n    {\n        using reflection  = reflect::invocation&lt;Interface const&amp;&gt;;\n        using args_t      = typename reflection::args_t;\n        using unqf_args_t = tuple_unqf_t&lt;args_t&gt;;\n        return {typeid(unqf_args_t)};\n    }\n\n    struct Registry\n    {\n        struct FrameBuffs\n        {\n            std::shared_ptr&lt;void&gt; args{};\n            std::shared_ptr&lt;void&gt; ret{};\n            std::shared_ptr&lt;void&gt; err{};\n        };\n\n        using FramesBuffMap = boost::concurrent_flat_map&lt;std::thread::id, FrameBuffs, std::hash&lt;std::thread::id&gt;&gt;;\n        using consume_fn_t = std::function&lt;void(Registry&amp;)&gt;;\n\n        std::type_index data_typeid;\n        boost::json::string interface_name;\n        consume_fn_t extract_fn;\n        std::shared_ptr&lt;FramesBuffMap&gt; frame_buff_map;\n\n        boost::json::array serialized_frames{};\n        std::atomic&lt;std::size_t&gt; count{0};\n        std::atomic&lt;std::size_t&gt; lost_count{0};\n\n        std::bitset&lt;static_cast&lt;unsigned&gt;(ChannelKind::Undefined)&gt; enable_categories_{};\n\n        Registry(\n            std::type_index typid,\n            boost::json::string name,\n            consume_fn_t efn,\n            std::shared_ptr&lt;FramesBuffMap&gt; fbm\n        )\n            : data_typeid(typid)\n            , interface_name{name}\n            , extract_fn(efn)\n            , frame_buff_map{fbm}\n        {\n        }\n\n        ~Registry()\n        {\n        }\n\n\n        template &lt;class Interface&gt;\n        static std::shared_ptr&lt;Registry&gt; Make()\n        {\n            using ArgsTuple = reflect::invocation_args_unqf_t&lt;Interface const&amp;&gt;;\n            using Return = reflect::invocation_ret_unqf_or_nullptr_t&lt;Interface const&amp;&gt;;\n\n            std::type_index const typid {typeid(std::tuple&lt;ArgsTuple, Return&gt;)};\n\n            consume_fn_t extract_fn = [](Registry&amp; registry) {\n\n                std::shared_ptr&lt;Registry&gt; expected {nullptr};\n\n                auto frame_buff_map = std::atomic_exchange(&amp;registry.frame_buff_map, std::make_shared&lt;Registry::FramesBuffMap&gt;());\n                if (!frame_buff_map)\n                {\n                    ZMBT_LOG(FATAL) &lt;&lt; \"corrupted output recorder registry on \" &lt;&lt; registry.interface_name;\n                    return;\n                }\n\n                bool const tid_enabled = registry.enable_categories_[static_cast&lt;unsigned&gt;(ChannelKind::ThreadId)];\n\n                using FB = Registry::FrameBuffs;\n                using ThreadFrameBuffers = std::pair&lt;std::thread::id, FB&gt;;\n\n                // Snapshot thread buffers\n                std::vector&lt;ThreadFrameBuffers&gt; fbs;\n                fbs.reserve(frame_buff_map-&gt;size());\n                frame_buff_map-&gt;visit_all([&amp;](auto&amp; record){\n                    fbs.push_back(record);\n                });\n\n                auto get_next_ts = [](FB&amp; fb) -&gt; std::size_t {\n                    std::size_t ts = std::string::npos;\n                    if (fb.args) {\n                        auto&amp; dq = *std::static_pointer_cast&lt;std::deque&lt;Frame&lt;ArgsTuple&gt;&gt;&gt;(fb.args);\n                        if (!dq.empty()) ts = std::min(ts, dq.front().ts);\n                    }\n                    if (fb.ret) {\n                        auto&amp; dq = *std::static_pointer_cast&lt;std::deque&lt;Frame&lt;Return&gt;&gt;&gt;(fb.ret);\n                        if (!dq.empty()) ts = std::min(ts, dq.front().ts);\n                    }\n                    if (fb.err) {\n                        auto&amp; dq = *std::static_pointer_cast&lt;std::deque&lt;Frame&lt;ErrorInfo&gt;&gt;&gt;(fb.err);\n                        if (!dq.empty()) ts = std::min(ts, dq.front().ts);\n                    }\n                    return ts;\n                };\n\n                struct Cursor {\n                    std::size_t ts {std::string::npos}; // next timestamp\n                    ThreadFrameBuffers* buffs{nullptr};\n                };\n\n                // initialize candidates\n                std::vector&lt;Cursor&gt; cursors;\n                cursors.reserve(fbs.size());\n                for (auto&amp; tfbs : fbs) {\n                    cursors.push_back({get_next_ts(tfbs.second), &amp;tfbs});\n                }\n\n                Cursor null{};\n                for (;;) {\n                    // find candidate with smallest ts\n                    Cursor* cursor = &amp;null;\n\n                    for (auto&amp; candidate: cursors)\n                    {\n                        if (candidate.ts &lt; cursor-&gt;ts) {\n                            cursor = &amp;candidate;\n                        }\n                    }\n                    if (cursor == &amp;null)\n                        break; // all empty\n\n                    boost::json::object json_frame{\n                        {\"ts\",  cursor-&gt;ts},\n                    };\n\n                    FB&amp; fb = cursor-&gt;buffs-&gt;second;\n\n                    if (tid_enabled)\n                    {\n                        json_frame[\"tid\"] = tid2str(cursor-&gt;buffs-&gt;first);\n                    }\n\n                    // consume exactly one element of each deque matching this ts\n                    if (fb.args) {\n                        auto&amp; dq = *std::static_pointer_cast&lt;std::deque&lt;Frame&lt;ArgsTuple&gt;&gt;&gt;(fb.args);\n                        if (!dq.empty() &amp;&amp; dq.front().ts == cursor-&gt;ts) {\n                            json_frame[\"args\"] = json_from(dq.front().data);\n                            dq.pop_front();\n                        }\n                    }\n                    if (fb.ret) {\n                        auto&amp; dq = *std::static_pointer_cast&lt;std::deque&lt;Frame&lt;Return&gt;&gt;&gt;(fb.ret);\n                        if (!dq.empty() &amp;&amp; dq.front().ts == cursor-&gt;ts) {\n                            json_frame[\"return\"] = json_from(dq.front().data);\n                            dq.pop_front();\n                        }\n                    }\n                    if (fb.err) {\n                        auto&amp; dq = *std::static_pointer_cast&lt;std::deque&lt;Frame&lt;ErrorInfo&gt;&gt;&gt;(fb.err);\n                        if (!dq.empty() &amp;&amp; dq.front().ts == cursor-&gt;ts) {\n                            json_frame[\"exception\"] = dq.front().data.to_json();\n                            dq.pop_front();\n                        }\n                    }\n\n                    registry.serialized_frames.push_back(std::move(json_frame));\n\n                    // refresh this candidate\u2019s ts\n                    cursor-&gt;ts = get_next_ts(fb);\n                }\n            };\n\n            auto frame_buff_map = std::make_shared&lt;FramesBuffMap&gt;();\n\n            return std::make_shared&lt;Registry&gt;(typid, type_name&lt;Interface&gt;().c_str(), extract_fn, frame_buff_map);\n        }\n    };\n\n    template &lt;ChannelKind ck&gt;\n    bool check_filter()\n    {\n        return registry_-&gt;enable_categories_[static_cast&lt;unsigned&gt;(ck)];\n    }\n\n    void report_test_error(ErrorInfo const&amp;) const;\n\n\n  public:\n\n\n    OutputRecorder(interface_id const&amp; ifc_id, object_id const&amp; obj_id);\n    ~OutputRecorder();\n\n    OutputRecorder(OutputRecorder const&amp;) = default;\n    OutputRecorder(OutputRecorder &amp;&amp;) = default;\n    OutputRecorder&amp; operator=(OutputRecorder const&amp;) = default;\n    OutputRecorder&amp; operator=(OutputRecorder &amp;&amp;) = default;\n\n    void flush();\n\n    template &lt;class Interface, class InterfacePointer = ifc_pointer_t&lt;Interface&gt;&gt;\n    void setup_handlers()\n    {\n        // std::atomic_store(&amp;(this-&gt;registry_), Registry::Make&lt;InterfacePointer&gt;());\n        if (registry_ != nullptr) return;\n        std::shared_ptr&lt;Registry&gt; expected {nullptr};\n        std::atomic_compare_exchange_weak(&amp;(this-&gt;registry_), &amp;expected, Registry::Make&lt;InterfacePointer&gt;());\n    }\n\n\n    template &lt;class ArgsTuple, class Return&gt;\n    void push(ArgsTuple const&amp; args, ErrorOr&lt;Return&gt; const&amp; return_or_error)\n    {\n        if (!ensure_registry())\n        {\n            ErrorInfo e;\n            e.type = type_name&lt;output_recorder_error&gt;();\n            e.what = \"push to unregistered output recorder\";\n            e.context = \"OutputRecorder\";\n            report_test_error(e);\n            return;\n        }\n\n        std::type_index const ti {typeid(std::tuple&lt;ArgsTuple, Return&gt;)};\n\n        if (ti != registry_-&gt;data_typeid)\n        {\n            ErrorInfo e;\n            e.type = type_name&lt;output_recorder_error&gt;();\n            e.what = format(\"invalid type on push - expected `%s`, got `%s`\",\n                boost::core::demangle(registry_-&gt;data_typeid.name()),\n                boost::core::demangle(ti.name())\n            ).c_str();\n            e.context = format(\"OutputRecorder[%s]\", registry_-&gt;interface_name).c_str();\n            report_test_error(e);\n            return;\n        }\n\n        if (!flags::TestIsRunning::status())\n        {\n            registry_-&gt;lost_count++;\n            // TODO: redesign me\n            // lost call may come from SUT initialization\n            // before expectations are st, which may be ok to skip\n            return;\n        }\n\n        auto const start = std::chrono::steady_clock::now();\n        registry_-&gt;count++;\n\n        auto const ts = get_ts();\n\n        bool const args_en = registry_-&gt;enable_categories_[static_cast&lt;unsigned&gt;(ChannelKind::Args)];\n        bool const ret_en = registry_-&gt;enable_categories_[static_cast&lt;unsigned&gt;(ChannelKind::Return)];\n        bool const err_en = registry_-&gt;enable_categories_[static_cast&lt;unsigned&gt;(ChannelKind::Exception)];\n        bool const tid_en = registry_-&gt;enable_categories_[static_cast&lt;unsigned&gt;(ChannelKind::ThreadId)];\n\n        boost::optional&lt;Registry::FrameBuffs&gt; maybe_fb_ref{};\n\n        registry_-&gt;frame_buff_map-&gt;visit(std::this_thread::get_id(),\n            [&amp;maybe_fb_ref](auto&amp; record){\n            maybe_fb_ref = record.second;\n        });\n\n        if (!maybe_fb_ref.has_value())\n        {\n            Registry::FrameBuffs new_fb;\n            if (args_en) new_fb.args = std::make_shared&lt;std::deque&lt;Frame&lt;ArgsTuple&gt;&gt;&gt;();\n            if (ret_en)  new_fb.ret  = std::make_shared&lt;std::deque&lt;Frame&lt;Return&gt;&gt;&gt;();\n            if (err_en)  new_fb.err  = std::make_shared&lt;std::deque&lt;Frame&lt;ErrorInfo&gt;&gt;&gt;();\n            maybe_fb_ref = new_fb;\n            registry_-&gt;frame_buff_map-&gt;try_emplace_or_visit(std::this_thread::get_id(), new_fb,\n                [&amp;maybe_fb_ref](auto&amp; record){\n                maybe_fb_ref = record.second;\n            });\n        }\n\n        Registry::FrameBuffs&amp; fb = maybe_fb_ref.value();\n\n\n        auto fb_args = std::static_pointer_cast&lt;std::deque&lt;Frame&lt;ArgsTuple&gt;&gt;&gt;(fb.args);\n        auto fb_ret  = std::static_pointer_cast&lt;std::deque&lt;Frame&lt;Return&gt;&gt;&gt;(fb.ret);\n        auto fb_err  = std::static_pointer_cast&lt;std::deque&lt;Frame&lt;ErrorInfo&gt;&gt;&gt;(fb.err);\n\n        if (args_en) fb_args-&gt;push_back({ts, args});\n        if (ret_en &amp;&amp; return_or_error.is_return()) fb_ret-&gt;push_back({ts, return_or_error.as_return()});\n\n        if (return_or_error.is_error())\n        {\n            if (err_en)\n            {\n                fb_err-&gt;push_back({ts, return_or_error.as_error()});\n            }\n            else\n            {\n                report_test_error(return_or_error.as_error());\n                registry_-&gt;enable_categories_.reset();\n            }\n        }\n\n        flags::RecordingTime::add(std::chrono::steady_clock::now() - start);\n    }\n\n    std::size_t count() const\n    {\n        return registry_ ? registry_-&gt;count.load(std::memory_order_relaxed) : 0UL;\n    }\n\n    std::size_t lost_count() const\n    {\n        return registry_ ? registry_-&gt;lost_count.load(std::memory_order_relaxed) : 0UL;\n    }\n\n    bool is_registered() const\n    {\n        return registry_ != nullptr;\n    }\n\n    boost::json::string_view interface_name() const\n    {\n        constexpr char* nil {\"unregistered\"};\n        return registry_ ? boost::json::string_view(registry_-&gt;interface_name) : boost::json::string_view(nil);\n    }\n\n\n    boost::json::array const&amp; data_frames() const;\n\n    void clear();\n\n    void enable_category(ChannelKind const ck);\n\n  private:\n\n    interface_id ifc_id_;\n    object_id obj_id_;\n    std::shared_ptr&lt;Registry&gt; registry_;\n    bool ensure_registry();\n};\n\n}\n\n#endif\n</code></pre>"},{"location":"CxxRef/param__transform_8hpp/","title":"File param_transform.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; param_transform.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/aliases.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/generic_traits.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/interface_id.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/interface_traits.hpp&gt;</code></li> <li><code>#include &lt;zmbt/core/object_id.hpp&gt;</code></li> <li><code>#include &lt;zmbt/model/parameter.hpp&gt;</code></li> <li><code>#include &lt;zmbt/model/exceptions.hpp&gt;</code></li> <li><code>#include &lt;zmbt/reflect/serialization.hpp&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"environment.hpp\"</code></li> <li><code>#include \"traits.hpp\"</code></li> </ul>"},{"location":"CxxRef/param__transform_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/param__transform_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/param_transform.hpp</code></p>"},{"location":"CxxRef/param__transform_8hpp_source/","title":"File param_transform.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; param_transform.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_PARAM_TRANSFORM_HPP_\n#define ZMBT_MODEL_PARAM_TRANSFORM_HPP_\n\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;zmbt/core/aliases.hpp&gt;\n#include &lt;zmbt/core/generic_traits.hpp&gt;\n#include &lt;zmbt/core/interface_id.hpp&gt;\n#include &lt;zmbt/core/interface_traits.hpp&gt;\n#include &lt;zmbt/core/object_id.hpp&gt;\n#include &lt;zmbt/model/parameter.hpp&gt;\n#include &lt;zmbt/model/exceptions.hpp&gt;\n#include &lt;zmbt/reflect/serialization.hpp&gt;\n#include &lt;stdint.h&gt;\n#include &lt;utility&gt;\n\n#include \"environment.hpp\"\n#include \"traits.hpp\"\n\n\nnamespace zmbt {\n\n\nnamespace detail {\n\ntemplate &lt;class T, class = void&gt;\nstruct param_transform;\n\n\nstruct param_transform_base\n{\n    Param const&amp; param;\n    boost::json::array const&amp; pointers;\n\n    struct Kind {\n        constexpr static uint32_t none      = 0;\n        constexpr static uint32_t trig_node = 0x1 &lt;&lt; 0U;\n        constexpr static uint32_t trig_obj  = 0x1 &lt;&lt; 1U;\n        constexpr static uint32_t trig_ifc  = 0x1 &lt;&lt; 2U;\n        constexpr static uint32_t ifc_node  = 0x1 &lt;&lt; 3U;\n        constexpr static uint32_t ifc_obj   = 0x1 &lt;&lt; 4U;\n        constexpr static uint32_t ifc_ifc   = 0x1 &lt;&lt; 5U;\n    };\n\n    uint32_t pkind {};\n\n    param_transform_base(Param const&amp; p, boost::json::array const&amp; ptrs);\n};\n\n\n\n\ntemplate &lt;class T&gt;\nstruct param_transform&lt;T, require_json_from&lt;T&gt;&gt;\n{\n    param_transform(Param const&amp;, boost::json::array const&amp;) {}\n\n    boost::json::value operator()(T&amp;&amp; arg)\n    {\n        return zmbt::json_from(arg);\n    }\n};\n\n\n\ntemplate &lt;class T, class = void&gt;\nstruct param_transform_interface;\n\ntemplate &lt;class T&gt;\nstruct param_transform_interface&lt;T, require_cal&lt;T&gt;&gt; : public param_transform_base\n{\n    using param_transform_base::param_transform_base;\n\n    boost::json::value operator()(T&amp;&amp; arg)\n    {\n        Environment env {};\n        env.InitializeInterfaceHandlers(std::forward&lt;T&gt;(arg));\n\n        boost::json::value pvalue {};\n        if ((Kind::trig_ifc &amp; pkind) &amp;&amp; (Kind::ifc_node &amp; pkind) )\n        {\n            throw_exception(model_error(\"Ambiguous param %s (missing object on channel nodes?)\", param));\n        }\n        if (Kind::trig_node &amp; pkind)\n        {\n            pvalue = env.RegisterAnonymousTrigger(arg, ifc_host_nullptr&lt;T&gt;);\n        }\n        else if (Kind::trig_ifc &amp; pkind)\n        {\n            pvalue = env.RegisterParametricTriggerIfc(arg);\n        }\n        else if (Kind::ifc_node &amp; pkind)\n        {\n            pvalue = {\n                {\"obj\", \"$(default)\"},\n                {\"ifc\", interface_id{arg} },\n            };\n        }\n        else if (Kind::ifc_ifc &amp; pkind)\n        {\n            pvalue = interface_id{arg};\n        }\n        else if (Kind::trig_obj &amp; pkind)\n        {\n            pvalue = register_trig_obj(arg);\n        }\n        else if (Kind::ifc_obj &amp; pkind) // it could be am mfp on an object with call operator\n        {\n            pvalue = construct_or_default&lt;object_id, T&gt;(std::forward&lt;T&gt;(arg));\n        }\n        else\n        {\n            throw_exception(model_error(\"Ambiguous param %s (should it be a part of an interface?) `%s`\", param, pointers));\n        }\n        return pvalue;\n    }\n\n    template &lt;class O&gt;\n    enable_if_t&lt;not ifc_is_fn_handle&lt;O&gt;::value, object_id&gt;\n    register_trig_obj(O&amp;&amp; obj)\n    {\n        return Environment().RegisterParametricTriggerObj(obj);\n    }\n\n    template &lt;class O&gt;\n    enable_if_t&lt;ifc_is_fn_handle&lt;O&gt;::value, object_id&gt;\n    register_trig_obj(O&amp;&amp;)\n    {\n        return object_id{};\n    }\n};\n\ntemplate &lt;class T&gt;\nstruct param_transform_interface&lt;T, require_not_cal&lt;T&gt;&gt; : public param_transform_base\n{\n    using param_transform_base::param_transform_base;\n\n    boost::json::value operator()(T&amp;&amp; arg)\n    {\n\n        if (Kind::trig_obj &amp; pkind)\n        {\n            return boost::json::value{Environment().RegisterParametricTriggerObj(arg)};\n        }\n        else if (Kind::ifc_obj &amp; pkind)\n        {\n            return object_id{arg};\n        }\n        else\n        {\n            throw_exception(model_error(\"Ambiguous param %s (should it be a trigger or channel object?)\", param));\n        }\n        return nullptr;\n    }\n};\n\ntemplate &lt;class T&gt;\nstruct param_transform&lt;T, require_no_json_from&lt;T&gt;&gt; : public param_transform_interface&lt;T&gt;\n{\n    using param_transform_interface&lt;T&gt;::param_transform_interface;\n};\n\n} // namespace detail\n\n\ntemplate &lt;class T&gt;\nboost::json::value param_transform(Param const&amp; param, boost::json::array const&amp; pointers, T&amp;&amp; value)\n{\n    return detail::param_transform&lt;T&gt;(param, pointers)(std::forward&lt;T&gt;(value));\n}\n\n}\n\n\n#endif\n</code></pre>"},{"location":"CxxRef/parameter_8hpp/","title":"File parameter.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; parameter.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include &lt;zmbt/expr.hpp&gt;</code></li> </ul>"},{"location":"CxxRef/parameter_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/parameter_8hpp/#classes","title":"Classes","text":"Type Name class Param Generic Parameter Placeholder."},{"location":"CxxRef/parameter_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/parameter.hpp</code></p>"},{"location":"CxxRef/parameter_8hpp_source/","title":"File parameter.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; parameter.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_PARAMETER_HPP_\n#define ZMBT_MODEL_PARAMETER_HPP_\n\n#include &lt;boost/json.hpp&gt;\n#include &lt;zmbt/expr.hpp&gt;\n\n\nnamespace zmbt {\n\n\nclass Param final : public zmbt::lang::Expression\n{\n    boost::json::string value_;\n\n    Param() = default;\npublic:\n\n\n    static bool isParam(boost::json::value const&amp; v);\n\n    // static Param parse(boost::json::value const&amp; v);\n\n    Param(boost::json::value v)\n        : Expression(Expression::encodePreProc(zmbt::format(\"$[%s]\", v).c_str()))\n    {}\n\n    Param(Param const&amp;) = default;\n    Param(Param &amp;&amp;) = default;\n    Param&amp; operator=(Param const&amp;) = default;\n    Param&amp; operator=(Param &amp;&amp;) = default;\n    ~Param() = default;\n\n    operator boost::json::value() const\n    {\n        return data();\n    }\n};\n\n\n}\n\n#endif\n</code></pre>"},{"location":"CxxRef/permanent__data_8hpp/","title":"File permanent_data.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; permanent_data.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;boost/unordered/concurrent_flat_map.hpp&gt;</code></li> <li><code>#include &lt;boost/optional.hpp&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/reflect/prototypes.hpp\"</code></li> <li><code>#include \"output_recorder.hpp\"</code></li> </ul>"},{"location":"CxxRef/permanent__data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/permanent__data_8hpp/#classes","title":"Classes","text":"Type Name struct PermanentEnvData"},{"location":"CxxRef/permanent__data_8hpp/#macros","title":"Macros","text":"Type Name define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK"},{"location":"CxxRef/permanent__data_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/permanent__data_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/permanent__data_8hpp/#define-boost_unordered_disable_reentrancy_check","title":"define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK","text":"<pre><code>#define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK \n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/permanent_data.hpp</code></p>"},{"location":"CxxRef/permanent__data_8hpp_source/","title":"File permanent_data.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; permanent_data.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_PERMANENT_DATA_HPP_\n#define ZMBT_MODEL_PERMANENT_DATA_HPP_\n\n#include &lt;functional&gt;\n#define BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK\n#include &lt;boost/unordered/concurrent_flat_map.hpp&gt;\n#include &lt;boost/optional.hpp&gt;\n\n\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/reflect/prototypes.hpp\"\n#include \"output_recorder.hpp\"\n\n\nnamespace zmbt {\n\nstruct PermanentEnvData final\n{\n    using SetupOutputRecorder = std::function&lt;void(OutputRecorder&amp;)&gt;;\n\n    boost::concurrent_flat_map&lt;interface_id, object_id&gt; default_objects{};\n    boost::concurrent_flat_map&lt;interface_id, reflect::Prototypes&gt; prototypes{};\n    boost::concurrent_flat_map&lt;interface_id, SetupOutputRecorder&gt; output_recorder_factories{};\n\n    boost::optional&lt;object_id&gt;             get_default_object(interface_id const&amp;) const;\n    boost::optional&lt;reflect::Prototypes&gt;   get_prototypes(interface_id const&amp;) const;\n    boost::optional&lt;SetupOutputRecorder&gt;   get_output_recorder_factory(interface_id const&amp;) const;\n};\n\n} // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/traits_8hpp/","title":"File traits.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; traits.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/expr/expression.hpp\"</code></li> </ul>"},{"location":"CxxRef/traits_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/traits_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/traits.hpp</code></p>"},{"location":"CxxRef/traits_8hpp_source/","title":"File traits.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; traits.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_TRAITS_HPP_\n#define ZMBT_MODEL_TRAITS_HPP_\n\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/expr/expression.hpp\"\n\n\nnamespace zmbt {\n\n\nnamespace detail {\n\ntemplate &lt;class T&gt;\nusing is_param = is_same&lt;remove_cvref_t&lt;T&gt;, Param&gt;;\n\n\ntemplate &lt;class T&gt;\nusing is_expr = is_same&lt;remove_cvref_t&lt;T&gt;, lang::Expression&gt;;\n\ntemplate &lt;class T&gt;\nusing is_ref = mp_or&lt;boost::json::is_string_like&lt;T&gt;, is_param&lt;T&gt;, is_expr&lt;T&gt;&gt;;\n\ntemplate &lt;class T&gt;\nusing not_ref = mp_not&lt;is_ref&lt;T&gt;&gt;;\n\ntemplate &lt;class T&gt;\nusing maybe_obj = mp_and&lt;not_ref&lt;T&gt;, is_constructible&lt;object_id, T&gt;&gt;;\n\ntemplate &lt;class T&gt;\nusing is_cal = is_ifc_handle&lt;T&gt;;\n\ntemplate &lt;class T&gt;\nusing not_cal = mp_not&lt;is_cal&lt;T&gt;&gt;;\n\n} // namespace detail\n\ntemplate &lt;class T, class R = void&gt;\nusing require_str = mp_if&lt;boost::json::is_string_like&lt;T&gt;, R&gt;;\n\ntemplate &lt;class T, class R = void&gt;\nusing require_not_str = mp_if&lt;mp_not&lt;boost::json::is_string_like&lt;T&gt;&gt;, R&gt;;\n\ntemplate &lt;class T, class R = void&gt;\nusing require_cal = mp_if&lt;detail::is_cal&lt;T&gt;, R&gt;;\n\ntemplate &lt;class T, class R = void&gt;\nusing require_not_cal = mp_if&lt;detail::not_cal&lt;T&gt;, R&gt;;\n\ntemplate &lt;class T, class R = void&gt;\nusing require_obj = mp_if&lt;detail::maybe_obj&lt;T&gt;, R&gt;;\n\ntemplate &lt;class O, class I, class R = void&gt;\nusing require_literal = mp_if&lt;mp_and&lt;detail::maybe_obj&lt;O&gt;, detail::is_cal&lt;I&gt;&gt;, R&gt;;\n\ntemplate &lt;class T, class R = void&gt;\nusing require_json_from = mp_if&lt;boost::json::has_value_from&lt;T&gt;, R&gt;;\n\ntemplate &lt;class T, class R = void&gt;\nusing require_no_json_from = mp_if&lt;mp_not&lt;boost::json::has_value_from&lt;T&gt;&gt;, R&gt;;\n\n} // namespace zmbt\n\n\n#endif\n</code></pre>"},{"location":"CxxRef/trigger_8hpp/","title":"File trigger.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; trigger.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;boost/type_index.hpp&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"zmbt/reflect.hpp\"</code></li> <li><code>#include \"output_recorder.hpp\"</code></li> </ul>"},{"location":"CxxRef/trigger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace."},{"location":"CxxRef/trigger_8hpp/#classes","title":"Classes","text":"Type Name class Trigger Controlled environment interface executor. class TriggerIfc class TriggerObj Object handler to be used with TriggerIfc ."},{"location":"CxxRef/trigger_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/model/trigger.hpp</code></p>"},{"location":"CxxRef/trigger_8hpp_source/","title":"File trigger.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; model &gt; trigger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_MODEL_TRIGGER_HPP_\n#define ZMBT_MODEL_TRIGGER_HPP_\n\n#include &lt;boost/type_index.hpp&gt;\n\n#include \"zmbt/core.hpp\"\n#include \"zmbt/reflect.hpp\"\n#include \"output_recorder.hpp\"\n\nnamespace zmbt {\n\nnamespace detail {\n\ntemplate &lt;class T&gt;\ninline auto static_ptr_cast(std::shared_ptr&lt;void&gt; obj)\n{\n    return std::static_pointer_cast&lt;T&gt;(obj);\n};\n\ntemplate &lt;&gt;\ninline auto static_ptr_cast&lt;nullptr_t&gt;(std::shared_ptr&lt;void&gt; obj)\n{\n    return nullptr;\n};\n\n}\n\n\n\nclass TriggerObj\n{\n    object_id id_;\n    bool is_unsafe_ptr_;\n    std::shared_ptr&lt;void&gt; ptr_;\n\n    static void stub_delete(void*) {}\n\npublic:\n\n    template &lt;class T&gt;\n    TriggerObj(std::shared_ptr&lt;T&gt; obj)\n        : id_{(remove_cvref_t&lt;T&gt;*)(obj.get())}\n        , is_unsafe_ptr_{false}\n        , ptr_{obj}\n    {\n    }\n\n    template &lt;class T&gt;\n    TriggerObj(T* obj)\n        : id_{obj}\n        , is_unsafe_ptr_{true}\n        , ptr_{std::shared_ptr&lt;void&gt;(obj, stub_delete)}\n    {\n    }\n\n    template &lt;class T&gt;\n    TriggerObj(T const* obj) : TriggerObj(const_cast&lt;T*&gt;(obj))\n    {\n    }\n\n    template &lt;class T&gt;\n    TriggerObj(T&amp; obj) : TriggerObj(&amp;obj)\n    {\n    }\n\n    template &lt;class T&gt;\n    TriggerObj(T const&amp; obj) : TriggerObj(&amp;obj)\n    {\n    }\n\n\n    TriggerObj(nullptr_t)\n        : id_{nullptr}\n        , is_unsafe_ptr_{false}\n        , ptr_{nullptr}\n    {\n    }\n\n    virtual ~TriggerObj() = default;\n\n    TriggerObj(TriggerObj const&amp;) = default;\n    TriggerObj(TriggerObj &amp;&amp;) = default;\n    TriggerObj&amp; operator=(TriggerObj const&amp;) = default;\n    TriggerObj&amp; operator=(TriggerObj &amp;&amp;) = default;\n\n    object_id id() const\n    {\n        return id_;\n    }\n\n    bool unsafe() const\n    {\n        return is_unsafe_ptr_;\n    }\n\n    std::shared_ptr&lt;void&gt; ptr() const\n    {\n        return ptr_;\n    }\n};\n\n\n\nclass TriggerIfc\n{\n    interface_id id_;\n    std::function&lt;void(std::shared_ptr&lt;void&gt;, boost::json::value const&amp;, OutputRecorder&amp;)&gt; fn_;\n\n    template &lt;class R&gt;\n    static auto apply_fn(std::function&lt;R()&gt; fn) -&gt; mp_if&lt;is_void&lt;R&gt;, nullptr_t&gt;\n    {\n        fn();\n        return nullptr;\n    }\n\n    template &lt;class R&gt;\n    static auto apply_fn(std::function&lt;R()&gt; fn) -&gt; mp_if&lt;mp_not&lt;is_void&lt;R&gt;&gt;, R&gt;\n    {\n        return fn();\n    }\n\npublic:\n\n    template &lt;class Interface&gt;\n    TriggerIfc(Interface&amp;&amp; interface)\n        : id_{std::forward&lt;Interface&gt;(interface)}\n        , fn_{[ifc_ptr = get_ifc_pointer(std::forward&lt;Interface&gt;(interface))]\n            (std::shared_ptr&lt;void&gt; obj, boost::json::value const&amp; args_in, OutputRecorder&amp; recorder) {\n            using reflection = reflect::invocation&lt;Interface const&amp;&gt;;\n            using return_t = typename reflection::return_t;\n            using args_t = typename reflection::args_t;\n            using args_unqf_t = tuple_unqf_t&lt;args_t&gt;;\n            using ifc_host_unref_t = remove_reference_t&lt;typename reflection::host_t&gt;;\n\n            using result_t = mp_if&lt;is_void&lt;return_t&gt;, nullptr_t, remove_cvref_t&lt;return_t&gt;&gt;;\n\n            boost::json::value args_json_in_out;\n            std::function&lt;return_t()&gt; fn;\n            std::function&lt;boost::json::value()&gt; get_in_out_args = []{ return nullptr; };\n\n            args_unqf_t args_to_capture = reflect::signal_traits&lt;args_unqf_t&gt;::init();\n            ErrorOr&lt;result_t&gt; return_or_error {};\n\n            try\n            {\n                args_unqf_t args_typed_unqf_in = args_in.is_array()\n                    ? dejsonize&lt;args_unqf_t&gt;(args_in)\n                    : dejsonize&lt;args_unqf_t&gt;(boost::json::array{args_in});\n\n                args_t args_typed_in_out = convert_tuple_to&lt;args_t&gt;(args_typed_unqf_in);\n\n                fn = [obj, ifc_ptr, args_typed_in_out]() -&gt; return_t {\n                    if (is_member_function_pointer&lt;Interface&gt;::value &amp;&amp; !obj) {\n                        throw_exception(environment_error(\"invoking mfp trigger with null object\"));\n                    }\n                    // WARN: is_unsafe_ptr cast\n                    // TODO: check type_index by comp option\n                    return reflection::apply(detail::static_ptr_cast&lt;ifc_host_unref_t&gt;(obj), ifc_ptr, args_typed_in_out);\n                };\n\n                try\n                {\n                    return_or_error = ErrorOr&lt;result_t&gt;::MakeValue(apply_fn&lt;return_t&gt;(fn));\n                }\n                catch(const std::exception&amp; e)\n                {\n                    auto const dynamic_exception_type = boost::typeindex::type_id_runtime(e).pretty_name();\n                    ErrorInfo err;\n                    err.type = dynamic_exception_type.c_str();\n                    err.what = e.what();\n                    err.context = \"trigger execution\";\n                    return_or_error = ErrorOr&lt;result_t&gt;::MakeError(err);\n\n                }\n                catch(...)\n                {\n                    // TODO: try to get type info from std::exception_ptr\n\n                    ErrorInfo err;\n                    err.type = \"unknown\";\n                    err.what = \"unknown\";\n                    err.context = \"trigger execution\";\n                    return_or_error = ErrorOr&lt;result_t&gt;::MakeError(err);\n                }\n\n                args_to_capture = convert_tuple_to&lt;args_unqf_t&gt;(args_typed_in_out);\n            }\n            catch(const std::exception&amp; e)\n            {\n                auto const dynamic_exception_type = boost::typeindex::type_id_runtime(e).pretty_name();\n                    ErrorInfo err;\n                    err.type = dynamic_exception_type.c_str();\n                    err.what = e.what();\n                    err.context = \"trigger args evaluation\";\n                    return_or_error = ErrorOr&lt;result_t&gt;::MakeError(err);\n            }\n\n            recorder.push(args_to_capture, return_or_error);\n        }}\n    {\n    }\n\n    virtual ~TriggerIfc() = default;\n\n    TriggerIfc(TriggerIfc const&amp;) = default;\n    TriggerIfc(TriggerIfc &amp;) = default;\n    TriggerIfc(TriggerIfc &amp;&amp;) = default;\n    TriggerIfc&amp; operator=(TriggerIfc const&amp;) = default;\n    TriggerIfc&amp; operator=(TriggerIfc &amp;&amp;) = default;\n\n    interface_id id() const\n    {\n        return id_;\n    }\n\n\n    void execute(std::shared_ptr&lt;void&gt; obj, boost::json::value const&amp; args_in, OutputRecorder&amp; recorder) const\n    {\n        return fn_(obj, args_in, recorder);\n    }\n};\n\nclass Trigger final {\n    struct internal_ctor {};\n    TriggerObj obj_;\n    TriggerIfc ifc_;\n    std::shared_ptr&lt;OutputRecorder&gt; output_recorder_;\n\n    Trigger(internal_ctor, TriggerObj const&amp; obj, TriggerIfc const&amp; ifc, std::shared_ptr&lt;OutputRecorder&gt; recorder)\n        : obj_{obj}\n        , ifc_{ifc}\n        , output_recorder_{std::move(recorder)}\n    {\n    }\n\n\n  public:\n\n    ~Trigger() = default;\n    Trigger(Trigger const&amp;) = default;\n    Trigger(Trigger &amp;&amp;) = default;\n    Trigger&amp; operator=(Trigger const&amp;) = default;\n    Trigger&amp; operator=(Trigger &amp;&amp;) = default;\n\n    template &lt;class T, class Interface&gt;\n    Trigger(T&amp;&amp; obj, Interface&amp;&amp; interface, std::shared_ptr&lt;OutputRecorder&gt; recorder)\n        : Trigger(internal_ctor{}, TriggerObj(std::forward&lt;T&gt;(obj)), TriggerIfc(std::forward&lt;Interface&gt;(interface)), recorder)\n    {\n    }\n\n\n    void operator()(boost::json::value args_in) const\n    {\n        ifc_.execute(obj_.ptr(), std::move(args_in), *output_recorder_);\n    }\n\n    bool operator==(Trigger const&amp; o) const\n    {\n        return (obj_.id() == o.obj_.id()) &amp;&amp; (ifc_.id() == o.ifc_.id());\n    }\n\n    bool operator!=(Trigger const&amp; o) const\n    {\n        return !this-&gt;operator==(o);\n    }\n\n    object_id obj_id() const\n    {\n        return obj_.id();\n    }\n\n    interface_id ifc_id() const\n    {\n        return ifc_.id();\n    }\n\n};\n\n\n}  // namespace zmbt\n\n#endif\n</code></pre>"},{"location":"CxxRef/dir_44621b39643a5ee7797a55bb572a295f/","title":"Dir zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect</p>"},{"location":"CxxRef/dir_44621b39643a5ee7797a55bb572a295f/#files","title":"Files","text":"Type Name file ducktyping_traits_pp.hpp file invocation.hpp file prototypes.hpp file serialization.hpp file serialization_defaults.hpp file signal_traits.hpp <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/</code></p>"},{"location":"CxxRef/ducktyping__traits__pp_8hpp/","title":"File ducktyping_traits_pp.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; ducktyping_traits_pp.hpp</p> <p>Go to the source code of this file</p> <p>More...</p>"},{"location":"CxxRef/ducktyping__traits__pp_8hpp/#macros","title":"Macros","text":"Type Name define CAT (a, b) <code>a##b</code> define ZMBT_HAS_MEMBER (name) <code>ZMBT\\_TRAIT\\_HAS\\_MEMBER(CAT(has\\_member\\_, name), name)</code> define ZMBT_HAS_TYPE (name) <code>ZMBT\\_TRAIT\\_HAS\\_TYPE(CAT(has\\_type\\_, name), name)</code> define ZMBT_TRAIT_HAS_MEMBER (trait, name) <code>/* multi line expression */</code> define ZMBT_TRAIT_HAS_TYPE (trait, name) <code>/* multi line expression */</code>"},{"location":"CxxRef/ducktyping__traits__pp_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/ducktyping__traits__pp_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/ducktyping__traits__pp_8hpp/#define-cat","title":"define CAT","text":"<pre><code>#define CAT (\n    a,\n    b\n) `a##b`\n</code></pre>"},{"location":"CxxRef/ducktyping__traits__pp_8hpp/#define-zmbt_has_member","title":"define ZMBT_HAS_MEMBER","text":"<pre><code>#define ZMBT_HAS_MEMBER (\n    name\n) `ZMBT_TRAIT_HAS_MEMBER(CAT(has_member_, name), name)`\n</code></pre>"},{"location":"CxxRef/ducktyping__traits__pp_8hpp/#define-zmbt_has_type","title":"define ZMBT_HAS_TYPE","text":"<pre><code>#define ZMBT_HAS_TYPE (\n    name\n) `ZMBT_TRAIT_HAS_TYPE(CAT(has_type_, name), name)`\n</code></pre>"},{"location":"CxxRef/ducktyping__traits__pp_8hpp/#define-zmbt_trait_has_member","title":"define ZMBT_TRAIT_HAS_MEMBER","text":"<pre><code>#define ZMBT_TRAIT_HAS_MEMBER (\n    trait,\n    name\n) `/* multi line expression */`\n</code></pre>"},{"location":"CxxRef/ducktyping__traits__pp_8hpp/#define-zmbt_trait_has_type","title":"define ZMBT_TRAIT_HAS_TYPE","text":"<pre><code>#define ZMBT_TRAIT_HAS_TYPE (\n    trait,\n    name\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/ducktyping_traits_pp.hpp</code></p>"},{"location":"CxxRef/ducktyping__traits__pp_8hpp_source/","title":"File ducktyping_traits_pp.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; ducktyping_traits_pp.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_REFLECT_DUCKTYPING_TRAITS_MACROS_HPP_\n#define ZMBT_REFLECT_DUCKTYPING_TRAITS_MACROS_HPP_\n\n#define CAT(a, b) a##b\n\n#define ZMBT_TRAIT_HAS_TYPE(trait, name)     \\\n    template &lt;class T, class = void&gt;         \\\n    struct trait : std::false_type {};       \\\n    template &lt;class T&gt;                       \\\n    struct trait&lt;                            \\\n        T, zmbt::void_t&lt;typename T::name&gt;&gt;   \\\n    : std::true_type {};\n\n\n#define ZMBT_TRAIT_HAS_MEMBER(trait, name)           \\\n    template &lt;class T, class = void&gt;                 \\\n    struct trait : std::false_type {};               \\\n    template &lt;class T&gt;                               \\\n    struct trait&lt;T,                                  \\\n    zmbt::void_t&lt;decltype(std::declval&lt;T&gt;().name())&gt;&gt;\\\n    : std::true_type {};\n\n\n#define ZMBT_HAS_TYPE(name) ZMBT_TRAIT_HAS_TYPE(CAT(has_type_, name), name)\n#define ZMBT_HAS_MEMBER(name) ZMBT_TRAIT_HAS_MEMBER(CAT(has_member_, name), name)\n\n\n\n\n#endif // ZMBT_REFLECT_DUCKTYPING_TRAITS_MACROS_HPP_\n</code></pre>"},{"location":"CxxRef/invocation_8hpp/","title":"File invocation.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; invocation.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> </ul>"},{"location":"CxxRef/invocation_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace reflect Reflection metafunctions."},{"location":"CxxRef/invocation_8hpp/#classes","title":"Classes","text":"Type Name struct default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt; &lt;class S&gt; struct default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt; &lt;class S&gt; struct default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt; &lt;class S&gt; struct has_invocation_for &lt;class T, class E&gt;Trait check for reflect::invocation&lt;T&gt; struct invocation&lt; S, detail::enable_custom_invocation&lt; S &gt; &gt; &lt;class S&gt; struct invocation&lt; S, detail::enable_default_invocation&lt; S &gt; &gt; &lt;class S&gt;"},{"location":"CxxRef/invocation_8hpp/#macros","title":"Macros","text":"Type Name define DEFAULT_INVOCATION_TYPEDEFS <code>/* multi line expression */</code>"},{"location":"CxxRef/invocation_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/invocation_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/invocation_8hpp/#define-default_invocation_typedefs","title":"define DEFAULT_INVOCATION_TYPEDEFS","text":"<pre><code>#define DEFAULT_INVOCATION_TYPEDEFS `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/invocation.hpp</code></p>"},{"location":"CxxRef/invocation_8hpp_source/","title":"File invocation.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; invocation.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_REFLECT_INTERFACE_HPP_\n#define ZMBT_REFLECT_INTERFACE_HPP_\n\n#include &lt;functional&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\n#include \"zmbt/core.hpp\"\n\n\n#define DEFAULT_INVOCATION_TYPEDEFS  \\\nusing host_t   = ifc_host_t&lt;type&gt;;   \\\nusing return_t = ifc_return_t&lt;type&gt;; \\\nusing args_t   = ifc_args_t&lt;type&gt;;\n\n\nnamespace zmbt {\nnamespace reflect {\n\n\ntemplate &lt;class T, class E = void&gt;\nstruct invocation;\n\n\ntemplate &lt;class T, class E = void&gt;\nstruct custom_invocation;\n\nnamespace detail {\n\n\ntemplate&lt;class T&gt;\nusing custom_invocation_t = typename custom_invocation&lt;T&gt;::type;\n\ntemplate&lt;class T&gt;\nusing has_custom_invocation = mp_valid&lt;custom_invocation_t, T&gt;;\n\ntemplate &lt;class Interface&gt;\nusing enable_default_invocation = first_if_t&lt;void,\n    is_ifc_handle&lt;Interface&gt;,\n    mp_not&lt;has_custom_invocation&lt;ifc_pointer_t&lt;Interface&gt;&gt;&gt;\n&gt;;\n\n\ntemplate &lt;class Interface&gt;\nusing enable_custom_invocation = first_if_t&lt;void, has_custom_invocation&lt;ifc_pointer_t&lt;Interface&gt;&gt;&gt;;\n\n} // namespace detail\n\ntemplate &lt;class S, class E = void&gt;\nstruct default_invocation;\n\n\n\ntemplate &lt;class S&gt;\nstruct default_invocation&lt;S, first_if_t&lt;void, ifc_is_member_handle&lt;S&gt;&gt;&gt;\n{\n    using type = S;\n    DEFAULT_INVOCATION_TYPEDEFS\n\n    template &lt;class H&gt;\n    static return_t apply(H&amp;&amp; object, type ifc, args_t args)\n    {\n        return boost::mp11::tuple_apply(std::mem_fn(ifc), std::tuple_cat(std::forward_as_tuple(object), args));\n    }\n};\n\ntemplate &lt;class S&gt;\nstruct default_invocation&lt;S, first_if_any_t&lt;void, ifc_is_fn_handle&lt;S&gt;, ifc_is_functor_ref&lt;S&gt;&gt;&gt;\n{\n    using type = S;\n    DEFAULT_INVOCATION_TYPEDEFS\n\n    static return_t apply(host_t, type ifc, args_t args)\n    {\n        static_assert(std::is_same&lt;host_t, nullptr_t&gt;::value, \"\");\n        return boost::mp11::tuple_apply(ifc, args);\n    }\n};\n\ntemplate &lt;class S&gt;\nstruct default_invocation&lt;S, first_if_t&lt;void, ifc_is_functor_ptr&lt;S&gt;&gt;&gt;\n{\n    using type = S;\n    DEFAULT_INVOCATION_TYPEDEFS\n\n    static return_t apply(host_t, type ifc, args_t args)\n    {\n        static_assert(std::is_same&lt;host_t, nullptr_t&gt;::value, \"\");\n        return boost::mp11::tuple_apply(*ifc, args);\n    }\n};\n\n\n\n\ntemplate &lt;class S&gt;\nstruct invocation&lt;S, detail::enable_default_invocation&lt;S&gt;&gt; : default_invocation&lt;ifc_pointer_t&lt;S&gt;&gt; {};\n\ntemplate &lt;class S&gt;\nstruct invocation&lt;S, detail::enable_custom_invocation&lt;S&gt;&gt; : custom_invocation&lt;ifc_pointer_t&lt;S&gt;&gt; {};\n\ntemplate&lt;class T, class E = void&gt;\nstruct has_invocation_for : std::false_type { };\n\ntemplate&lt;class T&gt;\nstruct has_invocation_for&lt;T, void_t&lt;typename invocation&lt;T&gt;::type&gt;&gt; : std::true_type { };\n\n\ntemplate &lt;class Interface&gt;\nusing interface_t = typename reflect::invocation&lt;Interface&gt;::type;\n\n\ntemplate &lt;class Interface&gt;\nusing invocation_args_t = typename invocation&lt;Interface&gt;::args_t;\n\ntemplate &lt;class Interface&gt;\nusing invocation_args_unqf_t = tuple_unqf_t&lt;invocation_args_t&lt;Interface&gt;&gt;;\n\ntemplate &lt;class Interface&gt;\nusing invocation_has_void_args = std::integral_constant&lt;bool, 0 == boost::mp11::mp_size&lt;invocation_args_t&lt;Interface&gt;&gt;::value &gt;;\n\n\ntemplate &lt;class Interface&gt;\nusing invocation_ret_t = typename invocation&lt;Interface&gt;::return_t;\n\ntemplate &lt;class Interface&gt;\nusing invocation_ret_unqf_t = remove_cvref_t&lt;invocation_ret_t&lt;Interface&gt;&gt;;\n\ntemplate &lt;class Interface&gt;\nusing invocation_has_void_ret = std::is_void&lt;invocation_ret_t&lt;Interface&gt;&gt;;\n\n\ntemplate &lt;class Interface&gt;\nusing invocation_ret_unqf_or_nullptr_t = mp_if&lt;invocation_has_void_ret&lt;Interface&gt;, nullptr_t, invocation_ret_unqf_t&lt;Interface&gt;&gt;;\n\n\n\n\ntemplate &lt;class T&gt;\nusing invocation_host_t = typename invocation&lt;T&gt;::host_t;\n\ntemplate &lt;class T&gt;\nusing invocation_unqf_host_t = remove_cvref_t&lt;invocation_host_t&lt;T&gt;&gt;;\n\n}  // namespace reflect\n}  // namespace zmbt\n\n\n#undef DEFAULT_INVOCATION_TYPEDEFS\n#endif  // ZMBT_REFLECT_INTERFACE_PLUGIN_DEFAULT_HPP_\n</code></pre>"},{"location":"CxxRef/prototypes_8hpp/","title":"File prototypes.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; prototypes.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"signal_traits.hpp\"</code></li> <li><code>#include \"serialization.hpp\"</code></li> <li><code>#include \"invocation.hpp\"</code></li> </ul>"},{"location":"CxxRef/prototypes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace reflect Reflection metafunctions."},{"location":"CxxRef/prototypes_8hpp/#classes","title":"Classes","text":"Type Name class Prototypes Interface prototypes in JSON as {\"args\": [...], \"return\": ... }."},{"location":"CxxRef/prototypes_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/prototypes.hpp</code></p>"},{"location":"CxxRef/prototypes_8hpp_source/","title":"File prototypes.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; prototypes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_REFLECT_PROTOTYPES_HPP_\n#define ZMBT_REFLECT_PROTOTYPES_HPP_\n\n#include \"zmbt/core.hpp\"\n#include \"signal_traits.hpp\"\n#include \"serialization.hpp\"\n#include \"invocation.hpp\"\n\nnamespace zmbt {\nnamespace reflect {\n\nnamespace detail\n{\ntemplate &lt;class T&gt;\nauto init_return() -&gt; mp_if&lt;is_void&lt;T&gt;, boost::json::value&gt;\n{\n    return nullptr;\n}\n\ntemplate &lt;class T&gt;\nauto init_return() -&gt; mp_if&lt;mp_not&lt;is_void&lt;T&gt;&gt;, boost::json::value&gt;\n{\n    return json_from(reflect::signal_traits&lt;T&gt;::init());\n}\n\ntemplate &lt;class T&gt;\nauto init_args()\n{\n    return json_from(reflect::init_tuple&lt;T&gt;()).as_array();\n}\n\n} // namespace detail\n\n\nclass Prototypes\n{\n    boost::json::array args_;\n    boost::json::value return_;\n\n  public:\n    Prototypes(boost::json::array&amp;&amp; args, boost::json::value&amp;&amp; ret)\n        : args_(std::move(args))\n        , return_(std::move(ret))\n    {\n    }\n\n    Prototypes() : Prototypes({}, {})\n    {\n    }\n\n    template&lt;class T&gt;\n    Prototypes(T const&amp;)\n        : Prototypes(\n            detail::init_args&lt;reflect::invocation_args_unqf_t&lt;T const&amp;&gt;&gt;(),\n            detail::init_return&lt;reflect::invocation_ret_unqf_t&lt;T const&amp;&gt;&gt;()\n        )\n    {\n    }\n\n    boost::json::array const&amp; args() const { return args_; };\n    boost::json::value const&amp; ret() const { return return_; };\n\n};\n\n} // namespace reflect\n} // namespace zmbt\n\n#endif // ZMBT_REFLECT_PROTOTYPES_HPP_\n</code></pre>"},{"location":"CxxRef/serialization_8hpp/","title":"File serialization.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; serialization.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"zmbt/core/preprocessor.hpp\"</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> <li><code>#include \"ducktyping_traits_pp.hpp\"</code></li> <li><code>#include \"signal_traits.hpp\"</code></li> <li><code>#include \"serialization_defaults.hpp\"</code></li> </ul>"},{"location":"CxxRef/serialization_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace reflect Reflection metafunctions."},{"location":"CxxRef/serialization_8hpp/#classes","title":"Classes","text":"Type Name struct has_serialization &lt;class T, class E&gt; struct serialization&lt; T, detail::enable_for_custom_serialization&lt; T &gt; &gt; &lt;class T&gt; struct serialization&lt; T, detail::enable_for_default_serialization&lt; T &gt; &gt; &lt;class T&gt;"},{"location":"CxxRef/serialization_8hpp/#macros","title":"Macros","text":"Type Name define ZMBT_INJECT_JSON_TAG_INVOKE <code>using [**zmbt::reflect::tag\\_invoke**](namespacezmbt_1_1reflect.md#function-tag_invoke);</code> define ZMBT_INJECT_JSON_TAG_INVOKE_INTO (...) <code>ZMBT\\_PP\\_INJECT\\_CODE\\_INTO\\_NS(ZMBT\\_INJECT\\_JSON\\_TAG\\_INVOKE, \\_\\_VA\\_ARGS\\_\\_)</code> define ZMBT_INJECT_OSTREAM_OPERATOR <code>using zmbt::reflect::operator&amp;lt;&amp;lt;;</code> define ZMBT_INJECT_OSTREAM_OPERATOR_INTO (...) <code>ZMBT\\_PP\\_INJECT\\_CODE\\_INTO\\_NS(ZMBT\\_INJECT\\_OSTREAM\\_OPERATOR, \\_\\_VA\\_ARGS\\_\\_)</code> define ZMBT_INJECT_SERIALIZATION <code>ZMBT\\_INJECT\\_JSON\\_TAG\\_INVOKE ZMBT\\_INJECT\\_OSTREAM\\_OPERATOR</code> define ZMBT_INJECT_SERIALIZATION_INTO (...) <code>ZMBT\\_PP\\_INJECT\\_CODE\\_INTO\\_NS(ZMBT\\_INJECT\\_SERIALIZATION, \\_\\_VA\\_ARGS\\_\\_)</code>"},{"location":"CxxRef/serialization_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/serialization_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/serialization_8hpp/#define-zmbt_inject_json_tag_invoke","title":"define ZMBT_INJECT_JSON_TAG_INVOKE","text":"<pre><code>#define ZMBT_INJECT_JSON_TAG_INVOKE `using zmbt::reflect::tag_invoke ;`\n</code></pre>"},{"location":"CxxRef/serialization_8hpp/#define-zmbt_inject_json_tag_invoke_into","title":"define ZMBT_INJECT_JSON_TAG_INVOKE_INTO","text":"<pre><code>#define ZMBT_INJECT_JSON_TAG_INVOKE_INTO (\n    ...\n) `ZMBT_PP_INJECT_CODE_INTO_NS(ZMBT_INJECT_JSON_TAG_INVOKE, __VA_ARGS__)`\n</code></pre>"},{"location":"CxxRef/serialization_8hpp/#define-zmbt_inject_ostream_operator","title":"define ZMBT_INJECT_OSTREAM_OPERATOR","text":"<pre><code>#define ZMBT_INJECT_OSTREAM_OPERATOR `using zmbt::reflect::operator&lt;&lt;;`\n</code></pre>"},{"location":"CxxRef/serialization_8hpp/#define-zmbt_inject_ostream_operator_into","title":"define ZMBT_INJECT_OSTREAM_OPERATOR_INTO","text":"<pre><code>#define ZMBT_INJECT_OSTREAM_OPERATOR_INTO (\n    ...\n) `ZMBT_PP_INJECT_CODE_INTO_NS(ZMBT_INJECT_OSTREAM_OPERATOR, __VA_ARGS__)`\n</code></pre>"},{"location":"CxxRef/serialization_8hpp/#define-zmbt_inject_serialization","title":"define ZMBT_INJECT_SERIALIZATION","text":"<pre><code>#define ZMBT_INJECT_SERIALIZATION `ZMBT_INJECT_JSON_TAG_INVOKE ZMBT_INJECT_OSTREAM_OPERATOR`\n</code></pre>"},{"location":"CxxRef/serialization_8hpp/#define-zmbt_inject_serialization_into","title":"define ZMBT_INJECT_SERIALIZATION_INTO","text":"<pre><code>#define ZMBT_INJECT_SERIALIZATION_INTO (\n    ...\n) `ZMBT_PP_INJECT_CODE_INTO_NS(ZMBT_INJECT_SERIALIZATION, __VA_ARGS__)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/serialization.hpp</code></p>"},{"location":"CxxRef/serialization_8hpp_source/","title":"File serialization.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; serialization.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_SERIALIZATION_HPP_\n#define ZMBT_CORE_SERIALIZATION_HPP_\n\n#include &lt;type_traits&gt;\n\n#include &lt;boost/json.hpp&gt;\n\n#include \"zmbt/core/preprocessor.hpp\" // IWYU pragma: export\n#include \"zmbt/core.hpp\"\n#include \"ducktyping_traits_pp.hpp\"\n#include \"signal_traits.hpp\"\n\n\n#define ZMBT_INJECT_JSON_TAG_INVOKE using zmbt::reflect::tag_invoke;\n#define ZMBT_INJECT_OSTREAM_OPERATOR using zmbt::reflect::operator&lt;&lt;;\n#define ZMBT_INJECT_SERIALIZATION ZMBT_INJECT_JSON_TAG_INVOKE ZMBT_INJECT_OSTREAM_OPERATOR\n\n\n#define ZMBT_INJECT_JSON_TAG_INVOKE_INTO(...) ZMBT_PP_INJECT_CODE_INTO_NS(ZMBT_INJECT_JSON_TAG_INVOKE, __VA_ARGS__)\n#define ZMBT_INJECT_OSTREAM_OPERATOR_INTO(...) ZMBT_PP_INJECT_CODE_INTO_NS(ZMBT_INJECT_OSTREAM_OPERATOR, __VA_ARGS__)\n#define ZMBT_INJECT_SERIALIZATION_INTO(...) ZMBT_PP_INJECT_CODE_INTO_NS(ZMBT_INJECT_SERIALIZATION, __VA_ARGS__)\n\n\n\nnamespace zmbt {\nnamespace reflect {\n\ntemplate &lt;class T, class = void&gt;\nstruct serialization;\n\ntemplate &lt;class T, class = void&gt;\nstruct custom_serialization;\n\n\nnamespace detail {\n\n\ntemplate &lt;class T, class E = void&gt;\nstruct default_serialization;\n\ntemplate&lt;class T&gt;\nusing default_serialization_t = decltype(default_serialization&lt;T&gt;::json_from(std::declval&lt;T&gt;()));\n\ntemplate&lt;class T&gt;\nusing has_default_serialization = mp_valid&lt;default_serialization_t, T&gt;;\n\ntemplate&lt;class T&gt;\nusing custom_serialization_t = decltype(custom_serialization&lt;T&gt;::json_from(std::declval&lt;T&gt;()));\n\ntemplate&lt;class T&gt;\nusing has_custom_serialization = mp_valid&lt;custom_serialization_t, T&gt;;\n\n\nZMBT_TRAIT_HAS_MEMBER(has_json_operator, operator boost::json::value)\n\ntemplate&lt;class T&gt;\nusing is_json_convertible = mp_and&lt;\n    is_constructible&lt;T, boost::json::value&gt;,\n    has_json_operator&lt;T&gt;\n&gt;;\n\n\ntemplate &lt;class T, class R = void&gt;\nusing enable_for_default_serialization = first_if_t&lt;R,\n    mp_not&lt;has_custom_serialization&lt;T&gt;&gt;,\n    has_default_serialization&lt;T&gt;\n&gt;;\n\ntemplate &lt;class T, class R = void&gt;\nusing enable_for_custom_serialization = first_if_t&lt;R, has_custom_serialization&lt;T&gt;&gt;;\n\n\ntemplate &lt;class T, class R = void&gt;\nusing enable_hermetic_serialization = first_if_any_t&lt;R,\n    has_custom_serialization&lt;T&gt;,\n    has_default_serialization&lt;T&gt;\n&gt;;\n\ntemplate &lt;class T, class R = void&gt;\nusing disable_hermetic_serialization = first_if_none_t&lt;R,\n    has_custom_serialization&lt;T&gt;,\n    has_default_serialization&lt;T&gt;\n&gt;;\n\n} // namespace detail\n\ntemplate &lt;class T&gt;\nstruct serialization&lt;T, detail::enable_for_default_serialization&lt;T&gt;&gt; : detail::default_serialization&lt;T&gt; {};\n\ntemplate &lt;class T&gt;\nstruct serialization&lt;T, detail::enable_for_custom_serialization&lt;T&gt;&gt; : custom_serialization&lt;T&gt; {};\n\ntemplate &lt;class T&gt;\ndetail::enable_hermetic_serialization&lt;T, void&gt;\ntag_invoke(boost::json::value_from_tag const&amp;, boost::json::value&amp; v, T const&amp; t)\n{\n    v = serialization&lt;T&gt;::json_from(t);\n}\n\ntemplate &lt;class T&gt;\ndetail::enable_hermetic_serialization&lt;T, T&gt;\ntag_invoke(boost::json::value_to_tag&lt;T&gt; const&amp;, boost::json::value const&amp; v)\n{\n    return serialization&lt;T&gt;::dejsonize(v);\n}\n\ntemplate &lt;class T&gt;\ndetail::enable_hermetic_serialization&lt;T, std::ostream&amp;&gt;\noperator&lt;&lt; (std::ostream&amp; os, T const&amp; value)\n{\n    os &lt;&lt; serialization&lt;T&gt;::json_from(value);\n    return os;\n}\n\n} // namespace reflect\n\nZMBT_INJECT_SERIALIZATION\n\n\ntemplate&lt;class T, class E = void&gt;\nstruct has_serialization : std::false_type { };\n\ntemplate&lt;class T&gt;\nstruct has_serialization&lt;T, void_t&lt;typename reflect::serialization&lt;T&gt;::type&gt;&gt; : std::true_type { };\n\n\ntemplate &lt;class T, class TT = remove_cvref_t&lt;T&gt;&gt;\nreflect::detail::disable_hermetic_serialization&lt;TT, boost::json::value&gt;\njson_from(T&amp;&amp; t)\n{\n    return boost::json::value_from(std::forward&lt;T&gt;(t));\n}\n\ntemplate &lt;class T&gt;\nreflect::detail::disable_hermetic_serialization&lt;T, T&gt;\ndejsonize(boost::json::value const&amp; v)\n{\n    return boost::json::value_to&lt;T&gt;(v);\n}\n\ntemplate &lt;class T, class TT = remove_cvref_t&lt;T&gt;&gt;\nreflect::detail::enable_hermetic_serialization&lt;TT, boost::json::value&gt;\njson_from(T&amp;&amp; t)\n{\n    return reflect::serialization&lt;TT&gt;::json_from(std::forward&lt;T&gt;(t));\n}\n\ntemplate &lt;class T&gt;\nreflect::detail::enable_hermetic_serialization&lt;T, T&gt;\ndejsonize(boost::json::value const&amp; v)\n{\n    return reflect::serialization&lt;T&gt;::dejsonize(v);\n}\n\n// Trivial conversions not handled by Boost JSON\n\ninline boost::json::value json_from(std::tuple&lt;&gt;)\n{\n    return boost::json::array{};\n}\ntemplate &lt;&gt;\ninline std::tuple&lt;&gt; dejsonize&lt;std::tuple&lt;&gt;&gt;(boost::json::value const&amp;)\n{\n    // TODO: check value\n    return {};\n}\n\n\ntemplate &lt;&gt; inline void dejsonize&lt;void&gt;(boost::json::value const&amp;)\n{\n    // TODO: check value\n    return;\n}\n\n\n\n\ntemplate &lt;class T, std::size_t N&gt;\nboost::json::value json_from_array(T const (&amp;array)[N])\n{\n\n    boost::json::array out {};\n    out.reserve(N);\n    for (size_t i = 0; i &lt; N; i++)\n    {\n        out.push_back(zmbt::json_from(array[i]));\n    }\n    return out;\n}\n\ntemplate &lt;class T, std::size_t N&gt;\nvoid dejsonize_array(boost::json::array const&amp; jarr, T (&amp;array)[N])\n{\n\n    if (jarr.size() != N)\n    {\n        throw serialization_error(\"JSON array size mismatch in deserialization of `%s[%d]`\",\n            zmbt::type_name&lt;T&gt;() , N);\n    }\n    auto jarr_it = jarr.cbegin();\n    for (size_t i = 0; i &lt; N; i++)\n    {\n        array[i] = zmbt::dejsonize&lt;T&gt;(*jarr_it++);\n    }\n}\n\n} // namespace zmbt\n\n\n#endif // ZMBT_CORE_SERIALIZATION_HPP_\n\n#include \"serialization_defaults.hpp\"  // IWYU pragma: keep\n</code></pre>"},{"location":"CxxRef/serialization__defaults_8hpp/","title":"File serialization_defaults.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; serialization_defaults.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;boost/describe.hpp&gt;</code></li> <li><code>#include &lt;boost/json.hpp&gt;</code></li> <li><code>#include \"serialization.hpp\"</code></li> <li><code>#include &lt;complex&gt;</code></li> </ul>"},{"location":"CxxRef/serialization__defaults_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace reflect Reflection metafunctions."},{"location":"CxxRef/serialization__defaults_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/serialization_defaults.hpp</code></p>"},{"location":"CxxRef/serialization__defaults_8hpp_source/","title":"File serialization_defaults.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; serialization_defaults.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_CORE_SERIALIZATION_DEFAULTS_HPP_\n#define ZMBT_CORE_SERIALIZATION_DEFAULTS_HPP_\n\n#include &lt;functional&gt;\n#include &lt;type_traits&gt;\n\n#include &lt;boost/describe.hpp&gt;\n#include &lt;boost/json.hpp&gt;\n\n#include \"serialization.hpp\"\n\n#include &lt;complex&gt;\n\n\n\nnamespace zmbt {\nnamespace reflect {\nnamespace detail {\n\n// DESCRIBED ENUM SERIALIZER\n\ntemplate &lt;class T&gt;\nstruct default_serialization&lt;T, first_if_t&lt;void,\n    boost::describe::has_describe_enumerators&lt;T&gt;\n&gt;&gt;\n{\n    static boost::json::value json_from(T const&amp; t) {\n        boost::json::value v;\n        using Descr = boost::describe::describe_enumerators&lt;T&gt;;\n        using underlying_t = std::underlying_type_t&lt;T&gt;;\n\n        // first assign numeric value if nominal representation does not exist.\n        if (std::is_signed&lt;underlying_t&gt;::value) {\n            v.emplace_int64() = static_cast&lt;std::underlying_type_t&lt;T&gt;&gt;(t);\n        }\n        else {\n            v.emplace_uint64() = static_cast&lt;std::underlying_type_t&lt;T&gt;&gt;(t);\n        }\n\n        boost::mp11::mp_for_each&lt;Descr&gt;([&amp;](auto descr) {\n            if (t == descr.value) {\n                v.emplace_string() = descr.name;\n            }\n        });\n\n        return v;\n    }\n\n    static T dejsonize(boost::json::value const&amp; v)\n    {\n        using Descr = boost::describe::describe_enumerators&lt;T&gt;;\n        T t = reflect::signal_traits&lt;T&gt;::init();\n\n        if (v.is_number()) {\n            using underlying_t = std::underlying_type_t&lt;T&gt;;\n            if (std::is_signed&lt;underlying_t&gt;::value) {\n\n                std::int64_t value = v.as_int64();\n                std::int64_t test_value = static_cast&lt;std::int64_t&gt;(static_cast&lt;underlying_t&gt;(value));\n                if (value != test_value) {\n                    throw_exception(serialization_error(\"narrowing enum conversion, can't represent \" + std::to_string(value)));\n                }\n                t = static_cast&lt;T&gt;(value);\n            }\n            else {\n\n                std::uint64_t value = v.as_uint64();\n                if (value &gt; std::numeric_limits&lt;underlying_t&gt;::max()) {\n                    throw_exception(serialization_error(\"narrowing enum conversion, can't represent \" + std::to_string(value)));\n                }\n                t = static_cast&lt;T&gt;(value);\n            }\n        }\n        else if (v.is_string())\n        {\n            auto const &amp;value = boost::json::string_view {v.as_string()};\n            bool found = false;\n\n            boost::mp11::mp_for_each&lt;Descr&gt;([&amp;](auto descr) {\n                if (not found and value == boost::json::string_view(descr.name)) {\n                    t = T(descr.value);\n                    found = true;\n                }\n            });\n\n            if (not found) {\n                throw_exception(serialization_error(\"invalid enum value: %s\", value));\n            }\n\n        }\n\n        return t;\n    }\n};\n\n\n// DESCRIBED STRUCT SERIALIZER\n\n\ntemplate &lt;class T&gt;\nstruct default_serialization&lt;T, first_if_t&lt;void,\n    boost::describe::has_describe_members&lt;T&gt;\n&gt;&gt;\n{\n\n    static boost::json::value json_from(T const&amp; t)\n    {\n\n        static_assert(not std::is_union&lt;T&gt;::value, \"union types are not supported by default, provide a specialization\");\n\n        using Descr = boost::describe::describe_members&lt;T, boost::describe::mod_public | boost::describe::mod_inherited | boost::describe::mod_protected | boost::describe::mod_private&gt;;\n\n        boost::json::value v;\n\n        auto&amp; obj = v.emplace_object();\n\n        boost::mp11::mp_for_each&lt;Descr&gt;([&amp;](auto descr) {\n            obj[descr.name] = zmbt::json_from(t.*descr.pointer);\n        });\n\n        return v;\n    }\n\n    static T dejsonize(boost::json::value const&amp; v)\n    {\n\n        static_assert(not std::is_union&lt;T&gt;::value, \"union types are not supported by default, provide a specialization\");\n\n        using Descr = boost::describe::describe_members&lt;T, boost::describe::mod_public | boost::describe::mod_inherited | boost::describe::mod_protected | boost::describe::mod_private&gt;;\n\n        auto const&amp; obj = v.as_object();\n\n        T t = reflect::signal_traits&lt;T&gt;::init();\n\n        boost::mp11::mp_for_each&lt;Descr&gt;([&amp;](auto descr) {\n\n            using TT = std::remove_reference_t&lt;decltype(t.*descr.pointer)&gt;;\n            t.*descr.pointer = zmbt::dejsonize&lt;TT&gt;(obj.at(descr.name));\n        });\n\n        return t;\n    }\n};\n\n\ntemplate &lt;class T&gt;\nstruct default_serialization&lt;T, first_if_t&lt;void,\n    is_json_convertible&lt;T&gt;,\n    mp_not&lt;boost::describe::has_describe_members&lt;T&gt;&gt;\n&gt;&gt;\n{\n\n    static boost::json::value json_from(T const&amp; t)\n    {\n        return t.operator boost::json::value();\n    }\n\n    static T dejsonize(boost::json::value const&amp; v)\n    {\n        return T(v);\n    }\n};\n\n\n// STD TYPES\n\n\ntemplate &lt;class T&gt;\nstruct default_serialization&lt;std::complex&lt;T&gt;&gt;\n{\n\n    static boost::json::value json_from(std::complex&lt;T&gt; const&amp; t)\n    {\n\n        auto const real = real_to_number(t.real());\n        auto const imag = real_to_number(t.imag());\n        return t.imag() ? boost::json::array{real, imag} : real;\n    }\n\n    static std::complex&lt;T&gt; dejsonize(boost::json::value const&amp; v)\n    {\n        T real, imag;\n        if (v.is_array() &amp;&amp; v.get_array().size() == 2)\n        {\n            real = boost::json::value_to&lt;T&gt;(v.get_array().at(0));\n            imag = boost::json::value_to&lt;T&gt;(v.get_array().at(1));\n        }\n        else if (v.is_number())\n        {\n            real = boost::json::value_to&lt;T&gt;(v);\n            imag = 0;\n        }\n        else\n        {\n            throw_exception(serialization_error(\"can't produce std::complex from `%s`\", v));\n        }\n        return {real, imag};\n    }\n};\n\n} // namespace detail\n} // namespace reflect\n} // namespace zmbt\n\n\n#endif // ZMBT_CORE_SERIALIZATION_DEFAULTS_HPP_\n</code></pre>"},{"location":"CxxRef/signal__traits_8hpp/","title":"File signal_traits.hpp","text":"<p>FileList &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; signal_traits.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"zmbt/core.hpp\"</code></li> </ul>"},{"location":"CxxRef/signal__traits_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace zmbt ZMBT root namespace. namespace reflect Reflection metafunctions."},{"location":"CxxRef/signal__traits_8hpp/#classes","title":"Classes","text":"Type Name struct signal_traits&lt; T, detail::enable_custom_signal_traits&lt; T &gt; &gt; &lt;class T&gt; struct signal_traits&lt; T, detail::enable_default_signal_traits&lt; T &gt; &gt; &lt;class T&gt; struct signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt; &lt;class T&gt;Unhandled types catcher. struct signal_traits&lt; void &gt; &lt;&gt;"},{"location":"CxxRef/signal__traits_8hpp/#macros","title":"Macros","text":"Type Name define ZMBT_DEFINE_CUSTOM_INIT (Type, Args) <code>/* multi line expression */</code> define ZMBT_PP_UNPACK (...) <code>\\_\\_VA\\_ARGS\\_\\_</code>"},{"location":"CxxRef/signal__traits_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Copyright:</p> <p>(c) Copyright 2022-2023 Volvo Car Corporation </p> <p>Copyright:</p> <p>(c) Copyright 2024 Zenseact AB </p> <p>** **</p> <p>SPDX-License-Identifier: Apache-2.0 </p>"},{"location":"CxxRef/signal__traits_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CxxRef/signal__traits_8hpp/#define-zmbt_define_custom_init","title":"define ZMBT_DEFINE_CUSTOM_INIT","text":"<pre><code>#define ZMBT_DEFINE_CUSTOM_INIT (\n    Type,\n    Args\n) `/* multi line expression */`\n</code></pre>"},{"location":"CxxRef/signal__traits_8hpp/#define-zmbt_pp_unpack","title":"define ZMBT_PP_UNPACK","text":"<pre><code>#define ZMBT_PP_UNPACK (\n    ...\n) `__VA_ARGS__`\n</code></pre> <p>The documentation for this class was generated from the following file <code>zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/reflect/signal_traits.hpp</code></p>"},{"location":"CxxRef/signal__traits_8hpp_source/","title":"File signal_traits.hpp","text":"<p>File List &gt; backends &gt; cxx &gt; include &gt; zmbt &gt; reflect &gt; signal_traits.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ZMBT_REFLECT_SIGNAL_TRAITS_HPP_\n#define ZMBT_REFLECT_SIGNAL_TRAITS_HPP_\n\n#include &lt;functional&gt;\n#include &lt;type_traits&gt;\n\n#include \"zmbt/core.hpp\"\n\n// TODO: move to common header\n#define ZMBT_PP_UNPACK(...) __VA_ARGS__\n\n#define ZMBT_DEFINE_CUSTOM_INIT(Type, Args) \\\ntemplate&lt;&gt; struct zmbt::reflect::custom_signal_traits&lt;Type&gt; { \\\n    static Type init() { return Type(ZMBT_PP_UNPACK Args); } \\\n};\n\nnamespace zmbt {\nnamespace reflect {\n\ntemplate &lt;class T, class E = void&gt;\nstruct signal_traits;\n\n\ntemplate &lt;class T, class E = void&gt;\nstruct custom_signal_traits;\n\nnamespace detail {\n\n\ntemplate &lt;class T, class E = void&gt;\nstruct default_signal_traits;\n\ntemplate&lt;class T&gt;\nusing default_signal_traits_t = decltype(default_signal_traits&lt;T&gt;::init());\n\ntemplate&lt;class T&gt;\nusing has_default_signal_traits = mp_valid&lt;default_signal_traits_t, T&gt;;\n\ntemplate&lt;class T&gt;\nusing custom_signal_traits_t = decltype(custom_signal_traits&lt;T&gt;::init());\n\ntemplate&lt;class T&gt;\nusing has_custom_signal_traits = mp_valid&lt;custom_signal_traits_t, T&gt;;\n\n\ntemplate &lt;class T&gt;\nusing enable_default_signal_traits = mp_if&lt;mp_and&lt;has_default_signal_traits&lt;T&gt;, mp_not&lt;has_custom_signal_traits&lt;T&gt;&gt;&gt;, void&gt;;\n\ntemplate &lt;class T&gt;\nusing enable_custom_signal_traits = mp_if&lt;has_custom_signal_traits&lt;T&gt;, void&gt;;\n\ntemplate &lt;class T&gt;\nusing enable_initialization_trap = first_if_none_t&lt;void, has_custom_signal_traits&lt;T&gt;, has_default_signal_traits&lt;T&gt;&gt;;\n\n\ntemplate &lt;class T&gt;\nstruct default_signal_traits&lt;T, first_if_t&lt;void, is_default_constructible&lt;T&gt;&gt;&gt;\n{\n    static constexpr T\n    init ()\n    {\n        return T{};\n    }\n};\n\n\ntemplate &lt;template &lt;class...&gt; class C, class... T&gt;\nstruct default_signal_traits&lt; C&lt;T...&gt;, first_if_none_t&lt;void, is_default_constructible&lt;C&lt;T...&gt;&gt;&gt;&gt;\n{\n    static C&lt;T...&gt;\n    init() {\n        return C&lt;T...&gt; {signal_traits&lt;T&gt;::init()...};\n    }\n};\n\n\n\ntemplate &lt;class T, std::size_t N&gt;\nstruct array_initializer {\n    using tuple_form = boost::mp11::mp_repeat_c&lt;std::tuple&lt;T&gt;, N&gt;;\n    std::array&lt;T, N&gt; value;\n\n    array_initializer() : array_initializer(\n        signal_traits&lt;tuple_form&gt;::init(),\n        std::make_index_sequence&lt;N&gt;()) {}\n\n    private:\n    template &lt;std::size_t... I&gt;\n    array_initializer (tuple_form tuple, std::index_sequence&lt;I...&gt;)\n    : value{std::get&lt;I&gt;(tuple)...} {}\n};\n\n\ntemplate &lt;class T, std::size_t N&gt;\nstruct default_signal_traits&lt;std::array&lt;T, N&gt;, first_if_none_t&lt;void, is_default_constructible&lt;std::array&lt;T, N&gt;&gt;&gt;&gt;\n{\n    static std::array&lt;T, N&gt;\n    init() {\n        return detail::array_initializer&lt;T, N&gt;().value;\n    }\n};\n\n\n} // ns detail\n\n\ntemplate &lt;class T&gt;\nstruct signal_traits&lt;T, detail::enable_default_signal_traits&lt;T&gt;&gt; : detail::default_signal_traits&lt;T&gt; {};\n\ntemplate &lt;class T&gt;\nstruct signal_traits&lt;T, detail::enable_custom_signal_traits&lt;T&gt;&gt; : custom_signal_traits&lt;T&gt; {};\n\n\ntemplate &lt;class T&gt;\nstruct signal_traits&lt;T, detail::enable_initialization_trap&lt;T&gt;&gt;\n{\n    static constexpr T\n    init()\n    {\n        static_assert(sizeof(T) &amp; 0, R\"(\n            Type T has no defined zmbt::reflect::signal_traits specialization.\n            To resolve this error, specialize custom_signal_traits for T\n            with the static function init() -&gt; T)\");\n        return *static_cast&lt;T*&gt;(nullptr);\n    }\n};\n\n\ntemplate&lt;&gt; struct signal_traits&lt;void&gt;\n{\n    static void\n    init() {}\n};\n\nnamespace detail\n{\ntemplate &lt;class T&gt;\nstruct init_tuple_impl;\n\ntemplate &lt;class... T&gt;\nstruct init_tuple_impl&lt;std::tuple&lt;T...&gt;&gt;\n{\n    static constexpr std::tuple&lt;T...&gt; init()\n    {\n        return {signal_traits&lt;T&gt;::init()...};\n    }\n};\n} // namespace detail\n\ntemplate &lt;class T&gt;\nconstexpr T init_tuple()\n{\n    return detail::init_tuple_impl&lt;T&gt;::init();\n}\n\ntemplate &lt;class T&gt;\nconstexpr T init_value()\n{\n    return signal_traits&lt;T&gt;::init();\n}\n\n\n// deprecated - use signal_traits instead\ntemplate &lt;class T, class E = void&gt;\nusing initialization = signal_traits&lt;T, E&gt;;\n\n// deprecated - use custom_signal_traits instead\ntemplate &lt;class T, class E = void&gt;\nusing custom_initialization = custom_signal_traits&lt;T, E&gt;;\n\n} // namespace reflect\n} // namespace zmbt\n\n#endif // ZMBT_REFLECT_SIGNAL_TRAITS_HPP_\n</code></pre>"},{"location":"CxxRef/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace zmbt ZMBT root namespace. <ul> <li>namespace api Framework API with fixture classes and entries from main ns. <ul> <li>namespace decor Signal type decorators API. </li> <li>namespace expr Expression Language API.</li> </ul> </li> <li>namespace application Test application configuration (work in progress) </li> <li>namespace decor Signal type decorators API. </li> <li>namespace expr Expression Language API. </li> <li>namespace flags </li> <li>namespace lang Expression Language implementation. <ul> <li>namespace attr </li> </ul> </li> <li>namespace mapping Signal Mapping model functionality. </li> <li>namespace reflect Reflection metafunctions. </li> </ul> </li> </ul>"},{"location":"CxxRef/classes/","title":"Class Index","text":""},{"location":"CxxRef/classes/#b","title":"b","text":"<ul> <li>base_error (zmbt)</li> <li>BaseTransition (zmbt::mapping::ModelDefinition)</li> </ul>"},{"location":"CxxRef/classes/#c","title":"c","text":"<ul> <li>ChannelHandle (zmbt::mapping)</li> <li>Config (zmbt)</li> <li>ConversionTime (zmbt::flags)</li> <li>custom_invocation (zmbt::reflect)</li> <li>custom_serialization (zmbt::reflect)</li> <li>custom_serialization&lt; ChannelKind &gt; (zmbt::reflect)</li> <li>custom_serialization&lt; decor::precise&lt; T &gt; &gt;</li> <li>custom_serialization&lt; decor::underlying&lt; T &gt; &gt;</li> <li>custom_serialization&lt; lang::Encoding &gt; (zmbt::reflect)</li> <li>custom_serialization&lt; lang::ExpressionView &gt; (zmbt::reflect)</li> <li>custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt; (zmbt::reflect)</li> <li>custom_signal_traits (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/classes/#d","title":"d","text":"<ul> <li>default_invocation (zmbt::reflect)</li> <li>default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt; (zmbt::reflect)</li> <li>default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt; (zmbt::reflect)</li> <li>default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt; (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/classes/#e","title":"e","text":"<ul> <li>Encoding (zmbt::lang)</li> <li>EncodingView (zmbt::lang)</li> <li>entity_id (zmbt)</li> <li>Environment (zmbt)</li> <li>Environment (zmbt::api)</li> <li>environment_error (zmbt)</li> <li>EnvironmentData (zmbt)</li> <li>ErrorInfo (zmbt)</li> <li>ErrorOr (zmbt)</li> <li>EvalContext (zmbt::lang)</li> <li>EvalImpl (zmbt::lang)</li> <li>EvalImplBase (zmbt::lang)</li> <li>EvalLog (zmbt::lang)</li> <li>EvalParams (zmbt::lang)</li> <li>EvalValidator (zmbt::lang)</li> <li>Expression (zmbt::api)</li> <li>Expression (zmbt::lang)</li> <li>ExpressionGrammar (zmbt::lang)</li> <li>ExpressionView (zmbt::lang)</li> <li>ExprRow (zmbt::lang::EncodingView)</li> </ul>"},{"location":"CxxRef/classes/#f","title":"f","text":"<ul> <li>FixedEvalParams (zmbt::lang)</li> <li>Frame (zmbt::OutputRecorder)</li> <li>FrameBuffs (zmbt::OutputRecorder::Registry)</li> </ul>"},{"location":"CxxRef/classes/#g","title":"g","text":"<ul> <li>Generator (zmbt)</li> </ul>"},{"location":"CxxRef/classes/#h","title":"h","text":"<ul> <li>Handle</li> <li>Handle (zmbt::lang::Operator::Handle)</li> <li>Handle (zmbt::lang::Operator::Handle)</li> <li>Handle (zmbt::lang::Operator::Handle)</li> <li>Handle (zmbt::lang::Operator::Handle)</li> <li>Handle (zmbt::lang::Operator::Handle)</li> <li>Handle (zmbt::lang::Operator::Handle)</li> <li>has_bit_and (zmbt)</li> <li>has_bit_or (zmbt)</li> <li>has_bit_xor (zmbt)</li> <li>has_complement (zmbt)</li> <li>has_divides (zmbt)</li> <li>has_equal_to (zmbt)</li> <li>has_greater (zmbt)</li> <li>has_greater_equal (zmbt)</li> <li>has_invocation_for (zmbt::reflect)</li> <li>has_left_shift (zmbt)</li> <li>has_less (zmbt)</li> <li>has_less_equal (zmbt)</li> <li>has_logical_and (zmbt)</li> <li>has_logical_not (zmbt)</li> <li>has_logical_or (zmbt)</li> <li>has_minus (zmbt)</li> <li>has_modulus (zmbt)</li> <li>has_multiplies (zmbt)</li> <li>has_negate (zmbt)</li> <li>has_not_equal_to (zmbt)</li> <li>has_plus (zmbt)</li> <li>has_right_shift (zmbt)</li> <li>has_serialization (zmbt)</li> </ul>"},{"location":"CxxRef/classes/#i","title":"i","text":"<ul> <li>ifc_args (zmbt)</li> <li>ifc_handle (zmbt)</li> <li>ifc_host (zmbt)</li> <li>ifc_pointer (zmbt)</li> <li>ifc_return (zmbt)</li> <li>InjectionTable (zmbt)</li> <li>InjectionTime (zmbt::flags)</li> <li>interface_id (zmbt)</li> <li>InterfaceHandle (zmbt::Environment)</li> <li>internal_ctor</li> <li>invocation (zmbt::reflect)</li> <li>invocation&lt; S, detail::enable_custom_invocation&lt; S &gt; &gt; (zmbt::reflect)</li> <li>invocation&lt; S, detail::enable_default_invocation&lt; S &gt; &gt; (zmbt::reflect)</li> <li>is_const_iterable (zmbt)</li> <li>Iterator (zmbt::lang::EncodingView)</li> </ul>"},{"location":"CxxRef/classes/#j","title":"j","text":"<ul> <li>JsonIter (zmbt)</li> <li>JsonIterZipProdBase (zmbt)</li> <li>JsonNode (zmbt)</li> <li>JsonProdIter (zmbt)</li> <li>JsonTraverse (zmbt)</li> <li>JsonZipIter (zmbt)</li> </ul>"},{"location":"CxxRef/classes/#k","title":"k","text":"<ul> <li>KeywordGrammar (zmbt::lang)</li> <li>KeywordInfo (zmbt::lang)</li> <li>KeywordSymbol (zmbt::lang)</li> </ul>"},{"location":"CxxRef/classes/#l","title":"l","text":"<ul> <li>LazyParam (zmbt::lang)</li> <li>Logger (zmbt)</li> </ul>"},{"location":"CxxRef/classes/#m","title":"m","text":"<ul> <li>model_error (zmbt)</li> <li>ModelDefinition (zmbt::mapping)</li> <li>ModelTestFixture (zmbt::api)</li> </ul>"},{"location":"CxxRef/classes/#n","title":"n","text":"<ul> <li>N_Alias (zmbt::mapping::ModelDefinition)</li> <li>N_Channel (zmbt::mapping::ModelDefinition)</li> <li>N_ChannelEnd (zmbt::mapping::ModelDefinition)</li> <li>N_Decor (zmbt::mapping::ModelDefinition)</li> <li>N_Descr (zmbt::mapping::ModelDefinition)</li> <li>N_Filter (zmbt::mapping::ModelDefinition)</li> <li>N_Main (zmbt::mapping::ModelDefinition)</li> <li>N_MaybeChannel (zmbt::mapping::ModelDefinition)</li> <li>N_Param (zmbt::mapping::ModelDefinition)</li> <li>N_ParamTable (zmbt::mapping::ModelDefinition)</li> <li>N_Post (zmbt::mapping::ModelDefinition)</li> <li>N_Pre (zmbt::mapping::ModelDefinition)</li> <li>N_Repeat (zmbt::mapping::ModelDefinition)</li> <li>N_Take (zmbt::mapping::ModelDefinition)</li> <li>N_Term (zmbt::mapping::ModelDefinition)</li> <li>N_Test (zmbt::mapping::ModelDefinition)</li> <li>N_TestTable (zmbt::mapping::ModelDefinition)</li> </ul>"},{"location":"CxxRef/classes/#o","title":"o","text":"<ul> <li>object_id (zmbt)</li> <li>Operator (zmbt::lang)</li> <li>operator_error (zmbt::lang::Operator)</li> <li>output_recorder_error (zmbt)</li> <li>OutputRecorder (zmbt)</li> </ul>"},{"location":"CxxRef/classes/#p","title":"p","text":"<ul> <li>Param (zmbt)</li> <li>Param (zmbt::api)</li> <li>PermanentEnvData (zmbt)</li> <li>PersistentConfig</li> <li>PipeHandle (zmbt::mapping)</li> <li>precise (zmbt::api)</li> <li>precise (zmbt::decor)</li> <li>precision_loss_error (zmbt::decor)</li> <li>Prototypes (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/classes/#r","title":"r","text":"<ul> <li>Record (zmbt::InjectionTable)</li> <li>RecordingTime (zmbt::flags)</li> <li>Registry</li> </ul>"},{"location":"CxxRef/classes/#s","title":"s","text":"<ul> <li>serialization (zmbt::reflect)</li> <li>serialization&lt; T, detail::enable_for_custom_serialization&lt; T &gt; &gt; (zmbt::reflect)</li> <li>serialization&lt; T, detail::enable_for_default_serialization&lt; T &gt; &gt; (zmbt::reflect)</li> <li>serialization_error (zmbt)</li> <li>shared_resource (zmbt)</li> <li>signal_traits (zmbt::reflect)</li> <li>signal_traits&lt; T, detail::enable_custom_signal_traits&lt; T &gt; &gt; (zmbt::reflect)</li> <li>signal_traits&lt; T, detail::enable_default_signal_traits&lt; T &gt; &gt; (zmbt::reflect)</li> <li>signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt; (zmbt::reflect)</li> <li>signal_traits&lt; void &gt; (zmbt::reflect)</li> <li>SignalMapping (zmbt::api)</li> <li>SignalMapping (zmbt::mapping)</li> <li>SignatureBase (zmbt::lang)</li> <li>SignatureBinary (zmbt::lang)</li> <li>SignatureBinary&lt; Keyword::PreProc &gt; (zmbt::lang)</li> <li>SignatureCast (zmbt::lang)</li> <li>SignatureConst (zmbt::lang)</li> <li>SignatureErr (zmbt::lang)</li> <li>SignatureOp (zmbt::lang)</li> <li>SignatureUnary (zmbt::lang)</li> <li>SignatureUncast (zmbt::lang)</li> <li>SignatureVariadic (zmbt::lang)</li> <li>string_key (zmbt::object_id)</li> <li>StubLogger (zmbt)</li> <li>Subexpression (zmbt::lang::Expression)</li> </ul>"},{"location":"CxxRef/classes/#t","title":"t","text":"<ul> <li>T_Alias</li> <li>T_As</li> <li>T_At</li> <li>T_ContinuePipe</li> <li>T_CustomParam</li> <li>T_Description</li> <li>T_Filter</li> <li>T_OnTrigger</li> <li>T_Param</li> <li>T_ParamRow</li> <li>T_PostRun</li> <li>T_PreRun</li> <li>T_Repeat</li> <li>T_Take</li> <li>T_TerminatePipe</li> <li>T_Test</li> <li>T_TestRow</li> <li>test_assertion_failure (zmbt)</li> <li>TestDiagnostics (zmbt::mapping)</li> <li>TestIsRunning (zmbt::flags)</li> <li>TestParameterResolver (zmbt::mapping)</li> <li>TestRunner (zmbt::mapping)</li> <li>Trigger (zmbt)</li> <li>TriggerIfc (zmbt)</li> <li>TriggerObj (zmbt)</li> <li>type_tag (zmbt)</li> <li>TypedInterfaceHandle (zmbt::Environment)</li> </ul>"},{"location":"CxxRef/classes/#u","title":"u","text":"<ul> <li>underlying (zmbt::decor)</li> </ul>"},{"location":"CxxRef/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class zmbt::Config Global app config. </li> <li>class zmbt::Environment Controlled environment data storage. </li> <li>class zmbt::Environment::InterfaceHandle Environment extension handling the interface data. <ul> <li>class zmbt::Environment::TypedInterfaceHandle Environment API handler for specific interface.</li> </ul> </li> <li>class zmbt::ErrorOr </li> <li>class zmbt::Generator </li> <li>class zmbt::InjectionTable </li> <li>class zmbt::JsonIter Boost JSON array iterator interface. <ul> <li>class zmbt::JsonIterZipProdBase Boost JSON array iterator base for zip or cartesian product. <ul> <li>class zmbt::JsonProdIter Cartesian Product Iterator. </li> <li>class zmbt::JsonZipIter Zip Iterator. </li> </ul> </li> </ul> </li> <li>class zmbt::JsonNode Mutator/accessor wrapper over shared JSON value. </li> <li>class zmbt::JsonTraverse Boost JSON value depth-first traverser. </li> <li>class zmbt::Logger </li> <li>class zmbt::OutputRecorder </li> <li>class zmbt::lang::ExpressionView <ul> <li>class zmbt::lang::Expression <ul> <li>struct zmbt::lang::SignatureBase <ul> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureConst Const expression. </li> <li>struct zmbt::lang::SignatureUnary Unary expression. </li> <li>struct zmbt::lang::SignatureVariadic Variadic expression. </li> </ul> </li> <li>struct zmbt::lang::SignatureBase <ul> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureConst Const expression. </li> <li>struct zmbt::lang::SignatureUnary Unary expression. </li> <li>struct zmbt::lang::SignatureVariadic Variadic expression. </li> </ul> </li> <li>struct zmbt::lang::SignatureBase <ul> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureConst Const expression. </li> <li>struct zmbt::lang::SignatureUnary Unary expression. </li> <li>struct zmbt::lang::SignatureVariadic Variadic expression. </li> </ul> </li> <li>class zmbt::Param Generic Parameter Placeholder. </li> <li>class zmbt::lang::Expression::Subexpression </li> <li>struct zmbt::lang::SignatureBase <ul> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureBinary Binary expression. </li> <li>struct zmbt::lang::SignatureConst Const expression. </li> <li>struct zmbt::lang::SignatureUnary Unary expression. </li> <li>struct zmbt::lang::SignatureVariadic Variadic expression. </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::Trigger Controlled environment interface executor. </li> <li>class zmbt::TriggerIfc </li> <li>class zmbt::TriggerObj Object handler to be used with TriggerIfc .</li> <li>class zmbt::api::Environment Alias for zmbt::Environment . <ul> <li>struct zmbt::api::ModelTestFixture Generic model-driven test fixture. </li> </ul> </li> <li>class zmbt::api::Expression Alias for lang::Expression .</li> <li>class zmbt::api::Param Alias for zmbt::Param .</li> <li>class zmbt::api::SignalMapping Alias for zmbt::mapping::SignalMapping .</li> <li>class zmbt::api::precise Alias for zmbt::precise. </li> <li>class zmbt::entity_id Base class for annotated key objects. <ul> <li>class zmbt::interface_id Pointer-based interface id with type annotation. </li> <li>class zmbt::object_id Pointer-based object id with type annotation. </li> </ul> </li> <li>class zmbt::ConversionTime </li> <li>class zmbt::InjectionTime </li> <li>class zmbt::RecordingTime </li> <li>class zmbt::TestIsRunning </li> <li>class zmbt::lang::EncodingView </li> <li>class zmbt::lang::EncodingView::Iterator </li> <li>class zmbt::lang::EvalParams <ul> <li>struct zmbt::lang::FixedEvalParams <ul> <li>class zmbt::lang::EvalImplBase </li> </ul> </li> </ul> </li> <li>struct zmbt::lang::KeywordInfo </li> <li>class zmbt::lang::LazyParam </li> <li>class zmbt::lang::Operator Signal transformation and comparison handler. Enables type erasure. </li> <li>class zmbt::mapping::ChannelHandle Channel clause handle for SignalMapping model.</li> <li>class zmbt::mapping::ModelDefinition Mapping model definition machine. </li> <li>class zmbt::mapping::ModelDefinition::BaseTransition <ul> <li>struct zmbt::mapping::ModelDefinition::T_Alias T_Alias transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_As T_As transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_At T_At transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Channel </li> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_ContinuePipe T_ContinuePipe transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_CustomParam T_CustomParam transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_Description T_Description transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_Filter T_Filter transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_OnTrigger T_OnTrigger transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Main <ul> <li>class zmbt::mapping::SignalMapping Signal Mapping Test Model. </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_Param T_Param transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_ParamRow T_ParamRow transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_PostRun T_PostRun transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_PreRun T_PreRun transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_Repeat T_Repeat transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_Take T_Take transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_TerminatePipe T_TerminatePipe transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_Test T_Test transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> </ul> </li> <li>struct zmbt::mapping::ModelDefinition::T_TestRow T_TestRow transition. <ul> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Term <ul> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::PipeHandle Pipe clause handle for SignalMapping model.</li> <li>class zmbt::mapping::TestParameterResolver Test spec generator that handles parameter resolution. </li> <li>class zmbt::mapping::TestRunner Test runner for SignalMapping model.</li> <li>class zmbt::reflect::Prototypes Interface prototypes in JSON as {\"args\": [...], \"return\": ... }. </li> <li>class zmbt::shared_resource </li> <li>struct zmbt::EnvironmentData Data container for the Environment .</li> <li>struct zmbt::ErrorInfo </li> <li>struct zmbt::InjectionTable::Record </li> <li>struct zmbt::OutputRecorder::Frame </li> <li>struct zmbt::PermanentEnvData </li> <li>struct zmbt::StubLogger </li> <li>struct zmbt::decor::precise Type decorator for floating point numbers. Throws on precision loss in runtime. </li> <li>struct zmbt::decor::underlying </li> <li>struct zmbt::has_bit_and </li> <li>struct zmbt::has_bit_or </li> <li>struct zmbt::has_bit_xor </li> <li>struct zmbt::has_complement </li> <li>struct zmbt::has_divides </li> <li>struct zmbt::has_equal_to </li> <li>struct zmbt::has_greater </li> <li>struct zmbt::has_greater_equal </li> <li>struct zmbt::has_left_shift </li> <li>struct zmbt::has_less </li> <li>struct zmbt::has_less_equal </li> <li>struct zmbt::has_logical_and </li> <li>struct zmbt::has_logical_not </li> <li>struct zmbt::has_logical_or </li> <li>struct zmbt::has_minus </li> <li>struct zmbt::has_modulus </li> <li>struct zmbt::has_multiplies </li> <li>struct zmbt::has_negate </li> <li>struct zmbt::has_not_equal_to </li> <li>struct zmbt::has_plus </li> <li>struct zmbt::has_right_shift </li> <li>struct zmbt::ifc_args </li> <li>struct zmbt::ifc_handle </li> <li>struct zmbt::ifc_host </li> <li>struct zmbt::ifc_pointer </li> <li>struct zmbt::lang::Encoding </li> <li>struct zmbt::lang::EncodingView::ExprRow </li> <li>struct zmbt::lang::EvalContext Expression evaluation context.</li> <li>struct zmbt::lang::EvalImpl </li> <li>struct zmbt::lang::EvalLog Expression evaluation log.</li> <li>struct zmbt::lang::EvalValidator </li> <li>struct zmbt::mapping::TestDiagnostics Test diagnostics for test case execution. </li> <li>struct zmbt::object_id::string_key </li> <li>struct zmbt::reflect::custom_invocation Customize the interface reflection metafunction. </li> <li>struct zmbt::reflect::custom_serialization User-defined serialization. <ul> <li>struct zmbt::reflect::serialization&lt; T, detail::enable_for_custom_serialization&lt; T &gt; &gt; </li> </ul> </li> <li>struct zmbt::reflect::custom_serialization&lt; ChannelKind &gt; </li> <li>struct zmbt::reflect::custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt; </li> <li>struct zmbt::reflect::custom_serialization&lt; lang::Encoding &gt; </li> <li>struct zmbt::reflect::custom_serialization&lt; lang::ExpressionView &gt; </li> <li>struct zmbt::reflect::custom_signal_traits Customize signal traits metafunction. <ul> <li>struct zmbt::reflect::signal_traits&lt; T, detail::enable_custom_signal_traits&lt; T &gt; &gt; </li> </ul> </li> <li>struct zmbt::reflect::default_invocation Interface reflection metafunction. </li> <li>struct zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt; </li> <li>struct zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt; </li> <li>struct zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt; </li> <li>struct zmbt::reflect::invocation Interface reflection metafunction. </li> <li>struct zmbt::reflect::serialization Serialization metafunction. </li> <li>struct zmbt::reflect::signal_traits Signal traits metafunction, providing default values. </li> <li>struct zmbt::reflect::signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt; Unhandled types catcher. </li> <li>struct zmbt::reflect::signal_traits&lt; void &gt; </li> <li>struct zmbt::type_tag Type tag to pass template parameters as function arguments. </li> <li>struct zmbt::Config::PersistentConfig </li> <li>struct zmbt::OutputRecorder::Registry </li> <li>struct zmbt::OutputRecorder::Registry::FrameBuffs </li> <li>struct zmbt::Trigger::internal_ctor </li> <li>struct zmbt::lang::Operator::Handle </li> <li>struct zmbt::lang::Operator::Handle::Handle </li> <li>struct zmbt::lang::Operator::Handle::Handle </li> <li>struct zmbt::lang::Operator::Handle::Handle </li> <li>struct zmbt::lang::Operator::Handle::Handle </li> <li>struct zmbt::lang::Operator::Handle::Handle </li> <li>struct zmbt::lang::Operator::Handle::Handle </li> <li>struct zmbt::reflect::custom_serialization&lt; decor::precise&lt; T &gt; &gt; </li> <li>struct zmbt::reflect::custom_serialization&lt; decor::underlying&lt; T &gt; &gt; </li> <li>class zmbt::mapping::ModelDefinition::T_TerminatePipe&lt; ModelDefinition::N_MaybeChannel &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_ContinuePipe&lt; ModelDefinition::N_Channel &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_ChannelEnd <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_As&lt; ModelDefinition::N_ChannelEnd &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Decor <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_Alias&lt; ModelDefinition::N_Decor &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Alias <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_At&lt; ModelDefinition::N_Filter &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Channel </li> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_Description&lt; ModelDefinition::N_Term &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Descr <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_Take&lt; ModelDefinition::N_Alias &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Take <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_Filter&lt; ModelDefinition::N_Take &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Filter </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_OnTrigger&lt; ModelDefinition::N_Repeat &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Main <ul> <li>class zmbt::mapping::SignalMapping Signal Mapping Test Model. </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Main <ul> <li>class zmbt::mapping::SignalMapping Signal Mapping Test Model. </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_PostRun&lt; ModelDefinition::N_Descr &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Post <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_PreRun&lt; ModelDefinition::N_Post &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Pre <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_Param&lt; ModelDefinition::N_ParamTable &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_CustomParam&lt; ModelDefinition::N_Param &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Param <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_Test&lt; ModelDefinition::N_TestTable &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::N_Test <ul> <li>class zmbt::mapping::ModelDefinition::N_MaybeChannel <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> </ul> </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_ParamRow&lt; ModelDefinition::N_ParamTable &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_ParamTable </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_Repeat&lt; ModelDefinition::N_MaybeChannel &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_Repeat </li> </ul> </li> <li>class zmbt::mapping::ModelDefinition::T_TestRow&lt; ModelDefinition::N_TestTable &gt; <ul> <li>class zmbt::mapping::ModelDefinition::N_TestTable </li> </ul> </li> <li>class std::runtime_error <ul> <li>struct zmbt::base_error ZMBT Base exception. <ul> <li>struct zmbt::environment_error Test environment error. </li> <li>struct zmbt::lang::Operator::operator_error </li> <li>struct zmbt::model_error Model definition error. </li> <li>struct zmbt::output_recorder_error </li> <li>struct zmbt::serialization_error Failed serialization. </li> <li>struct zmbt::test_assertion_failure Failed test assertion. </li> </ul> </li> <li>struct zmbt::decor::precision_loss_error Exception thrown by decor::precise .</li> <li>struct zmbt::base_error ZMBT Base exception. <ul> <li>struct zmbt::environment_error Test environment error. </li> <li>struct zmbt::lang::Operator::operator_error </li> <li>struct zmbt::model_error Model definition error. </li> <li>struct zmbt::output_recorder_error </li> <li>struct zmbt::serialization_error Failed serialization. </li> <li>struct zmbt::test_assertion_failure Failed test assertion. </li> </ul> </li> <li>struct zmbt::base_error ZMBT Base exception. <ul> <li>struct zmbt::environment_error Test environment error. </li> <li>struct zmbt::lang::Operator::operator_error </li> <li>struct zmbt::model_error Model definition error. </li> <li>struct zmbt::output_recorder_error </li> <li>struct zmbt::serialization_error Failed serialization. </li> <li>struct zmbt::test_assertion_failure Failed test assertion. </li> </ul> </li> <li>struct zmbt::base_error ZMBT Base exception. <ul> <li>struct zmbt::environment_error Test environment error. </li> <li>struct zmbt::lang::Operator::operator_error </li> <li>struct zmbt::model_error Model definition error. </li> <li>struct zmbt::output_recorder_error </li> <li>struct zmbt::serialization_error Failed serialization. </li> <li>struct zmbt::test_assertion_failure Failed test assertion. </li> </ul> </li> <li>struct zmbt::base_error ZMBT Base exception. <ul> <li>struct zmbt::environment_error Test environment error. </li> <li>struct zmbt::lang::Operator::operator_error </li> <li>struct zmbt::model_error Model definition error. </li> <li>struct zmbt::output_recorder_error </li> <li>struct zmbt::serialization_error Failed serialization. </li> <li>struct zmbt::test_assertion_failure Failed test assertion. </li> </ul> </li> <li>struct zmbt::base_error ZMBT Base exception. <ul> <li>struct zmbt::environment_error Test environment error. </li> <li>struct zmbt::lang::Operator::operator_error </li> <li>struct zmbt::model_error Model definition error. </li> <li>struct zmbt::output_recorder_error </li> <li>struct zmbt::serialization_error Failed serialization. </li> <li>struct zmbt::test_assertion_failure Failed test assertion. </li> </ul> </li> <li>struct zmbt::base_error ZMBT Base exception. <ul> <li>struct zmbt::environment_error Test environment error. </li> <li>struct zmbt::lang::Operator::operator_error </li> <li>struct zmbt::model_error Model definition error. </li> <li>struct zmbt::output_recorder_error </li> <li>struct zmbt::serialization_error Failed serialization. </li> <li>struct zmbt::test_assertion_failure Failed test assertion. </li> </ul> </li> </ul> </li> <li>class std::false_type <ul> <li>struct zmbt::has_serialization </li> <li>struct zmbt::is_const_iterable Variable template that checks if a type has begin() and end() member functions. </li> <li>struct zmbt::reflect::has_invocation_for Trait check for reflect::invocation&lt;T&gt; </li> </ul> </li> <li>class boost::callable_traits::return_type&lt; Interface &gt; <ul> <li>struct zmbt::ifc_return </li> </ul> </li> <li>class boost::spirit::karma::grammar&lt; OutputIterator, ExpressionView()&gt; <ul> <li>struct zmbt::lang::ExpressionGrammar </li> </ul> </li> <li>class boost::spirit::qi::grammar&lt; boost::json::string::const_iterator, Keyword()&gt; <ul> <li>struct zmbt::lang::KeywordGrammar Boost.Sirit.Qi Grammar for zmbt::lang::Keyword parsing.</li> </ul> </li> <li>class boost::spirit::qi::symbols&lt; char, Keyword &gt; <ul> <li>struct zmbt::lang::KeywordSymbol Boost.Sirit.Qi Symbol for zmbt::lang::Keyword parsing.</li> </ul> </li> <li>class zmbt::reflect::detail::default_serialization&lt; T &gt; <ul> <li>struct zmbt::reflect::serialization&lt; T, detail::enable_for_default_serialization&lt; T &gt; &gt; </li> </ul> </li> <li>class zmbt::reflect::detail::default_signal_traits&lt; T &gt; <ul> <li>struct zmbt::reflect::signal_traits&lt; T, detail::enable_default_signal_traits&lt; T &gt; &gt; </li> </ul> </li> </ul>"},{"location":"CxxRef/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"CxxRef/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"CxxRef/class_members/","title":"Class Members","text":""},{"location":"CxxRef/class_members/#a","title":"a","text":"<ul> <li>argsref_t (zmbt::Environment)</li> <li>autokey (zmbt::Environment)</li> <li>args_t (zmbt::Environment::TypedInterfaceHandle, zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;)</li> <li>as_error (zmbt::ErrorOr)</li> <li>as_return (zmbt::ErrorOr)</li> <li>add_record (zmbt::InjectionTable)</li> <li>args_ (zmbt::InjectionTable, zmbt::reflect::Prototypes)</li> <li>as_array (zmbt::JsonNode, zmbt::lang::ExpressionView)</li> <li>as_object (zmbt::JsonNode, zmbt::lang::ExpressionView)</li> <li>at (zmbt::JsonNode, zmbt::lang::EncodingView)</li> <li>apply_fn (zmbt::TriggerIfc)</li> <li>annotation (zmbt::entity_id, zmbt::lang::Operator, zmbt::lang::Operator::Handle)</li> <li>annotation_ (zmbt::entity_id)</li> <li>add (zmbt::ConversionTime, zmbt::InjectionTime, zmbt::RecordingTime, zmbt::lang::Operator::Handle::Handle)</li> <li>append_to_root (zmbt::lang::Encoding)</li> <li>arity (zmbt::lang::EncodingView)</li> <li>as_bool (zmbt::lang::ExpressionView)</li> <li>as_string (zmbt::lang::ExpressionView)</li> <li>attributes (zmbt::lang::KeywordInfo)</li> <li>apply (zmbt::lang::Operator, zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;)</li> <li>alias (zmbt::mapping::ChannelHandle)</li> <li>args (zmbt::reflect::Prototypes, zmbt::OutputRecorder::Registry::FrameBuffs)</li> <li>arithmetics (zmbt::lang::Operator::Handle)</li> <li>and_ (zmbt::lang::Operator::Handle::Handle, zmbt::lang::Operator::Handle::Handle)</li> <li>Alias (zmbt::mapping::ModelDefinition::T_Alias)</li> <li>As (zmbt::mapping::ModelDefinition::T_As)</li> <li>At (zmbt::mapping::ModelDefinition::T_At)</li> <li>Args (zmbt::mapping::ModelDefinition::T_Filter)</li> </ul>"},{"location":"CxxRef/class_members/#b","title":"b","text":"<ul> <li>begins_ (zmbt::JsonIterZipProdBase)</li> <li>branch (zmbt::JsonNode)</li> <li>base_error (zmbt::base_error, zmbt::environment_error, zmbt::lang::Operator::operator_error, zmbt::model_error, zmbt::output_recorder_error, zmbt::serialization_error, zmbt::test_assertion_failure)</li> <li>back (zmbt::lang::EncodingView)</li> <li>begin (zmbt::lang::EncodingView)</li> <li>binary_transform (zmbt::lang::Operator)</li> <li>BaseTransition (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>bitwise (zmbt::lang::Operator::Handle)</li> <li>bool_ (zmbt::lang::Operator::Handle::Handle)</li> <li>Blend (zmbt::mapping::ModelDefinition::T_ContinuePipe)</li> </ul>"},{"location":"CxxRef/class_members/#c","title":"c","text":"<ul> <li>Config (zmbt::Config, zmbt::lang::Operator)</li> <li>config_ (zmbt::Config)</li> <li>ContainsShared (zmbt::Environment)</li> <li>CaptureSlice (zmbt::Environment::InterfaceHandle)</li> <li>Captures (zmbt::Environment::InterfaceHandle)</li> <li>catch (zmbt::Environment::TypedInterfaceHandle, zmbt::lang::Operator)</li> <li>callbacks (zmbt::EnvironmentData)</li> <li>context (zmbt::ErrorInfo, zmbt::lang::EvalParams)</li> <li>counter_ (zmbt::Generator)</li> <li>contains (zmbt::JsonNode, zmbt::lang::Operator)</li> <li>copy (zmbt::JsonNode)</li> <li>check_filter (zmbt::OutputRecorder)</li> <li>clear (zmbt::OutputRecorder, zmbt::TestIsRunning)</li> <li>count (zmbt::OutputRecorder, zmbt::OutputRecorder::Registry)</li> <li>counter (zmbt::ConversionTime, zmbt::InjectionTime, zmbt::RecordingTime)</li> <li>cbegin (zmbt::lang::EncodingView)</li> <li>cend (zmbt::lang::EncodingView)</li> <li>child (zmbt::lang::EncodingView)</li> <li>child_idx (zmbt::lang::EncodingView)</li> <li>children (zmbt::lang::EncodingView)</li> <li>const_iterator (zmbt::lang::EncodingView)</li> <li>const_reverse_iterator (zmbt::lang::EncodingView)</li> <li>crbegin (zmbt::lang::EncodingView)</li> <li>crend (zmbt::lang::EncodingView)</li> <li>captures (zmbt::lang::EvalContext, zmbt::mapping::ChannelHandle)</li> <li>curr_ctx (zmbt::lang::EvalImplBase)</li> <li>curr_ctx_ (zmbt::lang::EvalImplBase)</li> <li>ctx_ (zmbt::lang::EvalParams)</li> <li>const_predicate_cache_ (zmbt::lang::ExpressionView)</li> <li>cache_ (zmbt::lang::LazyParam)</li> <li>ChannelHandle (zmbt::mapping::ChannelHandle)</li> <li>ConditionPipe (zmbt::mapping::ChannelHandle)</li> <li>channels (zmbt::mapping::PipeHandle)</li> <li>channels_ (zmbt::mapping::PipeHandle)</li> <li>column (zmbt::mapping::PipeHandle)</li> <li>ChannelId (zmbt::mapping::TestDiagnostics)</li> <li>Comment (zmbt::mapping::TestDiagnostics)</li> <li>channel_id (zmbt::mapping::TestDiagnostics)</li> <li>comment (zmbt::mapping::TestDiagnostics)</li> <li>consume_fn_t (zmbt::OutputRecorder::Registry)</li> <li>comp (zmbt::lang::Operator::Handle)</li> <li>compl_ (zmbt::lang::Operator::Handle::Handle)</li> <li>CallCount (zmbt::mapping::ModelDefinition::T_Filter)</li> </ul>"},{"location":"CxxRef/class_members/#d","title":"d","text":"<ul> <li>DefaultObjectId (zmbt::Environment)</li> <li>DeferLock (zmbt::Environment)</li> <li>DumpToJsonLog (zmbt::Environment)</li> <li>data_ (zmbt::Environment, zmbt::lang::EncodingView, zmbt::mapping::ChannelHandle, zmbt::mapping::PipeHandle)</li> <li>dump_to (zmbt::ErrorOr)</li> <li>data_frames (zmbt::OutputRecorder)</li> <li>data (zmbt::OutputRecorder::Frame, zmbt::lang::Encoding, zmbt::lang::EncodingView::ExprRow, zmbt::lang::ExpressionView)</li> <li>default_objects (zmbt::PermanentEnvData)</li> <li>decorated_type (zmbt::decor::precise, zmbt::decor::underlying)</li> <li>depth (zmbt::lang::Encoding, zmbt::lang::EncodingView::ExprRow, zmbt::lang::EvalContext)</li> <li>depth_ (zmbt::lang::EncodingView)</li> <li>depth_offset (zmbt::lang::EncodingView)</li> <li>d_ (zmbt::lang::EncodingView::Iterator)</li> <li>difference_type (zmbt::lang::EncodingView::Iterator)</li> <li>decorate (zmbt::lang::Operator, zmbt::lang::Operator::Handle::Handle)</li> <li>Description (zmbt::mapping::TestDiagnostics, zmbt::mapping::ModelDefinition::T_Description)</li> <li>description (zmbt::mapping::TestDiagnostics)</li> <li>dejsonize (zmbt::reflect::custom_serialization&lt; ChannelKind &gt;, zmbt::reflect::custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt;, zmbt::reflect::custom_serialization&lt; lang::Encoding &gt;, zmbt::reflect::custom_serialization&lt; decor::precise&lt; T &gt; &gt;, zmbt::reflect::custom_serialization&lt; decor::underlying&lt; T &gt; &gt;)</li> <li>data_typeid (zmbt::OutputRecorder::Registry)</li> <li>decor (zmbt::lang::Operator::Handle)</li> <li>div (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_members/#e","title":"e","text":"<ul> <li>Environment (zmbt::Environment)</li> <li>EnableOutputRecordFor (zmbt::Environment::InterfaceHandle)</li> <li>Env (zmbt::Environment::InterfaceHandle)</li> <li>env (zmbt::Environment::InterfaceHandle, zmbt::mapping::ChannelHandle, zmbt::mapping::PipeHandle, zmbt::mapping::TestParameterResolver)</li> <li>EnvironmentData (zmbt::EnvironmentData)</li> <li>ErrorOr (zmbt::ErrorOr)</li> <li>error_or_return (zmbt::ErrorOr)</li> <li>expr_ (zmbt::Generator)</li> <li>expression (zmbt::Generator, zmbt::mapping::PipeHandle)</li> <li>exception_ (zmbt::InjectionTable)</li> <li>ends_ (zmbt::JsonIterZipProdBase)</li> <li>enable_category (zmbt::OutputRecorder)</li> <li>ensure_registry (zmbt::OutputRecorder)</li> <li>execute (zmbt::TriggerIfc)</li> <li>entity_id (zmbt::entity_id, zmbt::interface_id, zmbt::object_id)</li> <li>exchange (zmbt::TestIsRunning)</li> <li>Encoding (zmbt::lang::Encoding)</li> <li>EncodingView (zmbt::lang::EncodingView)</li> <li>empty (zmbt::lang::EncodingView)</li> <li>end (zmbt::lang::EncodingView)</li> <li>EvalContext (zmbt::lang::EvalContext)</li> <li>EvalImplBase (zmbt::lang::EvalImplBase)</li> <li>EvalLog (zmbt::lang::EvalLog)</li> <li>EvalParams (zmbt::lang::EvalParams, zmbt::lang::FixedEvalParams)</li> <li>EvalValidator (zmbt::lang::EvalValidator)</li> <li>Expression (zmbt::lang::Expression)</li> <li>encodeLiteral (zmbt::lang::Expression)</li> <li>encodeNested (zmbt::lang::Expression)</li> <li>encodePreProc (zmbt::lang::Expression)</li> <li>encoding (zmbt::lang::Expression)</li> <li>encoding_ (zmbt::lang::Expression)</li> <li>ev_ (zmbt::lang::Expression::Subexpression)</li> <li>ExpressionGrammar (zmbt::lang::ExpressionGrammar)</li> <li>ExpressionView (zmbt::lang::ExpressionView)</li> <li>encoding_view (zmbt::lang::ExpressionView)</li> <li>encoding_view_ (zmbt::lang::ExpressionView)</li> <li>error_id (zmbt::lang::ExpressionView)</li> <li>eval (zmbt::lang::ExpressionView)</li> <li>eval_as_predicate (zmbt::lang::ExpressionView)</li> <li>eval_e (zmbt::lang::ExpressionView)</li> <li>eval_maybe_predicate (zmbt::lang::ExpressionView)</li> <li>exchangeHandle (zmbt::lang::Operator)</li> <li>E (zmbt::lang::SignatureVariadic)</li> <li>encodeVariadic (zmbt::lang::SignatureVariadic)</li> <li>Error (zmbt::mapping::TestDiagnostics)</li> <li>EvalStack (zmbt::mapping::TestDiagnostics)</li> <li>error (zmbt::mapping::TestDiagnostics)</li> <li>eval_stack (zmbt::mapping::TestDiagnostics)</li> <li>expected (zmbt::mapping::TestDiagnostics)</li> <li>enable_categories_ (zmbt::OutputRecorder::Registry)</li> <li>extract_fn (zmbt::OutputRecorder::Registry)</li> <li>err (zmbt::OutputRecorder::Registry::FrameBuffs)</li> <li>equal_to (zmbt::lang::Operator::Handle::Handle)</li> <li>Exception (zmbt::mapping::ModelDefinition::T_Filter)</li> <li>Expect (zmbt::mapping::ModelDefinition::T_TerminatePipe)</li> </ul>"},{"location":"CxxRef/class_members/#f","title":"f","text":"<ul> <li>FailureHandler (zmbt::Config, zmbt::EnvironmentData)</li> <li>find_pointer (zmbt::JsonNode)</li> <li>flush (zmbt::OutputRecorder)</li> <li>fn_ (zmbt::TriggerIfc)</li> <li>flag (zmbt::TestIsRunning)</li> <li>freeze (zmbt::lang::EncodingView)</li> <li>front (zmbt::lang::EncodingView)</li> <li>format (zmbt::lang::EvalLog)</li> <li>flip (zmbt::lang::ExpressionGrammar)</li> <li>fork (zmbt::lang::ExpressionGrammar)</li> <li>full_path (zmbt::mapping::ChannelHandle)</li> <li>Fail (zmbt::mapping::TestDiagnostics)</li> <li>failure_handler (zmbt::Config::PersistentConfig)</li> <li>FramesBuffMap (zmbt::OutputRecorder::Registry)</li> <li>frame_buff_map (zmbt::OutputRecorder::Registry)</li> </ul>"},{"location":"CxxRef/class_members/#g","title":"g","text":"<ul> <li>GetOrRegisterInterface (zmbt::Environment)</li> <li>GetOrRegisterParametricTrigger (zmbt::Environment)</li> <li>GetPrototypes (zmbt::Environment)</li> <li>GetRecorder (zmbt::Environment)</li> <li>GetShared (zmbt::Environment)</li> <li>GetSharedRef (zmbt::Environment)</li> <li>GetVar (zmbt::Environment)</li> <li>GetVarOrDefault (zmbt::Environment)</li> <li>GetVarOrUpdate (zmbt::Environment)</li> <li>Generator (zmbt::Generator)</li> <li>get_maybe_const (zmbt::InjectionTable)</li> <li>get_records (zmbt::InjectionTable)</li> <li>generator (zmbt::InjectionTable::Record)</li> <li>get (zmbt::JsonIter, zmbt::JsonIterZipProdBase)</li> <li>get_or_create (zmbt::JsonNode)</li> <li>get_or_create_array (zmbt::JsonNode)</li> <li>get_or_create_as (zmbt::JsonNode)</li> <li>get_or_create_object (zmbt::JsonNode)</li> <li>get_or_default (zmbt::JsonNode)</li> <li>get_args_typeid (zmbt::OutputRecorder)</li> <li>get_default_object (zmbt::PermanentEnvData)</li> <li>get_output_recorder_factory (zmbt::PermanentEnvData)</li> <li>get_prototypes (zmbt::PermanentEnvData)</li> <li>getter_ (zmbt::lang::LazyParam)</li> <li>generic_bit_and (zmbt::lang::Operator)</li> <li>generic_bit_or (zmbt::lang::Operator)</li> <li>generic_bit_xor (zmbt::lang::Operator)</li> <li>generic_complement (zmbt::lang::Operator)</li> <li>generic_decorate (zmbt::lang::Operator)</li> <li>generic_divides (zmbt::lang::Operator)</li> <li>generic_equal_to (zmbt::lang::Operator)</li> <li>generic_is_truth (zmbt::lang::Operator)</li> <li>generic_left_shift (zmbt::lang::Operator)</li> <li>generic_less (zmbt::lang::Operator)</li> <li>generic_less_equal (zmbt::lang::Operator)</li> <li>generic_log (zmbt::lang::Operator)</li> <li>generic_logical_and (zmbt::lang::Operator)</li> <li>generic_logical_not (zmbt::lang::Operator)</li> <li>generic_logical_or (zmbt::lang::Operator)</li> <li>generic_minus (zmbt::lang::Operator)</li> <li>generic_modulus (zmbt::lang::Operator)</li> <li>generic_multiplies (zmbt::lang::Operator)</li> <li>generic_negate (zmbt::lang::Operator)</li> <li>generic_plus (zmbt::lang::Operator)</li> <li>generic_pow (zmbt::lang::Operator)</li> <li>generic_quot (zmbt::lang::Operator)</li> <li>generic_right_shift (zmbt::lang::Operator)</li> <li>generic_undecorate (zmbt::lang::Operator)</li> <li>Group (zmbt::mapping::ModelDefinition::T_ContinuePipe)</li> </ul>"},{"location":"CxxRef/class_members/#h","title":"h","text":"<ul> <li>HandleTestFailure (zmbt::Config)</li> <li>HasAction (zmbt::Environment)</li> <li>HasTestError (zmbt::Environment)</li> <li>HasTrigger (zmbt::Environment)</li> <li>hookout_args_t (zmbt::Environment, zmbt::Environment::TypedInterfaceHandle)</li> <li>Hook (zmbt::Environment::TypedInterfaceHandle)</li> <li>HookArgsImpl (zmbt::Environment::TypedInterfaceHandle)</li> <li>HookReturnImpl (zmbt::Environment::TypedInterfaceHandle)</li> <li>has_test_error (zmbt::EnvironmentData)</li> <li>halt (zmbt::JsonIter, zmbt::JsonIterZipProdBase)</li> <li>halt_ (zmbt::JsonIterZipProdBase)</li> <li>hash_ (zmbt::entity_id)</li> <li>head (zmbt::lang::EncodingView)</li> <li>has_default_rhs (zmbt::lang::EvalParams)</li> <li>has_subexpr (zmbt::lang::ExpressionView)</li> <li>handle_ (zmbt::lang::Operator)</li> <li>handle_bit_and (zmbt::lang::Operator)</li> <li>handle_bit_or (zmbt::lang::Operator)</li> <li>handle_bit_xor (zmbt::lang::Operator)</li> <li>handle_complement (zmbt::lang::Operator)</li> <li>handle_decorate (zmbt::lang::Operator)</li> <li>handle_divides (zmbt::lang::Operator)</li> <li>handle_equal_to (zmbt::lang::Operator)</li> <li>handle_is_truth (zmbt::lang::Operator)</li> <li>handle_left_shift (zmbt::lang::Operator)</li> <li>handle_less (zmbt::lang::Operator)</li> <li>handle_less_equal (zmbt::lang::Operator)</li> <li>handle_logical_and (zmbt::lang::Operator)</li> <li>handle_logical_not (zmbt::lang::Operator)</li> <li>handle_logical_or (zmbt::lang::Operator)</li> <li>handle_minus (zmbt::lang::Operator)</li> <li>handle_modulus (zmbt::lang::Operator)</li> <li>handle_multiplies (zmbt::lang::Operator)</li> <li>handle_negate (zmbt::lang::Operator)</li> <li>handle_plus (zmbt::lang::Operator)</li> <li>handle_right_shift (zmbt::lang::Operator)</li> <li>handle_undecorate (zmbt::lang::Operator)</li> <li>host (zmbt::mapping::ChannelHandle)</li> <li>has_expression (zmbt::mapping::PipeHandle)</li> <li>host_t (zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;)</li> </ul>"},{"location":"CxxRef/class_members/#i","title":"i","text":"<ul> <li>InitializeInterfaceHandlers (zmbt::Environment)</li> <li>InterfaceId (zmbt::Environment)</li> <li>Inject (zmbt::Environment::InterfaceHandle, zmbt::mapping::ModelDefinition::T_TerminatePipe)</li> <li>InjectArgs (zmbt::Environment::InterfaceHandle)</li> <li>InjectReturn (zmbt::Environment::InterfaceHandle)</li> <li>InterfaceHandle (zmbt::Environment::InterfaceHandle)</li> <li>interface (zmbt::Environment::InterfaceHandle, zmbt::mapping::ChannelHandle)</li> <li>interface_ (zmbt::Environment::InterfaceHandle)</li> <li>init_json_data (zmbt::EnvironmentData)</li> <li>injection_tables (zmbt::EnvironmentData)</li> <li>is_error (zmbt::ErrorOr, zmbt::lang::ExpressionView)</li> <li>is_null (zmbt::ErrorOr, zmbt::JsonNode, zmbt::lang::ExpressionView)</li> <li>is_return (zmbt::ErrorOr)</li> <li>is_noop (zmbt::Generator, zmbt::lang::ExpressionView)</li> <li>InjectionTable (zmbt::InjectionTable)</li> <li>ifc_id_ (zmbt::InjectionTable, zmbt::OutputRecorder)</li> <li>init_iters (zmbt::JsonIterZipProdBase)</li> <li>its_ (zmbt::JsonIterZipProdBase)</li> <li>is_notrim_enabled (zmbt::Logger)</li> <li>is_pretty_print_enabled (zmbt::Logger)</li> <li>interface_name (zmbt::OutputRecorder, zmbt::OutputRecorder::Registry)</li> <li>is_registered (zmbt::OutputRecorder)</li> <li>isParam (zmbt::Param)</li> <li>ifc_ (zmbt::Trigger)</li> <li>ifc_id (zmbt::Trigger)</li> <li>id (zmbt::TriggerIfc, zmbt::TriggerObj)</li> <li>id_ (zmbt::TriggerIfc, zmbt::TriggerObj)</li> <li>is_unsafe_ptr_ (zmbt::TriggerObj)</li> <li>ifc_addr (zmbt::interface_id)</li> <li>interface_id (zmbt::interface_id)</li> <li>is_link_token (zmbt::lang::Encoding)</li> <li>is_preproc_token (zmbt::lang::Encoding)</li> <li>if_data (zmbt::lang::EncodingView)</li> <li>if_depth (zmbt::lang::EncodingView)</li> <li>if_keywords (zmbt::lang::EncodingView)</li> <li>index_offset (zmbt::lang::EncodingView)</li> <li>index_offset_ (zmbt::lang::EncodingView, zmbt::lang::EncodingView::Iterator)</li> <li>is_boolean (zmbt::lang::EncodingView, zmbt::lang::ExpressionView)</li> <li>is_const (zmbt::lang::EncodingView, zmbt::lang::ExpressionView)</li> <li>iterator (zmbt::lang::EncodingView)</li> <li>index (zmbt::lang::EncodingView::ExprRow, zmbt::mapping::ChannelHandle, zmbt::mapping::PipeHandle)</li> <li>Iterator (zmbt::lang::EncodingView::Iterator)</li> <li>i_ (zmbt::lang::EncodingView::Iterator)</li> <li>iterator_category (zmbt::lang::EncodingView::Iterator)</li> <li>is_invalid (zmbt::lang::EvalValidator)</li> <li>if_array (zmbt::lang::ExpressionView)</li> <li>if_bool (zmbt::lang::ExpressionView)</li> <li>if_object (zmbt::lang::ExpressionView)</li> <li>if_string (zmbt::lang::ExpressionView)</li> <li>is (zmbt::lang::ExpressionView)</li> <li>is_complete_flip (zmbt::lang::ExpressionView)</li> <li>is_compose (zmbt::lang::ExpressionView)</li> <li>is_fork (zmbt::lang::ExpressionView)</li> <li>is_infix_fork (zmbt::lang::ExpressionView)</li> <li>is_infix_pipe (zmbt::lang::ExpressionView)</li> <li>is_infix_tuple (zmbt::lang::ExpressionView)</li> <li>is_link (zmbt::lang::ExpressionView)</li> <li>is_literal (zmbt::lang::ExpressionView)</li> <li>is_preproc (zmbt::lang::ExpressionView)</li> <li>is_tuple (zmbt::lang::ExpressionView)</li> <li>is_valid_link (zmbt::lang::ExpressionView)</li> <li>is_generic (zmbt::lang::Operator)</li> <li>is_subset (zmbt::lang::Operator)</li> <li>inerface_handle (zmbt::mapping::ChannelHandle)</li> <li>inject (zmbt::mapping::PipeHandle)</li> <li>is_input (zmbt::mapping::PipeHandle)</li> <li>is_output (zmbt::mapping::PipeHandle)</li> <li>init_param_iters (zmbt::mapping::TestParameterResolver)</li> <li>iterators_ (zmbt::mapping::TestParameterResolver)</li> <li>impl_ (zmbt::mapping::TestRunner)</li> <li>is_not_ptr (zmbt::object_id)</li> <li>is_ptr (zmbt::object_id)</li> <li>init (zmbt::reflect::signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt;, zmbt::reflect::signal_traits&lt; void &gt;)</li> </ul>"},{"location":"CxxRef/class_members/#j","title":"j","text":"<ul> <li>json_data (zmbt::Environment, zmbt::EnvironmentData)</li> <li>jptr (zmbt::InjectionTable::Record)</li> <li>JsonIter (zmbt::JsonIter)</li> <li>JsonIterZipProdBase (zmbt::JsonIterZipProdBase, zmbt::JsonProdIter, zmbt::JsonZipIter)</li> <li>JsonNode (zmbt::JsonNode)</li> <li>JsonTraverse (zmbt::JsonTraverse)</li> <li>json_from (zmbt::reflect::custom_serialization&lt; ChannelKind &gt;, zmbt::reflect::custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt;, zmbt::reflect::custom_serialization&lt; lang::Encoding &gt;, zmbt::reflect::custom_serialization&lt; lang::ExpressionView &gt;, zmbt::reflect::custom_serialization&lt; decor::precise&lt; T &gt; &gt;, zmbt::reflect::custom_serialization&lt; decor::underlying&lt; T &gt; &gt;)</li> </ul>"},{"location":"CxxRef/class_members/#k","title":"k","text":"<ul> <li>key (zmbt::Environment::InterfaceHandle, zmbt::entity_id, zmbt::mapping::ChannelHandle)</li> <li>key_ (zmbt::entity_id)</li> <li>K (zmbt::lang::Encoding, zmbt::lang::EncodingView)</li> <li>keywords (zmbt::lang::Encoding)</li> <li>keywords_ (zmbt::lang::EncodingView)</li> <li>keyword (zmbt::lang::EncodingView::ExprRow, zmbt::lang::ExpressionGrammar, zmbt::lang::ExpressionView, zmbt::lang::KeywordInfo)</li> <li>k_ (zmbt::lang::EncodingView::Iterator)</li> <li>Keyword (zmbt::lang::ExpressionView)</li> <li>keyword_to_str (zmbt::lang::ExpressionView, zmbt::lang::KeywordInfo)</li> <li>KeywordGrammar (zmbt::lang::KeywordGrammar)</li> <li>keyword_symbol (zmbt::lang::KeywordGrammar)</li> <li>KeywordSymbol (zmbt::lang::KeywordSymbol)</li> <li>Kind (zmbt::mapping::ChannelHandle)</li> <li>kind (zmbt::mapping::ChannelHandle)</li> </ul>"},{"location":"CxxRef/class_members/#l","title":"l","text":"<ul> <li>Lock (zmbt::Environment)</li> <li>lock_t (zmbt::Environment, zmbt::EnvironmentData)</li> <li>last_record (zmbt::InjectionTable)</li> <li>Level (zmbt::Logger)</li> <li>Logger (zmbt::Logger)</li> <li>level_ (zmbt::Logger)</li> <li>lost_count (zmbt::OutputRecorder, zmbt::OutputRecorder::Registry)</li> <li>links (zmbt::lang::EvalContext)</li> <li>log (zmbt::lang::EvalContext)</li> <li>lhs (zmbt::lang::EvalParams)</li> <li>lhs_ (zmbt::lang::EvalParams)</li> <li>lhs_maybe_owned_ (zmbt::lang::EvalParams)</li> <li>link (zmbt::lang::ExpressionGrammar)</li> <li>LazyParam (zmbt::lang::LazyParam)</li> <li>LV (zmbt::lang::Operator)</li> <li>log_debug (zmbt::mapping::TestParameterResolver)</li> <li>logic (zmbt::lang::Operator::Handle)</li> <li>less (zmbt::lang::Operator::Handle::Handle)</li> <li>less_equal (zmbt::lang::Operator::Handle::Handle)</li> <li>left (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_members/#m","title":"m","text":"<ul> <li>MaybeThrowException (zmbt::Environment::InterfaceHandle)</li> <li>mutex (zmbt::EnvironmentData)</li> <li>mutex_t (zmbt::EnvironmentData)</li> <li>MakeError (zmbt::ErrorOr)</li> <li>MakeValue (zmbt::ErrorOr)</li> <li>Make (zmbt::InjectionTable, zmbt::OutputRecorder::Registry)</li> <li>maybe_constant_args_ (zmbt::InjectionTable)</li> <li>maybe_constant_exception_ (zmbt::InjectionTable)</li> <li>maybe_constant_ret_ (zmbt::InjectionTable)</li> <li>maybe_constant (zmbt::InjectionTable::Record)</li> <li>max_level (zmbt::Logger)</li> <li>ModelTestFixture (zmbt::api::ModelTestFixture)</li> <li>make (zmbt::lang::EvalContext, zmbt::lang::EvalLog)</li> <li>match (zmbt::lang::ExpressionView)</li> <li>makeHandle (zmbt::lang::Operator)</li> <li>make_error (zmbt::lang::SignatureErr)</li> <li>make_throw_action (zmbt::lang::SignatureErr)</li> <li>mapping_ (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>message (zmbt::mapping::TestDiagnostics)</li> <li>model_name (zmbt::mapping::TestDiagnostics)</li> <li>model_ (zmbt::mapping::TestParameterResolver)</li> <li>mod (zmbt::lang::Operator::Handle::Handle)</li> <li>mul (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_members/#n","title":"n","text":"<ul> <li>node (zmbt::JsonNode)</li> <li>node_ptr (zmbt::JsonNode)</li> <li>node_ptr_ (zmbt::JsonNode)</li> <li>nested_fork (zmbt::lang::ExpressionGrammar)</li> <li>nested_link (zmbt::lang::ExpressionGrammar)</li> <li>nested_pipe (zmbt::lang::ExpressionGrammar)</li> <li>nested_tuple (zmbt::lang::ExpressionGrammar)</li> <li>N_Alias (zmbt::mapping::ModelDefinition::N_Alias)</li> <li>N_Channel (zmbt::mapping::ModelDefinition::N_Channel)</li> <li>N_ChannelEnd (zmbt::mapping::ModelDefinition::N_ChannelEnd)</li> <li>N_Decor (zmbt::mapping::ModelDefinition::N_Decor)</li> <li>N_Descr (zmbt::mapping::ModelDefinition::N_Descr)</li> <li>N_Filter (zmbt::mapping::ModelDefinition::N_Filter)</li> <li>N_Main (zmbt::mapping::ModelDefinition::N_Main)</li> <li>N_MaybeChannel (zmbt::mapping::ModelDefinition::N_MaybeChannel)</li> <li>N_Param (zmbt::mapping::ModelDefinition::N_Param)</li> <li>N_ParamTable (zmbt::mapping::ModelDefinition::N_ParamTable)</li> <li>N_Post (zmbt::mapping::ModelDefinition::N_Post)</li> <li>N_Pre (zmbt::mapping::ModelDefinition::N_Pre)</li> <li>N_Repeat (zmbt::mapping::ModelDefinition::N_Repeat)</li> <li>N_Take (zmbt::mapping::ModelDefinition::N_Take)</li> <li>N_Term (zmbt::mapping::ModelDefinition::N_Term)</li> <li>N_Test (zmbt::mapping::ModelDefinition::N_Test)</li> <li>N_TestTable (zmbt::mapping::ModelDefinition::N_TestTable)</li> <li>Next (zmbt::mapping::TestParameterResolver)</li> <li>neg (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_members/#o","title":"o","text":"<ul> <li>operator= (zmbt::Config, zmbt::Environment, zmbt::Environment::InterfaceHandle, zmbt::EnvironmentData, zmbt::Generator, zmbt::JsonIter, zmbt::JsonIterZipProdBase, zmbt::JsonNode, zmbt::OutputRecorder, zmbt::Param, zmbt::Trigger, zmbt::TriggerIfc, zmbt::TriggerObj, zmbt::api::ModelTestFixture, zmbt::decor::precise, zmbt::decor::underlying, zmbt::entity_id, zmbt::lang::Expression, zmbt::lang::ExpressionView, zmbt::lang::LazyParam, zmbt::lang::Operator, zmbt::mapping::TestDiagnostics, zmbt::shared_resource)</li> <li>ObjectId (zmbt::Environment)</li> <li>ObservedCalls (zmbt::Environment::InterfaceHandle)</li> <li>output_recorder_ (zmbt::Environment::InterfaceHandle, zmbt::Trigger)</li> <li>output_recorders (zmbt::EnvironmentData)</li> <li>operator() (zmbt::Generator, zmbt::JsonNode, zmbt::JsonTraverse, zmbt::Trigger, zmbt::lang::EvalImplBase, zmbt::lang::LazyParam, zmbt::lang::SignatureBinary, zmbt::lang::SignatureBinary&lt; Keyword::PreProc &gt;, zmbt::lang::SignatureCast, zmbt::lang::SignatureErr, zmbt::lang::SignatureOp, zmbt::lang::SignatureUncast, zmbt::lang::SignatureVariadic, zmbt::mapping::ModelDefinition::T_ParamRow, zmbt::mapping::ModelDefinition::T_TestRow)</li> <li>obj_id_ (zmbt::InjectionTable, zmbt::OutputRecorder)</li> <li>operator* (zmbt::JsonIter, zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator, zmbt::shared_resource)</li> <li>operator++ (zmbt::JsonIter, zmbt::lang::EncodingView::Iterator, zmbt::lang::EvalContext)</li> <li>owned_sequences_ (zmbt::JsonIterZipProdBase)</li> <li>Output (zmbt::Logger)</li> <li>open_json (zmbt::Logger)</li> <li>operator&lt;&lt; (zmbt::Logger, zmbt::StubLogger, zmbt::decor::underlying)</li> <li>output_ (zmbt::Logger)</li> <li>OutputRecorder (zmbt::OutputRecorder)</li> <li>output_recorder_factories (zmbt::PermanentEnvData)</li> <li>obj_ (zmbt::Trigger)</li> <li>obj_id (zmbt::Trigger)</li> <li>operator!= (zmbt::Trigger, zmbt::decor::underlying, zmbt::entity_id, zmbt::interface_id, zmbt::lang::Encoding, zmbt::lang::EncodingView, zmbt::lang::EncodingView::Iterator, zmbt::lang::Expression, zmbt::lang::ExpressionView, zmbt::object_id)</li> <li>operator== (zmbt::Trigger, zmbt::decor::precise, zmbt::decor::underlying, zmbt::entity_id, zmbt::interface_id, zmbt::lang::Encoding, zmbt::lang::EncodingView, zmbt::lang::EncodingView::Iterator, zmbt::lang::Expression, zmbt::lang::ExpressionView, zmbt::mapping::ChannelHandle, zmbt::object_id)</li> <li>operator decorated_type (zmbt::decor::precise, zmbt::decor::underlying)</li> <li>operator&lt; (zmbt::decor::precise, zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator! (zmbt::decor::underlying)</li> <li>operator% (zmbt::decor::underlying)</li> <li>operator&amp; (zmbt::decor::underlying)</li> <li>operator&amp;&amp; (zmbt::decor::underlying)</li> <li>operator+ (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator- (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator/ (zmbt::decor::underlying)</li> <li>operator&lt;= (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator&gt; (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator&gt;= (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator&gt;&gt; (zmbt::decor::underlying)</li> <li>operator^ (zmbt::decor::underlying)</li> <li>operator| (zmbt::decor::underlying)</li> <li>operator|| (zmbt::decor::underlying)</li> <li>operator~ (zmbt::decor::underlying)</li> <li>operator[] (zmbt::lang::EncodingView, zmbt::lang::EncodingView::Iterator, zmbt::mapping::ModelDefinition::T_TestRow)</li> <li>operator+= (zmbt::lang::EncodingView::Iterator)</li> <li>operator-- (zmbt::lang::EncodingView::Iterator)</li> <li>operator-= (zmbt::lang::EncodingView::Iterator)</li> <li>op (zmbt::lang::EvalContext)</li> <li>operator V (zmbt::lang::LazyParam)</li> <li>Operator (zmbt::lang::Operator)</li> <li>observe (zmbt::mapping::PipeHandle)</li> <li>observe_blend (zmbt::mapping::PipeHandle)</li> <li>overload (zmbt::mapping::PipeHandle)</li> <li>observed (zmbt::mapping::TestDiagnostics)</li> <li>object_id (zmbt::object_id)</li> <li>operator-&gt; (zmbt::shared_resource)</li> <li>or_ (zmbt::lang::Operator::Handle::Handle, zmbt::lang::Operator::Handle::Handle)</li> <li>OnTrigger (zmbt::mapping::ModelDefinition::T_OnTrigger)</li> </ul>"},{"location":"CxxRef/class_members/#p","title":"p","text":"<ul> <li>permanent_data_ (zmbt::Environment)</li> <li>PrototypeArgs (zmbt::Environment::InterfaceHandle)</li> <li>PrototypeReturn (zmbt::Environment::InterfaceHandle)</li> <li>prototypes_ (zmbt::InjectionTable)</li> <li>payload_cache_ (zmbt::Logger)</li> <li>push (zmbt::OutputRecorder, zmbt::lang::EvalLog)</li> <li>Param (zmbt::Param)</li> <li>prototypes (zmbt::PermanentEnvData)</li> <li>ptr (zmbt::TriggerObj, zmbt::shared_resource)</li> <li>ptr_ (zmbt::TriggerObj, zmbt::shared_resource)</li> <li>precise (zmbt::decor::precise)</li> <li>preprocess (zmbt::lang::Encoding)</li> <li>push_back (zmbt::lang::Encoding)</li> <li>pointer (zmbt::lang::EncodingView::Iterator)</li> <li>parameters (zmbt::lang::ExpressionGrammar)</li> <li>pipe (zmbt::lang::ExpressionGrammar)</li> <li>preprocessing_parameters (zmbt::lang::ExpressionView)</li> <li>prettify (zmbt::lang::ExpressionView)</li> <li>prettify_to (zmbt::lang::ExpressionView)</li> <li>PipeHandle (zmbt::mapping::PipeHandle)</li> <li>PipeId (zmbt::mapping::TestDiagnostics)</li> <li>pipe_id (zmbt::mapping::TestDiagnostics)</li> <li>Prototypes (zmbt::reflect::Prototypes)</li> <li>Parametrize (zmbt::mapping::ModelDefinition::T_CustomParam)</li> <li>Pairwise (zmbt::mapping::ModelDefinition::T_Param)</li> <li>Prod (zmbt::mapping::ModelDefinition::T_Param)</li> <li>PostRun (zmbt::mapping::ModelDefinition::T_PostRun)</li> <li>PreRun (zmbt::mapping::ModelDefinition::T_PreRun)</li> </ul>"},{"location":"CxxRef/class_members/#r","title":"r","text":"<ul> <li>ResetFailureHandler (zmbt::Config)</li> <li>RegisterAction (zmbt::Environment)</li> <li>RegisterAnonymousInterface (zmbt::Environment)</li> <li>RegisterAnonymousTrigger (zmbt::Environment)</li> <li>RegisterInterface (zmbt::Environment)</li> <li>RegisterParametricTriggerIfc (zmbt::Environment)</li> <li>RegisterParametricTriggerObj (zmbt::Environment)</li> <li>RegisterTrigger (zmbt::Environment)</li> <li>ResetAll (zmbt::Environment)</li> <li>ResetInterfaceData (zmbt::Environment)</li> <li>RunAction (zmbt::Environment)</li> <li>RunActionNoCatch (zmbt::Environment)</li> <li>return_t (zmbt::Environment, zmbt::Environment::TypedInterfaceHandle, zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;)</li> <li>rvref_to_val (zmbt::Environment)</li> <li>RunAsAction (zmbt::Environment::InterfaceHandle)</li> <li>RunAsTrigger (zmbt::Environment::InterfaceHandle)</li> <li>refobj (zmbt::Environment::InterfaceHandle)</li> <li>refobj_ (zmbt::Environment::InterfaceHandle)</li> <li>reflection (zmbt::Environment::TypedInterfaceHandle)</li> <li>return_or_nullptr_t (zmbt::Environment::TypedInterfaceHandle)</li> <li>rvalue_reference_to_value (zmbt::Environment::TypedInterfaceHandle)</li> <li>reset (zmbt::Generator, zmbt::ConversionTime, zmbt::InjectionTime, zmbt::RecordingTime)</li> <li>ret_ (zmbt::InjectionTable)</li> <li>Record (zmbt::InjectionTable::Record)</li> <li>root (zmbt::JsonNode)</li> <li>root_ (zmbt::JsonNode)</li> <li>root_node (zmbt::JsonNode)</li> <li>registry_ (zmbt::OutputRecorder)</li> <li>report_test_error (zmbt::OutputRecorder)</li> <li>rbegin (zmbt::lang::EncodingView)</li> <li>rend (zmbt::lang::EncodingView)</li> <li>reverse_iterator (zmbt::lang::EncodingView)</li> <li>reference (zmbt::lang::EncodingView::Iterator)</li> <li>rhs (zmbt::lang::EvalParams)</li> <li>rhs_ (zmbt::lang::EvalParams)</li> <li>rhs_maybe_owned_ (zmbt::lang::EvalParams)</li> <li>Result (zmbt::mapping::TestDiagnostics)</li> <li>result (zmbt::mapping::TestDiagnostics)</li> <li>resolve_deferred_params (zmbt::mapping::TestParameterResolver)</li> <li>Run (zmbt::mapping::TestRunner)</li> <li>ret (zmbt::reflect::Prototypes, zmbt::OutputRecorder::Registry::FrameBuffs)</li> <li>return_ (zmbt::reflect::Prototypes)</li> <li>Registry (zmbt::OutputRecorder::Registry)</li> <li>right (zmbt::lang::Operator::Handle::Handle)</li> <li>Return (zmbt::mapping::ModelDefinition::T_Filter)</li> <li>Repeat (zmbt::mapping::ModelDefinition::T_Repeat)</li> </ul>"},{"location":"CxxRef/class_members/#s","title":"s","text":"<ul> <li>SetFailureHandler (zmbt::Config)</li> <li>SetShared (zmbt::Environment)</li> <li>SetTestError (zmbt::Environment)</li> <li>SetVar (zmbt::Environment)</li> <li>shared (zmbt::EnvironmentData)</li> <li>shared_data_record (zmbt::EnvironmentData)</li> <li>shared_data_table (zmbt::EnvironmentData)</li> <li>Shared (zmbt::Generator)</li> <li>step (zmbt::JsonIter, zmbt::JsonProdIter, zmbt::JsonZipIter)</li> <li>size (zmbt::JsonNode, zmbt::lang::Encoding, zmbt::lang::EncodingView)</li> <li>set_max_level (zmbt::Logger)</li> <li>set_notrim (zmbt::Logger)</li> <li>set_pretty_print (zmbt::Logger)</li> <li>set_timestamp (zmbt::Logger)</li> <li>src_loc_ (zmbt::Logger)</li> <li>setup_handlers (zmbt::OutputRecorder)</li> <li>SetupOutputRecorder (zmbt::PermanentEnvData)</li> <li>stub_delete (zmbt::TriggerObj)</li> <li>stringify (zmbt::decor::precise, zmbt::decor::underlying)</li> <li>str (zmbt::entity_id, zmbt::lang::EvalLog)</li> <li>str_ (zmbt::entity_id)</li> <li>set (zmbt::TestIsRunning)</li> <li>status (zmbt::TestIsRunning, zmbt::lang::EvalValidator)</li> <li>size_ (zmbt::lang::EncodingView)</li> <li>slice (zmbt::lang::EncodingView)</li> <li>subtree (zmbt::lang::EncodingView)</li> <li>stack (zmbt::lang::EvalLog)</li> <li>self (zmbt::lang::EvalParams)</li> <li>self_ (zmbt::lang::EvalParams)</li> <li>Subexpression (zmbt::lang::Expression::Subexpression)</li> <li>start (zmbt::lang::ExpressionGrammar, zmbt::lang::KeywordGrammar)</li> <li>subexpr (zmbt::lang::ExpressionGrammar)</li> <li>serialize (zmbt::lang::ExpressionView)</li> <li>subexpressions_list (zmbt::lang::ExpressionView)</li> <li>SignatureBase (zmbt::lang::SignatureBase)</li> <li>signal_path (zmbt::mapping::ChannelHandle)</li> <li>state (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>should_flatten_ (zmbt::mapping::PipeHandle)</li> <li>SignalMapping (zmbt::mapping::SignalMapping)</li> <li>shared_resource (zmbt::shared_resource)</li> <li>serialized_frames (zmbt::OutputRecorder::Registry)</li> <li>shift (zmbt::lang::Operator::Handle)</li> <li>sub (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_members/#t","title":"t","text":"<ul> <li>TestError (zmbt::Environment)</li> <li>TryLock (zmbt::Environment)</li> <li>TypedInterfaceHandle (zmbt::Environment::TypedInterfaceHandle)</li> <li>trigger_ifcs (zmbt::EnvironmentData)</li> <li>trigger_objs (zmbt::EnvironmentData)</li> <li>triggers (zmbt::EnvironmentData)</li> <li>to_json (zmbt::ErrorInfo, zmbt::lang::EncodingView, zmbt::lang::ExpressionView, zmbt::mapping::TestDiagnostics)</li> <li>type (zmbt::ErrorInfo, zmbt::ifc_args, zmbt::ifc_handle, zmbt::ifc_host, zmbt::ifc_pointer, zmbt::ifc_return, zmbt::mapping::PipeHandle, zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;, zmbt::type_tag)</li> <li>transform (zmbt::InjectionTable::Record, zmbt::mapping::ChannelHandle)</li> <li>traverse (zmbt::JsonTraverse)</li> <li>timestamp_ (zmbt::Logger)</li> <li>ts (zmbt::OutputRecorder::Frame)</li> <li>Trigger (zmbt::Trigger)</li> <li>TriggerIfc (zmbt::TriggerIfc)</li> <li>TriggerObj (zmbt::TriggerObj)</li> <li>type_index_hash_ (zmbt::entity_id)</li> <li>traverse_subtrees (zmbt::lang::EncodingView)</li> <li>to_predicate_if_const (zmbt::lang::Expression)</li> <li>tuple (zmbt::lang::ExpressionGrammar)</li> <li>tuple_parameters (zmbt::lang::ExpressionView)</li> <li>transit_to (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>TabularConditionFailure (zmbt::mapping::TestDiagnostics)</li> <li>TestDiagnostics (zmbt::mapping::TestDiagnostics)</li> <li>TestRow (zmbt::mapping::TestDiagnostics)</li> <li>tabular_condition_failure_ (zmbt::mapping::TestDiagnostics)</li> <li>tc (zmbt::mapping::TestDiagnostics)</li> <li>tr (zmbt::mapping::TestDiagnostics)</li> <li>TestParameterResolver (zmbt::mapping::TestParameterResolver)</li> <li>TestRunner (zmbt::mapping::TestRunner)</li> <li>to_string (zmbt::object_id)</li> <li>ThreadId (zmbt::mapping::ModelDefinition::T_Filter)</li> <li>Timestamp (zmbt::mapping::ModelDefinition::T_Filter)</li> <li>Take (zmbt::mapping::ModelDefinition::T_Take)</li> <li>Test (zmbt::mapping::ModelDefinition::T_Test)</li> </ul>"},{"location":"CxxRef/class_members/#u","title":"u","text":"<ul> <li>unqf_args_t (zmbt::Environment, zmbt::Environment::TypedInterfaceHandle)</li> <li>unsafe (zmbt::TriggerObj)</li> <li>underlying (zmbt::decor::underlying)</li> <li>unfold_left_assoc (zmbt::lang::Expression)</li> <li>unary_transform (zmbt::lang::Operator)</li> <li>undecorate (zmbt::lang::Operator, zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_members/#v","title":"v","text":"<ul> <li>variant_t (zmbt::ErrorOr)</li> <li>validate_jptr (zmbt::JsonNode)</li> <li>visit_ (zmbt::JsonTraverse)</li> <li>visitor_fn (zmbt::JsonTraverse)</li> <li>value_ (zmbt::Param, zmbt::decor::precise, zmbt::decor::underlying)</li> <li>validate (zmbt::decor::precise)</li> <li>validate_str (zmbt::decor::precise)</li> <li>validate_str_as (zmbt::decor::precise)</li> <li>value (zmbt::decor::precise, zmbt::decor::underlying, zmbt::ConversionTime, zmbt::InjectionTime, zmbt::RecordingTime)</li> <li>V (zmbt::lang::Encoding, zmbt::lang::EncodingView, zmbt::lang::ExpressionView, zmbt::lang::LazyParam, zmbt::lang::Operator)</li> <li>v_ (zmbt::lang::EncodingView::Iterator)</li> <li>value_type (zmbt::lang::EncodingView::Iterator)</li> <li>Vector (zmbt::mapping::TestDiagnostics)</li> <li>vector (zmbt::mapping::TestDiagnostics)</li> </ul>"},{"location":"CxxRef/class_members/#w","title":"w","text":"<ul> <li>what (zmbt::ErrorInfo)</li> <li>WithLevel (zmbt::Logger)</li> <li>WithOutput (zmbt::Logger)</li> <li>WithSrcLoc (zmbt::Logger)</li> </ul>"},{"location":"CxxRef/class_members/#x","title":"x","text":"<ul> <li>x (zmbt::lang::EvalParams)</li> <li>x_ (zmbt::lang::EvalParams)</li> <li>xor_ (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_members/#y","title":"y","text":"<ul> <li>YieldInjection (zmbt::Environment::InterfaceHandle)</li> <li>YieldInjectionArgs (zmbt::Environment::InterfaceHandle)</li> <li>YieldInjectionReturn (zmbt::Environment::InterfaceHandle)</li> <li>yield (zmbt::InjectionTable)</li> </ul>"},{"location":"CxxRef/class_members/#z","title":"z","text":"<ul> <li>Zip (zmbt::mapping::ModelDefinition::T_Param)</li> </ul>"},{"location":"CxxRef/class_members/#_1","title":"~","text":"<ul> <li>~Config (zmbt::Config)</li> <li>~InterfaceHandle (zmbt::Environment::InterfaceHandle)</li> <li>~TypedInterfaceHandle (zmbt::Environment::TypedInterfaceHandle)</li> <li>~Environment (zmbt::Environment)</li> <li>~EnvironmentData (zmbt::EnvironmentData)</li> <li>~Generator (zmbt::Generator)</li> <li>~JsonIter (zmbt::JsonIter)</li> <li>~JsonIterZipProdBase (zmbt::JsonIterZipProdBase)</li> <li>~JsonNode (zmbt::JsonNode)</li> <li>~Logger (zmbt::Logger)</li> <li>~OutputRecorder (zmbt::OutputRecorder)</li> <li>~Param (zmbt::Param)</li> <li>~Trigger (zmbt::Trigger)</li> <li>~TriggerIfc (zmbt::TriggerIfc)</li> <li>~TriggerObj (zmbt::TriggerObj)</li> <li>~ModelTestFixture (zmbt::api::ModelTestFixture)</li> <li>~precise (zmbt::decor::precise)</li> <li>~underlying (zmbt::decor::underlying)</li> <li>~entity_id (zmbt::entity_id)</li> <li>~Expression (zmbt::lang::Expression)</li> <li>~ExpressionView (zmbt::lang::ExpressionView)</li> <li>~LazyParam (zmbt::lang::LazyParam)</li> <li>~Operator (zmbt::lang::Operator)</li> <li>~ChannelHandle (zmbt::mapping::ChannelHandle)</li> <li>~BaseTransition (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>~N_Alias (zmbt::mapping::ModelDefinition::N_Alias)</li> <li>~N_Channel (zmbt::mapping::ModelDefinition::N_Channel)</li> <li>~N_ChannelEnd (zmbt::mapping::ModelDefinition::N_ChannelEnd)</li> <li>~N_Decor (zmbt::mapping::ModelDefinition::N_Decor)</li> <li>~N_Descr (zmbt::mapping::ModelDefinition::N_Descr)</li> <li>~N_Filter (zmbt::mapping::ModelDefinition::N_Filter)</li> <li>~N_Main (zmbt::mapping::ModelDefinition::N_Main)</li> <li>~N_MaybeChannel (zmbt::mapping::ModelDefinition::N_MaybeChannel)</li> <li>~N_Param (zmbt::mapping::ModelDefinition::N_Param)</li> <li>~N_ParamTable (zmbt::mapping::ModelDefinition::N_ParamTable)</li> <li>~N_Post (zmbt::mapping::ModelDefinition::N_Post)</li> <li>~N_Pre (zmbt::mapping::ModelDefinition::N_Pre)</li> <li>~N_Repeat (zmbt::mapping::ModelDefinition::N_Repeat)</li> <li>~N_Take (zmbt::mapping::ModelDefinition::N_Take)</li> <li>~N_Term (zmbt::mapping::ModelDefinition::N_Term)</li> <li>~N_Test (zmbt::mapping::ModelDefinition::N_Test)</li> <li>~N_TestTable (zmbt::mapping::ModelDefinition::N_TestTable)</li> <li>~PipeHandle (zmbt::mapping::PipeHandle)</li> <li>~SignalMapping (zmbt::mapping::SignalMapping)</li> <li>~TestDiagnostics (zmbt::mapping::TestDiagnostics)</li> <li>~TestRunner (zmbt::mapping::TestRunner)</li> <li>~shared_resource (zmbt::shared_resource)</li> <li>~Registry (zmbt::OutputRecorder::Registry)</li> </ul>"},{"location":"CxxRef/class_member_functions/","title":"Class Member Functions","text":""},{"location":"CxxRef/class_member_functions/#a","title":"a","text":"<ul> <li>autokey (zmbt::Environment)</li> <li>as_error (zmbt::ErrorOr)</li> <li>as_return (zmbt::ErrorOr)</li> <li>add_record (zmbt::InjectionTable)</li> <li>as_array (zmbt::JsonNode, zmbt::lang::ExpressionView)</li> <li>as_object (zmbt::JsonNode, zmbt::lang::ExpressionView)</li> <li>at (zmbt::JsonNode, zmbt::lang::EncodingView)</li> <li>apply_fn (zmbt::TriggerIfc)</li> <li>annotation (zmbt::entity_id, zmbt::lang::Operator)</li> <li>add (zmbt::ConversionTime, zmbt::InjectionTime, zmbt::RecordingTime)</li> <li>append_to_root (zmbt::lang::Encoding)</li> <li>arity (zmbt::lang::EncodingView)</li> <li>as_bool (zmbt::lang::ExpressionView)</li> <li>as_string (zmbt::lang::ExpressionView)</li> <li>attributes (zmbt::lang::KeywordInfo)</li> <li>apply (zmbt::lang::Operator, zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;)</li> <li>alias (zmbt::mapping::ChannelHandle)</li> <li>args (zmbt::reflect::Prototypes)</li> <li>Alias (zmbt::mapping::ModelDefinition::T_Alias)</li> <li>As (zmbt::mapping::ModelDefinition::T_As)</li> <li>At (zmbt::mapping::ModelDefinition::T_At)</li> <li>Args (zmbt::mapping::ModelDefinition::T_Filter)</li> </ul>"},{"location":"CxxRef/class_member_functions/#b","title":"b","text":"<ul> <li>branch (zmbt::JsonNode)</li> <li>base_error (zmbt::base_error, zmbt::environment_error, zmbt::lang::Operator::operator_error, zmbt::model_error, zmbt::output_recorder_error, zmbt::serialization_error, zmbt::test_assertion_failure)</li> <li>back (zmbt::lang::EncodingView)</li> <li>begin (zmbt::lang::EncodingView)</li> <li>BaseTransition (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>Blend (zmbt::mapping::ModelDefinition::T_ContinuePipe)</li> </ul>"},{"location":"CxxRef/class_member_functions/#c","title":"c","text":"<ul> <li>Config (zmbt::Config)</li> <li>ContainsShared (zmbt::Environment)</li> <li>CaptureSlice (zmbt::Environment::InterfaceHandle)</li> <li>Captures (zmbt::Environment::InterfaceHandle)</li> <li>catch (zmbt::Environment::TypedInterfaceHandle, zmbt::lang::Operator)</li> <li>contains (zmbt::JsonNode, zmbt::lang::Operator)</li> <li>copy (zmbt::JsonNode)</li> <li>check_filter (zmbt::OutputRecorder)</li> <li>clear (zmbt::OutputRecorder, zmbt::TestIsRunning)</li> <li>count (zmbt::OutputRecorder)</li> <li>counter (zmbt::ConversionTime, zmbt::InjectionTime, zmbt::RecordingTime)</li> <li>cbegin (zmbt::lang::EncodingView)</li> <li>cend (zmbt::lang::EncodingView)</li> <li>child (zmbt::lang::EncodingView)</li> <li>child_idx (zmbt::lang::EncodingView)</li> <li>children (zmbt::lang::EncodingView)</li> <li>crbegin (zmbt::lang::EncodingView)</li> <li>crend (zmbt::lang::EncodingView)</li> <li>curr_ctx (zmbt::lang::EvalImplBase)</li> <li>context (zmbt::lang::EvalParams)</li> <li>ChannelHandle (zmbt::mapping::ChannelHandle)</li> <li>captures (zmbt::mapping::ChannelHandle)</li> <li>channels (zmbt::mapping::PipeHandle)</li> <li>column (zmbt::mapping::PipeHandle)</li> <li>ChannelId (zmbt::mapping::TestDiagnostics)</li> <li>Comment (zmbt::mapping::TestDiagnostics)</li> <li>CallCount (zmbt::mapping::ModelDefinition::T_Filter)</li> </ul>"},{"location":"CxxRef/class_member_functions/#d","title":"d","text":"<ul> <li>DefaultObjectId (zmbt::Environment)</li> <li>DeferLock (zmbt::Environment)</li> <li>DumpToJsonLog (zmbt::Environment)</li> <li>dump_to (zmbt::ErrorOr)</li> <li>data_frames (zmbt::OutputRecorder)</li> <li>depth_offset (zmbt::lang::EncodingView)</li> <li>data (zmbt::lang::ExpressionView)</li> <li>decorate (zmbt::lang::Operator)</li> <li>Description (zmbt::mapping::TestDiagnostics, zmbt::mapping::ModelDefinition::T_Description)</li> <li>dejsonize (zmbt::reflect::custom_serialization&lt; ChannelKind &gt;, zmbt::reflect::custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt;, zmbt::reflect::custom_serialization&lt; lang::Encoding &gt;, zmbt::reflect::custom_serialization&lt; decor::precise&lt; T &gt; &gt;, zmbt::reflect::custom_serialization&lt; decor::underlying&lt; T &gt; &gt;)</li> </ul>"},{"location":"CxxRef/class_member_functions/#e","title":"e","text":"<ul> <li>Environment (zmbt::Environment)</li> <li>EnableOutputRecordFor (zmbt::Environment::InterfaceHandle)</li> <li>Env (zmbt::Environment::InterfaceHandle)</li> <li>EnvironmentData (zmbt::EnvironmentData)</li> <li>ErrorOr (zmbt::ErrorOr)</li> <li>expression (zmbt::Generator, zmbt::mapping::PipeHandle)</li> <li>enable_category (zmbt::OutputRecorder)</li> <li>ensure_registry (zmbt::OutputRecorder)</li> <li>execute (zmbt::TriggerIfc)</li> <li>entity_id (zmbt::entity_id, zmbt::interface_id, zmbt::object_id)</li> <li>exchange (zmbt::TestIsRunning)</li> <li>Encoding (zmbt::lang::Encoding)</li> <li>EncodingView (zmbt::lang::EncodingView)</li> <li>empty (zmbt::lang::EncodingView)</li> <li>end (zmbt::lang::EncodingView)</li> <li>EvalContext (zmbt::lang::EvalContext)</li> <li>EvalImplBase (zmbt::lang::EvalImplBase)</li> <li>EvalLog (zmbt::lang::EvalLog)</li> <li>EvalParams (zmbt::lang::EvalParams, zmbt::lang::FixedEvalParams)</li> <li>EvalValidator (zmbt::lang::EvalValidator)</li> <li>Expression (zmbt::lang::Expression)</li> <li>encodeLiteral (zmbt::lang::Expression)</li> <li>encodeNested (zmbt::lang::Expression)</li> <li>encodePreProc (zmbt::lang::Expression)</li> <li>encoding (zmbt::lang::Expression)</li> <li>ExpressionGrammar (zmbt::lang::ExpressionGrammar)</li> <li>ExpressionView (zmbt::lang::ExpressionView)</li> <li>encoding_view (zmbt::lang::ExpressionView)</li> <li>error_id (zmbt::lang::ExpressionView)</li> <li>eval (zmbt::lang::ExpressionView)</li> <li>eval_as_predicate (zmbt::lang::ExpressionView)</li> <li>eval_e (zmbt::lang::ExpressionView)</li> <li>eval_maybe_predicate (zmbt::lang::ExpressionView)</li> <li>exchangeHandle (zmbt::lang::Operator)</li> <li>encodeVariadic (zmbt::lang::SignatureVariadic)</li> <li>Error (zmbt::mapping::TestDiagnostics)</li> <li>EvalStack (zmbt::mapping::TestDiagnostics)</li> <li>Exception (zmbt::mapping::ModelDefinition::T_Filter)</li> <li>Expect (zmbt::mapping::ModelDefinition::T_TerminatePipe)</li> </ul>"},{"location":"CxxRef/class_member_functions/#f","title":"f","text":"<ul> <li>find_pointer (zmbt::JsonNode)</li> <li>flush (zmbt::OutputRecorder)</li> <li>flag (zmbt::TestIsRunning)</li> <li>freeze (zmbt::lang::EncodingView)</li> <li>front (zmbt::lang::EncodingView)</li> <li>format (zmbt::lang::EvalLog)</li> <li>full_path (zmbt::mapping::ChannelHandle)</li> <li>Fail (zmbt::mapping::TestDiagnostics)</li> </ul>"},{"location":"CxxRef/class_member_functions/#g","title":"g","text":"<ul> <li>GetOrRegisterInterface (zmbt::Environment)</li> <li>GetOrRegisterParametricTrigger (zmbt::Environment)</li> <li>GetPrototypes (zmbt::Environment)</li> <li>GetRecorder (zmbt::Environment)</li> <li>GetShared (zmbt::Environment)</li> <li>GetSharedRef (zmbt::Environment)</li> <li>GetVar (zmbt::Environment)</li> <li>GetVarOrDefault (zmbt::Environment)</li> <li>GetVarOrUpdate (zmbt::Environment)</li> <li>Generator (zmbt::Generator)</li> <li>get_maybe_const (zmbt::InjectionTable)</li> <li>get_records (zmbt::InjectionTable)</li> <li>get (zmbt::JsonIter, zmbt::JsonIterZipProdBase)</li> <li>get_or_create (zmbt::JsonNode)</li> <li>get_or_create_array (zmbt::JsonNode)</li> <li>get_or_create_as (zmbt::JsonNode)</li> <li>get_or_create_object (zmbt::JsonNode)</li> <li>get_or_default (zmbt::JsonNode)</li> <li>get_args_typeid (zmbt::OutputRecorder)</li> <li>get_default_object (zmbt::PermanentEnvData)</li> <li>get_output_recorder_factory (zmbt::PermanentEnvData)</li> <li>get_prototypes (zmbt::PermanentEnvData)</li> <li>generic_bit_and (zmbt::lang::Operator)</li> <li>generic_bit_or (zmbt::lang::Operator)</li> <li>generic_bit_xor (zmbt::lang::Operator)</li> <li>generic_complement (zmbt::lang::Operator)</li> <li>generic_decorate (zmbt::lang::Operator)</li> <li>generic_divides (zmbt::lang::Operator)</li> <li>generic_equal_to (zmbt::lang::Operator)</li> <li>generic_is_truth (zmbt::lang::Operator)</li> <li>generic_left_shift (zmbt::lang::Operator)</li> <li>generic_less (zmbt::lang::Operator)</li> <li>generic_less_equal (zmbt::lang::Operator)</li> <li>generic_log (zmbt::lang::Operator)</li> <li>generic_logical_and (zmbt::lang::Operator)</li> <li>generic_logical_not (zmbt::lang::Operator)</li> <li>generic_logical_or (zmbt::lang::Operator)</li> <li>generic_minus (zmbt::lang::Operator)</li> <li>generic_modulus (zmbt::lang::Operator)</li> <li>generic_multiplies (zmbt::lang::Operator)</li> <li>generic_negate (zmbt::lang::Operator)</li> <li>generic_plus (zmbt::lang::Operator)</li> <li>generic_pow (zmbt::lang::Operator)</li> <li>generic_quot (zmbt::lang::Operator)</li> <li>generic_right_shift (zmbt::lang::Operator)</li> <li>generic_undecorate (zmbt::lang::Operator)</li> <li>Group (zmbt::mapping::ModelDefinition::T_ContinuePipe)</li> </ul>"},{"location":"CxxRef/class_member_functions/#h","title":"h","text":"<ul> <li>HandleTestFailure (zmbt::Config)</li> <li>HasAction (zmbt::Environment)</li> <li>HasTestError (zmbt::Environment)</li> <li>HasTrigger (zmbt::Environment)</li> <li>Hook (zmbt::Environment::TypedInterfaceHandle)</li> <li>HookArgsImpl (zmbt::Environment::TypedInterfaceHandle)</li> <li>HookReturnImpl (zmbt::Environment::TypedInterfaceHandle)</li> <li>halt (zmbt::JsonIter, zmbt::JsonIterZipProdBase)</li> <li>head (zmbt::lang::EncodingView)</li> <li>has_default_rhs (zmbt::lang::EvalParams)</li> <li>has_subexpr (zmbt::lang::ExpressionView)</li> <li>handle_bit_and (zmbt::lang::Operator)</li> <li>handle_bit_or (zmbt::lang::Operator)</li> <li>handle_bit_xor (zmbt::lang::Operator)</li> <li>handle_complement (zmbt::lang::Operator)</li> <li>handle_decorate (zmbt::lang::Operator)</li> <li>handle_divides (zmbt::lang::Operator)</li> <li>handle_equal_to (zmbt::lang::Operator)</li> <li>handle_is_truth (zmbt::lang::Operator)</li> <li>handle_left_shift (zmbt::lang::Operator)</li> <li>handle_less (zmbt::lang::Operator)</li> <li>handle_less_equal (zmbt::lang::Operator)</li> <li>handle_logical_and (zmbt::lang::Operator)</li> <li>handle_logical_not (zmbt::lang::Operator)</li> <li>handle_logical_or (zmbt::lang::Operator)</li> <li>handle_minus (zmbt::lang::Operator)</li> <li>handle_modulus (zmbt::lang::Operator)</li> <li>handle_multiplies (zmbt::lang::Operator)</li> <li>handle_negate (zmbt::lang::Operator)</li> <li>handle_plus (zmbt::lang::Operator)</li> <li>handle_right_shift (zmbt::lang::Operator)</li> <li>handle_undecorate (zmbt::lang::Operator)</li> <li>host (zmbt::mapping::ChannelHandle)</li> <li>has_expression (zmbt::mapping::PipeHandle)</li> </ul>"},{"location":"CxxRef/class_member_functions/#i","title":"i","text":"<ul> <li>InitializeInterfaceHandlers (zmbt::Environment)</li> <li>InterfaceId (zmbt::Environment)</li> <li>Inject (zmbt::Environment::InterfaceHandle, zmbt::mapping::ModelDefinition::T_TerminatePipe)</li> <li>InjectArgs (zmbt::Environment::InterfaceHandle)</li> <li>InjectReturn (zmbt::Environment::InterfaceHandle)</li> <li>InterfaceHandle (zmbt::Environment::InterfaceHandle)</li> <li>interface (zmbt::Environment::InterfaceHandle, zmbt::mapping::ChannelHandle)</li> <li>init_json_data (zmbt::EnvironmentData)</li> <li>is_error (zmbt::ErrorOr, zmbt::lang::ExpressionView)</li> <li>is_null (zmbt::ErrorOr, zmbt::JsonNode, zmbt::lang::ExpressionView)</li> <li>is_return (zmbt::ErrorOr)</li> <li>is_noop (zmbt::Generator, zmbt::lang::ExpressionView)</li> <li>InjectionTable (zmbt::InjectionTable)</li> <li>init_iters (zmbt::JsonIterZipProdBase)</li> <li>is_notrim_enabled (zmbt::Logger)</li> <li>is_pretty_print_enabled (zmbt::Logger)</li> <li>interface_name (zmbt::OutputRecorder)</li> <li>is_registered (zmbt::OutputRecorder)</li> <li>isParam (zmbt::Param)</li> <li>ifc_id (zmbt::Trigger)</li> <li>id (zmbt::TriggerIfc, zmbt::TriggerObj)</li> <li>ifc_addr (zmbt::interface_id)</li> <li>interface_id (zmbt::interface_id)</li> <li>is_link_token (zmbt::lang::Encoding)</li> <li>is_preproc_token (zmbt::lang::Encoding)</li> <li>if_data (zmbt::lang::EncodingView)</li> <li>if_depth (zmbt::lang::EncodingView)</li> <li>if_keywords (zmbt::lang::EncodingView)</li> <li>index_offset (zmbt::lang::EncodingView)</li> <li>is_boolean (zmbt::lang::EncodingView, zmbt::lang::ExpressionView)</li> <li>is_const (zmbt::lang::EncodingView, zmbt::lang::ExpressionView)</li> <li>Iterator (zmbt::lang::EncodingView::Iterator)</li> <li>is_invalid (zmbt::lang::EvalValidator)</li> <li>if_array (zmbt::lang::ExpressionView)</li> <li>if_bool (zmbt::lang::ExpressionView)</li> <li>if_object (zmbt::lang::ExpressionView)</li> <li>if_string (zmbt::lang::ExpressionView)</li> <li>is (zmbt::lang::ExpressionView)</li> <li>is_complete_flip (zmbt::lang::ExpressionView)</li> <li>is_compose (zmbt::lang::ExpressionView)</li> <li>is_fork (zmbt::lang::ExpressionView)</li> <li>is_infix_fork (zmbt::lang::ExpressionView)</li> <li>is_infix_pipe (zmbt::lang::ExpressionView)</li> <li>is_infix_tuple (zmbt::lang::ExpressionView)</li> <li>is_link (zmbt::lang::ExpressionView)</li> <li>is_literal (zmbt::lang::ExpressionView)</li> <li>is_preproc (zmbt::lang::ExpressionView)</li> <li>is_tuple (zmbt::lang::ExpressionView)</li> <li>is_valid_link (zmbt::lang::ExpressionView)</li> <li>is_generic (zmbt::lang::Operator)</li> <li>is_subset (zmbt::lang::Operator)</li> <li>index (zmbt::mapping::ChannelHandle, zmbt::mapping::PipeHandle)</li> <li>inerface_handle (zmbt::mapping::ChannelHandle)</li> <li>inject (zmbt::mapping::PipeHandle)</li> <li>is_input (zmbt::mapping::PipeHandle)</li> <li>is_output (zmbt::mapping::PipeHandle)</li> <li>init_param_iters (zmbt::mapping::TestParameterResolver)</li> <li>init (zmbt::reflect::signal_traits&lt; T, detail::enable_initialization_trap&lt; T &gt; &gt;, zmbt::reflect::signal_traits&lt; void &gt;)</li> </ul>"},{"location":"CxxRef/class_member_functions/#j","title":"j","text":"<ul> <li>json_data (zmbt::Environment)</li> <li>JsonIter (zmbt::JsonIter)</li> <li>JsonIterZipProdBase (zmbt::JsonIterZipProdBase, zmbt::JsonProdIter, zmbt::JsonZipIter)</li> <li>JsonNode (zmbt::JsonNode)</li> <li>JsonTraverse (zmbt::JsonTraverse)</li> <li>json_from (zmbt::reflect::custom_serialization&lt; ChannelKind &gt;, zmbt::reflect::custom_serialization&lt; T, mp_if&lt; is_base_of&lt; lang::Expression, T &gt;, void &gt; &gt;, zmbt::reflect::custom_serialization&lt; lang::Encoding &gt;, zmbt::reflect::custom_serialization&lt; lang::ExpressionView &gt;, zmbt::reflect::custom_serialization&lt; decor::precise&lt; T &gt; &gt;, zmbt::reflect::custom_serialization&lt; decor::underlying&lt; T &gt; &gt;)</li> </ul>"},{"location":"CxxRef/class_member_functions/#k","title":"k","text":"<ul> <li>key (zmbt::Environment::InterfaceHandle, zmbt::entity_id, zmbt::mapping::ChannelHandle)</li> <li>keyword (zmbt::lang::ExpressionView, zmbt::lang::KeywordInfo)</li> <li>keyword_to_str (zmbt::lang::ExpressionView, zmbt::lang::KeywordInfo)</li> <li>KeywordGrammar (zmbt::lang::KeywordGrammar)</li> <li>KeywordSymbol (zmbt::lang::KeywordSymbol)</li> <li>kind (zmbt::mapping::ChannelHandle)</li> </ul>"},{"location":"CxxRef/class_member_functions/#l","title":"l","text":"<ul> <li>Lock (zmbt::Environment)</li> <li>last_record (zmbt::InjectionTable)</li> <li>Logger (zmbt::Logger)</li> <li>lost_count (zmbt::OutputRecorder)</li> <li>lhs (zmbt::lang::EvalParams)</li> <li>LazyParam (zmbt::lang::LazyParam)</li> <li>log_debug (zmbt::mapping::TestParameterResolver)</li> </ul>"},{"location":"CxxRef/class_member_functions/#m","title":"m","text":"<ul> <li>MaybeThrowException (zmbt::Environment::InterfaceHandle)</li> <li>MakeError (zmbt::ErrorOr)</li> <li>MakeValue (zmbt::ErrorOr)</li> <li>Make (zmbt::InjectionTable, zmbt::OutputRecorder::Registry)</li> <li>max_level (zmbt::Logger)</li> <li>ModelTestFixture (zmbt::api::ModelTestFixture)</li> <li>make (zmbt::lang::EvalContext, zmbt::lang::EvalLog)</li> <li>match (zmbt::lang::ExpressionView)</li> <li>makeHandle (zmbt::lang::Operator)</li> <li>make_error (zmbt::lang::SignatureErr)</li> <li>make_throw_action (zmbt::lang::SignatureErr)</li> </ul>"},{"location":"CxxRef/class_member_functions/#n","title":"n","text":"<ul> <li>node (zmbt::JsonNode)</li> <li>node_ptr (zmbt::JsonNode)</li> <li>N_Alias (zmbt::mapping::ModelDefinition::N_Alias)</li> <li>N_Channel (zmbt::mapping::ModelDefinition::N_Channel)</li> <li>N_ChannelEnd (zmbt::mapping::ModelDefinition::N_ChannelEnd)</li> <li>N_Decor (zmbt::mapping::ModelDefinition::N_Decor)</li> <li>N_Descr (zmbt::mapping::ModelDefinition::N_Descr)</li> <li>N_Filter (zmbt::mapping::ModelDefinition::N_Filter)</li> <li>N_Main (zmbt::mapping::ModelDefinition::N_Main)</li> <li>N_MaybeChannel (zmbt::mapping::ModelDefinition::N_MaybeChannel)</li> <li>N_Param (zmbt::mapping::ModelDefinition::N_Param)</li> <li>N_ParamTable (zmbt::mapping::ModelDefinition::N_ParamTable)</li> <li>N_Post (zmbt::mapping::ModelDefinition::N_Post)</li> <li>N_Pre (zmbt::mapping::ModelDefinition::N_Pre)</li> <li>N_Repeat (zmbt::mapping::ModelDefinition::N_Repeat)</li> <li>N_Take (zmbt::mapping::ModelDefinition::N_Take)</li> <li>N_Term (zmbt::mapping::ModelDefinition::N_Term)</li> <li>N_Test (zmbt::mapping::ModelDefinition::N_Test)</li> <li>N_TestTable (zmbt::mapping::ModelDefinition::N_TestTable)</li> <li>Next (zmbt::mapping::TestParameterResolver)</li> </ul>"},{"location":"CxxRef/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (zmbt::Config, zmbt::Environment, zmbt::Environment::InterfaceHandle, zmbt::EnvironmentData, zmbt::Generator, zmbt::JsonIter, zmbt::JsonIterZipProdBase, zmbt::JsonNode, zmbt::OutputRecorder, zmbt::Param, zmbt::Trigger, zmbt::TriggerIfc, zmbt::TriggerObj, zmbt::api::ModelTestFixture, zmbt::decor::precise, zmbt::decor::underlying, zmbt::entity_id, zmbt::lang::Expression, zmbt::lang::ExpressionView, zmbt::lang::LazyParam, zmbt::lang::Operator, zmbt::mapping::TestDiagnostics, zmbt::shared_resource)</li> <li>ObjectId (zmbt::Environment)</li> <li>ObservedCalls (zmbt::Environment::InterfaceHandle)</li> <li>operator() (zmbt::Generator, zmbt::JsonNode, zmbt::JsonTraverse, zmbt::Trigger, zmbt::lang::EvalImplBase, zmbt::lang::LazyParam, zmbt::lang::SignatureBinary, zmbt::lang::SignatureBinary&lt; Keyword::PreProc &gt;, zmbt::lang::SignatureCast, zmbt::lang::SignatureErr, zmbt::lang::SignatureOp, zmbt::lang::SignatureUncast, zmbt::lang::SignatureVariadic, zmbt::mapping::ModelDefinition::T_ParamRow, zmbt::mapping::ModelDefinition::T_TestRow)</li> <li>operator* (zmbt::JsonIter, zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator, zmbt::shared_resource)</li> <li>operator++ (zmbt::JsonIter, zmbt::lang::EncodingView::Iterator, zmbt::lang::EvalContext)</li> <li>open_json (zmbt::Logger)</li> <li>operator&lt;&lt; (zmbt::Logger, zmbt::StubLogger, zmbt::decor::underlying)</li> <li>OutputRecorder (zmbt::OutputRecorder)</li> <li>obj_id (zmbt::Trigger)</li> <li>operator!= (zmbt::Trigger, zmbt::decor::underlying, zmbt::entity_id, zmbt::interface_id, zmbt::lang::Encoding, zmbt::lang::EncodingView, zmbt::lang::EncodingView::Iterator, zmbt::lang::Expression, zmbt::lang::ExpressionView, zmbt::object_id)</li> <li>operator== (zmbt::Trigger, zmbt::decor::precise, zmbt::decor::underlying, zmbt::entity_id, zmbt::interface_id, zmbt::lang::Encoding, zmbt::lang::EncodingView, zmbt::lang::EncodingView::Iterator, zmbt::lang::Expression, zmbt::lang::ExpressionView, zmbt::mapping::ChannelHandle, zmbt::object_id)</li> <li>operator decorated_type (zmbt::decor::precise, zmbt::decor::underlying)</li> <li>operator&lt; (zmbt::decor::precise, zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator! (zmbt::decor::underlying)</li> <li>operator% (zmbt::decor::underlying)</li> <li>operator&amp; (zmbt::decor::underlying)</li> <li>operator&amp;&amp; (zmbt::decor::underlying)</li> <li>operator+ (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator- (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator/ (zmbt::decor::underlying)</li> <li>operator&lt;= (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator&gt; (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator&gt;= (zmbt::decor::underlying, zmbt::lang::EncodingView::Iterator)</li> <li>operator&gt;&gt; (zmbt::decor::underlying)</li> <li>operator^ (zmbt::decor::underlying)</li> <li>operator| (zmbt::decor::underlying)</li> <li>operator|| (zmbt::decor::underlying)</li> <li>operator~ (zmbt::decor::underlying)</li> <li>operator[] (zmbt::lang::EncodingView, zmbt::lang::EncodingView::Iterator, zmbt::mapping::ModelDefinition::T_TestRow)</li> <li>operator+= (zmbt::lang::EncodingView::Iterator)</li> <li>operator-- (zmbt::lang::EncodingView::Iterator)</li> <li>operator-= (zmbt::lang::EncodingView::Iterator)</li> <li>operator V (zmbt::lang::LazyParam)</li> <li>Operator (zmbt::lang::Operator)</li> <li>observe (zmbt::mapping::PipeHandle)</li> <li>observe_blend (zmbt::mapping::PipeHandle)</li> <li>overload (zmbt::mapping::PipeHandle)</li> <li>object_id (zmbt::object_id)</li> <li>operator-&gt; (zmbt::shared_resource)</li> <li>OnTrigger (zmbt::mapping::ModelDefinition::T_OnTrigger)</li> </ul>"},{"location":"CxxRef/class_member_functions/#p","title":"p","text":"<ul> <li>PrototypeArgs (zmbt::Environment::InterfaceHandle)</li> <li>PrototypeReturn (zmbt::Environment::InterfaceHandle)</li> <li>push (zmbt::OutputRecorder, zmbt::lang::EvalLog)</li> <li>Param (zmbt::Param)</li> <li>ptr (zmbt::TriggerObj, zmbt::shared_resource)</li> <li>precise (zmbt::decor::precise)</li> <li>preprocess (zmbt::lang::Encoding)</li> <li>push_back (zmbt::lang::Encoding)</li> <li>preprocessing_parameters (zmbt::lang::ExpressionView)</li> <li>prettify (zmbt::lang::ExpressionView)</li> <li>prettify_to (zmbt::lang::ExpressionView)</li> <li>PipeHandle (zmbt::mapping::PipeHandle)</li> <li>PipeId (zmbt::mapping::TestDiagnostics)</li> <li>Prototypes (zmbt::reflect::Prototypes)</li> <li>Parametrize (zmbt::mapping::ModelDefinition::T_CustomParam)</li> <li>Pairwise (zmbt::mapping::ModelDefinition::T_Param)</li> <li>Prod (zmbt::mapping::ModelDefinition::T_Param)</li> <li>PostRun (zmbt::mapping::ModelDefinition::T_PostRun)</li> <li>PreRun (zmbt::mapping::ModelDefinition::T_PreRun)</li> </ul>"},{"location":"CxxRef/class_member_functions/#r","title":"r","text":"<ul> <li>ResetFailureHandler (zmbt::Config)</li> <li>RegisterAction (zmbt::Environment)</li> <li>RegisterAnonymousInterface (zmbt::Environment)</li> <li>RegisterAnonymousTrigger (zmbt::Environment)</li> <li>RegisterInterface (zmbt::Environment)</li> <li>RegisterParametricTriggerIfc (zmbt::Environment)</li> <li>RegisterParametricTriggerObj (zmbt::Environment)</li> <li>RegisterTrigger (zmbt::Environment)</li> <li>ResetAll (zmbt::Environment)</li> <li>ResetInterfaceData (zmbt::Environment)</li> <li>RunAction (zmbt::Environment)</li> <li>RunActionNoCatch (zmbt::Environment)</li> <li>RunAsAction (zmbt::Environment::InterfaceHandle)</li> <li>RunAsTrigger (zmbt::Environment::InterfaceHandle)</li> <li>refobj (zmbt::Environment::InterfaceHandle)</li> <li>reset (zmbt::Generator, zmbt::ConversionTime, zmbt::InjectionTime, zmbt::RecordingTime)</li> <li>Record (zmbt::InjectionTable::Record)</li> <li>root (zmbt::JsonNode)</li> <li>root_node (zmbt::JsonNode)</li> <li>report_test_error (zmbt::OutputRecorder)</li> <li>rbegin (zmbt::lang::EncodingView)</li> <li>rend (zmbt::lang::EncodingView)</li> <li>rhs (zmbt::lang::EvalParams)</li> <li>resolve_deferred_params (zmbt::mapping::TestParameterResolver)</li> <li>Run (zmbt::mapping::TestRunner)</li> <li>ret (zmbt::reflect::Prototypes)</li> <li>Registry (zmbt::OutputRecorder::Registry)</li> <li>Return (zmbt::mapping::ModelDefinition::T_Filter)</li> <li>Repeat (zmbt::mapping::ModelDefinition::T_Repeat)</li> </ul>"},{"location":"CxxRef/class_member_functions/#s","title":"s","text":"<ul> <li>SetFailureHandler (zmbt::Config)</li> <li>SetShared (zmbt::Environment)</li> <li>SetTestError (zmbt::Environment)</li> <li>SetVar (zmbt::Environment)</li> <li>step (zmbt::JsonIter, zmbt::JsonProdIter, zmbt::JsonZipIter)</li> <li>size (zmbt::JsonNode, zmbt::lang::Encoding, zmbt::lang::EncodingView)</li> <li>set_max_level (zmbt::Logger)</li> <li>set_notrim (zmbt::Logger)</li> <li>set_pretty_print (zmbt::Logger)</li> <li>set_timestamp (zmbt::Logger)</li> <li>setup_handlers (zmbt::OutputRecorder)</li> <li>stub_delete (zmbt::TriggerObj)</li> <li>stringify (zmbt::decor::precise, zmbt::decor::underlying)</li> <li>str (zmbt::entity_id, zmbt::lang::EvalLog)</li> <li>set (zmbt::TestIsRunning)</li> <li>status (zmbt::TestIsRunning, zmbt::lang::EvalValidator)</li> <li>slice (zmbt::lang::EncodingView)</li> <li>subtree (zmbt::lang::EncodingView)</li> <li>self (zmbt::lang::EvalParams)</li> <li>Subexpression (zmbt::lang::Expression::Subexpression)</li> <li>serialize (zmbt::lang::ExpressionView)</li> <li>subexpressions_list (zmbt::lang::ExpressionView)</li> <li>SignatureBase (zmbt::lang::SignatureBase)</li> <li>signal_path (zmbt::mapping::ChannelHandle)</li> <li>state (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>SignalMapping (zmbt::mapping::SignalMapping)</li> <li>shared_resource (zmbt::shared_resource)</li> </ul>"},{"location":"CxxRef/class_member_functions/#t","title":"t","text":"<ul> <li>TestError (zmbt::Environment)</li> <li>TryLock (zmbt::Environment)</li> <li>TypedInterfaceHandle (zmbt::Environment::TypedInterfaceHandle)</li> <li>to_json (zmbt::ErrorInfo, zmbt::lang::EncodingView, zmbt::lang::ExpressionView, zmbt::mapping::TestDiagnostics)</li> <li>traverse (zmbt::JsonTraverse)</li> <li>Trigger (zmbt::Trigger)</li> <li>TriggerIfc (zmbt::TriggerIfc)</li> <li>TriggerObj (zmbt::TriggerObj)</li> <li>traverse_subtrees (zmbt::lang::EncodingView)</li> <li>to_predicate_if_const (zmbt::lang::Expression)</li> <li>tuple_parameters (zmbt::lang::ExpressionView)</li> <li>transform (zmbt::mapping::ChannelHandle)</li> <li>transit_to (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>type (zmbt::mapping::PipeHandle)</li> <li>TabularConditionFailure (zmbt::mapping::TestDiagnostics)</li> <li>TestDiagnostics (zmbt::mapping::TestDiagnostics)</li> <li>TestRow (zmbt::mapping::TestDiagnostics)</li> <li>TestParameterResolver (zmbt::mapping::TestParameterResolver)</li> <li>TestRunner (zmbt::mapping::TestRunner)</li> <li>to_string (zmbt::object_id)</li> <li>ThreadId (zmbt::mapping::ModelDefinition::T_Filter)</li> <li>Timestamp (zmbt::mapping::ModelDefinition::T_Filter)</li> <li>Take (zmbt::mapping::ModelDefinition::T_Take)</li> <li>Test (zmbt::mapping::ModelDefinition::T_Test)</li> </ul>"},{"location":"CxxRef/class_member_functions/#u","title":"u","text":"<ul> <li>unsafe (zmbt::TriggerObj)</li> <li>underlying (zmbt::decor::underlying)</li> <li>unfold_left_assoc (zmbt::lang::Expression)</li> <li>undecorate (zmbt::lang::Operator)</li> </ul>"},{"location":"CxxRef/class_member_functions/#v","title":"v","text":"<ul> <li>validate_jptr (zmbt::JsonNode)</li> <li>validate (zmbt::decor::precise)</li> <li>validate_str (zmbt::decor::precise)</li> <li>validate_str_as (zmbt::decor::precise)</li> <li>value (zmbt::decor::precise, zmbt::decor::underlying, zmbt::ConversionTime, zmbt::InjectionTime, zmbt::RecordingTime)</li> <li>Vector (zmbt::mapping::TestDiagnostics)</li> </ul>"},{"location":"CxxRef/class_member_functions/#w","title":"w","text":"<ul> <li>WithLevel (zmbt::Logger)</li> <li>WithOutput (zmbt::Logger)</li> <li>WithSrcLoc (zmbt::Logger)</li> </ul>"},{"location":"CxxRef/class_member_functions/#x","title":"x","text":"<ul> <li>x (zmbt::lang::EvalParams)</li> </ul>"},{"location":"CxxRef/class_member_functions/#y","title":"y","text":"<ul> <li>YieldInjection (zmbt::Environment::InterfaceHandle)</li> <li>YieldInjectionArgs (zmbt::Environment::InterfaceHandle)</li> <li>YieldInjectionReturn (zmbt::Environment::InterfaceHandle)</li> <li>yield (zmbt::InjectionTable)</li> </ul>"},{"location":"CxxRef/class_member_functions/#z","title":"z","text":"<ul> <li>Zip (zmbt::mapping::ModelDefinition::T_Param)</li> </ul>"},{"location":"CxxRef/class_member_functions/#_1","title":"~","text":"<ul> <li>~Config (zmbt::Config)</li> <li>~InterfaceHandle (zmbt::Environment::InterfaceHandle)</li> <li>~TypedInterfaceHandle (zmbt::Environment::TypedInterfaceHandle)</li> <li>~Environment (zmbt::Environment)</li> <li>~EnvironmentData (zmbt::EnvironmentData)</li> <li>~Generator (zmbt::Generator)</li> <li>~JsonIter (zmbt::JsonIter)</li> <li>~JsonIterZipProdBase (zmbt::JsonIterZipProdBase)</li> <li>~JsonNode (zmbt::JsonNode)</li> <li>~Logger (zmbt::Logger)</li> <li>~OutputRecorder (zmbt::OutputRecorder)</li> <li>~Param (zmbt::Param)</li> <li>~Trigger (zmbt::Trigger)</li> <li>~TriggerIfc (zmbt::TriggerIfc)</li> <li>~TriggerObj (zmbt::TriggerObj)</li> <li>~ModelTestFixture (zmbt::api::ModelTestFixture)</li> <li>~precise (zmbt::decor::precise)</li> <li>~underlying (zmbt::decor::underlying)</li> <li>~entity_id (zmbt::entity_id)</li> <li>~Expression (zmbt::lang::Expression)</li> <li>~ExpressionView (zmbt::lang::ExpressionView)</li> <li>~LazyParam (zmbt::lang::LazyParam)</li> <li>~Operator (zmbt::lang::Operator)</li> <li>~ChannelHandle (zmbt::mapping::ChannelHandle)</li> <li>~BaseTransition (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>~N_Alias (zmbt::mapping::ModelDefinition::N_Alias)</li> <li>~N_Channel (zmbt::mapping::ModelDefinition::N_Channel)</li> <li>~N_ChannelEnd (zmbt::mapping::ModelDefinition::N_ChannelEnd)</li> <li>~N_Decor (zmbt::mapping::ModelDefinition::N_Decor)</li> <li>~N_Descr (zmbt::mapping::ModelDefinition::N_Descr)</li> <li>~N_Filter (zmbt::mapping::ModelDefinition::N_Filter)</li> <li>~N_Main (zmbt::mapping::ModelDefinition::N_Main)</li> <li>~N_MaybeChannel (zmbt::mapping::ModelDefinition::N_MaybeChannel)</li> <li>~N_Param (zmbt::mapping::ModelDefinition::N_Param)</li> <li>~N_ParamTable (zmbt::mapping::ModelDefinition::N_ParamTable)</li> <li>~N_Post (zmbt::mapping::ModelDefinition::N_Post)</li> <li>~N_Pre (zmbt::mapping::ModelDefinition::N_Pre)</li> <li>~N_Repeat (zmbt::mapping::ModelDefinition::N_Repeat)</li> <li>~N_Take (zmbt::mapping::ModelDefinition::N_Take)</li> <li>~N_Term (zmbt::mapping::ModelDefinition::N_Term)</li> <li>~N_Test (zmbt::mapping::ModelDefinition::N_Test)</li> <li>~N_TestTable (zmbt::mapping::ModelDefinition::N_TestTable)</li> <li>~PipeHandle (zmbt::mapping::PipeHandle)</li> <li>~SignalMapping (zmbt::mapping::SignalMapping)</li> <li>~TestDiagnostics (zmbt::mapping::TestDiagnostics)</li> <li>~TestRunner (zmbt::mapping::TestRunner)</li> <li>~shared_resource (zmbt::shared_resource)</li> <li>~Registry (zmbt::OutputRecorder::Registry)</li> </ul>"},{"location":"CxxRef/class_member_variables/","title":"Class Member Variables","text":""},{"location":"CxxRef/class_member_variables/#a","title":"a","text":"<ul> <li>args_ (zmbt::InjectionTable, zmbt::reflect::Prototypes)</li> <li>annotation_ (zmbt::entity_id)</li> <li>args (zmbt::OutputRecorder::Registry::FrameBuffs)</li> <li>annotation (zmbt::lang::Operator::Handle)</li> <li>arithmetics (zmbt::lang::Operator::Handle)</li> <li>add (zmbt::lang::Operator::Handle::Handle)</li> <li>and_ (zmbt::lang::Operator::Handle::Handle, zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#b","title":"b","text":"<ul> <li>begins_ (zmbt::JsonIterZipProdBase)</li> <li>bitwise (zmbt::lang::Operator::Handle)</li> <li>bool_ (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#c","title":"c","text":"<ul> <li>config_ (zmbt::Config)</li> <li>callbacks (zmbt::EnvironmentData)</li> <li>context (zmbt::ErrorInfo)</li> <li>counter_ (zmbt::Generator)</li> <li>captures (zmbt::lang::EvalContext)</li> <li>curr_ctx_ (zmbt::lang::EvalImplBase)</li> <li>ctx_ (zmbt::lang::EvalParams)</li> <li>const_predicate_cache_ (zmbt::lang::ExpressionView)</li> <li>cache_ (zmbt::lang::LazyParam)</li> <li>channels_ (zmbt::mapping::PipeHandle)</li> <li>channel_id (zmbt::mapping::TestDiagnostics)</li> <li>comment (zmbt::mapping::TestDiagnostics)</li> <li>count (zmbt::OutputRecorder::Registry)</li> <li>comp (zmbt::lang::Operator::Handle)</li> <li>compl_ (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#d","title":"d","text":"<ul> <li>data_ (zmbt::Environment, zmbt::lang::EncodingView, zmbt::mapping::ChannelHandle, zmbt::mapping::PipeHandle)</li> <li>data (zmbt::OutputRecorder::Frame, zmbt::lang::Encoding, zmbt::lang::EncodingView::ExprRow)</li> <li>default_objects (zmbt::PermanentEnvData)</li> <li>depth (zmbt::lang::Encoding, zmbt::lang::EncodingView::ExprRow, zmbt::lang::EvalContext)</li> <li>depth_ (zmbt::lang::EncodingView)</li> <li>d_ (zmbt::lang::EncodingView::Iterator)</li> <li>description (zmbt::mapping::TestDiagnostics)</li> <li>data_typeid (zmbt::OutputRecorder::Registry)</li> <li>decor (zmbt::lang::Operator::Handle)</li> <li>div (zmbt::lang::Operator::Handle::Handle)</li> <li>decorate (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#e","title":"e","text":"<ul> <li>env (zmbt::Environment::InterfaceHandle, zmbt::mapping::ChannelHandle, zmbt::mapping::PipeHandle, zmbt::mapping::TestParameterResolver)</li> <li>error_or_return (zmbt::ErrorOr)</li> <li>expr_ (zmbt::Generator)</li> <li>exception_ (zmbt::InjectionTable)</li> <li>ends_ (zmbt::JsonIterZipProdBase)</li> <li>encoding_ (zmbt::lang::Expression)</li> <li>ev_ (zmbt::lang::Expression::Subexpression)</li> <li>encoding_view_ (zmbt::lang::ExpressionView)</li> <li>error (zmbt::mapping::TestDiagnostics)</li> <li>eval_stack (zmbt::mapping::TestDiagnostics)</li> <li>expected (zmbt::mapping::TestDiagnostics)</li> <li>enable_categories_ (zmbt::OutputRecorder::Registry)</li> <li>extract_fn (zmbt::OutputRecorder::Registry)</li> <li>err (zmbt::OutputRecorder::Registry::FrameBuffs)</li> <li>equal_to (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#f","title":"f","text":"<ul> <li>fn_ (zmbt::TriggerIfc)</li> <li>flip (zmbt::lang::ExpressionGrammar)</li> <li>fork (zmbt::lang::ExpressionGrammar)</li> <li>failure_handler (zmbt::Config::PersistentConfig)</li> <li>frame_buff_map (zmbt::OutputRecorder::Registry)</li> </ul>"},{"location":"CxxRef/class_member_variables/#g","title":"g","text":"<ul> <li>generator (zmbt::InjectionTable::Record)</li> <li>getter_ (zmbt::lang::LazyParam)</li> </ul>"},{"location":"CxxRef/class_member_variables/#h","title":"h","text":"<ul> <li>has_test_error (zmbt::EnvironmentData)</li> <li>halt_ (zmbt::JsonIterZipProdBase)</li> <li>hash_ (zmbt::entity_id)</li> <li>handle_ (zmbt::lang::Operator)</li> </ul>"},{"location":"CxxRef/class_member_variables/#i","title":"i","text":"<ul> <li>interface_ (zmbt::Environment::InterfaceHandle)</li> <li>injection_tables (zmbt::EnvironmentData)</li> <li>ifc_id_ (zmbt::InjectionTable, zmbt::OutputRecorder)</li> <li>its_ (zmbt::JsonIterZipProdBase)</li> <li>ifc_ (zmbt::Trigger)</li> <li>id_ (zmbt::TriggerIfc, zmbt::TriggerObj)</li> <li>is_unsafe_ptr_ (zmbt::TriggerObj)</li> <li>index_offset_ (zmbt::lang::EncodingView, zmbt::lang::EncodingView::Iterator)</li> <li>index (zmbt::lang::EncodingView::ExprRow)</li> <li>i_ (zmbt::lang::EncodingView::Iterator)</li> <li>iterators_ (zmbt::mapping::TestParameterResolver)</li> <li>impl_ (zmbt::mapping::TestRunner)</li> <li>interface_name (zmbt::OutputRecorder::Registry)</li> </ul>"},{"location":"CxxRef/class_member_variables/#j","title":"j","text":"<ul> <li>json_data (zmbt::EnvironmentData)</li> <li>jptr (zmbt::InjectionTable::Record)</li> </ul>"},{"location":"CxxRef/class_member_variables/#k","title":"k","text":"<ul> <li>key_ (zmbt::entity_id)</li> <li>keywords (zmbt::lang::Encoding)</li> <li>keywords_ (zmbt::lang::EncodingView)</li> <li>keyword (zmbt::lang::EncodingView::ExprRow, zmbt::lang::ExpressionGrammar)</li> <li>k_ (zmbt::lang::EncodingView::Iterator)</li> <li>keyword_symbol (zmbt::lang::KeywordGrammar)</li> </ul>"},{"location":"CxxRef/class_member_variables/#l","title":"l","text":"<ul> <li>level_ (zmbt::Logger)</li> <li>links (zmbt::lang::EvalContext)</li> <li>log (zmbt::lang::EvalContext)</li> <li>lhs_ (zmbt::lang::EvalParams)</li> <li>lhs_maybe_owned_ (zmbt::lang::EvalParams)</li> <li>link (zmbt::lang::ExpressionGrammar)</li> <li>lost_count (zmbt::OutputRecorder::Registry)</li> <li>logic (zmbt::lang::Operator::Handle)</li> <li>less (zmbt::lang::Operator::Handle::Handle)</li> <li>less_equal (zmbt::lang::Operator::Handle::Handle)</li> <li>left (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#m","title":"m","text":"<ul> <li>mutex (zmbt::EnvironmentData)</li> <li>maybe_constant_args_ (zmbt::InjectionTable)</li> <li>maybe_constant_exception_ (zmbt::InjectionTable)</li> <li>maybe_constant_ret_ (zmbt::InjectionTable)</li> <li>maybe_constant (zmbt::InjectionTable::Record)</li> <li>mapping_ (zmbt::mapping::ModelDefinition::BaseTransition)</li> <li>message (zmbt::mapping::TestDiagnostics)</li> <li>model_name (zmbt::mapping::TestDiagnostics)</li> <li>model_ (zmbt::mapping::TestParameterResolver)</li> <li>mod (zmbt::lang::Operator::Handle::Handle)</li> <li>mul (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#n","title":"n","text":"<ul> <li>node_ptr_ (zmbt::JsonNode)</li> <li>nested_fork (zmbt::lang::ExpressionGrammar)</li> <li>nested_link (zmbt::lang::ExpressionGrammar)</li> <li>nested_pipe (zmbt::lang::ExpressionGrammar)</li> <li>nested_tuple (zmbt::lang::ExpressionGrammar)</li> <li>neg (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#o","title":"o","text":"<ul> <li>output_recorder_ (zmbt::Environment::InterfaceHandle, zmbt::Trigger)</li> <li>output_recorders (zmbt::EnvironmentData)</li> <li>obj_id_ (zmbt::InjectionTable, zmbt::OutputRecorder)</li> <li>owned_sequences_ (zmbt::JsonIterZipProdBase)</li> <li>output_ (zmbt::Logger)</li> <li>output_recorder_factories (zmbt::PermanentEnvData)</li> <li>obj_ (zmbt::Trigger)</li> <li>op (zmbt::lang::EvalContext)</li> <li>observed (zmbt::mapping::TestDiagnostics)</li> <li>or_ (zmbt::lang::Operator::Handle::Handle, zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#p","title":"p","text":"<ul> <li>permanent_data_ (zmbt::Environment)</li> <li>prototypes_ (zmbt::InjectionTable)</li> <li>payload_cache_ (zmbt::Logger)</li> <li>prototypes (zmbt::PermanentEnvData)</li> <li>ptr_ (zmbt::TriggerObj, zmbt::shared_resource)</li> <li>parameters (zmbt::lang::ExpressionGrammar)</li> <li>pipe (zmbt::lang::ExpressionGrammar)</li> <li>pipe_id (zmbt::mapping::TestDiagnostics)</li> </ul>"},{"location":"CxxRef/class_member_variables/#r","title":"r","text":"<ul> <li>refobj_ (zmbt::Environment::InterfaceHandle)</li> <li>ret_ (zmbt::InjectionTable)</li> <li>root_ (zmbt::JsonNode)</li> <li>registry_ (zmbt::OutputRecorder)</li> <li>rhs_ (zmbt::lang::EvalParams)</li> <li>rhs_maybe_owned_ (zmbt::lang::EvalParams)</li> <li>result (zmbt::mapping::TestDiagnostics)</li> <li>return_ (zmbt::reflect::Prototypes)</li> <li>ret (zmbt::OutputRecorder::Registry::FrameBuffs)</li> <li>right (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#s","title":"s","text":"<ul> <li>shared (zmbt::EnvironmentData)</li> <li>src_loc_ (zmbt::Logger)</li> <li>str_ (zmbt::entity_id)</li> <li>size_ (zmbt::lang::EncodingView)</li> <li>stack (zmbt::lang::EvalLog)</li> <li>self_ (zmbt::lang::EvalParams)</li> <li>start (zmbt::lang::ExpressionGrammar, zmbt::lang::KeywordGrammar)</li> <li>subexpr (zmbt::lang::ExpressionGrammar)</li> <li>should_flatten_ (zmbt::mapping::PipeHandle)</li> <li>serialized_frames (zmbt::OutputRecorder::Registry)</li> <li>shift (zmbt::lang::Operator::Handle)</li> <li>sub (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#t","title":"t","text":"<ul> <li>trigger_ifcs (zmbt::EnvironmentData)</li> <li>trigger_objs (zmbt::EnvironmentData)</li> <li>triggers (zmbt::EnvironmentData)</li> <li>type (zmbt::ErrorInfo)</li> <li>transform (zmbt::InjectionTable::Record)</li> <li>timestamp_ (zmbt::Logger)</li> <li>ts (zmbt::OutputRecorder::Frame)</li> <li>type_index_hash_ (zmbt::entity_id)</li> <li>tuple (zmbt::lang::ExpressionGrammar)</li> <li>tabular_condition_failure_ (zmbt::mapping::TestDiagnostics)</li> <li>tc (zmbt::mapping::TestDiagnostics)</li> <li>tr (zmbt::mapping::TestDiagnostics)</li> </ul>"},{"location":"CxxRef/class_member_variables/#u","title":"u","text":"<ul> <li>undecorate (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_variables/#v","title":"v","text":"<ul> <li>visit_ (zmbt::JsonTraverse)</li> <li>value_ (zmbt::Param, zmbt::decor::precise, zmbt::decor::underlying)</li> <li>v_ (zmbt::lang::EncodingView::Iterator)</li> <li>vector (zmbt::mapping::TestDiagnostics)</li> </ul>"},{"location":"CxxRef/class_member_variables/#w","title":"w","text":"<ul> <li>what (zmbt::ErrorInfo)</li> </ul>"},{"location":"CxxRef/class_member_variables/#x","title":"x","text":"<ul> <li>x_ (zmbt::lang::EvalParams)</li> <li>xor_ (zmbt::lang::Operator::Handle::Handle)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"CxxRef/class_member_typedefs/#a","title":"a","text":"<ul> <li>argsref_t (zmbt::Environment)</li> <li>args_t (zmbt::Environment::TypedInterfaceHandle, zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#b","title":"b","text":"<ul> <li>binary_transform (zmbt::lang::Operator)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#c","title":"c","text":"<ul> <li>const_iterator (zmbt::lang::EncodingView)</li> <li>const_reverse_iterator (zmbt::lang::EncodingView)</li> <li>ConditionPipe (zmbt::mapping::ChannelHandle)</li> <li>consume_fn_t (zmbt::OutputRecorder::Registry)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#d","title":"d","text":"<ul> <li>decorated_type (zmbt::decor::precise, zmbt::decor::underlying)</li> <li>difference_type (zmbt::lang::EncodingView::Iterator)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#e","title":"e","text":"<ul> <li>E (zmbt::lang::SignatureVariadic)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#f","title":"f","text":"<ul> <li>FailureHandler (zmbt::Config, zmbt::EnvironmentData)</li> <li>FramesBuffMap (zmbt::OutputRecorder::Registry)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#h","title":"h","text":"<ul> <li>hookout_args_t (zmbt::Environment, zmbt::Environment::TypedInterfaceHandle)</li> <li>host_t (zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#i","title":"i","text":"<ul> <li>iterator (zmbt::lang::EncodingView)</li> <li>iterator_category (zmbt::lang::EncodingView::Iterator)</li> <li>is_not_ptr (zmbt::object_id)</li> <li>is_ptr (zmbt::object_id)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#k","title":"k","text":"<ul> <li>K (zmbt::lang::Encoding, zmbt::lang::EncodingView)</li> <li>Keyword (zmbt::lang::ExpressionView)</li> <li>Kind (zmbt::mapping::ChannelHandle)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#l","title":"l","text":"<ul> <li>lock_t (zmbt::Environment, zmbt::EnvironmentData)</li> <li>LV (zmbt::lang::Operator)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#m","title":"m","text":"<ul> <li>mutex_t (zmbt::EnvironmentData)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#p","title":"p","text":"<ul> <li>pointer (zmbt::lang::EncodingView::Iterator)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#r","title":"r","text":"<ul> <li>return_t (zmbt::Environment, zmbt::Environment::TypedInterfaceHandle, zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;)</li> <li>rvref_to_val (zmbt::Environment)</li> <li>reflection (zmbt::Environment::TypedInterfaceHandle)</li> <li>return_or_nullptr_t (zmbt::Environment::TypedInterfaceHandle)</li> <li>rvalue_reference_to_value (zmbt::Environment::TypedInterfaceHandle)</li> <li>reverse_iterator (zmbt::lang::EncodingView)</li> <li>reference (zmbt::lang::EncodingView::Iterator)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#s","title":"s","text":"<ul> <li>shared_data_record (zmbt::EnvironmentData)</li> <li>shared_data_table (zmbt::EnvironmentData)</li> <li>Shared (zmbt::Generator)</li> <li>SetupOutputRecorder (zmbt::PermanentEnvData)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#t","title":"t","text":"<ul> <li>type (zmbt::ifc_args, zmbt::ifc_handle, zmbt::ifc_host, zmbt::ifc_pointer, zmbt::ifc_return, zmbt::reflect::default_invocation&lt; S, first_if_any_t&lt; void, ifc_is_fn_handle&lt; S &gt;, ifc_is_functor_ref&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_functor_ptr&lt; S &gt; &gt; &gt;, zmbt::reflect::default_invocation&lt; S, first_if_t&lt; void, ifc_is_member_handle&lt; S &gt; &gt; &gt;, zmbt::type_tag)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#u","title":"u","text":"<ul> <li>unqf_args_t (zmbt::Environment, zmbt::Environment::TypedInterfaceHandle)</li> <li>unary_transform (zmbt::lang::Operator)</li> </ul>"},{"location":"CxxRef/class_member_typedefs/#v","title":"v","text":"<ul> <li>variant_t (zmbt::ErrorOr)</li> <li>visitor_fn (zmbt::JsonTraverse)</li> <li>V (zmbt::lang::Encoding, zmbt::lang::EncodingView, zmbt::lang::ExpressionView, zmbt::lang::LazyParam, zmbt::lang::Operator)</li> <li>value_type (zmbt::lang::EncodingView::Iterator)</li> </ul>"},{"location":"CxxRef/class_member_enums/","title":"Class Member Enums","text":""},{"location":"CxxRef/class_member_enums/#c","title":"c","text":"<ul> <li>Config (zmbt::lang::Operator)</li> </ul>"},{"location":"CxxRef/class_member_enums/#l","title":"l","text":"<ul> <li>Level (zmbt::Logger)</li> </ul>"},{"location":"CxxRef/class_member_enums/#o","title":"o","text":"<ul> <li>Output (zmbt::Logger)</li> </ul>"},{"location":"CxxRef/class_member_enums/#r","title":"r","text":"<ul> <li>Result (zmbt::mapping::TestDiagnostics)</li> </ul>"},{"location":"CxxRef/namespace_members/","title":"Namespace Members","text":""},{"location":"CxxRef/namespace_members/#a","title":"a","text":"<ul> <li>add_const (zmbt)</li> <li>add_const_t (zmbt)</li> <li>add_cv (zmbt)</li> <li>add_cv_t (zmbt)</li> <li>add_lvalue_reference (zmbt)</li> <li>add_lvalue_reference_t (zmbt)</li> <li>add_pointer (zmbt)</li> <li>add_pointer_t (zmbt)</li> <li>add_rvalue_reference (zmbt)</li> <li>add_rvalue_reference_t (zmbt)</li> <li>add_volatile (zmbt)</li> <li>add_volatile_t (zmbt)</li> <li>Abs (zmbt::expr)</li> <li>Acos (zmbt::expr)</li> <li>Acosh (zmbt::expr)</li> <li>Add (zmbt::expr)</li> <li>All (zmbt::expr)</li> <li>And (zmbt::expr)</li> <li>Any (zmbt::expr)</li> <li>Approx (zmbt::expr)</li> <li>Arange (zmbt::expr)</li> <li>Argmax (zmbt::expr)</li> <li>Argmin (zmbt::expr)</li> <li>Asin (zmbt::expr)</li> <li>Asinh (zmbt::expr)</li> <li>Assert (zmbt::expr)</li> <li>At (zmbt::expr)</li> <li>Atan (zmbt::expr)</li> <li>Atanh (zmbt::expr)</li> <li>Avg (zmbt::expr)</li> <li>attributes (zmbt::lang)</li> </ul>"},{"location":"CxxRef/namespace_members/#b","title":"b","text":"<ul> <li>bool_constant (zmbt)</li> <li>Bind (zmbt::expr)</li> <li>BitAnd (zmbt::expr)</li> <li>BitNot (zmbt::expr)</li> <li>BitOr (zmbt::expr)</li> <li>BitXor (zmbt::expr)</li> <li>Bool (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#c","title":"c","text":"<ul> <li>ChannelKind (zmbt)</li> <li>common_type (zmbt)</li> <li>common_type_t (zmbt)</li> <li>conditional (zmbt)</li> <li>conditional_t (zmbt)</li> <li>construct_or_default (zmbt)</li> <li>convert_tuple_to (zmbt)</li> <li>C (zmbt::expr)</li> <li>Capitalize (zmbt::expr)</li> <li>Card (zmbt::expr)</li> <li>Cartesian (zmbt::expr)</li> <li>Cast (zmbt::expr)</li> <li>Cat (zmbt::expr)</li> <li>Ceil (zmbt::expr)</li> <li>Chunks (zmbt::expr)</li> <li>Concat (zmbt::expr)</li> <li>Const (zmbt::expr)</li> <li>Contains (zmbt::expr)</li> <li>Cos (zmbt::expr)</li> <li>Cosh (zmbt::expr)</li> <li>Count (zmbt::expr)</li> <li>custom_initialization (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/namespace_members/#d","title":"d","text":"<ul> <li>decay (zmbt)</li> <li>decay_t (zmbt)</li> <li>default_test_failure (zmbt)</li> <li>dejsonize (zmbt)</li> <li>dejsonize&lt; void &gt; (zmbt)</li> <li>dejsonize_array (zmbt)</li> <li>D (zmbt::expr)</li> <li>Dbg (zmbt::expr)</li> <li>Debug (zmbt::expr)</li> <li>Decorate (zmbt::expr)</li> <li>Default (zmbt::expr)</li> <li>Del (zmbt::expr)</li> <li>Delete (zmbt::expr)</li> <li>Diff (zmbt::expr)</li> <li>Div (zmbt::expr)</li> <li>dispatch_eval (zmbt::lang)</li> </ul>"},{"location":"CxxRef/namespace_members/#e","title":"e","text":"<ul> <li>emplace_shared (zmbt)</li> <li>E (zmbt::expr)</li> <li>Each (zmbt::expr)</li> <li>Enumerate (zmbt::expr)</li> <li>Eps (zmbt::expr)</li> <li>Eq (zmbt::expr)</li> <li>Erf (zmbt::expr)</li> <li>Erfc (zmbt::expr)</li> <li>Err (zmbt::expr)</li> <li>Error (zmbt::expr)</li> <li>Eval (zmbt::expr)</li> <li>Exp (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#f","title":"f","text":"<ul> <li>FileFormat (zmbt)</li> <li>first_if_any_t (zmbt)</li> <li>first_if_none_t (zmbt)</li> <li>first_if_t (zmbt)</li> <li>format (zmbt)</li> <li>format_failure_report (zmbt)</li> <li>False (zmbt::expr)</li> <li>Falsy (zmbt::expr)</li> <li>Filter (zmbt::expr)</li> <li>Find (zmbt::expr)</li> <li>FindIdx (zmbt::expr)</li> <li>FindPtr (zmbt::expr)</li> <li>First (zmbt::expr)</li> <li>Flatten (zmbt::expr)</li> <li>Flip (zmbt::expr)</li> <li>Floor (zmbt::expr)</li> <li>Fmt (zmbt::expr)</li> <li>Fn (zmbt::expr)</li> <li>Fold (zmbt::expr)</li> <li>Fork (zmbt::expr)</li> <li>Format (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#g","title":"g","text":"<ul> <li>get_ifc_handle (zmbt)</li> <li>get_ifc_pointer (zmbt)</li> <li>get_tid (zmbt)</li> <li>get_ts (zmbt)</li> <li>Gamma (zmbt::expr)</li> <li>Ge (zmbt::expr)</li> <li>Gt (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#h","title":"h","text":"<ul> <li>has_virtual_destructor (zmbt)</li> <li>has_virtual_destructor_v (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_members/#i","title":"i","text":"<ul> <li>InitZmbt (zmbt)</li> <li>InterfaceRecord (zmbt, zmbt::api)</li> <li>ifc_args_t (zmbt)</li> <li>ifc_handle_t (zmbt)</li> <li>ifc_host_nullptr (zmbt)</li> <li>ifc_host_t (zmbt)</li> <li>ifc_is_fn_handle (zmbt)</li> <li>ifc_is_fn_ptr (zmbt)</li> <li>ifc_is_fn_ref (zmbt)</li> <li>ifc_is_functor_handle (zmbt)</li> <li>ifc_is_functor_ptr (zmbt)</li> <li>ifc_is_functor_ref (zmbt)</li> <li>ifc_is_member_handle (zmbt)</li> <li>ifc_is_pmd_handle (zmbt)</li> <li>ifc_is_pmf_handle (zmbt)</li> <li>ifc_pointer_t (zmbt)</li> <li>ifc_return_t (zmbt)</li> <li>indexator_for (zmbt)</li> <li>integral_constant (zmbt)</li> <li>is_abstract (zmbt)</li> <li>is_abstract_v (zmbt)</li> <li>is_arithmetic (zmbt)</li> <li>is_arithmetic_v (zmbt)</li> <li>is_array (zmbt)</li> <li>is_array_v (zmbt)</li> <li>is_assignable (zmbt)</li> <li>is_assignable_v (zmbt)</li> <li>is_base_of (zmbt)</li> <li>is_base_of_v (zmbt)</li> <li>is_class (zmbt)</li> <li>is_class_v (zmbt)</li> <li>is_compound (zmbt)</li> <li>is_compound_v (zmbt)</li> <li>is_const (zmbt, zmbt::lang::attr)</li> <li>is_const_v (zmbt)</li> <li>is_constructible (zmbt)</li> <li>is_convertible (zmbt)</li> <li>is_convertible_v (zmbt)</li> <li>is_copy_assignable (zmbt)</li> <li>is_copy_assignable_v (zmbt)</li> <li>is_copy_constructible (zmbt)</li> <li>is_copy_constructible_v (zmbt)</li> <li>is_default_constructible (zmbt)</li> <li>is_default_constructible_v (zmbt)</li> <li>is_destructible (zmbt)</li> <li>is_destructible_v (zmbt)</li> <li>is_empty (zmbt)</li> <li>is_empty_v (zmbt)</li> <li>is_enum (zmbt)</li> <li>is_enum_v (zmbt)</li> <li>is_final (zmbt)</li> <li>is_final_v (zmbt)</li> <li>is_floating_point (zmbt)</li> <li>is_floating_point_v (zmbt)</li> <li>is_function (zmbt)</li> <li>is_function_v (zmbt)</li> <li>is_fundamental (zmbt)</li> <li>is_fundamental_v (zmbt)</li> <li>is_ifc_handle (zmbt)</li> <li>is_integral (zmbt)</li> <li>is_integral_v (zmbt)</li> <li>is_lvalue_reference (zmbt)</li> <li>is_lvalue_reference_v (zmbt)</li> <li>is_member_function_pointer (zmbt)</li> <li>is_member_function_pointer_v (zmbt)</li> <li>is_member_object_pointer (zmbt)</li> <li>is_member_object_pointer_v (zmbt)</li> <li>is_member_pointer (zmbt)</li> <li>is_member_pointer_v (zmbt)</li> <li>is_move_assignable (zmbt)</li> <li>is_move_assignable_v (zmbt)</li> <li>is_move_constructible (zmbt)</li> <li>is_move_constructible_v (zmbt)</li> <li>is_nothrow_assignable (zmbt)</li> <li>is_nothrow_assignable_v (zmbt)</li> <li>is_nothrow_constructible (zmbt)</li> <li>is_nothrow_copy_assignable (zmbt)</li> <li>is_nothrow_copy_assignable_v (zmbt)</li> <li>is_nothrow_copy_constructible (zmbt)</li> <li>is_nothrow_copy_constructible_v (zmbt)</li> <li>is_nothrow_default_constructible (zmbt)</li> <li>is_nothrow_default_constructible_v (zmbt)</li> <li>is_nothrow_destructible (zmbt)</li> <li>is_nothrow_destructible_v (zmbt)</li> <li>is_nothrow_move_assignable (zmbt)</li> <li>is_nothrow_move_assignable_v (zmbt)</li> <li>is_nothrow_move_constructible (zmbt)</li> <li>is_nothrow_move_constructible_v (zmbt)</li> <li>is_null_pointer (zmbt)</li> <li>is_null_pointer_v (zmbt)</li> <li>is_object (zmbt)</li> <li>is_object_v (zmbt)</li> <li>is_pointer (zmbt)</li> <li>is_pointer_v (zmbt)</li> <li>is_polymorphic (zmbt)</li> <li>is_polymorphic_v (zmbt)</li> <li>is_reference (zmbt)</li> <li>is_reference_v (zmbt)</li> <li>is_rvalue_reference (zmbt)</li> <li>is_rvalue_reference_v (zmbt)</li> <li>is_same (zmbt)</li> <li>is_same_v (zmbt)</li> <li>is_scalar (zmbt)</li> <li>is_scalar_v (zmbt)</li> <li>is_signed (zmbt)</li> <li>is_signed_v (zmbt)</li> <li>is_standard_layout (zmbt)</li> <li>is_standard_layout_v (zmbt)</li> <li>is_trivial (zmbt)</li> <li>is_trivial_v (zmbt)</li> <li>is_trivially_assignable (zmbt)</li> <li>is_trivially_assignable_v (zmbt)</li> <li>is_trivially_constructible (zmbt)</li> <li>is_trivially_copy_assignable (zmbt)</li> <li>is_trivially_copy_assignable_v (zmbt)</li> <li>is_trivially_copy_constructible (zmbt)</li> <li>is_trivially_copy_constructible_v (zmbt)</li> <li>is_trivially_copyable (zmbt)</li> <li>is_trivially_copyable_v (zmbt)</li> <li>is_trivially_default_constructible (zmbt)</li> <li>is_trivially_default_constructible_v (zmbt)</li> <li>is_trivially_destructible (zmbt)</li> <li>is_trivially_destructible_v (zmbt)</li> <li>is_trivially_move_assignable (zmbt)</li> <li>is_trivially_move_assignable_v (zmbt)</li> <li>is_trivially_move_constructible (zmbt)</li> <li>is_trivially_move_constructible_v (zmbt)</li> <li>is_tuple (zmbt)</li> <li>is_type_tag (zmbt)</li> <li>is_union (zmbt)</li> <li>is_union_v (zmbt)</li> <li>is_unsigned (zmbt)</li> <li>is_unsigned_v (zmbt)</li> <li>is_void (zmbt)</li> <li>is_void_v (zmbt)</li> <li>is_volatile (zmbt)</li> <li>is_volatile_v (zmbt)</li> <li>Id (zmbt::expr)</li> <li>In (zmbt::expr)</li> <li>Inf (zmbt::expr)</li> <li>Intersect (zmbt::expr)</li> <li>IsErr (zmbt::expr)</li> <li>Iserror (zmbt::expr)</li> <li>Items (zmbt::expr)</li> <li>is_autogen (zmbt::lang::attr)</li> <li>is_binary (zmbt::lang::attr)</li> <li>is_error (zmbt::lang::attr)</li> <li>is_fork (zmbt::lang::attr)</li> <li>is_hiord (zmbt::lang::attr)</li> <li>is_infix_chain (zmbt::lang::attr)</li> <li>is_literal (zmbt::lang::attr)</li> <li>is_noop (zmbt::lang::attr)</li> <li>is_operator (zmbt::lang::attr)</li> <li>is_overload (zmbt::lang::attr)</li> <li>is_pipe (zmbt::lang::attr)</li> <li>is_predicate (zmbt::lang::attr)</li> <li>is_preproc (zmbt::lang::attr)</li> <li>is_quote (zmbt::lang::attr)</li> <li>is_unary (zmbt::lang::attr)</li> <li>is_variadic (zmbt::lang::attr)</li> <li>init_tuple (zmbt::reflect)</li> <li>init_value (zmbt::reflect)</li> <li>initialization (zmbt::reflect)</li> <li>interface_t (zmbt::reflect)</li> <li>invocation_args_t (zmbt::reflect)</li> <li>invocation_args_unqf_t (zmbt::reflect)</li> <li>invocation_has_void_args (zmbt::reflect)</li> <li>invocation_has_void_ret (zmbt::reflect)</li> <li>invocation_host_t (zmbt::reflect)</li> <li>invocation_ret_t (zmbt::reflect)</li> <li>invocation_ret_unqf_or_nullptr_t (zmbt::reflect)</li> <li>invocation_ret_unqf_t (zmbt::reflect)</li> <li>invocation_unqf_host_t (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/namespace_members/#j","title":"j","text":"<ul> <li>js_array_slice_const_gen (zmbt)</li> <li>js_array_slice_gen (zmbt)</li> <li>js_string_slice_gen (zmbt)</li> <li>json_from (zmbt)</li> <li>json_from_array (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_members/#k","title":"k","text":"<ul> <li>Keys (zmbt::expr)</li> <li>Kwrd (zmbt::expr)</li> <li>Keyword (zmbt::lang)</li> <li>keyword_to_str (zmbt::lang)</li> </ul>"},{"location":"CxxRef/namespace_members/#l","title":"l","text":"<ul> <li>Last (zmbt::expr)</li> <li>Le (zmbt::expr)</li> <li>Link (zmbt::expr)</li> <li>Log (zmbt::expr)</li> <li>Lookup (zmbt::expr)</li> <li>LowerCase (zmbt::expr)</li> <li>Lshift (zmbt::expr)</li> <li>Lt (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#m","title":"m","text":"<ul> <li>make_signed (zmbt)</li> <li>make_signed_t (zmbt)</li> <li>make_slice_const_generator (zmbt)</li> <li>make_slice_generator (zmbt)</li> <li>make_unsigned (zmbt)</li> <li>make_unsigned_t (zmbt)</li> <li>maybe_real_to_number (zmbt)</li> <li>maybe_real_to_number_inplace (zmbt)</li> <li>Map (zmbt::expr)</li> <li>Max (zmbt::expr)</li> <li>Min (zmbt::expr)</li> <li>Mod (zmbt::expr)</li> <li>Mul (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#n","title":"n","text":"<ul> <li>NaN (zmbt::expr)</li> <li>Ne (zmbt::expr)</li> <li>Near (zmbt::expr)</li> <li>Neg (zmbt::expr)</li> <li>Ni (zmbt::expr)</li> <li>Nil (zmbt::expr)</li> <li>Noop (zmbt::expr)</li> <li>Not (zmbt::expr)</li> <li>NotIn (zmbt::expr)</li> <li>NotNi (zmbt::expr)</li> <li>Null (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#o","title":"o","text":"<ul> <li>Op (zmbt::expr)</li> <li>Or (zmbt::expr)</li> <li>Overload (zmbt::expr)</li> <li>operator&lt;&lt; (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/namespace_members/#p","title":"p","text":"<ul> <li>param_transform (zmbt)</li> <li>pretty_print (zmbt)</li> <li>Precise (zmbt::decor)</li> <li>PSubset (zmbt::expr)</li> <li>PSuperset (zmbt::expr)</li> <li>Parameters (zmbt::expr)</li> <li>Parse (zmbt::expr)</li> <li>Pi (zmbt::expr)</li> <li>Pipe (zmbt::expr)</li> <li>Pow (zmbt::expr)</li> <li>PreProc (zmbt::expr)</li> <li>Prms (zmbt::expr)</li> <li>Prod (zmbt::expr)</li> <li>Push (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#q","title":"q","text":"<ul> <li>Q (zmbt::expr)</li> <li>Quot (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#r","title":"r","text":"<ul> <li>real_to_number (zmbt)</li> <li>remove_const (zmbt)</li> <li>remove_const_t (zmbt)</li> <li>remove_cv (zmbt)</li> <li>remove_cv_t (zmbt)</li> <li>remove_cvptr_t (zmbt)</li> <li>remove_cvref_t (zmbt)</li> <li>remove_pointer (zmbt)</li> <li>remove_pointer_t (zmbt)</li> <li>remove_reference (zmbt)</li> <li>remove_reference_t (zmbt)</li> <li>remove_volatile (zmbt)</li> <li>remove_volatile_t (zmbt)</li> <li>require_cal (zmbt)</li> <li>require_json_from (zmbt)</li> <li>require_literal (zmbt)</li> <li>require_no_json_from (zmbt)</li> <li>require_not_cal (zmbt)</li> <li>require_not_str (zmbt)</li> <li>require_obj (zmbt)</li> <li>require_str (zmbt)</li> <li>Re (zmbt::expr)</li> <li>Recur (zmbt::expr)</li> <li>Reduce (zmbt::expr)</li> <li>Regex (zmbt::expr)</li> <li>Repeat (zmbt::expr)</li> <li>Reverse (zmbt::expr)</li> <li>Round (zmbt::expr)</li> <li>Rshift (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#s","title":"s","text":"<ul> <li>slice (zmbt)</li> <li>Saturate (zmbt::expr)</li> <li>Serialize (zmbt::expr)</li> <li>SetEq (zmbt::expr)</li> <li>Sign (zmbt::expr)</li> <li>Sin (zmbt::expr)</li> <li>Sinh (zmbt::expr)</li> <li>Size (zmbt::expr)</li> <li>Slide (zmbt::expr)</li> <li>Sort (zmbt::expr)</li> <li>Sqrt (zmbt::expr)</li> <li>Str (zmbt::expr)</li> <li>Stride (zmbt::expr)</li> <li>Sub (zmbt::expr)</li> <li>Subset (zmbt::expr)</li> <li>Sum (zmbt::expr)</li> <li>Superset (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#t","title":"t","text":"<ul> <li>throw_exception (zmbt)</li> <li>tid2str (zmbt)</li> <li>tuple (zmbt)</li> <li>tuple_exchange (zmbt)</li> <li>tuple_size (zmbt)</li> <li>tuple_size_v (zmbt)</li> <li>tuple_unqf_t (zmbt)</li> <li>type (zmbt, zmbt::api)</li> <li>type_name (zmbt)</li> <li>Tan (zmbt::expr)</li> <li>Tanh (zmbt::expr)</li> <li>Thread (zmbt::expr)</li> <li>ToList (zmbt::expr)</li> <li>Trace (zmbt::expr)</li> <li>Transp (zmbt::expr)</li> <li>True (zmbt::expr)</li> <li>Truthy (zmbt::expr)</li> <li>Try (zmbt::expr)</li> <li>Tuple (zmbt::expr)</li> <li>tag_invoke (zmbt::lang, zmbt::reflect)</li> </ul>"},{"location":"CxxRef/namespace_members/#u","title":"u","text":"<ul> <li>underlying_type (zmbt)</li> <li>underlying_type_t (zmbt)</li> <li>Underlying (zmbt::decor)</li> <li>Uncast (zmbt::expr)</li> <li>Undecorate (zmbt::expr)</li> <li>Unfold (zmbt::expr)</li> <li>Union (zmbt::expr)</li> <li>Uniques (zmbt::expr)</li> <li>UpperCase (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#v","title":"v","text":"<ul> <li>Values (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_members/#_","title":"_","text":"<ul> <li>_ (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"CxxRef/namespace_member_functions/#a","title":"a","text":"<ul> <li>attributes (zmbt::lang)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#c","title":"c","text":"<ul> <li>construct_or_default (zmbt)</li> <li>convert_tuple_to (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#d","title":"d","text":"<ul> <li>default_test_failure (zmbt)</li> <li>dejsonize (zmbt)</li> <li>dejsonize&lt; void &gt; (zmbt)</li> <li>dejsonize_array (zmbt)</li> <li>dispatch_eval (zmbt::lang)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#f","title":"f","text":"<ul> <li>format (zmbt)</li> <li>format_failure_report (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_ifc_handle (zmbt)</li> <li>get_ifc_pointer (zmbt)</li> <li>get_tid (zmbt)</li> <li>get_ts (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#i","title":"i","text":"<ul> <li>InitZmbt (zmbt)</li> <li>InterfaceRecord (zmbt, zmbt::api)</li> <li>init_tuple (zmbt::reflect)</li> <li>init_value (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#j","title":"j","text":"<ul> <li>json_from (zmbt)</li> <li>json_from_array (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#k","title":"k","text":"<ul> <li>keyword_to_str (zmbt::lang)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#m","title":"m","text":"<ul> <li>make_slice_const_generator (zmbt)</li> <li>make_slice_generator (zmbt)</li> <li>maybe_real_to_number (zmbt)</li> <li>maybe_real_to_number_inplace (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#p","title":"p","text":"<ul> <li>param_transform (zmbt)</li> <li>pretty_print (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#r","title":"r","text":"<ul> <li>real_to_number (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#s","title":"s","text":"<ul> <li>slice (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_functions/#t","title":"t","text":"<ul> <li>throw_exception (zmbt)</li> <li>tid2str (zmbt)</li> <li>tuple_exchange (zmbt)</li> <li>type_name (zmbt)</li> <li>tag_invoke (zmbt::lang, zmbt::reflect)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"CxxRef/namespace_member_variables/#a","title":"a","text":"<ul> <li>Abs (zmbt::expr)</li> <li>Acos (zmbt::expr)</li> <li>Acosh (zmbt::expr)</li> <li>Add (zmbt::expr)</li> <li>All (zmbt::expr)</li> <li>And (zmbt::expr)</li> <li>Any (zmbt::expr)</li> <li>Approx (zmbt::expr)</li> <li>Arange (zmbt::expr)</li> <li>Argmax (zmbt::expr)</li> <li>Argmin (zmbt::expr)</li> <li>Asin (zmbt::expr)</li> <li>Asinh (zmbt::expr)</li> <li>Assert (zmbt::expr)</li> <li>At (zmbt::expr)</li> <li>Atan (zmbt::expr)</li> <li>Atanh (zmbt::expr)</li> <li>Avg (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#b","title":"b","text":"<ul> <li>Bind (zmbt::expr)</li> <li>BitAnd (zmbt::expr)</li> <li>BitNot (zmbt::expr)</li> <li>BitOr (zmbt::expr)</li> <li>BitXor (zmbt::expr)</li> <li>Bool (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#c","title":"c","text":"<ul> <li>C (zmbt::expr)</li> <li>Capitalize (zmbt::expr)</li> <li>Card (zmbt::expr)</li> <li>Cartesian (zmbt::expr)</li> <li>Cast (zmbt::expr)</li> <li>Cat (zmbt::expr)</li> <li>Ceil (zmbt::expr)</li> <li>Chunks (zmbt::expr)</li> <li>Concat (zmbt::expr)</li> <li>Const (zmbt::expr)</li> <li>Contains (zmbt::expr)</li> <li>Cos (zmbt::expr)</li> <li>Cosh (zmbt::expr)</li> <li>Count (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#d","title":"d","text":"<ul> <li>D (zmbt::expr)</li> <li>Dbg (zmbt::expr)</li> <li>Debug (zmbt::expr)</li> <li>Decorate (zmbt::expr)</li> <li>Default (zmbt::expr)</li> <li>Del (zmbt::expr)</li> <li>Delete (zmbt::expr)</li> <li>Diff (zmbt::expr)</li> <li>Div (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#e","title":"e","text":"<ul> <li>emplace_shared (zmbt)</li> <li>E (zmbt::expr)</li> <li>Each (zmbt::expr)</li> <li>Enumerate (zmbt::expr)</li> <li>Eps (zmbt::expr)</li> <li>Eq (zmbt::expr)</li> <li>Erf (zmbt::expr)</li> <li>Erfc (zmbt::expr)</li> <li>Err (zmbt::expr)</li> <li>Error (zmbt::expr)</li> <li>Eval (zmbt::expr)</li> <li>Exp (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#f","title":"f","text":"<ul> <li>False (zmbt::expr)</li> <li>Falsy (zmbt::expr)</li> <li>Filter (zmbt::expr)</li> <li>Find (zmbt::expr)</li> <li>FindIdx (zmbt::expr)</li> <li>FindPtr (zmbt::expr)</li> <li>First (zmbt::expr)</li> <li>Flatten (zmbt::expr)</li> <li>Flip (zmbt::expr)</li> <li>Floor (zmbt::expr)</li> <li>Fmt (zmbt::expr)</li> <li>Fn (zmbt::expr)</li> <li>Fold (zmbt::expr)</li> <li>Fork (zmbt::expr)</li> <li>Format (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#g","title":"g","text":"<ul> <li>Gamma (zmbt::expr)</li> <li>Ge (zmbt::expr)</li> <li>Gt (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#h","title":"h","text":"<ul> <li>has_virtual_destructor_v (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#i","title":"i","text":"<ul> <li>ifc_host_nullptr (zmbt)</li> <li>is_abstract_v (zmbt)</li> <li>is_arithmetic_v (zmbt)</li> <li>is_array_v (zmbt)</li> <li>is_assignable_v (zmbt)</li> <li>is_base_of_v (zmbt)</li> <li>is_class_v (zmbt)</li> <li>is_compound_v (zmbt)</li> <li>is_const_v (zmbt)</li> <li>is_convertible_v (zmbt)</li> <li>is_copy_assignable_v (zmbt)</li> <li>is_copy_constructible_v (zmbt)</li> <li>is_default_constructible_v (zmbt)</li> <li>is_destructible_v (zmbt)</li> <li>is_empty_v (zmbt)</li> <li>is_enum_v (zmbt)</li> <li>is_final_v (zmbt)</li> <li>is_floating_point_v (zmbt)</li> <li>is_function_v (zmbt)</li> <li>is_fundamental_v (zmbt)</li> <li>is_integral_v (zmbt)</li> <li>is_lvalue_reference_v (zmbt)</li> <li>is_member_function_pointer_v (zmbt)</li> <li>is_member_object_pointer_v (zmbt)</li> <li>is_member_pointer_v (zmbt)</li> <li>is_move_assignable_v (zmbt)</li> <li>is_move_constructible_v (zmbt)</li> <li>is_nothrow_assignable_v (zmbt)</li> <li>is_nothrow_copy_assignable_v (zmbt)</li> <li>is_nothrow_copy_constructible_v (zmbt)</li> <li>is_nothrow_default_constructible_v (zmbt)</li> <li>is_nothrow_destructible_v (zmbt)</li> <li>is_nothrow_move_assignable_v (zmbt)</li> <li>is_nothrow_move_constructible_v (zmbt)</li> <li>is_null_pointer_v (zmbt)</li> <li>is_object_v (zmbt)</li> <li>is_pointer_v (zmbt)</li> <li>is_polymorphic_v (zmbt)</li> <li>is_reference_v (zmbt)</li> <li>is_rvalue_reference_v (zmbt)</li> <li>is_same_v (zmbt)</li> <li>is_scalar_v (zmbt)</li> <li>is_signed_v (zmbt)</li> <li>is_standard_layout_v (zmbt)</li> <li>is_trivial_v (zmbt)</li> <li>is_trivially_assignable_v (zmbt)</li> <li>is_trivially_copy_assignable_v (zmbt)</li> <li>is_trivially_copy_constructible_v (zmbt)</li> <li>is_trivially_copyable_v (zmbt)</li> <li>is_trivially_default_constructible_v (zmbt)</li> <li>is_trivially_destructible_v (zmbt)</li> <li>is_trivially_move_assignable_v (zmbt)</li> <li>is_trivially_move_constructible_v (zmbt)</li> <li>is_union_v (zmbt)</li> <li>is_unsigned_v (zmbt)</li> <li>is_void_v (zmbt)</li> <li>is_volatile_v (zmbt)</li> <li>Id (zmbt::expr)</li> <li>In (zmbt::expr)</li> <li>Inf (zmbt::expr)</li> <li>Intersect (zmbt::expr)</li> <li>IsErr (zmbt::expr)</li> <li>Iserror (zmbt::expr)</li> <li>Items (zmbt::expr)</li> <li>is_autogen (zmbt::lang::attr)</li> <li>is_binary (zmbt::lang::attr)</li> <li>is_const (zmbt::lang::attr)</li> <li>is_error (zmbt::lang::attr)</li> <li>is_fork (zmbt::lang::attr)</li> <li>is_hiord (zmbt::lang::attr)</li> <li>is_infix_chain (zmbt::lang::attr)</li> <li>is_literal (zmbt::lang::attr)</li> <li>is_noop (zmbt::lang::attr)</li> <li>is_operator (zmbt::lang::attr)</li> <li>is_overload (zmbt::lang::attr)</li> <li>is_pipe (zmbt::lang::attr)</li> <li>is_predicate (zmbt::lang::attr)</li> <li>is_preproc (zmbt::lang::attr)</li> <li>is_quote (zmbt::lang::attr)</li> <li>is_unary (zmbt::lang::attr)</li> <li>is_variadic (zmbt::lang::attr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#k","title":"k","text":"<ul> <li>Keys (zmbt::expr)</li> <li>Kwrd (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#l","title":"l","text":"<ul> <li>Last (zmbt::expr)</li> <li>Le (zmbt::expr)</li> <li>Link (zmbt::expr)</li> <li>Log (zmbt::expr)</li> <li>Lookup (zmbt::expr)</li> <li>LowerCase (zmbt::expr)</li> <li>Lshift (zmbt::expr)</li> <li>Lt (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#m","title":"m","text":"<ul> <li>Map (zmbt::expr)</li> <li>Max (zmbt::expr)</li> <li>Min (zmbt::expr)</li> <li>Mod (zmbt::expr)</li> <li>Mul (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#n","title":"n","text":"<ul> <li>NaN (zmbt::expr)</li> <li>Ne (zmbt::expr)</li> <li>Near (zmbt::expr)</li> <li>Neg (zmbt::expr)</li> <li>Ni (zmbt::expr)</li> <li>Nil (zmbt::expr)</li> <li>Noop (zmbt::expr)</li> <li>Not (zmbt::expr)</li> <li>NotIn (zmbt::expr)</li> <li>NotNi (zmbt::expr)</li> <li>Null (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#o","title":"o","text":"<ul> <li>Op (zmbt::expr)</li> <li>Or (zmbt::expr)</li> <li>Overload (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#p","title":"p","text":"<ul> <li>Precise (zmbt::decor)</li> <li>PSubset (zmbt::expr)</li> <li>PSuperset (zmbt::expr)</li> <li>Parameters (zmbt::expr)</li> <li>Parse (zmbt::expr)</li> <li>Pi (zmbt::expr)</li> <li>Pipe (zmbt::expr)</li> <li>Pow (zmbt::expr)</li> <li>PreProc (zmbt::expr)</li> <li>Prms (zmbt::expr)</li> <li>Prod (zmbt::expr)</li> <li>Push (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#q","title":"q","text":"<ul> <li>Q (zmbt::expr)</li> <li>Quot (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#r","title":"r","text":"<ul> <li>Re (zmbt::expr)</li> <li>Recur (zmbt::expr)</li> <li>Reduce (zmbt::expr)</li> <li>Regex (zmbt::expr)</li> <li>Repeat (zmbt::expr)</li> <li>Reverse (zmbt::expr)</li> <li>Round (zmbt::expr)</li> <li>Rshift (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#s","title":"s","text":"<ul> <li>Saturate (zmbt::expr)</li> <li>Serialize (zmbt::expr)</li> <li>SetEq (zmbt::expr)</li> <li>Sign (zmbt::expr)</li> <li>Sin (zmbt::expr)</li> <li>Sinh (zmbt::expr)</li> <li>Size (zmbt::expr)</li> <li>Slide (zmbt::expr)</li> <li>Sort (zmbt::expr)</li> <li>Sqrt (zmbt::expr)</li> <li>Str (zmbt::expr)</li> <li>Stride (zmbt::expr)</li> <li>Sub (zmbt::expr)</li> <li>Subset (zmbt::expr)</li> <li>Sum (zmbt::expr)</li> <li>Superset (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#t","title":"t","text":"<ul> <li>tuple_size_v (zmbt)</li> <li>type (zmbt, zmbt::api)</li> <li>Tan (zmbt::expr)</li> <li>Tanh (zmbt::expr)</li> <li>Thread (zmbt::expr)</li> <li>ToList (zmbt::expr)</li> <li>Trace (zmbt::expr)</li> <li>Transp (zmbt::expr)</li> <li>True (zmbt::expr)</li> <li>Truthy (zmbt::expr)</li> <li>Try (zmbt::expr)</li> <li>Tuple (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#u","title":"u","text":"<ul> <li>Underlying (zmbt::decor)</li> <li>Uncast (zmbt::expr)</li> <li>Undecorate (zmbt::expr)</li> <li>Unfold (zmbt::expr)</li> <li>Union (zmbt::expr)</li> <li>Uniques (zmbt::expr)</li> <li>UpperCase (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#v","title":"v","text":"<ul> <li>Values (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_variables/#_","title":"_","text":"<ul> <li>_ (zmbt::expr)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"CxxRef/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>add_const (zmbt)</li> <li>add_const_t (zmbt)</li> <li>add_cv (zmbt)</li> <li>add_cv_t (zmbt)</li> <li>add_lvalue_reference (zmbt)</li> <li>add_lvalue_reference_t (zmbt)</li> <li>add_pointer (zmbt)</li> <li>add_pointer_t (zmbt)</li> <li>add_rvalue_reference (zmbt)</li> <li>add_rvalue_reference_t (zmbt)</li> <li>add_volatile (zmbt)</li> <li>add_volatile_t (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#b","title":"b","text":"<ul> <li>bool_constant (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>common_type (zmbt)</li> <li>common_type_t (zmbt)</li> <li>conditional (zmbt)</li> <li>conditional_t (zmbt)</li> <li>custom_initialization (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>decay (zmbt)</li> <li>decay_t (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>first_if_any_t (zmbt)</li> <li>first_if_none_t (zmbt)</li> <li>first_if_t (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#h","title":"h","text":"<ul> <li>has_virtual_destructor (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>ifc_args_t (zmbt)</li> <li>ifc_handle_t (zmbt)</li> <li>ifc_host_t (zmbt)</li> <li>ifc_is_fn_handle (zmbt)</li> <li>ifc_is_fn_ptr (zmbt)</li> <li>ifc_is_fn_ref (zmbt)</li> <li>ifc_is_functor_handle (zmbt)</li> <li>ifc_is_functor_ptr (zmbt)</li> <li>ifc_is_functor_ref (zmbt)</li> <li>ifc_is_member_handle (zmbt)</li> <li>ifc_is_pmd_handle (zmbt)</li> <li>ifc_is_pmf_handle (zmbt)</li> <li>ifc_pointer_t (zmbt)</li> <li>ifc_return_t (zmbt)</li> <li>indexator_for (zmbt)</li> <li>integral_constant (zmbt)</li> <li>is_abstract (zmbt)</li> <li>is_arithmetic (zmbt)</li> <li>is_array (zmbt)</li> <li>is_assignable (zmbt)</li> <li>is_base_of (zmbt)</li> <li>is_class (zmbt)</li> <li>is_compound (zmbt)</li> <li>is_const (zmbt)</li> <li>is_constructible (zmbt)</li> <li>is_convertible (zmbt)</li> <li>is_copy_assignable (zmbt)</li> <li>is_copy_constructible (zmbt)</li> <li>is_default_constructible (zmbt)</li> <li>is_destructible (zmbt)</li> <li>is_empty (zmbt)</li> <li>is_enum (zmbt)</li> <li>is_final (zmbt)</li> <li>is_floating_point (zmbt)</li> <li>is_function (zmbt)</li> <li>is_fundamental (zmbt)</li> <li>is_ifc_handle (zmbt)</li> <li>is_integral (zmbt)</li> <li>is_lvalue_reference (zmbt)</li> <li>is_member_function_pointer (zmbt)</li> <li>is_member_object_pointer (zmbt)</li> <li>is_member_pointer (zmbt)</li> <li>is_move_assignable (zmbt)</li> <li>is_move_constructible (zmbt)</li> <li>is_nothrow_assignable (zmbt)</li> <li>is_nothrow_constructible (zmbt)</li> <li>is_nothrow_copy_assignable (zmbt)</li> <li>is_nothrow_copy_constructible (zmbt)</li> <li>is_nothrow_default_constructible (zmbt)</li> <li>is_nothrow_destructible (zmbt)</li> <li>is_nothrow_move_assignable (zmbt)</li> <li>is_nothrow_move_constructible (zmbt)</li> <li>is_null_pointer (zmbt)</li> <li>is_object (zmbt)</li> <li>is_pointer (zmbt)</li> <li>is_polymorphic (zmbt)</li> <li>is_reference (zmbt)</li> <li>is_rvalue_reference (zmbt)</li> <li>is_same (zmbt)</li> <li>is_scalar (zmbt)</li> <li>is_signed (zmbt)</li> <li>is_standard_layout (zmbt)</li> <li>is_trivial (zmbt)</li> <li>is_trivially_assignable (zmbt)</li> <li>is_trivially_constructible (zmbt)</li> <li>is_trivially_copy_assignable (zmbt)</li> <li>is_trivially_copy_constructible (zmbt)</li> <li>is_trivially_copyable (zmbt)</li> <li>is_trivially_default_constructible (zmbt)</li> <li>is_trivially_destructible (zmbt)</li> <li>is_trivially_move_assignable (zmbt)</li> <li>is_trivially_move_constructible (zmbt)</li> <li>is_tuple (zmbt)</li> <li>is_type_tag (zmbt)</li> <li>is_union (zmbt)</li> <li>is_unsigned (zmbt)</li> <li>is_void (zmbt)</li> <li>is_volatile (zmbt)</li> <li>initialization (zmbt::reflect)</li> <li>interface_t (zmbt::reflect)</li> <li>invocation_args_t (zmbt::reflect)</li> <li>invocation_args_unqf_t (zmbt::reflect)</li> <li>invocation_has_void_args (zmbt::reflect)</li> <li>invocation_has_void_ret (zmbt::reflect)</li> <li>invocation_host_t (zmbt::reflect)</li> <li>invocation_ret_t (zmbt::reflect)</li> <li>invocation_ret_unqf_or_nullptr_t (zmbt::reflect)</li> <li>invocation_ret_unqf_t (zmbt::reflect)</li> <li>invocation_unqf_host_t (zmbt::reflect)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#j","title":"j","text":"<ul> <li>js_array_slice_const_gen (zmbt)</li> <li>js_array_slice_gen (zmbt)</li> <li>js_string_slice_gen (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>make_signed (zmbt)</li> <li>make_signed_t (zmbt)</li> <li>make_unsigned (zmbt)</li> <li>make_unsigned_t (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>remove_const (zmbt)</li> <li>remove_const_t (zmbt)</li> <li>remove_cv (zmbt)</li> <li>remove_cv_t (zmbt)</li> <li>remove_cvptr_t (zmbt)</li> <li>remove_cvref_t (zmbt)</li> <li>remove_pointer (zmbt)</li> <li>remove_pointer_t (zmbt)</li> <li>remove_reference (zmbt)</li> <li>remove_reference_t (zmbt)</li> <li>remove_volatile (zmbt)</li> <li>remove_volatile_t (zmbt)</li> <li>require_cal (zmbt)</li> <li>require_json_from (zmbt)</li> <li>require_literal (zmbt)</li> <li>require_no_json_from (zmbt)</li> <li>require_not_cal (zmbt)</li> <li>require_not_str (zmbt)</li> <li>require_obj (zmbt)</li> <li>require_str (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>tuple (zmbt)</li> <li>tuple_size (zmbt)</li> <li>tuple_unqf_t (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_typedefs/#u","title":"u","text":"<ul> <li>underlying_type (zmbt)</li> <li>underlying_type_t (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"CxxRef/namespace_member_enums/#c","title":"c","text":"<ul> <li>ChannelKind (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_enums/#f","title":"f","text":"<ul> <li>FileFormat (zmbt)</li> </ul>"},{"location":"CxxRef/namespace_member_enums/#k","title":"k","text":"<ul> <li>Keyword (zmbt::lang)</li> </ul>"},{"location":"CxxRef/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"CxxRef/macros/","title":"Macros","text":""},{"location":"CxxRef/macros/#a","title":"a","text":"<ul> <li>ASSERT (eval_impl_pp.hpp)</li> </ul>"},{"location":"CxxRef/macros/#b","title":"b","text":"<ul> <li>BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK (environment_data.hpp, output_recorder.hpp, permanent_data.hpp)</li> </ul>"},{"location":"CxxRef/macros/#c","title":"c","text":"<ul> <li>CAT (ducktyping_traits_pp.hpp)</li> </ul>"},{"location":"CxxRef/macros/#d","title":"d","text":"<ul> <li>DEFAULT_INVOCATION_TYPEDEFS (invocation.hpp)</li> </ul>"},{"location":"CxxRef/macros/#u","title":"u","text":"<ul> <li>USING_STD_TYPETRAIT (aliases.hpp)</li> <li>USING_STD_TYPETRAIT_BINARY (aliases.hpp)</li> <li>USING_STD_TYPETRAIT_PROPERTY (aliases.hpp)</li> <li>USING_STD_TYPETRAIT_TRANSFORM (aliases.hpp)</li> <li>USING_TYPETRAIT_T (aliases.hpp)</li> <li>USING_TYPETRAIT_V (aliases.hpp)</li> </ul>"},{"location":"CxxRef/macros/#z","title":"z","text":"<ul> <li>ZMBT_DEBUG (log.hpp)</li> <li>ZMBT_LOG (log.hpp)</li> <li>ZMBT_LOG_CERR (log.hpp)</li> <li>ZMBT_LOG_JSON (log.hpp)</li> <li>ZMBT_WRAP_BOOST_TRAIT (operator_traits.hpp)</li> <li>ZMBT_CUR_LOC (preprocessor.hpp)</li> <li>ZMBT_PP_INJECT_CODE_INTO_NS (preprocessor.hpp)</li> <li>ZMBT_PP_NS_CLOSE (preprocessor.hpp)</li> <li>ZMBT_PP_NS_CLOSE_ALL (preprocessor.hpp)</li> <li>ZMBT_PP_NS_OPEN (preprocessor.hpp)</li> <li>ZMBT_PP_NS_OPEN_ALL (preprocessor.hpp)</li> <li>ZMBT_STRINGIFY (preprocessor.hpp)</li> <li>ZMBT_STRINGIFY_IMPL (preprocessor.hpp)</li> <li>ZMBT_DEFINE_EVALUATE_IMPL (eval_impl_pp.hpp)</li> <li>ZMBT_SOH_HANDLE_BIN_TRANSFORM (operator.hpp)</li> <li>ZMBT_SOH_HANDLE_UNARY_TRANSFORM (operator.hpp)</li> <li>ZMBT_HAS_MEMBER (ducktyping_traits_pp.hpp)</li> <li>ZMBT_HAS_TYPE (ducktyping_traits_pp.hpp)</li> <li>ZMBT_TRAIT_HAS_MEMBER (ducktyping_traits_pp.hpp)</li> <li>ZMBT_TRAIT_HAS_TYPE (ducktyping_traits_pp.hpp)</li> <li>ZMBT_INJECT_JSON_TAG_INVOKE (serialization.hpp)</li> <li>ZMBT_INJECT_JSON_TAG_INVOKE_INTO (serialization.hpp)</li> <li>ZMBT_INJECT_OSTREAM_OPERATOR (serialization.hpp)</li> <li>ZMBT_INJECT_OSTREAM_OPERATOR_INTO (serialization.hpp)</li> <li>ZMBT_INJECT_SERIALIZATION (serialization.hpp)</li> <li>ZMBT_INJECT_SERIALIZATION_INTO (serialization.hpp)</li> <li>ZMBT_DEFINE_CUSTOM_INIT (signal_traits.hpp)</li> <li>ZMBT_PP_UNPACK (signal_traits.hpp)</li> </ul>"},{"location":"CxxRef/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"CxxRef/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}