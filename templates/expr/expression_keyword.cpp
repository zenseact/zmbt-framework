@require(keyword_groups)
/**
 * \file
 * \copyright (c) Copyright 2024 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * How to update:
 * 1. Update the template at `templates/expr/expression_keyword.cpp`
 * 2. Update the keyword data at `templates/expr/data.yaml`
 * 3. Regenerate file with `bazel run //templates/expr:expression_keyword_cpp > packages/cxx/src/model/expression_keyword.cpp`
 * 4. Commit changes
 */


#include <boost/spirit/include/qi.hpp>

#include "zmbt/reflect.hpp"
#include "zmbt/model/expression_keyword.hpp"
#include "zmbt/model/expression_grammar.hpp"


#ifndef ZMBT_KEYWORD_PREFIX
    #define ZMBT_KEYWORD_PREFIX ":"
#endif

namespace zmbt {
namespace reflect {
boost::json::value custom_serialization<ExpressionKeyword>::json_from(ExpressionKeyword const& kw)
{
    using Kw = ExpressionKeyword;

    switch(kw)
    {
@for group in keyword_groups:
@for keyword in group['keywords']:
    case Kw::@keyword.get('enum', keyword['name'].capitalize()): return ZMBT_KEYWORD_PREFIX "@keyword['name']";
@end
@end
        // TODO: throw
        default: return ":undefined";
    }
}

ExpressionKeyword custom_serialization<ExpressionKeyword>::dejsonize(boost::json::value const& v)
{
    if (not v.is_string())
    {
        return ExpressionKeyword::Undefined;
    }

    static ExpressionKeywordGrammar const keyword_parser {};

    auto const& str = v.as_string();
    auto iter = str.cbegin();
    auto end = str.cend();
    ExpressionKeyword keyword_out {ExpressionKeyword::Undefined};
    static_cast<void>(boost::spirit::qi::parse(iter, end, keyword_parser, keyword_out));
    return keyword_out;
}
} // namespace reflect
} // namespace zmbt
