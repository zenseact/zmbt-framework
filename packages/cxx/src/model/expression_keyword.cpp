/**
 * \file
 * \copyright (c) Copyright 2024 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * How to update:
 * 1. Update the template at `templates/expr/expression_keyword.cpp`
 * 2. Update the keyword data at `templates/expr/data.yaml`
 * 3. Regenerate file with `bazel run //templates/expr:expression_keyword_cpp > packages/cxx/src/model/expression_keyword.cpp`
 * 4. Commit changes
 */


#include <boost/spirit/include/qi.hpp>
#include <boost/json.hpp>


#include "zmbt/reflect.hpp"
#include "zmbt/model/expression_keyword.hpp"
#include "zmbt/model/expression_grammar.hpp"


#ifndef ZMBT_KEYWORD_PREFIX
    #define ZMBT_KEYWORD_PREFIX ":"
#endif


namespace zmbt {
void tag_invoke(boost::json::value_from_tag const&, boost::json::value& v, ExpressionKeyword const& kw)
{
    using Kw = ExpressionKeyword;

    switch(kw)
    {
    case Kw::Id: { v = ZMBT_KEYWORD_PREFIX "id"; break; }
    case Kw::Noop: { v = ZMBT_KEYWORD_PREFIX "noop"; break; }
    case Kw::True: { v = ZMBT_KEYWORD_PREFIX "true"; break; }
    case Kw::False: { v = ZMBT_KEYWORD_PREFIX "false"; break; }
    case Kw::Null: { v = ZMBT_KEYWORD_PREFIX "null"; break; }
    case Kw::Pi: { v = ZMBT_KEYWORD_PREFIX "pi"; break; }
    case Kw::E: { v = ZMBT_KEYWORD_PREFIX "e"; break; }
    case Kw::Inf: { v = ZMBT_KEYWORD_PREFIX "inf"; break; }
    case Kw::Eps: { v = ZMBT_KEYWORD_PREFIX "eps"; break; }
    case Kw::NaN: { v = ZMBT_KEYWORD_PREFIX "nan"; break; }
    case Kw::Bool: { v = ZMBT_KEYWORD_PREFIX "bool"; break; }
    case Kw::Nil: { v = ZMBT_KEYWORD_PREFIX "nil"; break; }
    case Kw::Not: { v = ZMBT_KEYWORD_PREFIX "not"; break; }
    case Kw::And: { v = ZMBT_KEYWORD_PREFIX "and"; break; }
    case Kw::Or: { v = ZMBT_KEYWORD_PREFIX "or"; break; }
    case Kw::Xor: { v = ZMBT_KEYWORD_PREFIX "xor"; break; }
    case Kw::Eq: { v = ZMBT_KEYWORD_PREFIX "eq"; break; }
    case Kw::Ne: { v = ZMBT_KEYWORD_PREFIX "ne"; break; }
    case Kw::Lt: { v = ZMBT_KEYWORD_PREFIX "lt"; break; }
    case Kw::Le: { v = ZMBT_KEYWORD_PREFIX "le"; break; }
    case Kw::Gt: { v = ZMBT_KEYWORD_PREFIX "gt"; break; }
    case Kw::Ge: { v = ZMBT_KEYWORD_PREFIX "ge"; break; }
    case Kw::Ni: { v = ZMBT_KEYWORD_PREFIX "ni"; break; }
    case Kw::NotNi: { v = ZMBT_KEYWORD_PREFIX "not-ni"; break; }
    case Kw::SetEq: { v = ZMBT_KEYWORD_PREFIX "set-eq"; break; }
    case Kw::Subset: { v = ZMBT_KEYWORD_PREFIX "subset"; break; }
    case Kw::Superset: { v = ZMBT_KEYWORD_PREFIX "superset"; break; }
    case Kw::ProperSubset: { v = ZMBT_KEYWORD_PREFIX "p-subset"; break; }
    case Kw::ProperSuperset: { v = ZMBT_KEYWORD_PREFIX "p-superset"; break; }
    case Kw::In: { v = ZMBT_KEYWORD_PREFIX "in"; break; }
    case Kw::NotIn: { v = ZMBT_KEYWORD_PREFIX "not-in"; break; }
    case Kw::Neg: { v = ZMBT_KEYWORD_PREFIX "neg"; break; }
    case Kw::Abs: { v = ZMBT_KEYWORD_PREFIX "abs"; break; }
    case Kw::Sign: { v = ZMBT_KEYWORD_PREFIX "sign"; break; }
    case Kw::Ceil: { v = ZMBT_KEYWORD_PREFIX "ceil"; break; }
    case Kw::Floor: { v = ZMBT_KEYWORD_PREFIX "floor"; break; }
    case Kw::Round: { v = ZMBT_KEYWORD_PREFIX "round"; break; }
    case Kw::Add: { v = ZMBT_KEYWORD_PREFIX "add"; break; }
    case Kw::Sub: { v = ZMBT_KEYWORD_PREFIX "sub"; break; }
    case Kw::Mul: { v = ZMBT_KEYWORD_PREFIX "mul"; break; }
    case Kw::Div: { v = ZMBT_KEYWORD_PREFIX "div"; break; }
    case Kw::Pow: { v = ZMBT_KEYWORD_PREFIX "pow"; break; }
    case Kw::Log: { v = ZMBT_KEYWORD_PREFIX "log"; break; }
    case Kw::Mod: { v = ZMBT_KEYWORD_PREFIX "mod"; break; }
    case Kw::Quot: { v = ZMBT_KEYWORD_PREFIX "quot"; break; }
    case Kw::Sqrt: { v = ZMBT_KEYWORD_PREFIX "sqrt"; break; }
    case Kw::Sin: { v = ZMBT_KEYWORD_PREFIX "sin"; break; }
    case Kw::Cos: { v = ZMBT_KEYWORD_PREFIX "cos"; break; }
    case Kw::Tan: { v = ZMBT_KEYWORD_PREFIX "tan"; break; }
    case Kw::Asin: { v = ZMBT_KEYWORD_PREFIX "asin"; break; }
    case Kw::Acos: { v = ZMBT_KEYWORD_PREFIX "acos"; break; }
    case Kw::Atan: { v = ZMBT_KEYWORD_PREFIX "atan"; break; }
    case Kw::Sinh: { v = ZMBT_KEYWORD_PREFIX "sinh"; break; }
    case Kw::Cosh: { v = ZMBT_KEYWORD_PREFIX "cosh"; break; }
    case Kw::Tanh: { v = ZMBT_KEYWORD_PREFIX "tanh"; break; }
    case Kw::Asinh: { v = ZMBT_KEYWORD_PREFIX "asinh"; break; }
    case Kw::Acosh: { v = ZMBT_KEYWORD_PREFIX "acosh"; break; }
    case Kw::Atanh: { v = ZMBT_KEYWORD_PREFIX "atanh"; break; }
    case Kw::Exp: { v = ZMBT_KEYWORD_PREFIX "exp"; break; }
    case Kw::Erf: { v = ZMBT_KEYWORD_PREFIX "erf"; break; }
    case Kw::Erfc: { v = ZMBT_KEYWORD_PREFIX "erfc"; break; }
    case Kw::Gamma: { v = ZMBT_KEYWORD_PREFIX "gamma"; break; }
    case Kw::BitNot: { v = ZMBT_KEYWORD_PREFIX "b-not"; break; }
    case Kw::BitAnd: { v = ZMBT_KEYWORD_PREFIX "b-and"; break; }
    case Kw::BitOr: { v = ZMBT_KEYWORD_PREFIX "b-or"; break; }
    case Kw::BitXor: { v = ZMBT_KEYWORD_PREFIX "b-xor"; break; }
    case Kw::BitLshift: { v = ZMBT_KEYWORD_PREFIX "b-lshift"; break; }
    case Kw::BitRshift: { v = ZMBT_KEYWORD_PREFIX "b-rshift"; break; }
    case Kw::Map: { v = ZMBT_KEYWORD_PREFIX "map"; break; }
    case Kw::Filter: { v = ZMBT_KEYWORD_PREFIX "filter"; break; }
    case Kw::Compose: { v = ZMBT_KEYWORD_PREFIX "compose"; break; }
    case Kw::Recur: { v = ZMBT_KEYWORD_PREFIX "recur"; break; }
    case Kw::Apply: { v = ZMBT_KEYWORD_PREFIX "apply"; break; }
    case Kw::Partial: { v = ZMBT_KEYWORD_PREFIX "partial"; break; }
    case Kw::Reduce: { v = ZMBT_KEYWORD_PREFIX "reduce"; break; }
    case Kw::Concat: { v = ZMBT_KEYWORD_PREFIX "concat"; break; }
    case Kw::Union: { v = ZMBT_KEYWORD_PREFIX "union"; break; }
    case Kw::Intersect: { v = ZMBT_KEYWORD_PREFIX "intersect"; break; }
    case Kw::Diff: { v = ZMBT_KEYWORD_PREFIX "set-diff"; break; }
    case Kw::Cartesian: { v = ZMBT_KEYWORD_PREFIX "cartesian"; break; }
    case Kw::Transp: { v = ZMBT_KEYWORD_PREFIX "transp"; break; }
    case Kw::Set: { v = ZMBT_KEYWORD_PREFIX "set"; break; }
    case Kw::List: { v = ZMBT_KEYWORD_PREFIX "list"; break; }
    case Kw::Slide: { v = ZMBT_KEYWORD_PREFIX "slide"; break; }
    case Kw::Stride: { v = ZMBT_KEYWORD_PREFIX "stride"; break; }
    case Kw::Slice: { v = ZMBT_KEYWORD_PREFIX "slice"; break; }
    case Kw::Sort: { v = ZMBT_KEYWORD_PREFIX "sort"; break; }
    case Kw::Repeat: { v = ZMBT_KEYWORD_PREFIX "repeat"; break; }
    case Kw::At: { v = ZMBT_KEYWORD_PREFIX "at"; break; }
    case Kw::Sum: { v = ZMBT_KEYWORD_PREFIX "sum"; break; }
    case Kw::Prod: { v = ZMBT_KEYWORD_PREFIX "prod"; break; }
    case Kw::Card: { v = ZMBT_KEYWORD_PREFIX "card"; break; }
    case Kw::Size: { v = ZMBT_KEYWORD_PREFIX "size"; break; }
    case Kw::Count: { v = ZMBT_KEYWORD_PREFIX "count"; break; }
    case Kw::Min: { v = ZMBT_KEYWORD_PREFIX "min"; break; }
    case Kw::Max: { v = ZMBT_KEYWORD_PREFIX "max"; break; }
    case Kw::Argmin: { v = ZMBT_KEYWORD_PREFIX "argmin"; break; }
    case Kw::Argmax: { v = ZMBT_KEYWORD_PREFIX "argmax"; break; }
    case Kw::Any: { v = ZMBT_KEYWORD_PREFIX "any"; break; }
    case Kw::All: { v = ZMBT_KEYWORD_PREFIX "all"; break; }
    case Kw::Saturate: { v = ZMBT_KEYWORD_PREFIX "saturate"; break; }
    case Kw::Re: { v = ZMBT_KEYWORD_PREFIX "re"; break; }
    case Kw::Approx: { v = ZMBT_KEYWORD_PREFIX "approx"; break; }
        // TODO: throw
        default: v = ":undefined";
    }
}

ExpressionKeyword
tag_invoke(boost::json::value_to_tag<ExpressionKeyword> const&, boost::json::value const& v)
{
    if (not v.is_string())
    {
        return ExpressionKeyword::Undefined;
    }

    static ExpressionKeywordGrammar const keyword_parser {};

    auto const& str = v.as_string();
    auto iter = str.cbegin();
    auto end = str.cend();
    ExpressionKeyword keyword_out {ExpressionKeyword::Undefined};
    static_cast<void>(boost::spirit::qi::parse(iter, end, keyword_parser, keyword_out));
    return keyword_out;
}
} // namespace zmbt

