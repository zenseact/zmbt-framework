<!-- (c) Copyright 2025 Zenseact AB -->
<!-- SPDX-License-Identifier: Apache-2.0 -->
<!-- Autogenerated file - do not change!
    app: codegen.expr
    template: codegen/expr/templates/docs/expression-dsl-reference.md

    How to update:
    1. Update the template
    2. Run `python -m codegen` in the project root
    3. Commit changes
-->

# Expression DSL Reference {#expression-dsl-reference}

[TOC]


## Constants {#expression-dsl-reference-constants}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Noop](\ref expr-noop)
        </td>
        <td>No operation
        <pre>Returns true without input validation.
Used in place of matchers for uninteresting signals.</pre>
        <br>Aliases: _
        </td>
    </tr>
    <tr>
        <td>[Null](\ref expr-null)
        </td>
        <td>Null value
        </td>
    </tr>
    <tr>
        <td>[True](\ref expr-true)
        </td>
        <td>Logical true
        </td>
    </tr>
    <tr>
        <td>[False](\ref expr-false)
        </td>
        <td>Logical false
        </td>
    </tr>
    <tr>
        <td>[Pi](\ref expr-pi)
        </td>
        <td>Pi constant
        </td>
    </tr>
    <tr>
        <td>[E](\ref expr-e)
        </td>
        <td>Euler's number
        </td>
    </tr>
    <tr>
        <td>[Inf](\ref expr-inf)
        </td>
        <td>Infinity
        </td>
    </tr>
    <tr>
        <td>[Eps](\ref expr-eps)
        </td>
        <td>Machine epsilon
        </td>
    </tr>
    <tr>
        <td>[NaN](\ref expr-nan)
        </td>
        <td>Not a number
        </td>
    </tr>

## Math Functions {#expression-dsl-reference-math-functions}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Sin](\ref expr-sin)
        </td>
        <td>Sinus
        </td>
    </tr>
    <tr>
        <td>[Cos](\ref expr-cos)
        </td>
        <td>Cosinus
        </td>
    </tr>
    <tr>
        <td>[Tan](\ref expr-tan)
        </td>
        <td>Tangens
        </td>
    </tr>
    <tr>
        <td>[Asin](\ref expr-asin)
        </td>
        <td>Arcsin
        </td>
    </tr>
    <tr>
        <td>[Acos](\ref expr-acos)
        </td>
        <td>Arccos
        </td>
    </tr>
    <tr>
        <td>[Atan](\ref expr-atan)
        </td>
        <td>Arctan
        </td>
    </tr>
    <tr>
        <td>[Sinh](\ref expr-sinh)
        </td>
        <td>Hyperbolic sin
        </td>
    </tr>
    <tr>
        <td>[Cosh](\ref expr-cosh)
        </td>
        <td>Hyperbolic cos
        </td>
    </tr>
    <tr>
        <td>[Tanh](\ref expr-tanh)
        </td>
        <td>Hyperbolic tan
        </td>
    </tr>
    <tr>
        <td>[Asinh](\ref expr-asinh)
        </td>
        <td>Hyperbolic arcsin
        </td>
    </tr>
    <tr>
        <td>[Acosh](\ref expr-acosh)
        </td>
        <td>Hyperbolic arccos
        </td>
    </tr>
    <tr>
        <td>[Atanh](\ref expr-atanh)
        </td>
        <td>Hyperbolic arctan
        </td>
    </tr>
    <tr>
        <td>[Exp](\ref expr-exp)
        </td>
        <td>Exponential (e^x)
        </td>
    </tr>
    <tr>
        <td>[Erf](\ref expr-erf)
        </td>
        <td>Error function
        </td>
    </tr>
    <tr>
        <td>[Erfc](\ref expr-erfc)
        </td>
        <td>Error function complement
        </td>
    </tr>
    <tr>
        <td>[Gamma](\ref expr-gamma)
        </td>
        <td>Gamma function
        </td>
    </tr>
    <tr>
        <td>[Abs](\ref expr-abs)
        </td>
        <td>Absolute value
        </td>
    </tr>
    <tr>
        <td>[Ceil](\ref expr-ceil)
        </td>
        <td>Ceil
        </td>
    </tr>
    <tr>
        <td>[Floor](\ref expr-floor)
        </td>
        <td>Floor
        </td>
    </tr>
    <tr>
        <td>[Round](\ref expr-round)
        </td>
        <td>Round to nearest integer
        <pre>Hint: To round to ndigits precision after the decimal point,
use Mul(ndigits)|Round|Div(ndigits) combo.</pre>
        </td>
    </tr>
    <tr>
        <td>[Sqrt](\ref expr-sqrt)
        </td>
        <td>Square root
        </td>
    </tr>
    <tr>
        <td>[Sign](\ref expr-sign)
        </td>
        <td>Sign
        </td>
    </tr>

## Arithmetic Operators {#expression-dsl-reference-arithmetic-operators}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Neg](\ref expr-neg)
        </td>
        <td></td>
        <td>Negate
        </td>
        <td><pre>Neg >> 42 == -42</pre></td>
    </tr>
    <tr>
        <td>[Add](\ref expr-add)
        </td>
        <td>+</td>
        <td>Addition
        </td>
        <td><pre>Add >> [2, -1] == 1
Add(-1) >> 2  == 1</pre></td>
    </tr>
    <tr>
        <td>[Sub](\ref expr-sub)
        </td>
        <td>-</td>
        <td>Subtraction
        </td>
        <td><pre>Sub >> [2, 1] == -1
Sub(1) >> 2   == 1</pre></td>
    </tr>
    <tr>
        <td>[SubFrom](\ref expr-sub-from)
        </td>
        <td></td>
        <td>Reverse subtraction
        <pre>Subtraction with reverse arguments, i. e.
  1. [ ] |-> [y, x] |-> x - y
  2. [x] |-> [y]    |-> x - y</pre>
        </td>
        <td><pre>SubFrom >> [2, 1] == -1
SubFrom(1) >> 2   == -1</pre></td>
    </tr>
    <tr>
        <td>[Mul](\ref expr-mul)
        </td>
        <td>*</td>
        <td>Multiplication
        </td>
        <td><pre>Mul >> [2, 3] == 6
Mul(3) >> 2   == 6</pre></td>
    </tr>
    <tr>
        <td>[Div](\ref expr-div)
        </td>
        <td>/</td>
        <td>Division
        <pre>1. [ ] |-> [x, y] |-> x / y
2. [y] |-> [x]    |-> x / y</pre>
        </td>
        <td><pre>Div >> [6, 3] == 2
Div(3) >> 6   == 2</pre></td>
    </tr>
    <tr>
        <td>[DivFrom](\ref expr-div-from)
        </td>
        <td></td>
        <td>Reverse division
        <pre>Division with reverse arguments, i. e.
  1. [ ] |-> [y, x] |-> x / y
  2. [x] |-> [y]    |-> x / y</pre>
        </td>
        <td><pre>DivFrom >> [6, 3] == 0.5
DivFrom(3) >> 6   == 0.5</pre></td>
    </tr>
    <tr>
        <td>[Pow](\ref expr-pow)
        </td>
        <td></td>
        <td>To power
        <pre>X to power p
  1. [ ] |-> [x, p] |-> x^p
  2. [p] |-> [x]    |-> x^p</pre>
        </td>
        <td><pre>Pow >> [2, 3] == 8
Pow(3) >> 2   == 8</pre></td>
    </tr>
    <tr>
        <td>[PowFrom](\ref expr-pow-from)
        </td>
        <td></td>
        <td>Reverse power
        <pre>Pow with reverse arguments, i. e.
  1. [ ] |-> [p, x] |-> x^p
  2. [x] |-> [p]    |-> x^p</pre>
        </td>
        <td><pre>PowFrom >> [2, 3] == 9
PowFrom(3) >> 2   == 9</pre></td>
    </tr>
    <tr>
        <td>[Log](\ref expr-log)
        </td>
        <td></td>
        <td>Logarithm
        <pre>Logarithm with base b:
  1. [ ] |-> [x, b] |-> log_b(x)
  2. [b] |-> [x]    |-> log_b(x)</pre>
        </td>
        <td><pre>Log >> [8, 2] == 3
Log(2) >> 8   == 3</pre></td>
    </tr>
    <tr>
        <td>[LogFrom](\ref expr-log-from)
        </td>
        <td></td>
        <td>Reverse logarithm
        <pre>Log with reverse arguments, i. e.
  1. [ ] |-> [b, x] |-> log_b(x)
  2. [b] |-> [b]    |-> log_b(x)</pre>
        </td>
        <td><pre>LogFrom >> [2, 8] == 3
LogFrom(2) >> 8   == 3</pre></td>
    </tr>
    <tr>
        <td>[Mod](\ref expr-mod)
        </td>
        <td>%</td>
        <td>Modulo
        <pre>Modulo of x:
  1. [ ] |-> [x, m] |-> x % m
  2. [m] |-> [x]    |-> x % m</pre>
        </td>
        <td><pre>Mod >> [7, 4] == 3
Mod(4) >> 7   == 3</pre></td>
    </tr>
    <tr>
        <td>[ModFrom](\ref expr-mod-from)
        </td>
        <td></td>
        <td>Reverse modulo
        <pre>Modulo with reverse arguments, i. e.
  1. [ ] |-> [b, x] |-> log_b(x)
  2. [b] |-> [b]    |-> log_b(x)</pre>
        </td>
        <td><pre>ModFrom >> [4, 7] == 3
ModFrom(4) >> 7   == 3</pre></td>
    </tr>
    <tr>
        <td>[Quot](\ref expr-quot)
        </td>
        <td>//</td>
        <td>Quotient
        <pre>Quotient of x:
  1. [ ] |-> [x, d] |-> x // d
  2. [d] |-> [x]    |-> x // d</pre>
        </td>
        <td><pre>Quot >> [7, 4] == 1
Quot(4) >> 7   == 1</pre></td>
    </tr>
    <tr>
        <td>[QuotFrom](\ref expr-quot-from)
        </td>
        <td></td>
        <td>Reverse quotient
        <pre>Quotient with reverse arguments, i. e.
  1. [ ] |-> [d, x] |-> x // d
  2. [x] |-> [d]    |-> x // d</pre>
        </td>
        <td><pre>QuotFrom >> [4, 7] == 1
QuotFrom(4) >> 7   == 1</pre></td>
    </tr>
    <tr>
        <td>[BitNot](\ref expr-b-not)
        </td>
        <td>~</td>
        <td>Bitwise not
        </td>
        <td><pre>BitNot >> 0b1010 == 0b0101</pre></td>
    </tr>
    <tr>
        <td>[BitAnd](\ref expr-b-and)
        </td>
        <td>&</td>
        <td>Bitwise and
        </td>
        <td><pre>BitAnd >> [0b1010, 0b1100] == 0b1000</pre></td>
    </tr>
    <tr>
        <td>[BitOr](\ref expr-b-or)
        </td>
        <td>|</td>
        <td>Bitwise or
        </td>
        <td><pre>BitOr >> [0b1010, 0b1100] == 0b1110</pre></td>
    </tr>
    <tr>
        <td>[BitXor](\ref expr-b-xor)
        </td>
        <td>^</td>
        <td>Bitwise xor
        </td>
        <td><pre>BitXor >> [0b1010, 0b1100] == 0b0110</pre></td>
    </tr>
    <tr>
        <td>[BitLshift](\ref expr-b-lshift)
        </td>
        <td><<</td>
        <td>Bitwise left shift
        <pre>1. [ ] |-> [x, s] |-> x << s
2. [s] |-> [x]    |-> x << s</pre>
        </td>
        <td><pre>BitLshift >> [0b1010, 2] == 0b101000</pre></td>
    </tr>
    <tr>
        <td>[BitLshiftFrom](\ref expr-b-lshift-from)
        </td>
        <td></td>
        <td>Reverse bitwise left shift
        <pre>Bitwise left shift with reverse arguments, i. e.
  1. [ ] |-> [s, x] |-> x << s
  2. [x] |-> [s]    |-> x << s</pre>
        </td>
        <td><pre>BitLshiftFrom >> [2, 0b1010] == 0b101000</pre></td>
    </tr>
    <tr>
        <td>[BitRshift](\ref expr-b-rshift)
        </td>
        <td>>></td>
        <td>Bitwise right shift
        <pre>1. [ ] |-> [x, s] |-> x >> s
2. [s] |-> [x]    |-> x >> s</pre>
        </td>
        <td><pre>BitRshift >> [0b1010, 2] == 0b0010</pre></td>
    </tr>
    <tr>
        <td>[BitRshiftFrom](\ref expr-b-rshift-from)
        </td>
        <td></td>
        <td>Reverse bitwise right shift
        <pre>Bitwise right shift with reverse arguments, i. e.
  1. [ ] |-> [s, x] |-> x >> s
  2. [x] |-> [s]    |-> x >> s</pre>
        </td>
        <td><pre>BitRshiftFrom >> [2, 0b1010] == 0b0010</pre></td>
    </tr>

## Relation Operators {#expression-dsl-reference-relation-operators}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Eq](\ref expr-eq)
        </td>
        <td>=</td>
        <td>Is equal
        </td>
        <td><pre>Eq >> [1, 1] == true
Eq(42) >> 41 == false</pre></td>
    </tr>
    <tr>
        <td>[Ne](\ref expr-ne)
        </td>
        <td>≠</td>
        <td>Not equal
        </td>
        <td><pre>Ne >> [1, 2] == true
Ne(42) >> 42 == false</pre></td>
    </tr>
    <tr>
        <td>[Lt](\ref expr-lt)
        </td>
        <td><</td>
        <td>Lesser than
        </td>
        <td><pre>Lt >> [1, 2] == true
Lt(42) >> 41 == false</pre></td>
    </tr>
    <tr>
        <td>[Le](\ref expr-le)
        </td>
        <td>≤</td>
        <td>Lesser or equal
        </td>
        <td><pre>Le >> [1, 2] == true
Le(42) >> 42 == true</pre></td>
    </tr>
    <tr>
        <td>[Gt](\ref expr-gt)
        </td>
        <td>></td>
        <td>Greater than
        </td>
        <td><pre>Gt >> [2, 1] == true
Gt(42) >> 43 == false</pre></td>
    </tr>
    <tr>
        <td>[Ge](\ref expr-ge)
        </td>
        <td>≥</td>
        <td>Greater or equal
        </td>
        <td><pre>Ge >> [2, 1] == true
Ge(42) >> 42 == true</pre></td>
    </tr>
    <tr>
        <td>[Approx](\ref expr-approx)
        </td>
        <td></td>
        <td>Floating point approximately equal
        <pre>Based on numpy.isclose: abs(x - ref) <= (atol + rtol * abs(ref))

Rhs parameters:
  ref: reference value
  rtol: relative tolerance, default = 1e-05
  atol: absolute tolerance, default = 1e-08

Rhs dynamic evaluation:
  1. ref                -> [ref, default, default]
  2. [ref]              -> [ref, default, default]
  3. [ref, rtol]        -> [ref, rtol   , default]
  4. [ref, rtol, atol]  -> [ref, rtol   , atol   ]</pre>
        <br>Aliases: near
        </td>
        <td><pre>Approx >> [42, 42] == true
Approx(42.0 + 1e-09) >> 42 == true
Approx(42.001) >> 42 == false

Relative tolerance 1e-03
Approx([3.14, 0.001]) >> pi == true
Absolute tolerance 0.01
Approx([3.14, 0, 0.01]) >> pi == true</pre></td>
    </tr>

## Set Operators {#expression-dsl-reference-set-operators}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Union](\ref expr-union)
        </td>
        <td>∪</td>
        <td>Set union
        </td>
        <td><pre>Union >> [[1, 2], [2, 3]] == [1, 2, 3]
Union([2, 3]) >> [1, 2] == [1, 2, 3]</pre></td>
    </tr>
    <tr>
        <td>[Intersect](\ref expr-intersect)
        </td>
        <td>∩</td>
        <td>Set intersection
        </td>
        <td><pre>Intersect >> [[1, 2], [2, 3]] == [2]
Intersect([2, 3]) >> [1, 2] == [2]</pre></td>
    </tr>
    <tr>
        <td>[Diff](\ref expr-set-diff)
        </td>
        <td></td>
        <td>Set difference
        </td>
        <td><pre>Diff >> [[1, 2], [2, 3]] == [1]
Diff([2, 3]) >> [1, 2] == [1]</pre></td>
    </tr>
    <tr>
        <td>[DiffFrom](\ref expr-set-diff-from)
        </td>
        <td></td>
        <td>Reverse set difference
        </td>
        <td><pre>DiffFrom >> [[1, 2], [2, 3]] == [3]
DiffFrom([2, 3]) >> [1, 2] == [3]</pre></td>
    </tr>

## Set Relation Operators {#expression-dsl-reference-set-relation-operators}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[SetEq](\ref expr-set-eq)
        </td>
        <td>≡</td>
        <td>Equal as set
        </td>
        <td><pre>SetEq >> [[1, 2], [2, 1]] == true
SetEq([2, 1]) >> [1, 2] == true</pre></td>
    </tr>
    <tr>
        <td>[Subset](\ref expr-subset)
        </td>
        <td>⊆</td>
        <td>Is subset
        </td>
        <td><pre>Subset >> [[1, 2], [1, 2, 3]] == true
Subset([1, 2, 3]) >> [1, 2] == true

Subset >> [[1, 2, 3], [2, 3]] == false
Subset([2, 3]) >> [1, 2, 3] == false

Subset >> [[1, 2], []] == true
Subset >> [[], []] == true</pre></td>
    </tr>
    <tr>
        <td>[Superset](\ref expr-superset)
        </td>
        <td>⊇</td>
        <td>Is superset
        </td>
        <td><pre>Superset >> [[1, 2, 3], [1, 2]] == true
Superset([1, 2]) >> [1, 2, 3] == true

Superset >> [[2, 3], [1, 2, 3]] == false
Superset([1, 2, 3]) >> [2, 3] == false

Superset >> [[], [1, 2]] == true
Superset >> [[], []] == true</pre></td>
    </tr>
    <tr>
        <td>[ProperSubset](\ref expr-p-subset)
        </td>
        <td>⊂</td>
        <td>Is proper subset
        </td>
        <td><pre>ProperSubset >> [[1, 2], [1, 2, 3]] == true
ProperSubset([1, 2, 3]) >> [1, 2] == true

ProperSubset >> [[1, 2, 3], [2, 3]] == false
ProperSubset([2, 3]) >> [1, 2, 3] == false

ProperSubset >> [[1, 2], []] == true
ProperSubset >> [[], []] == false</pre></td>
    </tr>
    <tr>
        <td>[ProperSuperset](\ref expr-p-superset)
        </td>
        <td>⊃</td>
        <td>Is proper superset
        </td>
        <td><pre>ProperSuperset >> [[1, 2, 3], [1, 2]] == true
ProperSuperset([1, 2]) >> [1, 2, 3] == true

ProperSuperset >> [[2, 3], [1, 2, 3]] == false
ProperSuperset([1, 2, 3]) >> [2, 3] == false

ProperSuperset >> [[], [1, 2]] == true
ProperSuperset >> [[], []] == false</pre></td>
    </tr>
    <tr>
        <td>[In](\ref expr-in)
        </td>
        <td>∈</td>
        <td>Element is in
        </td>
        <td><pre>In >> [1, [1, 2]] == true
In([1, 2]) >> 3 == false</pre></td>
    </tr>
    <tr>
        <td>[NotIn](\ref expr-not-in)
        </td>
        <td>∉</td>
        <td>Element is not in
        </td>
        <td><pre>NotIn >> [3, [1, 2]] == true
NotIn([1, 2]) >> 1 == false</pre></td>
    </tr>
    <tr>
        <td>[Ni](\ref expr-ni)
        </td>
        <td>∋</td>
        <td>Contains element
        <br>Aliases: contains
        </td>
        <td><pre>Ni >> [[1, 2], 1] == true
Ni([1, 2]) >> 3 == false</pre></td>
    </tr>
    <tr>
        <td>[NotNi](\ref expr-not-ni)
        </td>
        <td>∌</td>
        <td>Not contains element
        </td>
        <td><pre>NotNi >> [[1, 2], 3] == true
NotNi([1, 2]) >> 1 == false</pre></td>
    </tr>

## Branching Operators {#expression-dsl-reference-branching-operators}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Bool](\ref expr-bool)
        </td>
        <td>?</td>
        <td>Predicate on boolean transform (aka truthy)
        </td>
        <td><pre>Bool >> 42 == true
Bool >> 0 == false
Bool >> "false" == true
Bool >> "" == false
Bool >> [1] == true
Bool >> [] == false
Bool >> {} == false
Bool >> null == false</pre></td>
    </tr>
    <tr>
        <td>[Nil](\ref expr-nil)
        </td>
        <td></td>
        <td>Predicate on boolean transform (aka falsy)
        </td>
        <td><pre>Nil >> 42 == false
Nil >> 0 == true</pre></td>
    </tr>
    <tr>
        <td>[Not](\ref expr-not)
        </td>
        <td>¬</td>
        <td>Logical complement
        </td>
        <td><pre>Not >> true == false
Not >> false == true</pre></td>
    </tr>
    <tr>
        <td>[And](\ref expr-and)
        </td>
        <td>∧</td>
        <td>Logical and
        <pre>Generic behavior:
  if first operand is truthy, returns second operand, otherwise first</pre>
        </td>
        <td><pre>And >> [true, false] == false
And >> [true, true] == true

Generic behavior:
And >> ["foo", [42, 43]] == [42, 43]
And >> [""   , [42, 43]] == ""

And(42) >> 13 == 42
And(42) >> [] == []

If-Else using composition:
And(42)|Or(13) >> true  == 42
And(42)|Or(13) >> false == 13</pre></td>
    </tr>
    <tr>
        <td>[Or](\ref expr-or)
        </td>
        <td>∨</td>
        <td>Logical or
        <pre>Generic behavior:
  if first operand is truthy, returns first operand, second otherwise</pre>
        </td>
        <td><pre>Or >> [true, false] == true
Or >> [false, false] == false

Generic behavior:
Or >> ["foo", [42, 43]] == "foo"
Or >> [""   , [42, 43]] == [42, 43]

Or(42) >> 13 == 13
Or(42) >> [] == 42

If-Else using composition:
And(42)|Or(13) >> true  == 42
And(42)|Or(13) >> false == 13</pre></td>
    </tr>

## Unary Structural transforms {#expression-dsl-reference-unary-structural-transforms}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Id](\ref expr-id)
        </td>
        <td>Identity function
        </td>
        <td><pre>Id >> 42 == 42</pre></td>
    </tr>
    <tr>
        <td>[Transp](\ref expr-transp)
        </td>
        <td>Transpose multidimensional list, turning rows into columns
        <pre>May be used to zip sequences of equal length.</pre>
        </td>
        <td><pre>Transp >> [[1, 2, 3], [4, 5, 6]] == [[1, 4], [2, 5], [3, 6]]</pre></td>
    </tr>
    <tr>
        <td>[Cartesian](\ref expr-cartesian)
        </td>
        <td>Cartesian product
        </td>
        <td><pre>Cartesian >> [[1, 2], [3, 4]] == [[1, 3], [1, 4], [2, 3], [2, 4]]</pre></td>
    </tr>
    <tr>
        <td>[Reverse](\ref expr-reverse)
        </td>
        <td>Reverse sequence
        </td>
        <td><pre>Reverse >> [1, 2, 3] == [3, 2, 1]</pre></td>
    </tr>
    <tr>
        <td>[Uniques](\ref expr-uniques)
        </td>
        <td>Filter unique elements
        </td>
        <td><pre>Uniques >> [1, 2, 1, 3, 2] == [1, 2, 3]</pre></td>
    </tr>
    <tr>
        <td>[Items](\ref expr-items)
        </td>
        <td>Extract key-value pairs from object
        </td>
        <td><pre>Items >> {"a": 1, "b": 2} == [["a", 1], ["b", 2]]</pre></td>
    </tr>
    <tr>
        <td>[Keys](\ref expr-keys)
        </td>
        <td>Extract keys from object
        </td>
        <td><pre>Keys >> {"a": 1, "b": 2} == ["a", "b"]</pre></td>
    </tr>
    <tr>
        <td>[Values](\ref expr-values)
        </td>
        <td>Extract values from object
        </td>
        <td><pre>Values >> {"a": 1, "b": 2} == [1, 2]</pre></td>
    </tr>
    <tr>
        <td>[Enumerate](\ref expr-enumerate)
        </td>
        <td>Enumerate sequence
        <pre>Enumerate sequence with index.</pre>
        </td>
        <td><pre>Enumerate >> [1, 2, 3] == [[0, 1], [1, 2], [2, 3]]</pre></td>
    </tr>
    <tr>
        <td>[Flatten](\ref expr-flatten)
        </td>
        <td>Flatten nested list
        </td>
        <td><pre>Flatten >> [[1, 2], [3, 4]] == [1, 2, 3, 4]</pre></td>
    </tr>

## Unary Generators {#expression-dsl-reference-unary-generators}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Arange](\ref expr-arange)
        </td>
        <td>Generate range of numbers
        <pre>Return evenly spaced values within a given interval.

Parameters:
  1. start: start value
  2. stop: stop value
  3. step: step value

Parameters dynamic evaluation:
  1. stop: int            -> [0, stop, 1]
  2. [start, stop]        -> [start, stop, 1]
  3. [start, stop, step]  -> [start, stop, step]</pre>
        </td>
        <td><pre>Arange >> 6 == [0,1,2,3,4,5]
Arange >> [2,6]     == [2,3,4,5]
Arange >> [1,9,2]   == [1,3,5,7]
Arange >> [5,1,-1]  == [5,4,3,2]

Arange >> "2:6"     == [2,3,4,5]
Arange >> "1:9:2"   == [1,3,5,7]
Arange >> "5:1:-1"  == [5,4,3,2]</pre></td>
    </tr>

## String Transforms {#expression-dsl-reference-string-transforms}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Parse](\ref expr-parse)
        </td>
        <td>Parse string as json
        <br>Syntax: [Unary](\ref expression-dsl-forms)
        </td>
        <td><pre>Parse >> '{"a": 42}' == {"a": 42}</pre></td>
    </tr>
    <tr>
        <td>[Serialize](\ref expr-serialize)
        </td>
        <td>Serialize json as string
        <br>Aliases: str
        <br>Syntax: [Unary](\ref expression-dsl-forms)
        </td>
        <td><pre>Serialize >> {"a": 42} == '{"a":42}'</pre></td>
    </tr>
    <tr>
        <td>[Re](\ref expr-re)
        </td>
        <td>Regular expression match
        <pre>If input is not a string, match it's serialized form.</pre>
        <br>Aliases: regex
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Re >> ["[0-9]+", "42"] == true
Re("[0-9]+") >> "42" == true</pre></td>
    </tr>
    <tr>
        <td>[Format](\ref expr-format)
        </td>
        <td>Format string with given parameter list
        <br>Aliases: fmt
        <br>Syntax: [Variadic](\ref expression-dsl-forms)
        </td>
        <td><pre>Format >> ["Hello, %s!", ["world"]] == "Hello, world!"
Format(2,2,4) >> "%d + %d = %d" == "2 + 2 = 4"</pre></td>
    </tr>

## Structural properties {#expression-dsl-reference-structural-properties}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Card](\ref expr-card)
        </td>
        <td>Set cardinality (uniques count)
        <br>Syntax: [Unary](\ref expression-dsl-forms)
        </td>
        <td><pre>Card >> [1, 2, 1, 3, 2] == 3
Card >> {"a": 1, "b": 2} == 2</pre></td>
    </tr>
    <tr>
        <td>[Size](\ref expr-size)
        </td>
        <td>Sequence size
        <br>Syntax: [Unary](\ref expression-dsl-forms)
        </td>
        <td><pre>Size >> [1, 1, 1] == 3
Size >> {"a": 1, "b": 2} == 2</pre></td>
    </tr>
    <tr>
        <td>[Sum](\ref expr-sum)
        </td>
        <td>Summation reduction
        <pre>Equivalent to Reduce(Add)</pre>
        <br>Syntax: [Unary](\ref expression-dsl-forms)
        </td>
        <td><pre>Sum >> [1, 2, 3] == 6</pre></td>
    </tr>
    <tr>
        <td>[Prod](\ref expr-prod)
        </td>
        <td>Multiplication reduction
        <pre>Equivalent to Reduce(Mul)</pre>
        <br>Syntax: [Unary](\ref expression-dsl-forms)
        </td>
        <td><pre>Prod >> [1, 2, 3] == 6</pre></td>
    </tr>
    <tr>
        <td>[Avg](\ref expr-avg)
        </td>
        <td>Arythmetic average
        <br>Syntax: [Unary](\ref expression-dsl-forms)
        </td>
        <td><pre>Avg >> [1, 2, 3] == 2</pre></td>
    </tr>

## Binary Structural transforms {#expression-dsl-reference-binary-structural-transforms}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Slide](\ref expr-slide)
        </td>
        <td>Sliding-window iteration
        <pre>Sliding window iteration by specified window width.</pre>
        </td>
        <td><pre>Slide(3) >> [1,2,3,4,5] == [[1,2,3],[2,3,4],[3,4,5]]</pre></td>
    </tr>
    <tr>
        <td>[Stride](\ref expr-stride)
        </td>
        <td>Striding iteration
        <pre>Striding iteration by specified step width.</pre>
        </td>
        <td><pre>Stride(2) >> [1,2,3,4,5] == [[1,3,5],[2,4]]</pre></td>
    </tr>
    <tr>
        <td>[Repeat](\ref expr-repeat)
        </td>
        <td>Repeat value in list
        </td>
        <td><pre>Repeat(3) >> 42 == [42, 42, 42]
Repeat(3)|Repeat(2) >> 1 == [[1,1,1],[1,1,1]]</pre></td>
    </tr>
    <tr>
        <td>[Concat](\ref expr-concat)
        </td>
        <td>Concatenate sequences
        </td>
        <td><pre>Concat >> [1, 2], [3, 4] == [1, 2, 3, 4]
Concat("World!") >> "Hello, " == "Hello, World!"</pre></td>
    </tr>
    <tr>
        <td>[Push](\ref expr-push)
        </td>
        <td>Push element into a front of sequence
        </td>
        <td><pre>Push >> [1, 2], 3 == [3, 1, 2]
Push(3) >> [1, 2] == [3, 1, 2]</pre></td>
    </tr>
    <tr>
        <td>[At](\ref expr-at)
        </td>
        <td>Transform json value with given query
        <pre>Query evaluation rules:
  1. q: int   |-> x: list  |-> x at index q (negative -> reverse)
  2. q: slice |-> x: list  |-> x[start:stop:step]
  3. q: str   |-> x: any   |-> x at JSON Pointer q
  4. q: list  |-> x: any   |-> [x at q1, x at q2, ...]
  5. {"key": q1, "$q2": q3, ...} |-> x: any |->
      { "key1": x at q1, "$(x at q2)": x at q3, ...}</pre>
        </td>
        <td><pre>• Index query:
At(2) >> [1, 2, 3] == 3
At(3) >> [1, 2, 3] == nullptr
At(0) >> 42 == nullptr

• JSON Pointer query:
At("")   >> "foo" == "foo"
At("/a") >> {"a": 42, "b": 13} == 42

• List query:
At(["/a", "/b"])  >> {"a": 42, "b": 13} == [42, 13]
At([""])          >> 42 ==  [42]

• Object query:
At({"f": "/a", "g": "/b"})  >> {"a": 42, "b": 13} == {"f": 42, "g": 13}
At({"$/b": "/a"})           >> {"a": 42, "b": 13} == {"13": 42}

• Slice query:
At("::2")     >> [1,2,3,4,5,6,7,8] == [1,3,5,7]
At("4:")      >> [1,2,3,4,5,6,7,8] == [5,6,7,8]
At("-1:0:-1") >> [1,2,3,4,5,6,7,8] == [8,7,6,5,4,3,2,1]</pre></td>
    </tr>

## High-Order {#expression-dsl-reference-high-order}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Reduce](\ref expr-reduce)
        </td>
        <td>Reduce sequence with binary operator
        <pre>To set specific initial value, use composition with Push, e.g.
Push(0)|Reduce(Add)

For reverse operatin, see Unfold</pre>
        <br>Aliases: fold
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Reduce(Add) >> [-1, 2, 3] ==  4
Reduce(Mul) >> [-1, 2, 3] == -6</pre></td>
    </tr>
    <tr>
        <td>[Map](\ref expr-map)
        </td>
        <td>Apply param expr to every element of sequence
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Map(Add(1)) >> [1, 2, 3] == [2, 3, 4]</pre></td>
    </tr>
    <tr>
        <td>[Filter](\ref expr-filter)
        </td>
        <td>Filter sequence by predicate param
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Filter(Gt(2)) >> [1, 2, 3, 4] == [3, 4]</pre></td>
    </tr>
    <tr>
        <td>[Count](\ref expr-count)
        </td>
        <td>Count matches by predicate param
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Count(Gt(2)) >> [1, 2, 3, 4] == 2</pre></td>
    </tr>
    <tr>
        <td>[Sort](\ref expr-sort)
        </td>
        <td>Sort list by key function
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Sort >> [3, 1, 2] == [1, 2, 3]
Sort(Id) >> [3, 1, 2] == [1, 2, 3]
Sort(Abs) >> [-3, 1, -2] == [1, -2, -3]
Sort|Reverse >> [3, 1, 2] == [3, 2, 1]</pre></td>
    </tr>
    <tr>
        <td>[Min](\ref expr-min)
        </td>
        <td>Min value by key function
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Min      >> [-3, 1, -2] ==  1
Min(Abs) >> [-3, 1, -2] == -3</pre></td>
    </tr>
    <tr>
        <td>[Max](\ref expr-max)
        </td>
        <td>Max value by key function
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Max      >> [-3, 1, -2] ==  1
Max(Abs) >> [-3, 1, -2] == -3</pre></td>
    </tr>
    <tr>
        <td>[Argmin](\ref expr-argmin)
        </td>
        <td>Min value index by key function
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Argmin      >> [-3, 1, -2] == 0
Argmin(Abs) >> [-3, 1, -2] == 1</pre></td>
    </tr>
    <tr>
        <td>[Argmax](\ref expr-argmax)
        </td>
        <td>Max value index by key function
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Argmax      >> [-3, 1, -2] == 1
Argmax(Abs) >> [-3, 1, -2] == 0</pre></td>
    </tr>
    <tr>
        <td>[Apply](\ref expr-apply)
        </td>
        <td>Apply expr to literal param
        <br>Syntax: [Ternary](\ref expression-dsl-forms)
        </td>
        <td><pre>Apply(Add(1), 42) >> null == 43

• Infix operator form (left shift):
(Add(1) << 42) ≡ Apply(Add(1), 42)</pre></td>
    </tr>
    <tr>
        <td>[Recur](\ref expr-recur)
        </td>
        <td>Apply recursion to parameter expr
        <br>Syntax: [Ternary](\ref expression-dsl-forms)
        </td>
        <td><pre>Recur(Add(1), 3)  >> 0 ==  3
Recur(Mul(-1), 3) >> 1 == -1</pre></td>
    </tr>
    <tr>
        <td>[Unfold](\ref expr-unfold)
        </td>
        <td>Put results of recursive fn call on initial value x into an array
        <br>Syntax: [Ternary](\ref expression-dsl-forms)
        </td>
        <td><pre>Unfold(Add(1), 3)  >> 0 ==  [0, 1, 2, 3]
Unfold(Mul(-1), 3) >> 1 ==  [1,-1, 1,-1]</pre></td>
    </tr>
    <tr>
        <td>[Bind](\ref expr-bind)
        </td>
        <td>!not implemented! bind design-time parameters
        <br>Syntax: [Variadic](\ref expression-dsl-forms)
        </td>
    </tr>
    <tr>
        <td>[Any](\ref expr-any)
        </td>
        <td>Match any predicate
        <br>Syntax: [Variadic](\ref expression-dsl-forms)
        </td>
        <td><pre>Any(Gt(2), Lt(0)) >> 3 == true
Any(Gt(2), Lt(0)) >> 0 == false</pre></td>
    </tr>
    <tr>
        <td>[All](\ref expr-all)
        </td>
        <td>Match all predicates
        <br>Syntax: [Variadic](\ref expression-dsl-forms)
        </td>
        <td><pre>All(Gt(2), Lt(0)) >> 3 == false
All(Gt(2), Lt(3)) >> 2.5 == true</pre></td>
    </tr>
    <tr>
        <td>[Saturate](\ref expr-saturate)
        </td>
        <td>Saturate matches in order
        <br>Syntax: [Variadic](\ref expression-dsl-forms)
        </td>
        <td><pre>Saturate(Gt(2), Lt(0)) >> 3 == true
Saturate(Gt(2), Lt(0)) >> 0 == false

Saturate(42, Mod(2)|0) >> [2,4,8,42,1,2] == true
Saturate(42, Mod(2)|0) >> [2,4,8,41,2]   == false
Saturate(42, Mod(2)|0) >> [2,4,8,42]     == false</pre></td>
    </tr>
    <tr>
        <td>[Compose](\ref expr-compose)
        </td>
        <td>Compose functions
        <br>Syntax: [Variadic](\ref expression-dsl-forms)
        </td>
        <td><pre>Compose(Add(1), Mul(2)) >> 3 == 7
Compose(Add(1), Mul(2)) >> 4 == 9

• Infix operator form (pipe):
Add(1)|Mul(2) ≡ Compose(Add(1), Mul(2))
Add(1)|Mul(2) >> 3 == 7</pre></td>
    </tr>
    <tr>
        <td>[Pack](\ref expr-pack)
        </td>
        <td>Pack results from enveloped functions into an array
        <pre>Allows to combine different properties in a single expression</pre>
        <br>Syntax: [Variadic](\ref expression-dsl-forms)
        </td>
        <td><pre>Pack(Reduce(Add), Size) >> [1,2,3] == [6,3]

• Infix operator form (ampersand):
Reduce(Add) & Size >> [1,2,3] == [6,3]
Reduce(Add) & Size | Div >> [1,2,3] == 2</pre></td>
    </tr>

## Evaluation handlers {#expression-dsl-reference-evaluation-handlers}
<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td>[Default](\ref expr-default)
        </td>
        <td>Return x if not null, else return default value
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Default(42) >> null == 42
Default(42) >> 13 == 13</pre></td>
    </tr>
    <tr>
        <td>[Try](\ref expr-try)
        </td>
        <td>Evaluate enveloped function and return result or null if it throws
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>Try(Add(1)) >> 42    == 43
Try(Add(1)) >> "foo" == null</pre></td>
    </tr>
    <tr>
        <td>[TryCatch](\ref expr-try-catch)
        </td>
        <td>Evaluate enveloped function and return result or error info if it throws
        <br>Syntax: [Binary](\ref expression-dsl-forms)
        </td>
        <td><pre>TryCatch(Div(0)) >> 42 == {
    "err": "zero division",
    "fn": ":div",
    "x": 42,
    "op":
    "zmbt::GenericSignalOperator"
}</pre></td>
    </tr>
</tbody></table>