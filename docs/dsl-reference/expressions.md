<!-- (c) Copyright 2025 Zenseact AB -->
<!-- SPDX-License-Identifier: Apache-2.0 -->
<!-- Autogenerated file - do not change!
    app: codegen.expr
    template: codegen/expr/templates/docs/dsl-reference/expressions.md

    How to update:
    1. Update the template
    2. Run `python -m codegen` in the project root
    3. Commit changes
-->

# Expression Language Reference


## Constants

### Noop

*Signature*: [Const](../user-guide/expressions.md#syntax)

*Aliases*: _

No operation

Returns true without input validation.
Used in place of matchers for uninteresting signals.


### Null

*Signature*: [Const](../user-guide/expressions.md#syntax)


Null value



### True

*Signature*: [Const](../user-guide/expressions.md#syntax)


Logical true



### False

*Signature*: [Const](../user-guide/expressions.md#syntax)


Logical false



### Pi

*Signature*: [Const](../user-guide/expressions.md#syntax)


Pi constant



### E

*Signature*: [Const](../user-guide/expressions.md#syntax)


Euler's number



### Inf

*Signature*: [Const](../user-guide/expressions.md#syntax)


Infinity



### Eps

*Signature*: [Const](../user-guide/expressions.md#syntax)


Machine epsilon



### NaN

*Signature*: [Const](../user-guide/expressions.md#syntax)


Not a number



### Thread

*Signature*: [Const](../user-guide/expressions.md#syntax)


Thread id

Not really a constant, but useful for
branching the test input conditions.



## Math Functions

### Sin

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Sinus function



### Cos

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Cosinus function



### Tan

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Tangens function



### Asin

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Arcsin function



### Acos

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Arccos function



### Atan

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Arctan function



### Sinh

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Hyperbolic sin



### Cosh

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Hyperbolic cos



### Tanh

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Hyperbolic tan



### Asinh

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Hyperbolic arcsin



### Acosh

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Hyperbolic arccos



### Atanh

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Hyperbolic arctan



### Exp

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Exponential (e^x)



### Erf

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Error function



### Erfc

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Error function complement



### Gamma

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Gamma function



### Abs

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Absolute value



### Ceil

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Ceil



### Floor

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Floor



### Round

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Round to nearest integer

Hint: To round to ndigits precision after the decimal point,
use `Mul(ndigits) | Round | Div(ndigits)` combo.


### Sqrt

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Square root



### Sign

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Sign




## Arithmetic Operators

### Neg

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Negate


*Examples*:

 * `42 | Neg `$\mapsto$` -42`

### Add

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Addition


*Examples*:

 * `[2, -1] | Add `$\mapsto$` 1`
 * `2 | Add(-1) `$\mapsto$` 1`

### Sub

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Subtraction


*Examples*:

 * `[2, 1] | Sub `$\mapsto$` -1`
 * `2 | Sub(1) `$\mapsto$` 1`

### Mul

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Multiplication


*Examples*:

 * `[2, 3] | Mul `$\mapsto$` 6`
 * `2 | Mul(3) `$\mapsto$` 6`

### Div

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Division

1. $[ ] \mapsto [x, y] \mapsto x / y$
2. $[y] \mapsto [x]    \mapsto x / y$

*Examples*:

 * `[6, 3] | Div `$\mapsto$` 2`
 * `6 | Div(3) `$\mapsto$` 2`

### Pow

*Signature*: [Binary](../user-guide/expressions.md#syntax)


To power

X to power p
  1. $[ ] \mapsto [x, p] \mapsto x^p$
  2. $[p] \mapsto [x]    \mapsto x^p$

*Examples*:

 * `[2, 3] | Pow `$\mapsto$` 8`
 * `2 | Pow(3) `$\mapsto$` 8`

### Log

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Logarithm

Logarithm with base b:
  1. $[ ] \mapsto [x, b] \mapsto log_b(x)$
  2. $[b] \mapsto [x]    \mapsto log_b(x)$

*Examples*:

 * `[8, 2] | Log `$\mapsto$` 3`
 * `8 | Log(2) `$\mapsto$` 3`

### Mod

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Modulo

Modulo of x:
  1. $[ ] \mapsto [x, m] \mapsto x % m$
  2. $[m] \mapsto [x]    \mapsto x % m$

*Examples*:

 * `[7, 4] | Mod `$\mapsto$` 3`
 * `7 | Mod(4) `$\mapsto$` 3`

### Quot

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Quotient

Quotient of x:
  1. $[ ] \mapsto [x, d] \mapsto x // d$
  2. $[d] \mapsto [x]    \mapsto x // d$

*Examples*:

 * `[7, 4] | Quot `$\mapsto$` 1`
 * `7 | Quot(4) `$\mapsto$` 1`

### BitNot

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Bitwise not


*Examples*:

 * `0b1010 | BitNot `$\mapsto$` 0b0101`

### BitAnd

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Bitwise and


*Examples*:

 * `[0b1010, 0b1100] | BitAnd `$\mapsto$` 0b1000`

### BitOr

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Bitwise or


*Examples*:

 * `[0b1010, 0b1100] | BitOr `$\mapsto$` 0b1110`

### BitXor

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Bitwise xor


*Examples*:

 * `[0b1010, 0b1100] | BitXor `$\mapsto$` 0b0110`

### Lshift

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Bitwise left shift

1. $[ ] \mapsto [x, s] \mapsto x \texttt{ << } s$
2. $[s] \mapsto [x]    \mapsto x \texttt{ << } s$

*Examples*:

 * `[0b1010, 2] | Lshift `$\mapsto$` 0b101000`

### Rshift

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Bitwise right shift

1. $[ ] ↦ [x, s] ↦ x \texttt{ >> } s$
2. $[s] ↦ [x]    ↦ x \texttt{ >> } s$

*Examples*:

 * `[0b1010, 2] | Rshift `$\mapsto$` 0b0010`


## Relation Operators

### Eq

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Is equal


*Examples*:

 * `[1, 1] | Eq `$\mapsto$` true`
 * `41 | Eq(42) `$\mapsto$` false`

### Ne

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Not equal


*Examples*:

 * `[1, 2] | Ne `$\mapsto$` true`
 * `42 | Ne(42) `$\mapsto$` false`

### Lt

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Lesser than


*Examples*:

 * `[1, 2] | Lt `$\mapsto$` true`
 * `41 | Lt(42) `$\mapsto$` false`

### Le

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Lesser or equal


*Examples*:

 * `[1, 2] | Le `$\mapsto$` true`
 * `42 | Le(42) `$\mapsto$` true`

### Gt

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Greater than


*Examples*:

 * `[2, 1] | Gt `$\mapsto$` true`
 * `43 | Gt(42) `$\mapsto$` false`

### Ge

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Greater or equal


*Examples*:

 * `[2, 1] | Ge `$\mapsto$` true`
 * `42 | Ge(42) `$\mapsto$` true`

### Near

*Signature*: [Binary](../user-guide/expressions.md#syntax)

*Aliases*: Approx

Floating point approximately equal

Based on numpy.isclose:
  abs(x - ref) <= (atol + rtol * abs(ref))

Rhs parameters:
  ref: reference value
  rtol: relative tolerance, default = 1e-05
  atol: absolute tolerance, default = 1e-08

Rhs dynamic evaluation:
  1. ref                -> [ref, default, default]
  2. [ref]              -> [ref, default, default]
  3. [ref, rtol]        -> [ref, rtol   , default]
  4. [ref, rtol, atol]  -> [ref, rtol   , atol   ]

*Examples*:

 * `[42, 42] | Approx `$\mapsto$` true`
 * `42 | Approx(42.0 + 1e-09) `$\mapsto$` true`
 * `42 | Approx(42.001) `$\mapsto$` false`

Relative tolerance 1e-03
 * `pi | Approx([3.14, 0.001]) `$\mapsto$` true`
Absolute tolerance 0.01
 * `pi | Approx([3.14, 0, 0.01]) `$\mapsto$` true`


## Set Operators

### Union

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Set union


*Examples*:

 * `[[1, 2], [2, 3]] | Union `$\mapsto$` [1, 2, 3]`
 * `[1, 2] | Union([2, 3]) `$\mapsto$` [1, 2, 3]`

### Intersect

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Set intersection


*Examples*:

 * `[[1, 2], [2, 3]] | Intersect `$\mapsto$` [2]`
 * `[1, 2] | Intersect([2, 3]) `$\mapsto$` [2]`

### Diff

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Set difference


*Examples*:

 * `[[1, 2], [2, 3]] | Diff `$\mapsto$` [1]`
 * `[1, 2] | Diff([2, 3]) `$\mapsto$` [1]`


## Set Relation Operators

### SetEq

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Equal as set


*Examples*:

 * `[[1, 2], [2, 1]] | SetEq `$\mapsto$` true`
 * `[1, 2] | SetEq([2, 1]) `$\mapsto$` true`

### Subset

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Is subset


*Examples*:

 * `[[1, 2], [1, 2, 3]] | Subset `$\mapsto$` true`
 * `[1, 2] | Subset([1, 2, 3]) `$\mapsto$` true`

 * `[[1, 2, 3], [2, 3]] | Subset `$\mapsto$` false`
 * `[1, 2, 3] | Subset([2, 3]) `$\mapsto$` false`

 * `[[1, 2], []] | Subset `$\mapsto$` true`
 * `[[], []] | Subset `$\mapsto$` true`

### Superset

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Is superset


*Examples*:

 * `[[1, 2, 3], [1, 2]] | Superset `$\mapsto$` true`
 * `[1, 2, 3] | Superset([1, 2]) `$\mapsto$` true`

 * `[[2, 3], [1, 2, 3]] | Superset `$\mapsto$` false`
 * `[2, 3] | Superset([1, 2, 3]) `$\mapsto$` false`

 * `[[], [1, 2]] | Superset `$\mapsto$` true`
 * `[[], []] | Superset `$\mapsto$` true`

### PSubset

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Is proper subset


*Examples*:

 * `[[1, 2], [1, 2, 3]] | PSubset `$\mapsto$` true`
 * `[1, 2] | PSubset([1, 2, 3]) `$\mapsto$` true`

 * `[[1, 2, 3], [2, 3]] | PSubset `$\mapsto$` false`
 * `[1, 2, 3] | PSubset([2, 3]) `$\mapsto$` false`

 * `[[1, 2], []] | PSubset `$\mapsto$` true`
 * `[[], []] | PSubset `$\mapsto$` false`

### PSuperset

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Is proper superset


*Examples*:

 * `[[1, 2, 3], [1, 2]] | PSuperset `$\mapsto$` true`
 * `[1, 2, 3] | PSuperset([1, 2]) `$\mapsto$` true`

 * `[[2, 3], [1, 2, 3]] | PSuperset `$\mapsto$` false`
 * `[2, 3] | PSuperset([1, 2, 3]) `$\mapsto$` false`

 * `[[], [1, 2]] | PSuperset `$\mapsto$` true`
 * `[[], []] | PSuperset `$\mapsto$` false`

### In

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Element is in


*Examples*:

 * `[1, [1, 2]] | In `$\mapsto$` true`
 * `3 | In([1, 2]) `$\mapsto$` false`

### NotIn

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Element is not in


*Examples*:

 * `[3, [1, 2]] | NotIn `$\mapsto$` true`
 * `1 | NotIn([1, 2]) `$\mapsto$` false`

### Ni

*Signature*: [Binary](../user-guide/expressions.md#syntax)

*Aliases*: Contains

Contains element


*Examples*:

 * `[[1, 2], 1] | Ni `$\mapsto$` true`
 * `3 | Ni([1, 2]) `$\mapsto$` false`

### NotNi

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Not contains element


*Examples*:

 * `[[1, 2], 3] | NotNi `$\mapsto$` true`
 * `1 | NotNi([1, 2]) `$\mapsto$` false`


## Branching Operators

### Bool

*Signature*: [Unary](../user-guide/expressions.md#syntax)

*Aliases*: Truthy

Predicate on boolean transform (aka truthy)


*Examples*:

 * `42 | Bool `$\mapsto$` true`
 * `0 | Bool `$\mapsto$` false`
 * `"false" | Bool `$\mapsto$` true`
 * `"" | Bool `$\mapsto$` false`
 * `[1] | Bool `$\mapsto$` true`
 * `[] | Bool `$\mapsto$` false`
 * `{} | Bool `$\mapsto$` false`
 * `null | Bool `$\mapsto$` false`

### Not

*Signature*: [Unary](../user-guide/expressions.md#syntax)

*Aliases*: Falsy, Nil

Logical complement


*Examples*:

 * `42 | Nil `$\mapsto$` false`
 * `0 | Nil `$\mapsto$` true`

### And

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Logical and

Generic behavior:
  if first operand is truthy,
  returns second operand, otherwise first

*Examples*:

 * `[true, false] | And `$\mapsto$` false`
 * `[true, true] | And `$\mapsto$` true`

**Generic behavior**:

 * `["foo", [42, 43]] | And `$\mapsto$` [42, 43]`
 * `[""   , [42, 43]] | And `$\mapsto$` ""`

 * `13 | And(42) `$\mapsto$` 42`
 * `[] | And(42) `$\mapsto$` []`

**If-Else using composition**:

 * `true | And(42) | Or(13) `$\mapsto$` 42`
 * `false | And(42) | Or(13) `$\mapsto$` 13`

### Or

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Logical or

Generic behavior:
  if first operand is truthy,
  returns first operand, second otherwise

*Examples*:

 * `[true, false] | Or `$\mapsto$` true`
 * `[false, false] | Or `$\mapsto$` false`

**Generic behavior**:

 * `["foo", [42, 43]] | Or `$\mapsto$` "foo"`
 * `[""   , [42, 43]] | Or `$\mapsto$` [42, 43]`

 * `13 | Or(42) `$\mapsto$` 13`
 * `[] | Or(42) `$\mapsto$` 42`

**If-Else using composition**:

 * `true | And(42) | Or(13) `$\mapsto$` 42`
 * `false | And(42) | Or(13) `$\mapsto$` 13`


## Unary Structural transforms

### Id

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Identity function


*Examples*:

 * `42 | Id `$\mapsto$` 42`

### Transp

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Transpose multidimensional list, turning rows into columns

May be used to zip sequences of equal length.

*Examples*:

 * `[[1, 2, 3], [4, 5, 6]] | Transp `$\mapsto$` [[1, 4], [2, 5], [3, 6]]`

### Cartesian

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Cartesian product


*Examples*:

 * `[[1, 2], [3, 4]] | Cartesian `$\mapsto$` [[1, 3], [1, 4], [2, 3], [2, 4]]`

### Reverse

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Reverse sequence


*Examples*:

 * `[1, 2, 3] | Reverse `$\mapsto$` [3, 2, 1]`

### Uniques

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Filter unique elements


*Examples*:

 * `[1, 2, 1, 3, 2] | Uniques `$\mapsto$` [1, 2, 3]`

### Items

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Extract key-value pairs from object


*Examples*:

 * `{"a": 1, "b": 2} | Items `$\mapsto$` [["a", 1], ["b", 2]]`

### Keys

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Extract keys from object


*Examples*:

 * `{"a": 1, "b": 2} | Keys `$\mapsto$` ["a", "b"]`

### Values

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Extract values from object


*Examples*:

 * `{"a": 1, "b": 2} | Values `$\mapsto$` [1, 2]`

### Enumerate

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Enumerate sequence

Enumerate sequence with index.

*Examples*:

 * `[1, 2, 3] | Enumerate `$\mapsto$` [[0, 1], [1, 2], [2, 3]]`

### Flatten

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Flatten nested list


*Examples*:

 * `[[1, 2], [3, 4]] | Flatten `$\mapsto$` [1, 2, 3, 4]`

### ToList

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Put argument into a list

Equivalent to At([""])

*Examples*:

 * `42 | List `$\mapsto$` [42]`


## Unary Generators

### Arange

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Generate range of numbers

Return evenly spaced values within a given interval.

Parameters:
  1. start: start value
  2. stop: stop value
  3. step: step value

Parameters dynamic evaluation:
  1. stop: int            -> [0, stop, 1]
  2. [start, stop]        -> [start, stop, 1]
  3. [start, stop, step]  -> [start, stop, step]

*Examples*:

 * `6 | Arange `$\mapsto$` [0,1,2,3,4,5]`
 * `[2,6] | Arange `$\mapsto$` [2,3,4,5]`
 * `[1,9,2] | Arange `$\mapsto$` [1,3,5,7]`
 * `[5,1,-1] | Arange `$\mapsto$` [5,4,3,2]`

 * `"2:6" | Arange `$\mapsto$` [2,3,4,5]`
 * `"1:9:2" | Arange `$\mapsto$` [1,3,5,7]`
 * `"5:1:-1" | Arange `$\mapsto$` [5,4,3,2]`


## String Transforms

### Parse

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Parse string as json


*Examples*:

 * `'{"a": 42}' | Parse `$\mapsto$` {"a": 42}`

### Str

*Signature*: [Unary](../user-guide/expressions.md#syntax)

*Aliases*: Serialize

Serialize json as string


*Examples*:

 * `{"a": 42} | Serialize `$\mapsto$` '{"a":42}'`

### Re

*Signature*: [Binary](../user-guide/expressions.md#syntax)

*Aliases*: Regex

Regular expression match

If input is not a string, match it's serialized form.

*Examples*:

 * `["[0-9]+", "42"] | Re `$\mapsto$` true`
 * `"42" | Re("[0-9]+") `$\mapsto$` true`

### Fmt

*Signature*: [Variadic](../user-guide/expressions.md#syntax)

*Aliases*: Format

Format string with the given parameter list.

Constant expressions are supported for the token list,
s.t. "%s" | Fmt(Pi)  produces "3.141592653589793E0"

*Examples*:

 * `["Hello, %s!", ["world"]] | Format `$\mapsto$` "Hello, world!"`
 * `"%d + %d = %d" | Format(2,2,4) `$\mapsto$` "2 + 2 = 4"`


## Structural properties

### Card

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Set cardinality (uniques count)


*Examples*:

 * `[1, 2, 1, 3, 2] | Card `$\mapsto$` 3`
 * `{"a": 1, "b": 2} | Card `$\mapsto$` 2`

### Size

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Sequence size


*Examples*:

 * `[1, 1, 1] | Size `$\mapsto$` 3`
 * `{"a": 1, "b": 2} | Size `$\mapsto$` 2`

### Sum

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Summation reduction

Equivalent to Reduce(Add)

*Examples*:

 * `[1, 2, 3] | Sum `$\mapsto$` 6`

### Prod

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Multiplication reduction

Equivalent to Reduce(Mul)

*Examples*:

 * `[1, 2, 3] | Prod `$\mapsto$` 6`

### Avg

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Arythmetic average


*Examples*:

 * `[1, 2, 3] | Avg `$\mapsto$` 2`


## Binary Structural transforms

### Slide

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Sliding-window iteration

Sliding window iteration by specified window width.

*Examples*:

 * `[1,2,3,4,5] | Slide(3) `$\mapsto$` [[1,2,3],[2,3,4],[3,4,5]]`
 * `[1,2,3,4,5] | Slide(42) `$\mapsto$` []`

### Stride

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Striding iteration

Striding iteration by specified step width.
Reminder subsequence smaller then step width is discarded.

*Examples*:

 * `[1,2,3,4,5,6] | Stride(2) `$\mapsto$` [[1,2],[3,4],[5,6]]`
 * `[1,2,3,4,5] | Stride(3) `$\mapsto$` [[1,2,3]]`

### Chunks

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Split into chunks of specified max width

Similar to Stride, but includes the last subsequence
smaller then step width.

*Examples*:

 * `[1,2,3,4,5,6] | Chunks(2) `$\mapsto$` [[1,2],[3,4],[5,6]]`
 * `[1,2,3,4,5] | Chunks(3) `$\mapsto$` [[1,2,3],[4,5]]`

### Repeat

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Repeat value in list


*Examples*:

 * `42 | Repeat(3) `$\mapsto$` [42, 42, 42]`
 * `1 | Repeat(3) | Repeat(2) `$\mapsto$` [[1,1,1],[1,1,1]]`

### Cat

*Signature*: [Binary](../user-guide/expressions.md#syntax)

*Aliases*: Concat

Concatenate sequences


*Examples*:

 * `[[1, 2], [3, 4]] | Concat `$\mapsto$` [1, 2, 3, 4]`
 * `"Hello, " | Concat("World!") `$\mapsto$` "Hello, World!"`

### Push

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Push element into a front of sequence


*Examples*:

 * `[[1, 2], 3] | Push `$\mapsto$` [3, 1, 2]`
 * `[1, 2] | Push(3) `$\mapsto$` [3, 1, 2]`

### At

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Transform json value with given query

Query evaluation rules:

  1. Structure index (negative resolves as reverse): $q: int   \mapsto x: list  \mapsto x_q$
  2. Array slice: $q: slice \mapsto x: list  \mapsto x[start:stop:step]$
  3. JSON Pointer: $q: str   \mapsto x: any   \mapsto x_q$
  4. Array pack: $q: list  \mapsto x: any   \mapsto [x_{q_1}, x_{q_2}, ...]$
  5. Object pack:
    $\{key: q_1, \$q_2: q_3, ...\} \mapsto x: any \mapsto \{ key: x_{q_1}, q_2: x_{q_3}, ...\}$

  Structure index is evaluated as array index or as key-value pair index for objects
  on order-preserving backends.

  Result is null if requested element not found.

*Examples*:

**Array index**:

 * `[1, 2, 3] | At(2) `$\mapsto$` 3`
 * `[1, 2, 3] | At(3) `$\mapsto$` nullptr`
 * `42 | At(0) `$\mapsto$` nullptr`

**Array slice**:

 * `[1,2,3,4,5,6,7,8] | At("::2")     `$\mapsto$` [1,3,5,7]`
 * `[1,2,3,4,5,6,7,8] | At("4:")      `$\mapsto$` [5,6,7,8]`
 * `[1,2,3,4,5,6,7,8] | At("-1:0:-1") `$\mapsto$` [8,7,6,5,4,3,2,1]`

**JSON Pointer**:

 * `"foo" | At("")   `$\mapsto$` "foo"`
 * `{"a": 42, "b": 13} | At("/a") `$\mapsto$` 42`

**Array pack**:

 * `{"a": 42, "b": 13} | At(["/a", "/b"])  `$\mapsto$` [42, 13]`
 * `42 | At([""])          `$\mapsto$`  [42]`

**Object pack**:

 * `{"a": 42, "b": 13} | At({"f": "/a", "g": "/b"})  `$\mapsto$` {"f": 42, "g": 13}`
 * `{"a": 42, "b": 13} | At({"$/b": "/a"})           `$\mapsto$` {"13": 42}`

### Del

*Signature*: [Binary](../user-guide/expressions.md#syntax)

*Aliases*: Delete

Delete elements from structure by given query

Possible queries:
  1. Structure index (negative resolves as reverse)
  2. JSON Pointer
  3. List of queries

Structure index is evaluated as array index or as key-value pair index for objects
  on order-preserving backends.
When deleting an object element, resulting items order may change.

*Examples*:

 * `[1,2,3,4,5] | Del(2) `$\mapsto$` [1,2,4,5]`
 * `[[1, 2], 3] | Del("/0/1") `$\mapsto$` [[1], 3]`
 * `{"a": {"b": [1,2,3]}} | Del({"/a/b/0", "/a/b/1"}) `$\mapsto$` {"a": {"b": [3]}}`

### Lookup

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Lookup table function

Parametrized at design time with fixed array or object,
produces the value at corresponding At query given
as eval-time argument.
Equivalent to ~At(...)

*Examples*:

 * `0 | Lookup([1,2,3]) `$\mapsto$`  1`
 * `"/foo" | Lookup([1,2,3]) `$\mapsto$`  null`

### Cast

*Signature*: [Special](../user-guide/expressions.md#syntax)

*Aliases*: Decorate

Reserialize decorated type as decorator



### Uncast

*Signature*: [Special](../user-guide/expressions.md#syntax)

*Aliases*: Undecorate

Reserialize decorator as decorated type




## High-Order

### Fold

*Signature*: [Binary](../user-guide/expressions.md#syntax)

*Aliases*: Reduce

Reduce sequence with binary operator

To set a specific initial value, use composition with Push, e.g.
`Push(0) | Fold(Add)`

For reverse operation, see Unfold

*Examples*:

 * `[-1, 2, 3] | Fold(Add) `$\mapsto$`  4`
 * `[-1, 2, 3] | Fold(Mul) `$\mapsto$` -6`

### Map

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Apply param expr to every element of sequence


*Examples*:

 * `[1, 2, 3] | Map(Add(1)) `$\mapsto$` [2, 3, 4]`

### Filter

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Filter sequence by predicate param


*Examples*:

 * `[1, 2, 3, 4] | Filter(Gt(2)) `$\mapsto$` [3, 4]`

### Count

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Count matches by predicate param


*Examples*:

 * `[1, 2, 3, 4] | Count(Gt(2)) `$\mapsto$` 2`

### Each

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Test predicate for each item in a sequence

Equivalent to `Count(p | Not) | Eq(0)`

*Examples*:

 * `[1, 2, 3, 4] | Each(Gt(2)) `$\mapsto$` false`
 * `[1, 2, 3, 4] | Slide(2) | Each(Lt) `$\mapsto$` true`

### Sort

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Sort list by key function


*Examples*:

 * `[3, 1, 2] | Sort `$\mapsto$` [1, 2, 3]`
 * `[3, 1, 2] | Sort(Id) `$\mapsto$` [1, 2, 3]`
 * `[-3, 1, -2] | Sort(Abs) `$\mapsto$` [1, -2, -3]`
 * `[3, 1, 2] | Sort | Reverse `$\mapsto$` [3, 2, 1]`

### Find

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Find the first element that satisfies given predicate


*Examples*:

 * `[-3, 1, -2] | Find(Ge(2)) `$\mapsto$`  nullptr`
 * `[-3, 1,  4] | Find(Ge(2)) `$\mapsto$`  4`

### FindPtr

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Find json pointer of the first element that satisfies given predicate


*Examples*:

 * `[-3, 1, -2] | FindPtr(Ge(2)) `$\mapsto$`  nullptr`
 * `[-3, 1,  4] | FindPtr(Ge(2)) `$\mapsto$`  "/2"`

### FindIdx

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Find index of the first element that satisfies given predicate

Similar to FindPtr, but will integer index or nullptr for non-indexable input.
Objects are processed as list of key-value pairs.

*Examples*:

 * `[-3, 1, -2] | FindIdx(Ge(2)) `$\mapsto$`  nullptr`
 * `[-3, 1,  4] | FindIdx(Ge(2)) `$\mapsto$`  2`

### Min

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Min value by key function


*Examples*:

 * `[-3, 1, -2] | Min      `$\mapsto$`  1`
 * `[-3, 1, -2] | Min(Abs) `$\mapsto$` -3`

### Max

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Max value by key function


*Examples*:

 * `[-3, 1, -2] | Max      `$\mapsto$`  1`
 * `[-3, 1, -2] | Max(Abs) `$\mapsto$` -3`

### Argmin

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Min value index by key function


*Examples*:

 * `[-3, 1, -2] | Argmin      `$\mapsto$` 0`
 * `[-3, 1, -2] | Argmin(Abs) `$\mapsto$` 1`

### Argmax

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Max value index by key function


*Examples*:

 * `[-3, 1, -2] | Argmax      `$\mapsto$` 1`
 * `[-3, 1, -2] | Argmax(Abs) `$\mapsto$` 0`

### Recur

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Apply recursion to parameter expr and initial value

Inference rules:

  - `n | Recur(x & f)` $\mapsto ◯ⁿ f(x)$, or
  - `Q(p) | Recur(x₀ & f)` $\mapsto x_k$, where

    - $x_{i+1} = f(x_i)$
    - $p(x_{i}) = \top \quad \forall i \le k$
    - $p(x_{i+1}) = \bot$ (exit condition)

*Examples*:

 * `0 | Recur(0 & Add(1))  `$\mapsto$`  3`
 * `3 | Recur(1 & Mul(-1)) `$\mapsto$` -1`

### Unfold

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Put results of recursive fn call on initial value into an array


Inference rules:

  - `n | Unfold(x & f)`$\mapsto [x_0, x_1, ...,  x_n]$, or
  - `Q(p) | Unfold(x₀ & f)` $\mapsto [x_0, x_1, ...,  x_k]$, where

    - $x_{i+1} = f(x_i)$
    - $p(x_{i}) = \top \quad \forall i \le k$
    - $p(x_{i+1}) = \bot$ (exit condition)

*Examples*:

 * `3 | Unfold(0 & Add(1)) `$\mapsto$`  [0, 1, 2, 3]`
 * `3 | Unfold(1 & Mul(-1)) `$\mapsto$`  [1,-1, 1,-1]`

### Op

*Signature*: [Special](../user-guide/expressions.md#syntax)

*Aliases*: Overload

Bind type-specific operator handler to function

Expression Op(op, f) instructs f to use op operator on
invocation instead of the default generic.

Operator parameter singleton can be referenced with a
string key or constructed in place using type<T> tag.

This operator handler is propagated downstream to all terminal
subexpression in `f`.
The result of `f(x)` is not decorated as type<T>.

*Examples*:

 * `[0.5, 2] | Op("complex", Add(1)) `$\mapsto$` [1.5, 2]`

### Bind

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Bind design-time parameters to function.


*Examples*:

 * `42 & Q(Add) | Bind `$\mapsto$` Add(42)`
 * `42 | Bind(F) | Bind(G) | Bind(H) `$\mapsto$`  H(G(F(42)))`

### Fn

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Inline named function

Expression `Fn(reference, expr)` creates a symbolic link to expr,
at the same time evaluating given arguments (inlining the expr).
The reference is avaliable in the evaluation context,
including in the expr itself (essentially enabling an arbitrary recursion).

**Infix operator form (left shift)**:

"$f" << E ≡ Fn("$f", E)

*Examples*:

x | ("$f" << Add(1)) | "$f"  | "$f" = x + 1 + 1 + 1

auto const factorial = "$f" << ("$x"
  | Assert(Ge(0))
  | Lt(2)
  | And(1)
  | Or("$x" & ("$x" | Sub(1) | "$f") | Mul)
);

### Link

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Symbolic binding of the input value

The capture is referenced by an arbitrary string preceded by dollar sign,
e.g. "$x".

On the first access it stores the input value in isolated expression context,
and returns it on each subsequent call.
It can't be reset after the first access.

The string after $ sign shall not be enclosed in [], {}, or (),
as those formats are reserved for internal usage.

*Examples*:

 * `42 | "$x" | Ge(0) | And("$x") | Or("$x" | Mul(-1)) `$\mapsto$` 42`
 * `-7 | "$x" | Ge(0) | And("$x") | Or("$x" | Mul(-1)) `$\mapsto$` 7`

### Any

*Signature*: [Variadic](../user-guide/expressions.md#syntax)


Match any predicate


*Examples*:

 * `3 | Any(Gt(2), Lt(0)) `$\mapsto$` true`
 * `0 | Any(Gt(2), Lt(0)) `$\mapsto$` false`

### All

*Signature*: [Variadic](../user-guide/expressions.md#syntax)


Match all predicates


*Examples*:

 * `3 | All(Gt(2), Lt(0)) `$\mapsto$` false`
 * `2.5 | All(Gt(2), Lt(3)) `$\mapsto$` true`

### Saturate

*Signature*: [Variadic](../user-guide/expressions.md#syntax)


Saturate matches in order


*Examples*:

 * `3 | Saturate(Gt(2), Lt(0)) `$\mapsto$` true`
 * `0 | Saturate(Gt(2), Lt(0)) `$\mapsto$` false`

 * `[2,4,8,42,1,2] | Saturate(42, Mod(2)|0) `$\mapsto$` true`
 * `[2,4,8,41,2] | Saturate(42, Mod(2)|0) `$\mapsto$` false`
 * `[2,4,8,42] | Saturate(42, Mod(2)|0) `$\mapsto$` false`

### Pipe

*Signature*: [Variadic](../user-guide/expressions.md#syntax)


Pipe functions in left-to-right composition


*Examples*:

 * `3 | Pipe(Mul(2), Add(1)) `$\mapsto$` 7`
 * `4 | Pipe(Mul(2), Add(1)) `$\mapsto$` 9`

**Infix operator form (pipe)**:

 * `Add(1) | Mul(2) `$\equiv$` Pipe(Add(1), Mul(2))`
 * `3 | Add(1) | Mul(2) `$\mapsto$` 8`

### Tuple

*Signature*: [Variadic](../user-guide/expressions.md#syntax)


Pack expressions into an tuple without evaluation


*Examples*:

 * `null | Tuple(Reduce(Add), Size) `$\mapsto$` [Reduce(Add), Size]`

**Infix operator form (plus):**

 * `Add(1) + Mul(2) `$\equiv$` Tuple(Add(1), Mul(2))`

### Fork

*Signature*: [Variadic](../user-guide/expressions.md#syntax)


Pack results from enveloped functions into an array

Allows to combine different properties in a single expression.
Parameter

*Examples*:

 * `[1,2,3] | Fork(Reduce(Add), Size) `$\mapsto$` [6,3]`
 * `[1,2,3] | Fork(42, Card, Id) `$\mapsto$` [42, 3, [1,2,3]]`

**Infix operator form (ampersand):**

 * `Add(1) & Mul(2) `$\equiv$` Fork(Add(1), Mul(2))`
 * `[1,2,3] | Reduce(Add) & Size `$\mapsto$` [6,3]`
 * `[1,2,3] | Reduce(Add) & Size | Div `$\mapsto$` 2`

Note that the Fork is not associative,
therefore an infix operator chain is not unfolded
as it is done for variadic Pipe or Tuple:
 * `a & b & c `$\equiv$` (a & b) & c `$\equiv$` Fork(Fork(a, b), c)`

### Flip

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Flip design-time and eval-time parameters.

Useful for binding lhs operands to non-commutative
operators. Unlike Haskell's flip, won't change the
order or eval-time parameters - for that case use
the Reverse keyword instead.

**Prefix operator form (tilde)**:

Flip(Div(1)) ≡ ~Div(1)

*Examples*:

 * `2 | Div(1) `$\mapsto$` 2/1`
 * `2 | ~Div(1) `$\mapsto$` 1/2`

### Dbg

*Signature*: [Binary](../user-guide/expressions.md#syntax)

*Aliases*: Debug

Evaluate function and print evaluation log to stderr


*Examples*:

42 | Dbg(Trace(ZMBT_CUR_LOC) | Add(2))

### Eval

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Flip designtime and run-time parameters, evaluating input as expression



### Try

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Evaluate function and return result or null if it returns error


*Examples*:

 * `42 | Try(Add(1)) `$\mapsto$` 43`
 * `"foo" | Try(Add(1)) `$\mapsto$` null`

### Kwrd

*Signature*: [Unary](../user-guide/expressions.md#syntax)


Introspect expression keyword.


*Examples*:

 * `Q(Fold(Add)) | Kwrd `$\mapsto$` "Fold"`
 * `[1, 1, 1] | Kwrd `$\mapsto$` "Literal"`

### Prms

*Signature*: [Unary](../user-guide/expressions.md#syntax)

*Aliases*: Parameters

Introspect expression parameters.


*Examples*:

 * `Q(Fold(Add)) | Prms `$\mapsto$` Add`
 * `[1, 1, 1] | Prms `$\mapsto$` [1, 1, 1]`


## Evaluation handlers

### Q

*Signature*: [Binary](../user-guide/expressions.md#syntax)

*Aliases*: C, Const

Quote parameter, similar to lisp quotation.

Quotation lifts any parameter to constant, s.t.
produced expression will return the design-time parameter
on evaluation, ignoring input. If evaluable expression
is passed, it is returned unevaluated.
Unlike plain literals which can be treated
as predicate matchers in certain context, Q(x) is always
a constant expression discarding input.
~Q (Flip(Q)) is equivalent to Id.

*Examples*:

 * `null | C(42) `$\mapsto$` 42`

### D

*Signature*: [Binary](../user-guide/expressions.md#syntax)

*Aliases*: Default

Return x if not null, else return default value


*Examples*:

 * `null | Default(42) `$\mapsto$` 42`
 * `13 | Default(42) `$\mapsto$` 13`

### Err

*Signature*: [Special](../user-guide/expressions.md#syntax)

*Aliases*: Error

Error object

Error object handling the message and context info


### IsErr

*Signature*: [Unary](../user-guide/expressions.md#syntax)

*Aliases*: IsError

Test the argument is err expression



### Assert

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Return argument if it holds assertion or error otherwise.


*Examples*:

 * `42 | Assert(Ge(0)) `$\mapsto$` 42`
 * `-7 | Assert(Ge(0)) `$\mapsto$` Err("assertion failed", "-7 | Ge(0)")`

### Trace

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Same as id, but also prints identifier parameter to debug log.



### PreProc

*Signature*: [Binary](../user-guide/expressions.md#syntax)


Preprocessing token

String token that can be substituted with arbitrary expression
on expression preprocessing.

*Examples*:

 * `null | C(42) `$\mapsto$` 42`

