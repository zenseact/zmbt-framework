<!-- (c) Copyright 2025 Zenseact AB -->
<!-- SPDX-License-Identifier: Apache-2.0 -->
<!-- Autogenerated file - do not change!
    app: codegen.expr
    template: codegen/expr/templates/docs/dsl-reference/expressions.md

    How to update:
    1. Update the template
    2. Run `python -m codegen` in the project root
    3. Commit changes
-->

# Expression DSL Reference


## Constants

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Syntax</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="noop"> Noop
        </td>
        <td>No operation
        <pre>Returns true without input validation.
Used in place of matchers for uninteresting signals.</pre>
        <br>Aliases: _
        </td>
        <td><a href="/user-guide/expressions/#syntax">Const</a></td>
    </tr>
    <tr>
        <td><a id ="null"> Null
        </td>
        <td>Null value
        </td>
        <td><a href="/user-guide/expressions/#syntax">Const</a></td>
    </tr>
    <tr>
        <td><a id ="true"> True
        </td>
        <td>Logical true
        </td>
        <td><a href="/user-guide/expressions/#syntax">Const</a></td>
    </tr>
    <tr>
        <td><a id ="false"> False
        </td>
        <td>Logical false
        </td>
        <td><a href="/user-guide/expressions/#syntax">Const</a></td>
    </tr>
    <tr>
        <td><a id ="pi"> Pi
        </td>
        <td>Pi constant
        </td>
        <td><a href="/user-guide/expressions/#syntax">Const</a></td>
    </tr>
    <tr>
        <td><a id ="e"> E
        </td>
        <td>Euler's number
        </td>
        <td><a href="/user-guide/expressions/#syntax">Const</a></td>
    </tr>
    <tr>
        <td><a id ="inf"> Inf
        </td>
        <td>Infinity
        </td>
        <td><a href="/user-guide/expressions/#syntax">Const</a></td>
    </tr>
    <tr>
        <td><a id ="eps"> Eps
        </td>
        <td>Machine epsilon
        </td>
        <td><a href="/user-guide/expressions/#syntax">Const</a></td>
    </tr>
    <tr>
        <td><a id ="nan"> NaN
        </td>
        <td>Not a number
        </td>
        <td><a href="/user-guide/expressions/#syntax">Const</a></td>
    </tr>
</tbody></table>

## Math Functions

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Syntax</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="sin"> Sin
        </td>
        <td>Sinus
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="cos"> Cos
        </td>
        <td>Cosinus
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="tan"> Tan
        </td>
        <td>Tangens
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="asin"> Asin
        </td>
        <td>Arcsin
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="acos"> Acos
        </td>
        <td>Arccos
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="atan"> Atan
        </td>
        <td>Arctan
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="sinh"> Sinh
        </td>
        <td>Hyperbolic sin
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="cosh"> Cosh
        </td>
        <td>Hyperbolic cos
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="tanh"> Tanh
        </td>
        <td>Hyperbolic tan
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="asinh"> Asinh
        </td>
        <td>Hyperbolic arcsin
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="acosh"> Acosh
        </td>
        <td>Hyperbolic arccos
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="atanh"> Atanh
        </td>
        <td>Hyperbolic arctan
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="exp"> Exp
        </td>
        <td>Exponential (e^x)
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="erf"> Erf
        </td>
        <td>Error function
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="erfc"> Erfc
        </td>
        <td>Error function complement
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="gamma"> Gamma
        </td>
        <td>Gamma function
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="abs"> Abs
        </td>
        <td>Absolute value
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="ceil"> Ceil
        </td>
        <td>Ceil
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="floor"> Floor
        </td>
        <td>Floor
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="round"> Round
        </td>
        <td>Round to nearest integer
        <pre>Hint: To round to ndigits precision after the decimal point,
use Mul(ndigits)|Round|Div(ndigits) combo.</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="sqrt"> Sqrt
        </td>
        <td>Square root
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
    <tr>
        <td><a id ="sign"> Sign
        </td>
        <td>Sign
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
    </tr>
</tbody></table>

## Arithmetic Operators

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="neg"> Neg
        </td>
        <td></td>
        <td>Negate
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Neg >> 42 == -42</pre></td>
    </tr>
    <tr>
        <td><a id ="add"> Add
        </td>
        <td>+</td>
        <td>Addition
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Add >> [2, -1] == 1
Add(-1) >> 2  == 1</pre></td>
    </tr>
    <tr>
        <td><a id ="sub"> Sub
        </td>
        <td>-</td>
        <td>Subtraction
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Sub >> [2, 1] == -1
Sub(1) >> 2   == 1</pre></td>
    </tr>
    <tr>
        <td><a id ="mul"> Mul
        </td>
        <td>*</td>
        <td>Multiplication
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Mul >> [2, 3] == 6
Mul(3) >> 2   == 6</pre></td>
    </tr>
    <tr>
        <td><a id ="div"> Div
        </td>
        <td>/</td>
        <td>Division
        <pre>1. [ ] |-> [x, y] |-> x / y
2. [y] |-> [x]    |-> x / y</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Div >> [6, 3] == 2
Div(3) >> 6   == 2</pre></td>
    </tr>
    <tr>
        <td><a id ="pow"> Pow
        </td>
        <td></td>
        <td>To power
        <pre>X to power p
  1. [ ] |-> [x, p] |-> x^p
  2. [p] |-> [x]    |-> x^p</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Pow >> [2, 3] == 8
Pow(3) >> 2   == 8</pre></td>
    </tr>
    <tr>
        <td><a id ="log"> Log
        </td>
        <td></td>
        <td>Logarithm
        <pre>Logarithm with base b:
  1. [ ] |-> [x, b] |-> log_b(x)
  2. [b] |-> [x]    |-> log_b(x)</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Log >> [8, 2] == 3
Log(2) >> 8   == 3</pre></td>
    </tr>
    <tr>
        <td><a id ="mod"> Mod
        </td>
        <td>%</td>
        <td>Modulo
        <pre>Modulo of x:
  1. [ ] |-> [x, m] |-> x % m
  2. [m] |-> [x]    |-> x % m</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Mod >> [7, 4] == 3
Mod(4) >> 7   == 3</pre></td>
    </tr>
    <tr>
        <td><a id ="quot"> Quot
        </td>
        <td>//</td>
        <td>Quotient
        <pre>Quotient of x:
  1. [ ] |-> [x, d] |-> x // d
  2. [d] |-> [x]    |-> x // d</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Quot >> [7, 4] == 1
Quot(4) >> 7   == 1</pre></td>
    </tr>
    <tr>
        <td><a id ="bitnot"> BitNot
        </td>
        <td>~</td>
        <td>Bitwise not
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>BitNot >> 0b1010 == 0b0101</pre></td>
    </tr>
    <tr>
        <td><a id ="bitand"> BitAnd
        </td>
        <td>&</td>
        <td>Bitwise and
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>BitAnd >> [0b1010, 0b1100] == 0b1000</pre></td>
    </tr>
    <tr>
        <td><a id ="bitor"> BitOr
        </td>
        <td>|</td>
        <td>Bitwise or
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>BitOr >> [0b1010, 0b1100] == 0b1110</pre></td>
    </tr>
    <tr>
        <td><a id ="bitxor"> BitXor
        </td>
        <td>^</td>
        <td>Bitwise xor
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>BitXor >> [0b1010, 0b1100] == 0b0110</pre></td>
    </tr>
    <tr>
        <td><a id ="bitlshift"> BitLshift
        </td>
        <td><<</td>
        <td>Bitwise left shift
        <pre>1. [ ] |-> [x, s] |-> x << s
2. [s] |-> [x]    |-> x << s</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>BitLshift >> [0b1010, 2] == 0b101000</pre></td>
    </tr>
    <tr>
        <td><a id ="bitrshift"> BitRshift
        </td>
        <td>>></td>
        <td>Bitwise right shift
        <pre>1. [ ] |-> [x, s] |-> x >> s
2. [s] |-> [x]    |-> x >> s</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>BitRshift >> [0b1010, 2] == 0b0010</pre></td>
    </tr>
</tbody></table>

## Relation Operators

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="eq"> Eq
        </td>
        <td>=</td>
        <td>Is equal
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Eq >> [1, 1] == true
Eq(42) >> 41 == false</pre></td>
    </tr>
    <tr>
        <td><a id ="ne"> Ne
        </td>
        <td>≠</td>
        <td>Not equal
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Ne >> [1, 2] == true
Ne(42) >> 42 == false</pre></td>
    </tr>
    <tr>
        <td><a id ="lt"> Lt
        </td>
        <td><</td>
        <td>Lesser than
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Lt >> [1, 2] == true
Lt(42) >> 41 == false</pre></td>
    </tr>
    <tr>
        <td><a id ="le"> Le
        </td>
        <td>≤</td>
        <td>Lesser or equal
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Le >> [1, 2] == true
Le(42) >> 42 == true</pre></td>
    </tr>
    <tr>
        <td><a id ="gt"> Gt
        </td>
        <td>></td>
        <td>Greater than
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Gt >> [2, 1] == true
Gt(42) >> 43 == false</pre></td>
    </tr>
    <tr>
        <td><a id ="ge"> Ge
        </td>
        <td>≥</td>
        <td>Greater or equal
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Ge >> [2, 1] == true
Ge(42) >> 42 == true</pre></td>
    </tr>
    <tr>
        <td><a id ="approx"> Approx
        </td>
        <td></td>
        <td>Floating point approximately equal
        <pre>Based on numpy.isclose: abs(x - ref) <= (atol + rtol * abs(ref))

Rhs parameters:
  ref: reference value
  rtol: relative tolerance, default = 1e-05
  atol: absolute tolerance, default = 1e-08

Rhs dynamic evaluation:
  1. ref                -> [ref, default, default]
  2. [ref]              -> [ref, default, default]
  3. [ref, rtol]        -> [ref, rtol   , default]
  4. [ref, rtol, atol]  -> [ref, rtol   , atol   ]</pre>
        <br>Aliases: near
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Approx >> [42, 42] == true
Approx(42.0 + 1e-09) >> 42 == true
Approx(42.001) >> 42 == false

Relative tolerance 1e-03
Approx([3.14, 0.001]) >> pi == true
Absolute tolerance 0.01
Approx([3.14, 0, 0.01]) >> pi == true</pre></td>
    </tr>
</tbody></table>

## Set Operators

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="union"> Union
        </td>
        <td>∪</td>
        <td>Set union
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Union >> [[1, 2], [2, 3]] == [1, 2, 3]
Union([2, 3]) >> [1, 2] == [1, 2, 3]</pre></td>
    </tr>
    <tr>
        <td><a id ="intersect"> Intersect
        </td>
        <td>∩</td>
        <td>Set intersection
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Intersect >> [[1, 2], [2, 3]] == [2]
Intersect([2, 3]) >> [1, 2] == [2]</pre></td>
    </tr>
    <tr>
        <td><a id ="diff"> Diff
        </td>
        <td></td>
        <td>Set difference
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Diff >> [[1, 2], [2, 3]] == [1]
Diff([2, 3]) >> [1, 2] == [1]</pre></td>
    </tr>
</tbody></table>

## Set Relation Operators

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="seteq"> SetEq
        </td>
        <td>≡</td>
        <td>Equal as set
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>SetEq >> [[1, 2], [2, 1]] == true
SetEq([2, 1]) >> [1, 2] == true</pre></td>
    </tr>
    <tr>
        <td><a id ="subset"> Subset
        </td>
        <td>⊆</td>
        <td>Is subset
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Subset >> [[1, 2], [1, 2, 3]] == true
Subset([1, 2, 3]) >> [1, 2] == true

Subset >> [[1, 2, 3], [2, 3]] == false
Subset([2, 3]) >> [1, 2, 3] == false

Subset >> [[1, 2], []] == true
Subset >> [[], []] == true</pre></td>
    </tr>
    <tr>
        <td><a id ="superset"> Superset
        </td>
        <td>⊇</td>
        <td>Is superset
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Superset >> [[1, 2, 3], [1, 2]] == true
Superset([1, 2]) >> [1, 2, 3] == true

Superset >> [[2, 3], [1, 2, 3]] == false
Superset([1, 2, 3]) >> [2, 3] == false

Superset >> [[], [1, 2]] == true
Superset >> [[], []] == true</pre></td>
    </tr>
    <tr>
        <td><a id ="propersubset"> ProperSubset
        </td>
        <td>⊂</td>
        <td>Is proper subset
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>ProperSubset >> [[1, 2], [1, 2, 3]] == true
ProperSubset([1, 2, 3]) >> [1, 2] == true

ProperSubset >> [[1, 2, 3], [2, 3]] == false
ProperSubset([2, 3]) >> [1, 2, 3] == false

ProperSubset >> [[1, 2], []] == true
ProperSubset >> [[], []] == false</pre></td>
    </tr>
    <tr>
        <td><a id ="propersuperset"> ProperSuperset
        </td>
        <td>⊃</td>
        <td>Is proper superset
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>ProperSuperset >> [[1, 2, 3], [1, 2]] == true
ProperSuperset([1, 2]) >> [1, 2, 3] == true

ProperSuperset >> [[2, 3], [1, 2, 3]] == false
ProperSuperset([1, 2, 3]) >> [2, 3] == false

ProperSuperset >> [[], [1, 2]] == true
ProperSuperset >> [[], []] == false</pre></td>
    </tr>
    <tr>
        <td><a id ="in"> In
        </td>
        <td>∈</td>
        <td>Element is in
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>In >> [1, [1, 2]] == true
In([1, 2]) >> 3 == false</pre></td>
    </tr>
    <tr>
        <td><a id ="notin"> NotIn
        </td>
        <td>∉</td>
        <td>Element is not in
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>NotIn >> [3, [1, 2]] == true
NotIn([1, 2]) >> 1 == false</pre></td>
    </tr>
    <tr>
        <td><a id ="ni"> Ni
        </td>
        <td>∋</td>
        <td>Contains element
        <br>Aliases: contains
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Ni >> [[1, 2], 1] == true
Ni([1, 2]) >> 3 == false</pre></td>
    </tr>
    <tr>
        <td><a id ="notni"> NotNi
        </td>
        <td>∌</td>
        <td>Not contains element
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>NotNi >> [[1, 2], 3] == true
NotNi([1, 2]) >> 1 == false</pre></td>
    </tr>
</tbody></table>

## Branching Operators

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Symbol</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="bool"> Bool
        </td>
        <td>?</td>
        <td>Predicate on boolean transform (aka truthy)
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Bool >> 42 == true
Bool >> 0 == false
Bool >> "false" == true
Bool >> "" == false
Bool >> [1] == true
Bool >> [] == false
Bool >> {} == false
Bool >> null == false</pre></td>
    </tr>
    <tr>
        <td><a id ="nil"> Nil
        </td>
        <td></td>
        <td>Predicate on boolean transform (aka falsy)
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Nil >> 42 == false
Nil >> 0 == true</pre></td>
    </tr>
    <tr>
        <td><a id ="not"> Not
        </td>
        <td>¬</td>
        <td>Logical complement
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Not >> true == false
Not >> false == true</pre></td>
    </tr>
    <tr>
        <td><a id ="and"> And
        </td>
        <td>∧</td>
        <td>Logical and
        <pre>Generic behavior:
  if first operand is truthy, returns second operand, otherwise first</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>And >> [true, false] == false
And >> [true, true] == true

Generic behavior:
And >> ["foo", [42, 43]] == [42, 43]
And >> [""   , [42, 43]] == ""

And(42) >> 13 == 42
And(42) >> [] == []

If-Else using composition:
And(42)|Or(13) >> true  == 42
And(42)|Or(13) >> false == 13</pre></td>
    </tr>
    <tr>
        <td><a id ="or"> Or
        </td>
        <td>∨</td>
        <td>Logical or
        <pre>Generic behavior:
  if first operand is truthy, returns first operand, second otherwise</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Or >> [true, false] == true
Or >> [false, false] == false

Generic behavior:
Or >> ["foo", [42, 43]] == "foo"
Or >> [""   , [42, 43]] == [42, 43]

Or(42) >> 13 == 13
Or(42) >> [] == 42

If-Else using composition:
And(42)|Or(13) >> true  == 42
And(42)|Or(13) >> false == 13</pre></td>
    </tr>
</tbody></table>

## Unary Structural transforms

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="id"> Id
        </td>
        <td>Identity function
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Id >> 42 == 42</pre></td>
    </tr>
    <tr>
        <td><a id ="transp"> Transp
        </td>
        <td>Transpose multidimensional list, turning rows into columns
        <pre>May be used to zip sequences of equal length.</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Transp >> [[1, 2, 3], [4, 5, 6]] == [[1, 4], [2, 5], [3, 6]]</pre></td>
    </tr>
    <tr>
        <td><a id ="cartesian"> Cartesian
        </td>
        <td>Cartesian product
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Cartesian >> [[1, 2], [3, 4]] == [[1, 3], [1, 4], [2, 3], [2, 4]]</pre></td>
    </tr>
    <tr>
        <td><a id ="reverse"> Reverse
        </td>
        <td>Reverse sequence
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Reverse >> [1, 2, 3] == [3, 2, 1]</pre></td>
    </tr>
    <tr>
        <td><a id ="uniques"> Uniques
        </td>
        <td>Filter unique elements
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Uniques >> [1, 2, 1, 3, 2] == [1, 2, 3]</pre></td>
    </tr>
    <tr>
        <td><a id ="items"> Items
        </td>
        <td>Extract key-value pairs from object
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Items >> {"a": 1, "b": 2} == [["a", 1], ["b", 2]]</pre></td>
    </tr>
    <tr>
        <td><a id ="keys"> Keys
        </td>
        <td>Extract keys from object
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Keys >> {"a": 1, "b": 2} == ["a", "b"]</pre></td>
    </tr>
    <tr>
        <td><a id ="values"> Values
        </td>
        <td>Extract values from object
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Values >> {"a": 1, "b": 2} == [1, 2]</pre></td>
    </tr>
    <tr>
        <td><a id ="enumerate"> Enumerate
        </td>
        <td>Enumerate sequence
        <pre>Enumerate sequence with index.</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Enumerate >> [1, 2, 3] == [[0, 1], [1, 2], [2, 3]]</pre></td>
    </tr>
    <tr>
        <td><a id ="flatten"> Flatten
        </td>
        <td>Flatten nested list
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Flatten >> [[1, 2], [3, 4]] == [1, 2, 3, 4]</pre></td>
    </tr>
    <tr>
        <td><a id ="tolist"> ToList
        </td>
        <td>Put argument into a list
        <pre>Equivalent to `At([""])`</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>List >> 42 == [42]</pre></td>
    </tr>
</tbody></table>

## Unary Generators

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="arange"> Arange
        </td>
        <td>Generate range of numbers
        <pre>Return evenly spaced values within a given interval.

Parameters:
  1. start: start value
  2. stop: stop value
  3. step: step value

Parameters dynamic evaluation:
  1. stop: int            -> [0, stop, 1]
  2. [start, stop]        -> [start, stop, 1]
  3. [start, stop, step]  -> [start, stop, step]</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Arange >> 6 == [0,1,2,3,4,5]
Arange >> [2,6]     == [2,3,4,5]
Arange >> [1,9,2]   == [1,3,5,7]
Arange >> [5,1,-1]  == [5,4,3,2]

Arange >> "2:6"     == [2,3,4,5]
Arange >> "1:9:2"   == [1,3,5,7]
Arange >> "5:1:-1"  == [5,4,3,2]</pre></td>
    </tr>
</tbody></table>

## String Transforms

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="parse"> Parse
        </td>
        <td>Parse string as json
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Parse >> '{"a": 42}' == {"a": 42}</pre></td>
    </tr>
    <tr>
        <td><a id ="serialize"> Serialize
        </td>
        <td>Serialize json as string
        <br>Aliases: str
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Serialize >> {"a": 42} == '{"a":42}'</pre></td>
    </tr>
    <tr>
        <td><a id ="re"> Re
        </td>
        <td>Regular expression match
        <pre>If input is not a string, match it's serialized form.</pre>
        <br>Aliases: regex
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Re >> ["[0-9]+", "42"] == true
Re("[0-9]+") >> "42" == true</pre></td>
    </tr>
    <tr>
        <td><a id ="format"> Format
        </td>
        <td>Format string with given parameter list
        <br>Aliases: fmt
        </td>
        <td><a href="/user-guide/expressions/#syntax">Variadic</a></td>
        <td><pre>Format >> ["Hello, %s!", ["world"]] == "Hello, world!"
Format(2,2,4) >> "%d + %d = %d" == "2 + 2 = 4"</pre></td>
    </tr>
</tbody></table>

## Structural properties

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="card"> Card
        </td>
        <td>Set cardinality (uniques count)
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Card >> [1, 2, 1, 3, 2] == 3
Card >> {"a": 1, "b": 2} == 2</pre></td>
    </tr>
    <tr>
        <td><a id ="size"> Size
        </td>
        <td>Sequence size
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Size >> [1, 1, 1] == 3
Size >> {"a": 1, "b": 2} == 2</pre></td>
    </tr>
    <tr>
        <td><a id ="sum"> Sum
        </td>
        <td>Summation reduction
        <pre>Equivalent to Reduce(Add)</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Sum >> [1, 2, 3] == 6</pre></td>
    </tr>
    <tr>
        <td><a id ="prod"> Prod
        </td>
        <td>Multiplication reduction
        <pre>Equivalent to Reduce(Mul)</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Prod >> [1, 2, 3] == 6</pre></td>
    </tr>
    <tr>
        <td><a id ="avg"> Avg
        </td>
        <td>Arythmetic average
        </td>
        <td><a href="/user-guide/expressions/#syntax">Unary</a></td>
        <td><pre>Avg >> [1, 2, 3] == 2</pre></td>
    </tr>
</tbody></table>

## Binary Structural transforms

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="slide"> Slide
        </td>
        <td>Sliding-window iteration
        <pre>Sliding window iteration by specified window width.</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Slide(3) >> [1,2,3,4,5] == [[1,2,3],[2,3,4],[3,4,5]]</pre></td>
    </tr>
    <tr>
        <td><a id ="stride"> Stride
        </td>
        <td>Striding iteration
        <pre>Striding iteration by specified step width.</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Stride(2) >> [1,2,3,4,5] == [[1,3,5],[2,4]]</pre></td>
    </tr>
    <tr>
        <td><a id ="repeat"> Repeat
        </td>
        <td>Repeat value in list
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Repeat(3) >> 42 == [42, 42, 42]
Repeat(3)|Repeat(2) >> 1 == [[1,1,1],[1,1,1]]</pre></td>
    </tr>
    <tr>
        <td><a id ="concat"> Concat
        </td>
        <td>Concatenate sequences
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Concat >> [1, 2], [3, 4] == [1, 2, 3, 4]
Concat("World!") >> "Hello, " == "Hello, World!"</pre></td>
    </tr>
    <tr>
        <td><a id ="push"> Push
        </td>
        <td>Push element into a front of sequence
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Push >> [1, 2], 3 == [3, 1, 2]
Push(3) >> [1, 2] == [3, 1, 2]</pre></td>
    </tr>
    <tr>
        <td><a id ="at"> At
        </td>
        <td>Transform json value with given query
        <pre>Query evaluation rules:
  1. q: int   |-> x: list  |-> x at index q (negative -> reverse)
  2. q: slice |-> x: list  |-> x[start:stop:step]
  3. q: str   |-> x: any   |-> x at JSON Pointer q
  4. q: list  |-> x: any   |-> [x at q1, x at q2, ...]
  5. {"key": q1, "$q2": q3, ...} |-> x: any |->
      { "key1": x at q1, "$(x at q2)": x at q3, ...}</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>• Index query:
At(2) >> [1, 2, 3] == 3
At(3) >> [1, 2, 3] == nullptr
At(0) >> 42 == nullptr

• JSON Pointer query:
At("")   >> "foo" == "foo"
At("/a") >> {"a": 42, "b": 13} == 42

• List query:
At(["/a", "/b"])  >> {"a": 42, "b": 13} == [42, 13]
At([""])          >> 42 ==  [42]

• Object query:
At({"f": "/a", "g": "/b"})  >> {"a": 42, "b": 13} == {"f": 42, "g": 13}
At({"$/b": "/a"})           >> {"a": 42, "b": 13} == {"13": 42}

• Slice query:
At("::2")     >> [1,2,3,4,5,6,7,8] == [1,3,5,7]
At("4:")      >> [1,2,3,4,5,6,7,8] == [5,6,7,8]
At("-1:0:-1") >> [1,2,3,4,5,6,7,8] == [8,7,6,5,4,3,2,1]</pre></td>
    </tr>
    <tr>
        <td><a id ="lookup"> Lookup
        </td>
        <td>Lookup table function
        <pre>Parametrized at design time with fixed array or object,
produces the value at corresponding `At` query given
as eval-time argument.
Equivalent to `Flip(At(...))`</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Lookup([1,2,3]) >> 0 ==  1
Lookup([1,2,3]) >> "/foo" ==  null</pre></td>
    </tr>
    <tr>
        <td><a id ="c"> C
        </td>
        <td>User-defined constant
        <pre>Produced expression will return the design-time parameter
on evaluation, ignoring input.
C(x) is a shorthand for `Id << x` or `And(false)|Or(x)`</pre>
        <br>Aliases: let
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>C(42) >> 13 == 42</pre></td>
    </tr>
</tbody></table>

## High-Order

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="reduce"> Reduce
        </td>
        <td>Reduce sequence with binary operator
        <pre>To set specific initial value, use composition with Push, e.g.
Push(0)|Reduce(Add)

For reverse operation, see Unfold</pre>
        <br>Aliases: fold
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Reduce(Add) >> [-1, 2, 3] ==  4
Reduce(Mul) >> [-1, 2, 3] == -6</pre></td>
    </tr>
    <tr>
        <td><a id ="map"> Map
        </td>
        <td>Apply param expr to every element of sequence
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Map(Add(1)) >> [1, 2, 3] == [2, 3, 4]</pre></td>
    </tr>
    <tr>
        <td><a id ="filter"> Filter
        </td>
        <td>Filter sequence by predicate param
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Filter(Gt(2)) >> [1, 2, 3, 4] == [3, 4]</pre></td>
    </tr>
    <tr>
        <td><a id ="count"> Count
        </td>
        <td>Count matches by predicate param
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Count(Gt(2)) >> [1, 2, 3, 4] == 2</pre></td>
    </tr>
    <tr>
        <td><a id ="sort"> Sort
        </td>
        <td>Sort list by key function
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Sort >> [3, 1, 2] == [1, 2, 3]
Sort(Id) >> [3, 1, 2] == [1, 2, 3]
Sort(Abs) >> [-3, 1, -2] == [1, -2, -3]
Sort|Reverse >> [3, 1, 2] == [3, 2, 1]</pre></td>
    </tr>
    <tr>
        <td><a id ="min"> Min
        </td>
        <td>Min value by key function
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Min      >> [-3, 1, -2] ==  1
Min(Abs) >> [-3, 1, -2] == -3</pre></td>
    </tr>
    <tr>
        <td><a id ="max"> Max
        </td>
        <td>Max value by key function
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Max      >> [-3, 1, -2] ==  1
Max(Abs) >> [-3, 1, -2] == -3</pre></td>
    </tr>
    <tr>
        <td><a id ="argmin"> Argmin
        </td>
        <td>Min value index by key function
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Argmin      >> [-3, 1, -2] == 0
Argmin(Abs) >> [-3, 1, -2] == 1</pre></td>
    </tr>
    <tr>
        <td><a id ="argmax"> Argmax
        </td>
        <td>Max value index by key function
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Argmax      >> [-3, 1, -2] == 1
Argmax(Abs) >> [-3, 1, -2] == 0</pre></td>
    </tr>
    <tr>
        <td><a id ="apply"> Apply
        </td>
        <td>Apply expr to literal param
        </td>
        <td><a href="/user-guide/expressions/#syntax">Ternary</a></td>
        <td><pre>Apply(Add(1), 42) >> null == 43

• Infix operator form (left shift):
(Add(1) << 42) ≡ Apply(Add(1), 42)</pre></td>
    </tr>
    <tr>
        <td><a id ="recur"> Recur
        </td>
        <td>Apply recursion to parameter expr and initial value
        <pre>Recur(f, x) >> n = ◯ⁿ f(x)</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Ternary</a></td>
        <td><pre>Recur(Add(1), 0)  >> 0 ==  3
Recur(Mul(-1), 1) >> 3 == -1</pre></td>
    </tr>
    <tr>
        <td><a id ="unfold"> Unfold
        </td>
        <td>Put results of recursive fn call on initial value into an array
        <pre>Unfold(f, x) >> n = [x, ◯¹f(x), ◯²f(x), ...,  ◯ⁿ f(x)]</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Ternary</a></td>
        <td><pre>Unfold(Add(1),  0) >> 3 ==  [0, 1, 2, 3]
Unfold(Mul(-1), 1) >> 3 ==  [1,-1, 1,-1]</pre></td>
    </tr>
    <tr>
        <td><a id ="bind"> Bind
        </td>
        <td>!not implemented! bind design-time parameters
        </td>
        <td><a href="/user-guide/expressions/#syntax">Variadic</a></td>
    </tr>
    <tr>
        <td><a id ="any"> Any
        </td>
        <td>Match any predicate
        </td>
        <td><a href="/user-guide/expressions/#syntax">Variadic</a></td>
        <td><pre>Any(Gt(2), Lt(0)) >> 3 == true
Any(Gt(2), Lt(0)) >> 0 == false</pre></td>
    </tr>
    <tr>
        <td><a id ="all"> All
        </td>
        <td>Match all predicates
        </td>
        <td><a href="/user-guide/expressions/#syntax">Variadic</a></td>
        <td><pre>All(Gt(2), Lt(0)) >> 3 == false
All(Gt(2), Lt(3)) >> 2.5 == true</pre></td>
    </tr>
    <tr>
        <td><a id ="saturate"> Saturate
        </td>
        <td>Saturate matches in order
        </td>
        <td><a href="/user-guide/expressions/#syntax">Variadic</a></td>
        <td><pre>Saturate(Gt(2), Lt(0)) >> 3 == true
Saturate(Gt(2), Lt(0)) >> 0 == false

Saturate(42, Mod(2)|0) >> [2,4,8,42,1,2] == true
Saturate(42, Mod(2)|0) >> [2,4,8,41,2]   == false
Saturate(42, Mod(2)|0) >> [2,4,8,42]     == false</pre></td>
    </tr>
    <tr>
        <td><a id ="compose"> Compose
        </td>
        <td>Compose functions
        </td>
        <td><a href="/user-guide/expressions/#syntax">Variadic</a></td>
        <td><pre>Compose(Add(1), Mul(2)) >> 3 == 7
Compose(Add(1), Mul(2)) >> 4 == 9

• Infix operator form (pipe):
Add(1)|Mul(2) ≡ Compose(Add(1), Mul(2))
Add(1)|Mul(2) >> 3 == 7</pre></td>
    </tr>
    <tr>
        <td><a id ="pack"> Pack
        </td>
        <td>Pack results from enveloped functions into an array
        <pre>Allows to combine different properties in a single expression</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Variadic</a></td>
        <td><pre>Pack(Reduce(Add), Size) >> [1,2,3] == [6,3]

• Infix operator form (ampersand):
Reduce(Add) & Size >> [1,2,3] == [6,3]
Reduce(Add) & Size | Div >> [1,2,3] == 2</pre></td>
    </tr>
    <tr>
        <td><a id ="flip"> Flip
        </td>
        <td>Flips design-time and eval-time parameters for enveloped expression.
        <pre>Useful for binding lhs operands to non-commutative operators.
Unlike Haskell's flip, won't change the order or eval-time parameters
- for that case use the Reverse keyword instead.</pre>
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Div(1) >> 2 == 2
Flip(Div(1)) >> 2 == 0.5</pre></td>
    </tr>
</tbody></table>

## Evaluation handlers

<table>
<thead>
    <tr>
        <th>Keyword</th>
        <th>Description</th>
        <th>Syntax</th>
        <th>Examples</th>
    </tr>
<thead>
<tbody>
    <tr>
        <td><a id ="default"> Default
        </td>
        <td>Return x if not null, else return default value
        <br>Aliases: d
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Default(42) >> null == 42
Default(42) >> 13 == 13</pre></td>
    </tr>
    <tr>
        <td><a id ="try"> Try
        </td>
        <td>Evaluate enveloped function and return result or null if it throws
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>Try(Add(1)) >> 42    == 43
Try(Add(1)) >> "foo" == null</pre></td>
    </tr>
    <tr>
        <td><a id ="trycatch"> TryCatch
        </td>
        <td>Evaluate enveloped function and return result or error info if it throws
        </td>
        <td><a href="/user-guide/expressions/#syntax">Binary</a></td>
        <td><pre>TryCatch(Div(0)) >> 42 == {
    "err": "zero division",
    "fn": ":div",
    "x": 42,
    "op":
    "zmbt::GenericSignalOperator"
}</pre></td>
    </tr>
</tbody></table>
