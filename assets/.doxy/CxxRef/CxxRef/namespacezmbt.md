

# Namespace zmbt



[**Namespace List**](namespaces.md) **>** [**zmbt**](namespacezmbt.md)



_ZMBT root namespace._ [More...](#detailed-description)














## Namespaces

| Type | Name |
| ---: | :--- |
| namespace | [**api**](namespacezmbt_1_1api.md) <br>_Framework API with fixture classes and entries from main ns._  |
| namespace | [**application**](namespacezmbt_1_1application.md) <br>_Test application configuration (work in progress)_  |
| namespace | [**decor**](namespacezmbt_1_1decor.md) <br>_Signal type decorators API._  |
| namespace | [**expr**](namespacezmbt_1_1expr.md) <br>_Expression Language API._  |
| namespace | [**flags**](namespacezmbt_1_1flags.md) <br> |
| namespace | [**lang**](namespacezmbt_1_1lang.md) <br>[_**Expression**_](classzmbt_1_1lang_1_1Expression.md) _Language implementation._ |
| namespace | [**mapping**](namespacezmbt_1_1mapping.md) <br>_Signal Mapping model functionality._  |
| namespace | [**reflect**](namespacezmbt_1_1reflect.md) <br>_Reflection metafunctions._  |


## Classes

| Type | Name |
| ---: | :--- |
| class | [**Config**](classzmbt_1_1Config.md) <br>_Global app config._  |
| class | [**Environment**](classzmbt_1_1Environment.md) <br>_Controlled environment data storage._  |
| struct | [**EnvironmentData**](structzmbt_1_1EnvironmentData.md) <br>_Data container for the_ [_**Environment**_](classzmbt_1_1Environment.md) _._ |
| struct | [**ErrorInfo**](structzmbt_1_1ErrorInfo.md) <br> |
| class | [**ErrorOr**](classzmbt_1_1ErrorOr.md) &lt;class Return&gt;<br> |
| class | [**Generator**](classzmbt_1_1Generator.md) <br> |
| class | [**InjectionTable**](classzmbt_1_1InjectionTable.md) <br> |
| class | [**JsonIter**](classzmbt_1_1JsonIter.md) <br>_Boost JSON array iterator interface._  |
| class | [**JsonIterZipProdBase**](classzmbt_1_1JsonIterZipProdBase.md) <br>_Boost JSON array iterator base for zip or cartesian product._  |
| class | [**JsonNode**](classzmbt_1_1JsonNode.md) <br>_Mutator/accessor wrapper over shared JSON value._  |
| class | [**JsonProdIter**](classzmbt_1_1JsonProdIter.md) <br>_Cartesian Product Iterator._  |
| class | [**JsonTraverse**](classzmbt_1_1JsonTraverse.md) <br>_Boost JSON value depth-first traverser._  |
| class | [**JsonZipIter**](classzmbt_1_1JsonZipIter.md) <br>_Zip Iterator._  |
| class | [**Logger**](classzmbt_1_1Logger.md) <br> |
| class | [**OutputRecorder**](classzmbt_1_1OutputRecorder.md) <br> |
| class | [**Param**](classzmbt_1_1Param.md) <br>_Generic Parameter Placeholder._  |
| struct | [**PermanentEnvData**](structzmbt_1_1PermanentEnvData.md) <br> |
| struct | [**StubLogger**](structzmbt_1_1StubLogger.md) <br> |
| class | [**Trigger**](classzmbt_1_1Trigger.md) <br>_Controlled environment interface executor._  |
| class | [**TriggerIfc**](classzmbt_1_1TriggerIfc.md) <br> |
| class | [**TriggerObj**](classzmbt_1_1TriggerObj.md) <br>_Object handler to be used with_ [_**TriggerIfc**_](classzmbt_1_1TriggerIfc.md) _._ |
| struct | [**base\_error**](structzmbt_1_1base__error.md) <br>_ZMBT Base exception._  |
| class | [**entity\_id**](classzmbt_1_1entity__id.md) <br>_Base class for annotated key objects._  |
| struct | [**environment\_error**](structzmbt_1_1environment__error.md) <br>_Test environment error._  |
| struct | [**has\_bit\_and**](structzmbt_1_1has__bit__and.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_bit\_or**](structzmbt_1_1has__bit__or.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_bit\_xor**](structzmbt_1_1has__bit__xor.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_complement**](structzmbt_1_1has__complement.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_divides**](structzmbt_1_1has__divides.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_equal\_to**](structzmbt_1_1has__equal__to.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_greater**](structzmbt_1_1has__greater.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_greater\_equal**](structzmbt_1_1has__greater__equal.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_left\_shift**](structzmbt_1_1has__left__shift.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_less**](structzmbt_1_1has__less.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_less\_equal**](structzmbt_1_1has__less__equal.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_logical\_and**](structzmbt_1_1has__logical__and.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_logical\_not**](structzmbt_1_1has__logical__not.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_logical\_or**](structzmbt_1_1has__logical__or.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_minus**](structzmbt_1_1has__minus.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_modulus**](structzmbt_1_1has__modulus.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_multiplies**](structzmbt_1_1has__multiplies.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_negate**](structzmbt_1_1has__negate.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_not\_equal\_to**](structzmbt_1_1has__not__equal__to.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_plus**](structzmbt_1_1has__plus.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_right\_shift**](structzmbt_1_1has__right__shift.md) &lt;class T, class E&gt;<br> |
| struct | [**has\_serialization**](structzmbt_1_1has__serialization.md) &lt;class T, class E&gt;<br> |
| struct | [**ifc\_args**](structzmbt_1_1ifc__args.md) &lt;class Interface&gt;<br> |
| struct | [**ifc\_handle**](structzmbt_1_1ifc__handle.md) &lt;class Interface&gt;<br> |
| struct | [**ifc\_host**](structzmbt_1_1ifc__host.md) &lt;class Interface, class&gt;<br> |
| struct | [**ifc\_pointer**](structzmbt_1_1ifc__pointer.md) &lt;class Interface&gt;<br> |
| struct | [**ifc\_return**](structzmbt_1_1ifc__return.md) &lt;class Interface&gt;<br> |
| class | [**interface\_id**](classzmbt_1_1interface__id.md) <br>_Pointer-based interface id with type annotation._  |
| struct | [**is\_const\_iterable**](structzmbt_1_1is__const__iterable.md) &lt;class, class&gt;<br>_Variable template that checks if a type has begin() and end() member functions._  |
| struct | [**model\_error**](structzmbt_1_1model__error.md) <br>_Model definition error._  |
| class | [**object\_id**](classzmbt_1_1object__id.md) <br>_Pointer-based object id with type annotation._  |
| struct | [**output\_recorder\_error**](structzmbt_1_1output__recorder__error.md) <br> |
| struct | [**serialization\_error**](structzmbt_1_1serialization__error.md) <br>_Failed serialization._  |
| class | [**shared\_resource**](classzmbt_1_1shared__resource.md) &lt;class T&gt;<br> |
| struct | [**test\_assertion\_failure**](structzmbt_1_1test__assertion__failure.md) <br>_Failed test assertion._  |
| struct | [**type\_tag**](structzmbt_1_1type__tag.md) &lt;class T&gt;<br>_Type tag to pass template parameters as function arguments._  |


## Public Types

| Type | Name |
| ---: | :--- |
| enum unsigned | [**ChannelKind**](#enum-channelkind)  <br> |
| enum  | [**FileFormat**](#enum-fileformat)  <br> |
| typedef std::add\_const&lt; T &gt; | [**add\_const**](#typedef-add_const)  <br> |
| typedef typename add\_const&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**add\_const\_t**](#typedef-add_const_t)  <br> |
| typedef std::add\_cv&lt; T &gt; | [**add\_cv**](#typedef-add_cv)  <br> |
| typedef typename add\_cv&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**add\_cv\_t**](#typedef-add_cv_t)  <br> |
| typedef std::add\_lvalue\_reference&lt; T &gt; | [**add\_lvalue\_reference**](#typedef-add_lvalue_reference)  <br> |
| typedef typename add\_lvalue\_reference&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**add\_lvalue\_reference\_t**](#typedef-add_lvalue_reference_t)  <br> |
| typedef std::add\_pointer&lt; T &gt; | [**add\_pointer**](#typedef-add_pointer)  <br> |
| typedef typename add\_pointer&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**add\_pointer\_t**](#typedef-add_pointer_t)  <br> |
| typedef std::add\_rvalue\_reference&lt; T &gt; | [**add\_rvalue\_reference**](#typedef-add_rvalue_reference)  <br> |
| typedef typename add\_rvalue\_reference&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**add\_rvalue\_reference\_t**](#typedef-add_rvalue_reference_t)  <br> |
| typedef std::add\_volatile&lt; T &gt; | [**add\_volatile**](#typedef-add_volatile)  <br> |
| typedef typename add\_volatile&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**add\_volatile\_t**](#typedef-add_volatile_t)  <br> |
| typedef integral\_constant&lt; bool, V &gt; | [**bool\_constant**](#typedef-bool_constant)  <br> |
| typedef std::common\_type&lt; T... &gt; | [**common\_type**](#typedef-common_type)  <br> |
| typedef typename common\_type&lt; T... &gt;[**::type**](namespacezmbt.md#variable-type) | [**common\_type\_t**](#typedef-common_type_t)  <br> |
| typedef std::conditional&lt; B, T, F &gt; | [**conditional**](#typedef-conditional)  <br> |
| typedef typename conditional&lt; B, T, F &gt;[**::type**](namespacezmbt.md#variable-type) | [**conditional\_t**](#typedef-conditional_t)  <br> |
| typedef std::decay&lt; T &gt; | [**decay**](#typedef-decay)  <br> |
| typedef typename decay&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**decay\_t**](#typedef-decay_t)  <br> |
| typedef mp\_if&lt; mp\_any&lt; C... &gt;, R &gt; | [**first\_if\_any\_t**](#typedef-first_if_any_t)  <br> |
| typedef mp\_if&lt; mp\_not&lt; mp\_any&lt; C... &gt; &gt;, R &gt; | [**first\_if\_none\_t**](#typedef-first_if_none_t)  <br> |
| typedef mp\_if&lt; mp\_all&lt; C... &gt;, R &gt; | [**first\_if\_t**](#typedef-first_if_t)  <br> |
| typedef std::has\_virtual\_destructor&lt; T &gt; | [**has\_virtual\_destructor**](#typedef-has_virtual_destructor)  <br> |
| typedef typename [**ifc\_args**](structzmbt_1_1ifc__args.md)&lt; Interface &gt;[**::type**](namespacezmbt.md#variable-type) | [**ifc\_args\_t**](#typedef-ifc_args_t)  <br> |
| typedef typename [**ifc\_handle**](structzmbt_1_1ifc__handle.md)&lt; Interface &gt;[**::type**](namespacezmbt.md#variable-type) | [**ifc\_handle\_t**](#typedef-ifc_handle_t)  <br> |
| typedef typename [**ifc\_host**](structzmbt_1_1ifc__host.md)&lt; Interface &gt;[**::type**](namespacezmbt.md#variable-type) | [**ifc\_host\_t**](#typedef-ifc_host_t)  <br> |
| typedef mp\_any&lt; ifc\_is\_fn\_ref&lt; Interface &gt;, ifc\_is\_fn\_ptr&lt; Interface &gt; &gt; | [**ifc\_is\_fn\_handle**](#typedef-ifc_is_fn_handle)  <br> |
| typedef mp\_all&lt; is\_pointer&lt; Interface &gt;, is\_function&lt; remove\_pointer\_t&lt; DecayedInterface &gt; &gt; &gt; | [**ifc\_is\_fn\_ptr**](#typedef-ifc_is_fn_ptr)  <br> |
| typedef mp\_all&lt; is\_lvalue\_reference&lt; Interface &gt;, is\_function&lt; remove\_pointer\_t&lt; DecayedInterface &gt; &gt; &gt; | [**ifc\_is\_fn\_ref**](#typedef-ifc_is_fn_ref)  <br> |
| typedef mp\_any&lt; ifc\_is\_functor\_ptr&lt; Interface &gt;, ifc\_is\_functor\_ref&lt; Interface &gt; &gt; | [**ifc\_is\_functor\_handle**](#typedef-ifc_is_functor_handle)  <br> |
| typedef mp\_all&lt; is\_pointer&lt; InterfacePointer &gt;, is\_class&lt; Functor &gt;, detail::support\_calltraits\_function&lt; Functor &gt; &gt; | [**ifc\_is\_functor\_ptr**](#typedef-ifc_is_functor_ptr)  <br> |
| typedef mp\_all&lt; is\_reference&lt; Interface &gt;, is\_class&lt; Functor &gt;, detail::support\_calltraits\_function&lt; Functor &gt; &gt; | [**ifc\_is\_functor\_ref**](#typedef-ifc_is_functor_ref)  <br> |
| typedef is\_member\_pointer&lt; DecayedInterface &gt; | [**ifc\_is\_member\_handle**](#typedef-ifc_is_member_handle)  <br> |
| typedef is\_member\_object\_pointer&lt; DecayedInterface &gt; | [**ifc\_is\_pmd\_handle**](#typedef-ifc_is_pmd_handle)  <br> |
| typedef is\_member\_function\_pointer&lt; DecayedInterface &gt; | [**ifc\_is\_pmf\_handle**](#typedef-ifc_is_pmf_handle)  <br> |
| typedef typename [**ifc\_pointer**](structzmbt_1_1ifc__pointer.md)&lt; Interface &gt;[**::type**](namespacezmbt.md#variable-type) | [**ifc\_pointer\_t**](#typedef-ifc_pointer_t)  <br> |
| typedef typename [**ifc\_return**](structzmbt_1_1ifc__return.md)&lt; Interface &gt;[**::type**](namespacezmbt.md#variable-type) | [**ifc\_return\_t**](#typedef-ifc_return_t)  <br> |
| typedef typename detail::tuple\_indexator&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**indexator\_for**](#typedef-indexator_for)  <br>_Make indexator tuple for T._  |
| typedef std::integral\_constant&lt; T, V &gt; | [**integral\_constant**](#typedef-integral_constant)  <br> |
| typedef std::is\_abstract&lt; T &gt; | [**is\_abstract**](#typedef-is_abstract)  <br> |
| typedef std::is\_arithmetic&lt; T &gt; | [**is\_arithmetic**](#typedef-is_arithmetic)  <br> |
| typedef std::is\_array&lt; T &gt; | [**is\_array**](#typedef-is_array)  <br> |
| typedef std::is\_assignable&lt; A, B &gt; | [**is\_assignable**](#typedef-is_assignable)  <br> |
| typedef std::is\_base\_of&lt; A, B &gt; | [**is\_base\_of**](#typedef-is_base_of)  <br> |
| typedef std::is\_class&lt; T &gt; | [**is\_class**](#typedef-is_class)  <br> |
| typedef std::is\_compound&lt; T &gt; | [**is\_compound**](#typedef-is_compound)  <br> |
| typedef std::is\_const&lt; T &gt; | [**is\_const**](#typedef-is_const)  <br> |
| typedef std::is\_constructible&lt; T, Args... &gt; | [**is\_constructible**](#typedef-is_constructible)  <br> |
| typedef std::is\_convertible&lt; A, B &gt; | [**is\_convertible**](#typedef-is_convertible)  <br> |
| typedef std::is\_copy\_assignable&lt; T &gt; | [**is\_copy\_assignable**](#typedef-is_copy_assignable)  <br> |
| typedef std::is\_copy\_constructible&lt; T &gt; | [**is\_copy\_constructible**](#typedef-is_copy_constructible)  <br> |
| typedef std::is\_default\_constructible&lt; T &gt; | [**is\_default\_constructible**](#typedef-is_default_constructible)  <br> |
| typedef std::is\_destructible&lt; T &gt; | [**is\_destructible**](#typedef-is_destructible)  <br> |
| typedef std::is\_empty&lt; T &gt; | [**is\_empty**](#typedef-is_empty)  <br> |
| typedef std::is\_enum&lt; T &gt; | [**is\_enum**](#typedef-is_enum)  <br> |
| typedef std::is\_final&lt; T &gt; | [**is\_final**](#typedef-is_final)  <br> |
| typedef std::is\_floating\_point&lt; T &gt; | [**is\_floating\_point**](#typedef-is_floating_point)  <br> |
| typedef std::is\_function&lt; T &gt; | [**is\_function**](#typedef-is_function)  <br> |
| typedef std::is\_fundamental&lt; T &gt; | [**is\_fundamental**](#typedef-is_fundamental)  <br> |
| typedef mp\_any&lt; ifc\_is\_pmf\_handle&lt; Interface &gt;, ifc\_is\_pmd\_handle&lt; Interface &gt;, ifc\_is\_fn\_handle&lt; Interface &gt;, ifc\_is\_functor\_handle&lt; Interface &gt; &gt; | [**is\_ifc\_handle**](#typedef-is_ifc_handle)  <br> |
| typedef std::is\_integral&lt; T &gt; | [**is\_integral**](#typedef-is_integral)  <br> |
| typedef std::is\_lvalue\_reference&lt; T &gt; | [**is\_lvalue\_reference**](#typedef-is_lvalue_reference)  <br> |
| typedef std::is\_member\_function\_pointer&lt; T &gt; | [**is\_member\_function\_pointer**](#typedef-is_member_function_pointer)  <br> |
| typedef std::is\_member\_object\_pointer&lt; T &gt; | [**is\_member\_object\_pointer**](#typedef-is_member_object_pointer)  <br> |
| typedef std::is\_member\_pointer&lt; T &gt; | [**is\_member\_pointer**](#typedef-is_member_pointer)  <br> |
| typedef std::is\_move\_assignable&lt; T &gt; | [**is\_move\_assignable**](#typedef-is_move_assignable)  <br> |
| typedef std::is\_move\_constructible&lt; T &gt; | [**is\_move\_constructible**](#typedef-is_move_constructible)  <br> |
| typedef std::is\_nothrow\_assignable&lt; A, B &gt; | [**is\_nothrow\_assignable**](#typedef-is_nothrow_assignable)  <br> |
| typedef std::is\_nothrow\_constructible&lt; T, Args... &gt; | [**is\_nothrow\_constructible**](#typedef-is_nothrow_constructible)  <br> |
| typedef std::is\_nothrow\_copy\_assignable&lt; T &gt; | [**is\_nothrow\_copy\_assignable**](#typedef-is_nothrow_copy_assignable)  <br> |
| typedef std::is\_nothrow\_copy\_constructible&lt; T &gt; | [**is\_nothrow\_copy\_constructible**](#typedef-is_nothrow_copy_constructible)  <br> |
| typedef std::is\_nothrow\_default\_constructible&lt; T &gt; | [**is\_nothrow\_default\_constructible**](#typedef-is_nothrow_default_constructible)  <br> |
| typedef std::is\_nothrow\_destructible&lt; T &gt; | [**is\_nothrow\_destructible**](#typedef-is_nothrow_destructible)  <br> |
| typedef std::is\_nothrow\_move\_assignable&lt; T &gt; | [**is\_nothrow\_move\_assignable**](#typedef-is_nothrow_move_assignable)  <br> |
| typedef std::is\_nothrow\_move\_constructible&lt; T &gt; | [**is\_nothrow\_move\_constructible**](#typedef-is_nothrow_move_constructible)  <br> |
| typedef std::is\_null\_pointer&lt; T &gt; | [**is\_null\_pointer**](#typedef-is_null_pointer)  <br> |
| typedef std::is\_object&lt; T &gt; | [**is\_object**](#typedef-is_object)  <br> |
| typedef std::is\_pointer&lt; T &gt; | [**is\_pointer**](#typedef-is_pointer)  <br> |
| typedef std::is\_polymorphic&lt; T &gt; | [**is\_polymorphic**](#typedef-is_polymorphic)  <br> |
| typedef std::is\_reference&lt; T &gt; | [**is\_reference**](#typedef-is_reference)  <br> |
| typedef std::is\_rvalue\_reference&lt; T &gt; | [**is\_rvalue\_reference**](#typedef-is_rvalue_reference)  <br> |
| typedef std::is\_same&lt; A, B &gt; | [**is\_same**](#typedef-is_same)  <br> |
| typedef std::is\_scalar&lt; T &gt; | [**is\_scalar**](#typedef-is_scalar)  <br> |
| typedef std::is\_signed&lt; T &gt; | [**is\_signed**](#typedef-is_signed)  <br> |
| typedef std::is\_standard\_layout&lt; T &gt; | [**is\_standard\_layout**](#typedef-is_standard_layout)  <br> |
| typedef std::is\_trivial&lt; T &gt; | [**is\_trivial**](#typedef-is_trivial)  <br> |
| typedef std::is\_trivially\_assignable&lt; A, B &gt; | [**is\_trivially\_assignable**](#typedef-is_trivially_assignable)  <br> |
| typedef std::is\_trivially\_constructible&lt; T, Args... &gt; | [**is\_trivially\_constructible**](#typedef-is_trivially_constructible)  <br> |
| typedef std::is\_trivially\_copy\_assignable&lt; T &gt; | [**is\_trivially\_copy\_assignable**](#typedef-is_trivially_copy_assignable)  <br> |
| typedef std::is\_trivially\_copy\_constructible&lt; T &gt; | [**is\_trivially\_copy\_constructible**](#typedef-is_trivially_copy_constructible)  <br> |
| typedef std::is\_trivially\_copyable&lt; T &gt; | [**is\_trivially\_copyable**](#typedef-is_trivially_copyable)  <br> |
| typedef std::is\_trivially\_default\_constructible&lt; T &gt; | [**is\_trivially\_default\_constructible**](#typedef-is_trivially_default_constructible)  <br> |
| typedef std::is\_trivially\_destructible&lt; T &gt; | [**is\_trivially\_destructible**](#typedef-is_trivially_destructible)  <br> |
| typedef std::is\_trivially\_move\_assignable&lt; T &gt; | [**is\_trivially\_move\_assignable**](#typedef-is_trivially_move_assignable)  <br> |
| typedef std::is\_trivially\_move\_constructible&lt; T &gt; | [**is\_trivially\_move\_constructible**](#typedef-is_trivially_move_constructible)  <br> |
| typedef mp\_or&lt; mp\_similar&lt; tuple&lt;&gt;, T &gt;, mp\_similar&lt; std::pair&lt; void, void &gt;, T &gt; &gt; | [**is\_tuple**](#typedef-is_tuple)  <br> |
| typedef mp\_similar&lt; decay\_t&lt; T &gt;, [**type\_tag**](structzmbt_1_1type__tag.md)&lt; void &gt; &gt; | [**is\_type\_tag**](#typedef-is_type_tag)  <br> |
| typedef std::is\_union&lt; T &gt; | [**is\_union**](#typedef-is_union)  <br> |
| typedef std::is\_unsigned&lt; T &gt; | [**is\_unsigned**](#typedef-is_unsigned)  <br> |
| typedef std::is\_void&lt; T &gt; | [**is\_void**](#typedef-is_void)  <br> |
| typedef std::is\_volatile&lt; T &gt; | [**is\_volatile**](#typedef-is_volatile)  <br> |
| typedef std::function&lt; boost::json::array::const\_iterator()&gt; | [**js\_array\_slice\_const\_gen**](#typedef-js_array_slice_const_gen)  <br> |
| typedef std::function&lt; boost::json::array::iterator()&gt; | [**js\_array\_slice\_gen**](#typedef-js_array_slice_gen)  <br> |
| typedef std::function&lt; boost::json::string\_view::const\_iterator()&gt; | [**js\_string\_slice\_gen**](#typedef-js_string_slice_gen)  <br> |
| typedef std::make\_signed&lt; T &gt; | [**make\_signed**](#typedef-make_signed)  <br> |
| typedef typename make\_signed&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**make\_signed\_t**](#typedef-make_signed_t)  <br> |
| typedef std::make\_unsigned&lt; T &gt; | [**make\_unsigned**](#typedef-make_unsigned)  <br> |
| typedef typename make\_unsigned&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**make\_unsigned\_t**](#typedef-make_unsigned_t)  <br> |
| typedef std::remove\_const&lt; T &gt; | [**remove\_const**](#typedef-remove_const)  <br> |
| typedef typename remove\_const&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**remove\_const\_t**](#typedef-remove_const_t)  <br> |
| typedef std::remove\_cv&lt; T &gt; | [**remove\_cv**](#typedef-remove_cv)  <br> |
| typedef typename remove\_cv&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**remove\_cv\_t**](#typedef-remove_cv_t)  <br> |
| typedef remove\_cv\_t&lt; remove\_pointer\_t&lt; T &gt; &gt; | [**remove\_cvptr\_t**](#typedef-remove_cvptr_t)  <br> |
| typedef remove\_cv\_t&lt; remove\_reference\_t&lt; T &gt; &gt; | [**remove\_cvref\_t**](#typedef-remove_cvref_t)  <br> |
| typedef std::remove\_pointer&lt; T &gt; | [**remove\_pointer**](#typedef-remove_pointer)  <br> |
| typedef typename remove\_pointer&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**remove\_pointer\_t**](#typedef-remove_pointer_t)  <br> |
| typedef std::remove\_reference&lt; T &gt; | [**remove\_reference**](#typedef-remove_reference)  <br> |
| typedef typename remove\_reference&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**remove\_reference\_t**](#typedef-remove_reference_t)  <br> |
| typedef std::remove\_volatile&lt; T &gt; | [**remove\_volatile**](#typedef-remove_volatile)  <br> |
| typedef typename remove\_volatile&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**remove\_volatile\_t**](#typedef-remove_volatile_t)  <br> |
| typedef mp\_if&lt; detail::is\_cal&lt; T &gt;, R &gt; | [**require\_cal**](#typedef-require_cal)  <br> |
| typedef mp\_if&lt; boost::json::has\_value\_from&lt; T &gt;, R &gt; | [**require\_json\_from**](#typedef-require_json_from)  <br> |
| typedef mp\_if&lt; mp\_and&lt; detail::maybe\_obj&lt; O &gt;, detail::is\_cal&lt; I &gt; &gt;, R &gt; | [**require\_literal**](#typedef-require_literal)  <br> |
| typedef mp\_if&lt; mp\_not&lt; boost::json::has\_value\_from&lt; T &gt; &gt;, R &gt; | [**require\_no\_json\_from**](#typedef-require_no_json_from)  <br> |
| typedef mp\_if&lt; detail::not\_cal&lt; T &gt;, R &gt; | [**require\_not\_cal**](#typedef-require_not_cal)  <br> |
| typedef mp\_if&lt; mp\_not&lt; boost::json::is\_string\_like&lt; T &gt; &gt;, R &gt; | [**require\_not\_str**](#typedef-require_not_str)  <br> |
| typedef mp\_if&lt; detail::maybe\_obj&lt; T &gt;, R &gt; | [**require\_obj**](#typedef-require_obj)  <br> |
| typedef mp\_if&lt; boost::json::is\_string\_like&lt; T &gt;, R &gt; | [**require\_str**](#typedef-require_str)  <br> |
| typedef std::tuple&lt; T... &gt; | [**tuple**](#typedef-tuple)  <br> |
| typedef std::tuple\_size&lt; T &gt; | [**tuple\_size**](#typedef-tuple_size)  <br> |
| typedef mp\_transform&lt; remove\_cvref\_t, L &gt; | [**tuple\_unqf\_t**](#typedef-tuple_unqf_t)  <br> |
| typedef std::underlying\_type&lt; T &gt; | [**underlying\_type**](#typedef-underlying_type)  <br> |
| typedef typename underlying\_type&lt; T &gt;[**::type**](namespacezmbt.md#variable-type) | [**underlying\_type\_t**](#typedef-underlying_type_t)  <br> |




## Public Attributes

| Type | Name |
| ---: | :--- |
|  constexpr add\_pointer\_t&lt; remove\_reference\_t&lt; ifc\_host\_t&lt; Interface &gt; &gt; &gt; | [**ifc\_host\_nullptr**](#variable-ifc_host_nullptr)   = `{}`<br>_Resolves to H\*{} for member function pointers of H, or to nullptr\_t for other callables._  |
|  constexpr [**type\_tag**](structzmbt_1_1type__tag.md)&lt; T &gt; const | [**type**](#variable-type)   = `{}`<br>_type tag value_  |


## Public Static Attributes

| Type | Name |
| ---: | :--- |
|  constexpr detail::emplace\_shared\_tag | [**emplace\_shared**](#variable-emplace_shared)  <br> |
|  constexpr bool | [**has\_virtual\_destructor\_v**](#variable-has_virtual_destructor_v)   = `has\_virtual\_destructor &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_abstract\_v**](#variable-is_abstract_v)   = `is\_abstract &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_arithmetic\_v**](#variable-is_arithmetic_v)   = `is\_arithmetic &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_array\_v**](#variable-is_array_v)   = `is\_array &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_assignable\_v**](#variable-is_assignable_v)   = `is\_assignable &lt;A, B&gt;::value`<br> |
|  constexpr bool | [**is\_base\_of\_v**](#variable-is_base_of_v)   = `is\_base\_of &lt;A, B&gt;::value`<br> |
|  constexpr bool | [**is\_class\_v**](#variable-is_class_v)   = `is\_class &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_compound\_v**](#variable-is_compound_v)   = `is\_compound &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_const\_v**](#variable-is_const_v)   = `is\_const &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_convertible\_v**](#variable-is_convertible_v)   = `is\_convertible &lt;A, B&gt;::value`<br> |
|  constexpr bool | [**is\_copy\_assignable\_v**](#variable-is_copy_assignable_v)   = `is\_copy\_assignable &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_copy\_constructible\_v**](#variable-is_copy_constructible_v)   = `is\_copy\_constructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_default\_constructible\_v**](#variable-is_default_constructible_v)   = `is\_default\_constructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_destructible\_v**](#variable-is_destructible_v)   = `is\_destructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_empty\_v**](#variable-is_empty_v)   = `is\_empty &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_enum\_v**](#variable-is_enum_v)   = `is\_enum &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_final\_v**](#variable-is_final_v)   = `is\_final &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_floating\_point\_v**](#variable-is_floating_point_v)   = `is\_floating\_point &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_function\_v**](#variable-is_function_v)   = `is\_function &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_fundamental\_v**](#variable-is_fundamental_v)   = `is\_fundamental &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_integral\_v**](#variable-is_integral_v)   = `is\_integral &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_lvalue\_reference\_v**](#variable-is_lvalue_reference_v)   = `is\_lvalue\_reference &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_member\_function\_pointer\_v**](#variable-is_member_function_pointer_v)   = `is\_member\_function\_pointer &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_member\_object\_pointer\_v**](#variable-is_member_object_pointer_v)   = `is\_member\_object\_pointer &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_member\_pointer\_v**](#variable-is_member_pointer_v)   = `is\_member\_pointer &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_move\_assignable\_v**](#variable-is_move_assignable_v)   = `is\_move\_assignable &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_move\_constructible\_v**](#variable-is_move_constructible_v)   = `is\_move\_constructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_nothrow\_assignable\_v**](#variable-is_nothrow_assignable_v)   = `is\_nothrow\_assignable &lt;A, B&gt;::value`<br> |
|  constexpr bool | [**is\_nothrow\_copy\_assignable\_v**](#variable-is_nothrow_copy_assignable_v)   = `is\_nothrow\_copy\_assignable &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_nothrow\_copy\_constructible\_v**](#variable-is_nothrow_copy_constructible_v)   = `is\_nothrow\_copy\_constructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_nothrow\_default\_constructible\_v**](#variable-is_nothrow_default_constructible_v)   = `is\_nothrow\_default\_constructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_nothrow\_destructible\_v**](#variable-is_nothrow_destructible_v)   = `is\_nothrow\_destructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_nothrow\_move\_assignable\_v**](#variable-is_nothrow_move_assignable_v)   = `is\_nothrow\_move\_assignable &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_nothrow\_move\_constructible\_v**](#variable-is_nothrow_move_constructible_v)   = `is\_nothrow\_move\_constructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_null\_pointer\_v**](#variable-is_null_pointer_v)   = `is\_null\_pointer &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_object\_v**](#variable-is_object_v)   = `is\_object &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_pointer\_v**](#variable-is_pointer_v)   = `is\_pointer &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_polymorphic\_v**](#variable-is_polymorphic_v)   = `is\_polymorphic &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_reference\_v**](#variable-is_reference_v)   = `is\_reference &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_rvalue\_reference\_v**](#variable-is_rvalue_reference_v)   = `is\_rvalue\_reference &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_same\_v**](#variable-is_same_v)   = `is\_same &lt;A, B&gt;::value`<br> |
|  constexpr bool | [**is\_scalar\_v**](#variable-is_scalar_v)   = `is\_scalar &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_signed\_v**](#variable-is_signed_v)   = `is\_signed &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_standard\_layout\_v**](#variable-is_standard_layout_v)   = `is\_standard\_layout &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_trivial\_v**](#variable-is_trivial_v)   = `is\_trivial &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_trivially\_assignable\_v**](#variable-is_trivially_assignable_v)   = `is\_trivially\_assignable &lt;A, B&gt;::value`<br> |
|  constexpr bool | [**is\_trivially\_copy\_assignable\_v**](#variable-is_trivially_copy_assignable_v)   = `is\_trivially\_copy\_assignable &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_trivially\_copy\_constructible\_v**](#variable-is_trivially_copy_constructible_v)   = `is\_trivially\_copy\_constructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_trivially\_copyable\_v**](#variable-is_trivially_copyable_v)   = `is\_trivially\_copyable &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_trivially\_default\_constructible\_v**](#variable-is_trivially_default_constructible_v)   = `is\_trivially\_default\_constructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_trivially\_destructible\_v**](#variable-is_trivially_destructible_v)   = `is\_trivially\_destructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_trivially\_move\_assignable\_v**](#variable-is_trivially_move_assignable_v)   = `is\_trivially\_move\_assignable &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_trivially\_move\_constructible\_v**](#variable-is_trivially_move_constructible_v)   = `is\_trivially\_move\_constructible &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_union\_v**](#variable-is_union_v)   = `is\_union &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_unsigned\_v**](#variable-is_unsigned_v)   = `is\_unsigned &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_void\_v**](#variable-is_void_v)   = `is\_void &lt;T&gt;::value`<br> |
|  constexpr bool | [**is\_volatile\_v**](#variable-is_volatile_v)   = `is\_volatile &lt;T&gt;::value`<br> |
|  constexpr size\_t | [**tuple\_size\_v**](#variable-tuple_size_v)   = `tuple\_size&lt;T&gt;::value`<br> |














## Public Functions

| Type | Name |
| ---: | :--- |
|  void | [**InitZmbt**](#function-initzmbt) (int argc, char \*\* argv) <br>_Initialize test application._  |
|  [**Environment::TypedInterfaceHandle**](classzmbt_1_1Environment_1_1TypedInterfaceHandle.md)&lt; Interface &gt; | [**InterfaceRecord**](#function-interfacerecord) (Interface const & interface, [**object\_id**](classzmbt_1_1object__id.md) const & obj={[**ifc\_host\_nullptr**](namespacezmbt.md#variable-ifc_host_nullptr)&lt; Interface &gt;}) <br>_Make TypedInterfaceHandle instance._  |
|  T | [**construct\_or\_default**](#function-construct_or_default) (A &&... args) <br>_Construct T from the given arguments or return default T if construction is invalid._  |
|  T | [**convert\_tuple\_to**](#function-convert_tuple_to) (tuple&lt; A... &gt; & source) <br>_Convert given tuple to a tuple of type T._  |
|  void | [**default\_test\_failure**](#function-default_test_failure) (boost::json::value const & report) <br>_default test failure handler_  |
|  reflect::detail::disable\_hermetic\_serialization&lt; T, T &gt; | [**dejsonize**](#function-dejsonize) (boost::json::value const & v) <br> |
|  reflect::detail::enable\_hermetic\_serialization&lt; T, T &gt; | [**dejsonize**](#function-dejsonize) (boost::json::value const & v) <br> |
|  void | [**dejsonize&lt; void &gt;**](#function-dejsonize-void) (boost::json::value const &) <br> |
|  void | [**dejsonize\_array**](#function-dejsonize_array) (boost::json::array const & jarr, T(&) array) <br> |
|  std::string | [**format**](#function-format) (boost::json::string\_view fmtstr, A &&... arg) <br>_boost::format wrapper with printf-like api_  |
|  void | [**format\_failure\_report**](#function-format_failure_report) (std::ostream & os, boost::json::value const & report) <br>_default failure report formatter_  |
|  auto | [**get\_ifc\_handle**](#function-get_ifc_handle) (Interface const x) <br>_Get reference to callable object._  |
|  auto | [**get\_ifc\_handle**](#function-get_ifc_handle) (Interface \* x) <br> |
|  auto | [**get\_ifc\_handle**](#function-get_ifc_handle) (Interface & x) <br> |
|  auto | [**get\_ifc\_pointer**](#function-get_ifc_pointer) (Interface x) <br>_Get pointer to callable object._  |
|  auto | [**get\_ifc\_pointer**](#function-get_ifc_pointer) (Interface \* x) <br> |
|  auto | [**get\_ifc\_pointer**](#function-get_ifc_pointer) (Interface & x) <br> |
|  std::string | [**get\_tid**](#function-get_tid) () <br>_get thread id in string_  |
|  std::size\_t | [**get\_ts**](#function-get_ts) () <br>_get timestamp_  |
|  reflect::detail::disable\_hermetic\_serialization&lt; TT, boost::json::value &gt; | [**json\_from**](#function-json_from) (T && t) <br> |
|  reflect::detail::enable\_hermetic\_serialization&lt; TT, boost::json::value &gt; | [**json\_from**](#function-json_from) (T && t) <br> |
|  boost::json::value | [**json\_from**](#function-json_from) (std::tuple&lt;&gt;) <br> |
|  boost::json::value | [**json\_from\_array**](#function-json_from_array) (T const (&) array) <br> |
|  js\_array\_slice\_const\_gen | [**make\_slice\_const\_generator**](#function-make_slice_const_generator) (boost::json::array const & src, std::int64\_t const start=0, std::int64\_t const stop=-1, std::int64\_t const step=1) <br> |
|  js\_string\_slice\_gen | [**make\_slice\_const\_generator**](#function-make_slice_const_generator) (boost::json::string\_view const src, std::int64\_t const start=0, std::int64\_t const stop=-1, std::int64\_t const step=1) <br> |
|  js\_array\_slice\_gen | [**make\_slice\_generator**](#function-make_slice_generator) (boost::json::array & src, std::int64\_t const start=0, std::int64\_t const stop=-1, std::int64\_t const step=1) <br> |
|  boost::json::value | [**maybe\_real\_to\_number**](#function-maybe_real_to_number) (boost::json::value const & value) <br> |
|  bool | [**maybe\_real\_to\_number\_inplace**](#function-maybe_real_to_number_inplace) (boost::json::value & value) <br> |
|  boost::json::value | [**param\_transform**](#function-param_transform) ([**Param**](classzmbt_1_1Param.md) const & param, boost::json::array const & pointers, T && value) <br>_Transform_ [_**Param**_](classzmbt_1_1Param.md) _value of type T to json value and handle type-specific environment effects._ |
|  std::ostream & | [**pretty\_print**](#function-pretty_print) (std::ostream & os, boost::json::value const & jv, int const indent=0) <br>_Pretty print JSON data._  |
|  boost::json::value | [**real\_to\_number**](#function-real_to_number) (double value) <br> |
|  boost::json::value | [**real\_to\_number**](#function-real_to_number) (std::int64\_t value) <br> |
|  boost::json::array | [**slice**](#function-slice) (boost::json::array const & src, boost::json::string\_view jp, std::int64\_t const start=0, std::int64\_t const stop=-1, std::int64\_t const step=1) <br>_Slice array with inclusive boundaries and subsignal cherry-pick._  |
|  boost::json::array | [**slice**](#function-slice) (boost::json::array const & src, std::int64\_t const start=0, std::int64\_t const stop=-1, std::int64\_t const step=1) <br>_Slice array with inclusive boundaries._  |
|  boost::json::string | [**slice**](#function-slice) (boost::json::string\_view const src, std::int64\_t const start=0, std::int64\_t const stop=-1, std::int64\_t const step=1) <br> |
|  void | [**throw\_exception**](#function-throw_exception) (E && e) <br> |
|  std::string | [**tid2str**](#function-tid2str) (std::thread::id const tid) <br>_thread id to string_  |
|  void | [**tuple\_exchange**](#function-tuple_exchange) (T1 & target, T2 const & src) <br> |
|  std::string | [**type\_name**](#function-type_name) () <br>_Prettified typename._  |
|  std::string | [**type\_name**](#function-type_name) (T) <br>_Prettified typename._  |




























## Detailed Description




**Copyright:**

(c) Copyright 2022-2023 Volvo Car Corporation 




**Copyright:**

(c) Copyright 2024 Zenseact AB 




**
**

SPDX-License-Identifier: Apache-2.0 





    
## Public Types Documentation




### enum ChannelKind 

```C++
enum zmbt::ChannelKind {
    Args,
    Return,
    Exception,
    Timestamp,
    ThreadId,
    CallCount,
    Undefined
};
```




<hr>



### enum FileFormat 

```C++
enum zmbt::FileFormat {
    DeduceFromExtension,
    JSON,
    YAML,
    XML
};
```




<hr>



### typedef add\_const 

```C++
using zmbt::add_const = typedef std:: add_const <T>;
```




<hr>



### typedef add\_const\_t 

```C++
using zmbt::add_const_t = typedef typename add_const <T>::type;
```




<hr>



### typedef add\_cv 

```C++
using zmbt::add_cv = typedef std:: add_cv <T>;
```




<hr>



### typedef add\_cv\_t 

```C++
using zmbt::add_cv_t = typedef typename add_cv <T>::type;
```




<hr>



### typedef add\_lvalue\_reference 

```C++
using zmbt::add_lvalue_reference = typedef std:: add_lvalue_reference <T>;
```




<hr>



### typedef add\_lvalue\_reference\_t 

```C++
using zmbt::add_lvalue_reference_t = typedef typename add_lvalue_reference <T>::type;
```




<hr>



### typedef add\_pointer 

```C++
using zmbt::add_pointer = typedef std:: add_pointer <T>;
```




<hr>



### typedef add\_pointer\_t 

```C++
using zmbt::add_pointer_t = typedef typename add_pointer <T>::type;
```




<hr>



### typedef add\_rvalue\_reference 

```C++
using zmbt::add_rvalue_reference = typedef std:: add_rvalue_reference <T>;
```




<hr>



### typedef add\_rvalue\_reference\_t 

```C++
using zmbt::add_rvalue_reference_t = typedef typename add_rvalue_reference <T>::type;
```




<hr>



### typedef add\_volatile 

```C++
using zmbt::add_volatile = typedef std:: add_volatile <T>;
```




<hr>



### typedef add\_volatile\_t 

```C++
using zmbt::add_volatile_t = typedef typename add_volatile <T>::type;
```




<hr>



### typedef bool\_constant 

```C++
using zmbt::bool_constant = typedef integral_constant<bool, V>;
```




<hr>



### typedef common\_type 

```C++
using zmbt::common_type = typedef std::common_type<T...>;
```




<hr>



### typedef common\_type\_t 

```C++
using zmbt::common_type_t = typedef typename common_type<T...>::type;
```




<hr>



### typedef conditional 

```C++
using zmbt::conditional = typedef std::conditional<B, T, F>;
```




<hr>



### typedef conditional\_t 

```C++
using zmbt::conditional_t = typedef typename conditional<B, T, F>::type;
```




<hr>



### typedef decay 

```C++
using zmbt::decay = typedef std:: decay <T>;
```




<hr>



### typedef decay\_t 

```C++
using zmbt::decay_t = typedef typename decay <T>::type;
```




<hr>



### typedef first\_if\_any\_t 

```C++
using zmbt::first_if_any_t = typedef mp_if<mp_any<C...>, R>;
```




<hr>



### typedef first\_if\_none\_t 

```C++
using zmbt::first_if_none_t = typedef mp_if<mp_not<mp_any<C...> >, R>;
```




<hr>



### typedef first\_if\_t 

```C++
using zmbt::first_if_t = typedef mp_if<mp_all<C...>, R>;
```




<hr>



### typedef has\_virtual\_destructor 

```C++
using zmbt::has_virtual_destructor = typedef std:: has_virtual_destructor <T>;
```




<hr>



### typedef ifc\_args\_t 

```C++
using zmbt::ifc_args_t = typedef typename ifc_args<Interface>::type;
```




<hr>



### typedef ifc\_handle\_t 

```C++
using zmbt::ifc_handle_t = typedef typename ifc_handle<Interface>::type;
```




<hr>



### typedef ifc\_host\_t 

```C++
using zmbt::ifc_host_t = typedef typename ifc_host<Interface>::type;
```




<hr>



### typedef ifc\_is\_fn\_handle 

```C++
using zmbt::ifc_is_fn_handle = typedef mp_any< ifc_is_fn_ref<Interface>, ifc_is_fn_ptr<Interface> >;
```




<hr>



### typedef ifc\_is\_fn\_ptr 

```C++
using zmbt::ifc_is_fn_ptr = typedef mp_all< is_pointer<Interface>, is_function<remove_pointer_t<DecayedInterface> > >;
```




<hr>



### typedef ifc\_is\_fn\_ref 

```C++
using zmbt::ifc_is_fn_ref = typedef mp_all< is_lvalue_reference<Interface>, is_function<remove_pointer_t<DecayedInterface> > >;
```




<hr>



### typedef ifc\_is\_functor\_handle 

```C++
using zmbt::ifc_is_functor_handle = typedef mp_any< ifc_is_functor_ptr<Interface>, ifc_is_functor_ref<Interface> >;
```




<hr>



### typedef ifc\_is\_functor\_ptr 

```C++
using zmbt::ifc_is_functor_ptr = typedef mp_all< is_pointer<InterfacePointer>, is_class<Functor>, detail::support_calltraits_function<Functor> >;
```




<hr>



### typedef ifc\_is\_functor\_ref 

```C++
using zmbt::ifc_is_functor_ref = typedef mp_all< is_reference<Interface>, is_class<Functor>, detail::support_calltraits_function<Functor> >;
```




<hr>



### typedef ifc\_is\_member\_handle 

```C++
using zmbt::ifc_is_member_handle = typedef is_member_pointer<DecayedInterface>;
```




<hr>



### typedef ifc\_is\_pmd\_handle 

```C++
using zmbt::ifc_is_pmd_handle = typedef is_member_object_pointer<DecayedInterface>;
```




<hr>



### typedef ifc\_is\_pmf\_handle 

```C++
using zmbt::ifc_is_pmf_handle = typedef is_member_function_pointer<DecayedInterface>;
```




<hr>



### typedef ifc\_pointer\_t 

```C++
using zmbt::ifc_pointer_t = typedef typename ifc_pointer<Interface>::type;
```




<hr>



### typedef ifc\_return\_t 

```C++
using zmbt::ifc_return_t = typedef typename ifc_return<Interface>::type;
```




<hr>



### typedef indexator\_for 

_Make indexator tuple for T._ 
```C++
using zmbt::indexator_for = typedef typename detail::tuple_indexator<T>::type;
```



Create std::tuple of std::integral\_constant with 0, ..., N-1 values for input tuple of size N 

**Template parameters:**


* `T` input tuple 




        

<hr>



### typedef integral\_constant 

```C++
using zmbt::integral_constant = typedef std::integral_constant<T, V>;
```




<hr>



### typedef is\_abstract 

```C++
using zmbt::is_abstract = typedef std:: is_abstract <T>;
```




<hr>



### typedef is\_arithmetic 

```C++
using zmbt::is_arithmetic = typedef std:: is_arithmetic <T>;
```




<hr>



### typedef is\_array 

```C++
using zmbt::is_array = typedef std:: is_array <T>;
```




<hr>



### typedef is\_assignable 

```C++
using zmbt::is_assignable = typedef std:: is_assignable <A, B>;
```




<hr>



### typedef is\_base\_of 

```C++
using zmbt::is_base_of = typedef std:: is_base_of <A, B>;
```




<hr>



### typedef is\_class 

```C++
using zmbt::is_class = typedef std:: is_class <T>;
```




<hr>



### typedef is\_compound 

```C++
using zmbt::is_compound = typedef std:: is_compound <T>;
```




<hr>



### typedef is\_const 

```C++
using zmbt::is_const = typedef std:: is_const <T>;
```




<hr>



### typedef is\_constructible 

```C++
using zmbt::is_constructible = typedef std::is_constructible<T, Args...>;
```




<hr>



### typedef is\_convertible 

```C++
using zmbt::is_convertible = typedef std:: is_convertible <A, B>;
```




<hr>



### typedef is\_copy\_assignable 

```C++
using zmbt::is_copy_assignable = typedef std:: is_copy_assignable <T>;
```




<hr>



### typedef is\_copy\_constructible 

```C++
using zmbt::is_copy_constructible = typedef std:: is_copy_constructible <T>;
```




<hr>



### typedef is\_default\_constructible 

```C++
using zmbt::is_default_constructible = typedef std:: is_default_constructible <T>;
```




<hr>



### typedef is\_destructible 

```C++
using zmbt::is_destructible = typedef std:: is_destructible <T>;
```




<hr>



### typedef is\_empty 

```C++
using zmbt::is_empty = typedef std:: is_empty <T>;
```




<hr>



### typedef is\_enum 

```C++
using zmbt::is_enum = typedef std:: is_enum <T>;
```




<hr>



### typedef is\_final 

```C++
using zmbt::is_final = typedef std:: is_final <T>;
```




<hr>



### typedef is\_floating\_point 

```C++
using zmbt::is_floating_point = typedef std:: is_floating_point <T>;
```




<hr>



### typedef is\_function 

```C++
using zmbt::is_function = typedef std:: is_function <T>;
```




<hr>



### typedef is\_fundamental 

```C++
using zmbt::is_fundamental = typedef std:: is_fundamental <T>;
```




<hr>



### typedef is\_ifc\_handle 

```C++
using zmbt::is_ifc_handle = typedef mp_any< ifc_is_pmf_handle<Interface>, ifc_is_pmd_handle<Interface>, ifc_is_fn_handle<Interface>, ifc_is_functor_handle<Interface> >;
```




<hr>



### typedef is\_integral 

```C++
using zmbt::is_integral = typedef std:: is_integral <T>;
```




<hr>



### typedef is\_lvalue\_reference 

```C++
using zmbt::is_lvalue_reference = typedef std:: is_lvalue_reference <T>;
```




<hr>



### typedef is\_member\_function\_pointer 

```C++
using zmbt::is_member_function_pointer = typedef std:: is_member_function_pointer <T>;
```




<hr>



### typedef is\_member\_object\_pointer 

```C++
using zmbt::is_member_object_pointer = typedef std:: is_member_object_pointer <T>;
```




<hr>



### typedef is\_member\_pointer 

```C++
using zmbt::is_member_pointer = typedef std:: is_member_pointer <T>;
```




<hr>



### typedef is\_move\_assignable 

```C++
using zmbt::is_move_assignable = typedef std:: is_move_assignable <T>;
```




<hr>



### typedef is\_move\_constructible 

```C++
using zmbt::is_move_constructible = typedef std:: is_move_constructible <T>;
```




<hr>



### typedef is\_nothrow\_assignable 

```C++
using zmbt::is_nothrow_assignable = typedef std:: is_nothrow_assignable <A, B>;
```




<hr>



### typedef is\_nothrow\_constructible 

```C++
using zmbt::is_nothrow_constructible = typedef std::is_nothrow_constructible<T, Args...>;
```




<hr>



### typedef is\_nothrow\_copy\_assignable 

```C++
using zmbt::is_nothrow_copy_assignable = typedef std:: is_nothrow_copy_assignable <T>;
```




<hr>



### typedef is\_nothrow\_copy\_constructible 

```C++
using zmbt::is_nothrow_copy_constructible = typedef std:: is_nothrow_copy_constructible <T>;
```




<hr>



### typedef is\_nothrow\_default\_constructible 

```C++
using zmbt::is_nothrow_default_constructible = typedef std:: is_nothrow_default_constructible <T>;
```




<hr>



### typedef is\_nothrow\_destructible 

```C++
using zmbt::is_nothrow_destructible = typedef std:: is_nothrow_destructible <T>;
```




<hr>



### typedef is\_nothrow\_move\_assignable 

```C++
using zmbt::is_nothrow_move_assignable = typedef std:: is_nothrow_move_assignable <T>;
```




<hr>



### typedef is\_nothrow\_move\_constructible 

```C++
using zmbt::is_nothrow_move_constructible = typedef std:: is_nothrow_move_constructible <T>;
```




<hr>



### typedef is\_null\_pointer 

```C++
using zmbt::is_null_pointer = typedef std:: is_null_pointer <T>;
```




<hr>



### typedef is\_object 

```C++
using zmbt::is_object = typedef std:: is_object <T>;
```




<hr>



### typedef is\_pointer 

```C++
using zmbt::is_pointer = typedef std:: is_pointer <T>;
```




<hr>



### typedef is\_polymorphic 

```C++
using zmbt::is_polymorphic = typedef std:: is_polymorphic <T>;
```




<hr>



### typedef is\_reference 

```C++
using zmbt::is_reference = typedef std:: is_reference <T>;
```




<hr>



### typedef is\_rvalue\_reference 

```C++
using zmbt::is_rvalue_reference = typedef std:: is_rvalue_reference <T>;
```




<hr>



### typedef is\_same 

```C++
using zmbt::is_same = typedef std:: is_same <A, B>;
```




<hr>



### typedef is\_scalar 

```C++
using zmbt::is_scalar = typedef std:: is_scalar <T>;
```




<hr>



### typedef is\_signed 

```C++
using zmbt::is_signed = typedef std:: is_signed <T>;
```




<hr>



### typedef is\_standard\_layout 

```C++
using zmbt::is_standard_layout = typedef std:: is_standard_layout <T>;
```




<hr>



### typedef is\_trivial 

```C++
using zmbt::is_trivial = typedef std:: is_trivial <T>;
```




<hr>



### typedef is\_trivially\_assignable 

```C++
using zmbt::is_trivially_assignable = typedef std:: is_trivially_assignable <A, B>;
```




<hr>



### typedef is\_trivially\_constructible 

```C++
using zmbt::is_trivially_constructible = typedef std::is_trivially_constructible<T, Args...>;
```




<hr>



### typedef is\_trivially\_copy\_assignable 

```C++
using zmbt::is_trivially_copy_assignable = typedef std:: is_trivially_copy_assignable <T>;
```




<hr>



### typedef is\_trivially\_copy\_constructible 

```C++
using zmbt::is_trivially_copy_constructible = typedef std:: is_trivially_copy_constructible <T>;
```




<hr>



### typedef is\_trivially\_copyable 

```C++
using zmbt::is_trivially_copyable = typedef std:: is_trivially_copyable <T>;
```




<hr>



### typedef is\_trivially\_default\_constructible 

```C++
using zmbt::is_trivially_default_constructible = typedef std:: is_trivially_default_constructible <T>;
```




<hr>



### typedef is\_trivially\_destructible 

```C++
using zmbt::is_trivially_destructible = typedef std:: is_trivially_destructible <T>;
```




<hr>



### typedef is\_trivially\_move\_assignable 

```C++
using zmbt::is_trivially_move_assignable = typedef std:: is_trivially_move_assignable <T>;
```




<hr>



### typedef is\_trivially\_move\_constructible 

```C++
using zmbt::is_trivially_move_constructible = typedef std:: is_trivially_move_constructible <T>;
```




<hr>



### typedef is\_tuple 

```C++
using zmbt::is_tuple = typedef mp_or< mp_similar<tuple<>, T>, mp_similar<std::pair<void, void>, T> >;
```




<hr>



### typedef is\_type\_tag 

```C++
using zmbt::is_type_tag = typedef mp_similar<decay_t<T>, type_tag<void> >;
```




<hr>



### typedef is\_union 

```C++
using zmbt::is_union = typedef std:: is_union <T>;
```




<hr>



### typedef is\_unsigned 

```C++
using zmbt::is_unsigned = typedef std:: is_unsigned <T>;
```




<hr>



### typedef is\_void 

```C++
using zmbt::is_void = typedef std:: is_void <T>;
```




<hr>



### typedef is\_volatile 

```C++
using zmbt::is_volatile = typedef std:: is_volatile <T>;
```




<hr>



### typedef js\_array\_slice\_const\_gen 

```C++
using zmbt::js_array_slice_const_gen = typedef std::function<boost::json::array::const_iterator()>;
```




<hr>



### typedef js\_array\_slice\_gen 

```C++
using zmbt::js_array_slice_gen = typedef std::function<boost::json::array::iterator()>;
```




<hr>



### typedef js\_string\_slice\_gen 

```C++
using zmbt::js_string_slice_gen = typedef std::function<boost::json::string_view::const_iterator()>;
```




<hr>



### typedef make\_signed 

```C++
using zmbt::make_signed = typedef std:: make_signed <T>;
```




<hr>



### typedef make\_signed\_t 

```C++
using zmbt::make_signed_t = typedef typename make_signed <T>::type;
```




<hr>



### typedef make\_unsigned 

```C++
using zmbt::make_unsigned = typedef std:: make_unsigned <T>;
```




<hr>



### typedef make\_unsigned\_t 

```C++
using zmbt::make_unsigned_t = typedef typename make_unsigned <T>::type;
```




<hr>



### typedef remove\_const 

```C++
using zmbt::remove_const = typedef std:: remove_const <T>;
```




<hr>



### typedef remove\_const\_t 

```C++
using zmbt::remove_const_t = typedef typename remove_const <T>::type;
```




<hr>



### typedef remove\_cv 

```C++
using zmbt::remove_cv = typedef std:: remove_cv <T>;
```




<hr>



### typedef remove\_cv\_t 

```C++
using zmbt::remove_cv_t = typedef typename remove_cv <T>::type;
```




<hr>



### typedef remove\_cvptr\_t 

```C++
using zmbt::remove_cvptr_t = typedef remove_cv_t<remove_pointer_t<T> >;
```




<hr>



### typedef remove\_cvref\_t 

```C++
using zmbt::remove_cvref_t = typedef remove_cv_t<remove_reference_t<T> >;
```




<hr>



### typedef remove\_pointer 

```C++
using zmbt::remove_pointer = typedef std:: remove_pointer <T>;
```




<hr>



### typedef remove\_pointer\_t 

```C++
using zmbt::remove_pointer_t = typedef typename remove_pointer <T>::type;
```




<hr>



### typedef remove\_reference 

```C++
using zmbt::remove_reference = typedef std:: remove_reference <T>;
```




<hr>



### typedef remove\_reference\_t 

```C++
using zmbt::remove_reference_t = typedef typename remove_reference <T>::type;
```




<hr>



### typedef remove\_volatile 

```C++
using zmbt::remove_volatile = typedef std:: remove_volatile <T>;
```




<hr>



### typedef remove\_volatile\_t 

```C++
using zmbt::remove_volatile_t = typedef typename remove_volatile <T>::type;
```




<hr>



### typedef require\_cal 

```C++
using zmbt::require_cal = typedef mp_if<detail::is_cal<T>, R>;
```




<hr>



### typedef require\_json\_from 

```C++
using zmbt::require_json_from = typedef mp_if<boost::json::has_value_from<T>, R>;
```




<hr>



### typedef require\_literal 

```C++
using zmbt::require_literal = typedef mp_if<mp_and<detail::maybe_obj<O>, detail::is_cal<I> >, R>;
```




<hr>



### typedef require\_no\_json\_from 

```C++
using zmbt::require_no_json_from = typedef mp_if<mp_not<boost::json::has_value_from<T> >, R>;
```




<hr>



### typedef require\_not\_cal 

```C++
using zmbt::require_not_cal = typedef mp_if<detail::not_cal<T>, R>;
```




<hr>



### typedef require\_not\_str 

```C++
using zmbt::require_not_str = typedef mp_if<mp_not<boost::json::is_string_like<T> >, R>;
```




<hr>



### typedef require\_obj 

```C++
using zmbt::require_obj = typedef mp_if<detail::maybe_obj<T>, R>;
```




<hr>



### typedef require\_str 

```C++
using zmbt::require_str = typedef mp_if<boost::json::is_string_like<T>, R>;
```




<hr>



### typedef tuple 

```C++
using zmbt::tuple = typedef std::tuple<T...>;
```




<hr>



### typedef tuple\_size 

```C++
using zmbt::tuple_size = typedef std::tuple_size<T>;
```




<hr>



### typedef tuple\_unqf\_t 

```C++
using zmbt::tuple_unqf_t = typedef mp_transform<remove_cvref_t, L>;
```




<hr>



### typedef underlying\_type 

```C++
using zmbt::underlying_type = typedef std:: underlying_type <T>;
```




<hr>



### typedef underlying\_type\_t 

```C++
using zmbt::underlying_type_t = typedef typename underlying_type <T>::type;
```




<hr>
## Public Attributes Documentation




### variable ifc\_host\_nullptr 

_Resolves to H\*{} for member function pointers of H, or to nullptr\_t for other callables._ 
```C++
constexpr add_pointer_t<remove_reference_t<ifc_host_t<Interface> > > zmbt::ifc_host_nullptr;
```




<hr>



### variable type 

_type tag value_ 
```C++
constexpr type_tag<T> const zmbt::type;
```





**Template parameters:**


* `T` 




        

<hr>
## Public Static Attributes Documentation




### variable emplace\_shared 

```C++
constexpr detail::emplace_shared_tag zmbt::emplace_shared;
```




<hr>



### variable has\_virtual\_destructor\_v 

```C++
constexpr bool zmbt::has_virtual_destructor_v;
```




<hr>



### variable is\_abstract\_v 

```C++
constexpr bool zmbt::is_abstract_v;
```




<hr>



### variable is\_arithmetic\_v 

```C++
constexpr bool zmbt::is_arithmetic_v;
```




<hr>



### variable is\_array\_v 

```C++
constexpr bool zmbt::is_array_v;
```




<hr>



### variable is\_assignable\_v 

```C++
constexpr bool zmbt::is_assignable_v;
```




<hr>



### variable is\_base\_of\_v 

```C++
constexpr bool zmbt::is_base_of_v;
```




<hr>



### variable is\_class\_v 

```C++
constexpr bool zmbt::is_class_v;
```




<hr>



### variable is\_compound\_v 

```C++
constexpr bool zmbt::is_compound_v;
```




<hr>



### variable is\_const\_v 

```C++
constexpr bool zmbt::is_const_v;
```




<hr>



### variable is\_convertible\_v 

```C++
constexpr bool zmbt::is_convertible_v;
```




<hr>



### variable is\_copy\_assignable\_v 

```C++
constexpr bool zmbt::is_copy_assignable_v;
```




<hr>



### variable is\_copy\_constructible\_v 

```C++
constexpr bool zmbt::is_copy_constructible_v;
```




<hr>



### variable is\_default\_constructible\_v 

```C++
constexpr bool zmbt::is_default_constructible_v;
```




<hr>



### variable is\_destructible\_v 

```C++
constexpr bool zmbt::is_destructible_v;
```




<hr>



### variable is\_empty\_v 

```C++
constexpr bool zmbt::is_empty_v;
```




<hr>



### variable is\_enum\_v 

```C++
constexpr bool zmbt::is_enum_v;
```




<hr>



### variable is\_final\_v 

```C++
constexpr bool zmbt::is_final_v;
```




<hr>



### variable is\_floating\_point\_v 

```C++
constexpr bool zmbt::is_floating_point_v;
```




<hr>



### variable is\_function\_v 

```C++
constexpr bool zmbt::is_function_v;
```




<hr>



### variable is\_fundamental\_v 

```C++
constexpr bool zmbt::is_fundamental_v;
```




<hr>



### variable is\_integral\_v 

```C++
constexpr bool zmbt::is_integral_v;
```




<hr>



### variable is\_lvalue\_reference\_v 

```C++
constexpr bool zmbt::is_lvalue_reference_v;
```




<hr>



### variable is\_member\_function\_pointer\_v 

```C++
constexpr bool zmbt::is_member_function_pointer_v;
```




<hr>



### variable is\_member\_object\_pointer\_v 

```C++
constexpr bool zmbt::is_member_object_pointer_v;
```




<hr>



### variable is\_member\_pointer\_v 

```C++
constexpr bool zmbt::is_member_pointer_v;
```




<hr>



### variable is\_move\_assignable\_v 

```C++
constexpr bool zmbt::is_move_assignable_v;
```




<hr>



### variable is\_move\_constructible\_v 

```C++
constexpr bool zmbt::is_move_constructible_v;
```




<hr>



### variable is\_nothrow\_assignable\_v 

```C++
constexpr bool zmbt::is_nothrow_assignable_v;
```




<hr>



### variable is\_nothrow\_copy\_assignable\_v 

```C++
constexpr bool zmbt::is_nothrow_copy_assignable_v;
```




<hr>



### variable is\_nothrow\_copy\_constructible\_v 

```C++
constexpr bool zmbt::is_nothrow_copy_constructible_v;
```




<hr>



### variable is\_nothrow\_default\_constructible\_v 

```C++
constexpr bool zmbt::is_nothrow_default_constructible_v;
```




<hr>



### variable is\_nothrow\_destructible\_v 

```C++
constexpr bool zmbt::is_nothrow_destructible_v;
```




<hr>



### variable is\_nothrow\_move\_assignable\_v 

```C++
constexpr bool zmbt::is_nothrow_move_assignable_v;
```




<hr>



### variable is\_nothrow\_move\_constructible\_v 

```C++
constexpr bool zmbt::is_nothrow_move_constructible_v;
```




<hr>



### variable is\_null\_pointer\_v 

```C++
constexpr bool zmbt::is_null_pointer_v;
```




<hr>



### variable is\_object\_v 

```C++
constexpr bool zmbt::is_object_v;
```




<hr>



### variable is\_pointer\_v 

```C++
constexpr bool zmbt::is_pointer_v;
```




<hr>



### variable is\_polymorphic\_v 

```C++
constexpr bool zmbt::is_polymorphic_v;
```




<hr>



### variable is\_reference\_v 

```C++
constexpr bool zmbt::is_reference_v;
```




<hr>



### variable is\_rvalue\_reference\_v 

```C++
constexpr bool zmbt::is_rvalue_reference_v;
```




<hr>



### variable is\_same\_v 

```C++
constexpr bool zmbt::is_same_v;
```




<hr>



### variable is\_scalar\_v 

```C++
constexpr bool zmbt::is_scalar_v;
```




<hr>



### variable is\_signed\_v 

```C++
constexpr bool zmbt::is_signed_v;
```




<hr>



### variable is\_standard\_layout\_v 

```C++
constexpr bool zmbt::is_standard_layout_v;
```




<hr>



### variable is\_trivial\_v 

```C++
constexpr bool zmbt::is_trivial_v;
```




<hr>



### variable is\_trivially\_assignable\_v 

```C++
constexpr bool zmbt::is_trivially_assignable_v;
```




<hr>



### variable is\_trivially\_copy\_assignable\_v 

```C++
constexpr bool zmbt::is_trivially_copy_assignable_v;
```




<hr>



### variable is\_trivially\_copy\_constructible\_v 

```C++
constexpr bool zmbt::is_trivially_copy_constructible_v;
```




<hr>



### variable is\_trivially\_copyable\_v 

```C++
constexpr bool zmbt::is_trivially_copyable_v;
```




<hr>



### variable is\_trivially\_default\_constructible\_v 

```C++
constexpr bool zmbt::is_trivially_default_constructible_v;
```




<hr>



### variable is\_trivially\_destructible\_v 

```C++
constexpr bool zmbt::is_trivially_destructible_v;
```




<hr>



### variable is\_trivially\_move\_assignable\_v 

```C++
constexpr bool zmbt::is_trivially_move_assignable_v;
```




<hr>



### variable is\_trivially\_move\_constructible\_v 

```C++
constexpr bool zmbt::is_trivially_move_constructible_v;
```




<hr>



### variable is\_union\_v 

```C++
constexpr bool zmbt::is_union_v;
```




<hr>



### variable is\_unsigned\_v 

```C++
constexpr bool zmbt::is_unsigned_v;
```




<hr>



### variable is\_void\_v 

```C++
constexpr bool zmbt::is_void_v;
```




<hr>



### variable is\_volatile\_v 

```C++
constexpr bool zmbt::is_volatile_v;
```




<hr>



### variable tuple\_size\_v 

```C++
constexpr size_t zmbt::tuple_size_v;
```




<hr>
## Public Functions Documentation




### function InitZmbt 

_Initialize test application._ 
```C++
void zmbt::InitZmbt (
    int argc,
    char ** argv
) 
```




<hr>



### function InterfaceRecord 

_Make TypedInterfaceHandle instance._ 
```C++
template<class Interface>
Environment::TypedInterfaceHandle < Interface > zmbt::InterfaceRecord (
    Interface const & interface,
    object_id const & obj={ ifc_host_nullptr < Interface >}
) 
```





**Template parameters:**


* `Interface` 



**Parameters:**


* `obj` 
* `interface` 



**Returns:**

TypedInterfaceHandle&lt;Interface&gt; 





        

<hr>



### function construct\_or\_default 

_Construct T from the given arguments or return default T if construction is invalid._ 
```C++
template<class T, class... A>
T zmbt::construct_or_default (
    A &&... args
) 
```




<hr>



### function convert\_tuple\_to 

_Convert given tuple to a tuple of type T._ 
```C++
template<class T, class... A>
inline T zmbt::convert_tuple_to (
    tuple< A... > & source
) 
```





**Template parameters:**


* `T` target tuple type 
* `A` source tuple parameters 



**Parameters:**


* `source` input tuple 



**Returns:**

T 





        

<hr>



### function default\_test\_failure 

_default test failure handler_ 
```C++
void zmbt::default_test_failure (
    boost::json::value const & report
) 
```




<hr>



### function dejsonize 

```C++
template<class T>
reflect::detail::disable_hermetic_serialization< T, T > zmbt::dejsonize (
    boost::json::value const & v
) 
```




<hr>



### function dejsonize 

```C++
template<class T>
reflect::detail::enable_hermetic_serialization< T, T > zmbt::dejsonize (
    boost::json::value const & v
) 
```




<hr>



### function dejsonize&lt; void &gt; 

```C++
template<>
inline void zmbt::dejsonize< void > (
    boost::json::value const &
) 
```




<hr>



### function dejsonize\_array 

```C++
template<class T, std::size_t N>
void zmbt::dejsonize_array (
    boost::json::array const & jarr,
    T(&) array
) 
```




<hr>



### function format 

_boost::format wrapper with printf-like api_ 
```C++
template<class... A>
std::string zmbt::format (
    boost::json::string_view fmtstr,
    A &&... arg
) 
```




<hr>



### function format\_failure\_report 

_default failure report formatter_ 
```C++
void zmbt::format_failure_report (
    std::ostream & os,
    boost::json::value const & report
) 
```




<hr>



### function get\_ifc\_handle 

_Get reference to callable object._ 
```C++
template<class Interface, class Result>
auto zmbt::get_ifc_handle (
    Interface const x
) 
```




<hr>



### function get\_ifc\_handle 

```C++
template<class Interface, class Result>
auto zmbt::get_ifc_handle (
    Interface * x
) 
```




<hr>



### function get\_ifc\_handle 

```C++
template<class Interface, class Result>
auto zmbt::get_ifc_handle (
    Interface & x
) 
```




<hr>



### function get\_ifc\_pointer 

_Get pointer to callable object._ 
```C++
template<class Interface, class Result>
auto zmbt::get_ifc_pointer (
    Interface x
) 
```




<hr>



### function get\_ifc\_pointer 

```C++
template<class Interface, class Result>
auto zmbt::get_ifc_pointer (
    Interface * x
) 
```




<hr>



### function get\_ifc\_pointer 

```C++
template<class Interface, class Result>
auto zmbt::get_ifc_pointer (
    Interface & x
) 
```




<hr>



### function get\_tid 

_get thread id in string_ 
```C++
std::string zmbt::get_tid () 
```




<hr>



### function get\_ts 

_get timestamp_ 
```C++
std::size_t zmbt::get_ts () 
```




<hr>



### function json\_from 

```C++
template<class T, class TT>
reflect::detail::disable_hermetic_serialization< TT, boost::json::value > zmbt::json_from (
    T && t
) 
```




<hr>



### function json\_from 

```C++
template<class T, class TT>
reflect::detail::enable_hermetic_serialization< TT, boost::json::value > zmbt::json_from (
    T && t
) 
```




<hr>



### function json\_from 

```C++
inline boost::json::value zmbt::json_from (
    std::tuple<>
) 
```




<hr>



### function json\_from\_array 

```C++
template<class T, std::size_t N>
boost::json::value zmbt::json_from_array (
    T const (&) array
) 
```




<hr>



### function make\_slice\_const\_generator 

```C++
js_array_slice_const_gen zmbt::make_slice_const_generator (
    boost::json::array const & src,
    std::int64_t const start=0,
    std::int64_t const stop=-1,
    std::int64_t const step=1
) 
```




<hr>



### function make\_slice\_const\_generator 

```C++
js_string_slice_gen zmbt::make_slice_const_generator (
    boost::json::string_view const src,
    std::int64_t const start=0,
    std::int64_t const stop=-1,
    std::int64_t const step=1
) 
```




<hr>



### function make\_slice\_generator 

```C++
js_array_slice_gen zmbt::make_slice_generator (
    boost::json::array & src,
    std::int64_t const start=0,
    std::int64_t const stop=-1,
    std::int64_t const step=1
) 
```




<hr>



### function maybe\_real\_to\_number 

```C++
boost::json::value zmbt::maybe_real_to_number (
    boost::json::value const & value
) 
```




<hr>



### function maybe\_real\_to\_number\_inplace 

```C++
bool zmbt::maybe_real_to_number_inplace (
    boost::json::value & value
) 
```



Convert a signed integer to JSON number in place, storing result as uint64\_t if possible. 


        

<hr>



### function param\_transform 

_Transform_ [_**Param**_](classzmbt_1_1Param.md) _value of type T to json value and handle type-specific environment effects._
```C++
template<class T>
boost::json::value zmbt::param_transform (
    Param const & param,
    boost::json::array const & pointers,
    T && value
) 
```




<hr>



### function pretty\_print 

_Pretty print JSON data._ 
```C++
std::ostream & zmbt::pretty_print (
    std::ostream & os,
    boost::json::value const & jv,
    int const indent=0
) 
```





**Parameters:**


* `os` 
* `jv` 
* `indent` initial indent 



**Returns:**

std::ostream& 





        

<hr>



### function real\_to\_number 

```C++
boost::json::value zmbt::real_to_number (
    double value
) 
```



Convert a double to a JSON number, storing result as uint64\_t or int64\_t if possible. 


        

<hr>



### function real\_to\_number 

```C++
boost::json::value zmbt::real_to_number (
    std::int64_t value
) 
```



Convert a signed integer to JSON number, storing result as uint64\_t if possible. 


        

<hr>



### function slice 

_Slice array with inclusive boundaries and subsignal cherry-pick._ 
```C++
boost::json::array zmbt::slice (
    boost::json::array const & src,
    boost::json::string_view jp,
    std::int64_t const start=0,
    std::int64_t const stop=-1,
    std::int64_t const step=1
) 
```





**Parameters:**


* `src` source array 
* `jp` JSON Pointer for subsignal cherry-pick 
* `start` start index, 0-based, inclusive; negative value yields reverse index; 
* `stop` stop index, 0-based, inclusive; negative value yields reverse index; 
* `step` step value, negative value yields reverse iteration 



**Returns:**

slice array 





        

<hr>



### function slice 

_Slice array with inclusive boundaries._ 
```C++
boost::json::array zmbt::slice (
    boost::json::array const & src,
    std::int64_t const start=0,
    std::int64_t const stop=-1,
    std::int64_t const step=1
) 
```





**Parameters:**


* `src` source array 
* `start` start index, 0-based, inclusive; negative value yields reverse index; 
* `stop` stop index, 0-based, inclusive; negative value yields reverse index; 
* `step` step value, negative value yields reverse iteration 



**Returns:**

slice array 





        

<hr>



### function slice 

```C++
boost::json::string zmbt::slice (
    boost::json::string_view const src,
    std::int64_t const start=0,
    std::int64_t const stop=-1,
    std::int64_t const step=1
) 
```




<hr>



### function throw\_exception 

```C++
template<class E>
void zmbt::throw_exception (
    E && e
) 
```




<hr>



### function tid2str 

_thread id to string_ 
```C++
std::string zmbt::tid2str (
    std::thread::id const tid
) 
```




<hr>



### function tuple\_exchange 

```C++
template<class T1, class T2>
void zmbt::tuple_exchange (
    T1 & target,
    T2 const & src
) 
```




<hr>



### function type\_name 

_Prettified typename._ 
```C++
template<class T>
inline std::string zmbt::type_name () 
```





**Template parameters:**


* `T` 



**Returns:**

std::string 





        

<hr>



### function type\_name 

_Prettified typename._ 
```C++
template<class T>
inline std::string zmbt::type_name (
    T
) 
```





**Template parameters:**


* `T` 



**Returns:**

std::string 





        

<hr>

------------------------------
The documentation for this class was generated from the following file `zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/api/model_test.hpp`

