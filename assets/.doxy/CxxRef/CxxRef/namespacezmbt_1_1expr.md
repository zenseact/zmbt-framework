

# Namespace zmbt::expr



[**Namespace List**](namespaces.md) **>** [**zmbt**](namespacezmbt.md) **>** [**expr**](namespacezmbt_1_1expr.md)



_Expression Language API._ 






















## Public Attributes

| Type | Name |
| ---: | :--- |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Abs &gt; const | [**Abs**](#variable-abs)  <br>_Absolute value._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Acos &gt; const | [**Acos**](#variable-acos)  <br>_Arccos function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Acosh &gt; const | [**Acosh**](#variable-acosh)  <br>_Hyperbolic arccos._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Add &gt; const | [**Add**](#variable-add)  <br>_Addition._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::All &gt; const | [**All**](#variable-all)  <br>_Match all predicates._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::And &gt; const | [**And**](#variable-and)  <br>_Logical and._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Any &gt; const | [**Any**](#variable-any)  <br>_Match any predicate._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Near &gt; const | [**Approx**](#variable-approx)  <br>_Alias for Near._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Arange &gt; const | [**Arange**](#variable-arange)  <br>_Generate range of numbers._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Argmax &gt; const | [**Argmax**](#variable-argmax)  <br>_Max value index by key function._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Argmin &gt; const | [**Argmin**](#variable-argmin)  <br>_Min value index by key function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Asin &gt; const | [**Asin**](#variable-asin)  <br>_Arcsin function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Asinh &gt; const | [**Asinh**](#variable-asinh)  <br>_Hyperbolic arcsin._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Assert &gt; const | [**Assert**](#variable-assert)  <br>_Return argument if it holds assertion or error otherwise._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::At &gt; const | [**At**](#variable-at)  <br> |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Atan &gt; const | [**Atan**](#variable-atan)  <br>_Arctan function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Atanh &gt; const | [**Atanh**](#variable-atanh)  <br>_Hyperbolic arctan._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Avg &gt; const | [**Avg**](#variable-avg)  <br>_Arythmetic average._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Bind &gt; const | [**Bind**](#variable-bind)  <br>_Bind design-time parameters to function._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::BitAnd &gt; const | [**BitAnd**](#variable-bitand)  <br>_Bitwise and._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::BitNot &gt; const | [**BitNot**](#variable-bitnot)  <br>_Bitwise not._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::BitOr &gt; const | [**BitOr**](#variable-bitor)  <br>_Bitwise or._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::BitXor &gt; const | [**BitXor**](#variable-bitxor)  <br>_Bitwise xor._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Bool &gt; const | [**Bool**](#variable-bool)  <br>_Predicate on boolean transform (aka truthy)_  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Q &gt; const | [**C**](#variable-c)  <br>_Alias for Q._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Capitalize &gt; const | [**Capitalize**](#variable-capitalize)  <br>_Capitalize string._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Card &gt; const | [**Card**](#variable-card)  <br>_Set cardinality (uniques count)_  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Cartesian &gt; const | [**Cartesian**](#variable-cartesian)  <br>_Cartesian product._  |
|  [**lang::SignatureCast**](structzmbt_1_1lang_1_1SignatureCast.md) const | [**Cast**](#variable-cast)  <br>_Reserialize decorated type as decorator._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Cat &gt; const | [**Cat**](#variable-cat)  <br>_Concatenate sequences._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Ceil &gt; const | [**Ceil**](#variable-ceil)  <br>_Ceil._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Chunks &gt; const | [**Chunks**](#variable-chunks)  <br>_Split into chunks of specified max width._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Cat &gt; const | [**Concat**](#variable-concat)  <br>_Alias for Cat._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Q &gt; const | [**Const**](#variable-const)  <br>_Alias for Q._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Ni &gt; const | [**Contains**](#variable-contains)  <br>_Alias for Ni._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Cos &gt; const | [**Cos**](#variable-cos)  <br>_Cosinus function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Cosh &gt; const | [**Cosh**](#variable-cosh)  <br>_Hyperbolic cos._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Count &gt; const | [**Count**](#variable-count)  <br>_Count matches by predicate param._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::D &gt; const | [**D**](#variable-d)  <br>_Return x if not null, else return default value._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Dbg &gt; const | [**Dbg**](#variable-dbg)  <br>_Evaluate function and print evaluation log to stderr._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Dbg &gt; const | [**Debug**](#variable-debug)  <br>_Alias for Dbg._  |
|  [**lang::SignatureCast**](structzmbt_1_1lang_1_1SignatureCast.md) const | [**Decorate**](#variable-decorate)  <br>_Alias for Cast._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::D &gt; const | [**Default**](#variable-default)  <br>_Alias for D._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Del &gt; const | [**Del**](#variable-del)  <br>_Delete elements from structure by given query._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Del &gt; const | [**Delete**](#variable-delete)  <br>_Alias for Del._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Diff &gt; const | [**Diff**](#variable-diff)  <br>_Set difference._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Div &gt; const | [**Div**](#variable-div)  <br>_Division._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::E &gt; const | [**E**](#variable-e)  <br>_Euler's number._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Each &gt; const | [**Each**](#variable-each)  <br>_Test predicate for each item in a sequence._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Elif &gt; const | [**Elif**](#variable-elif)  <br>_Else if._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Else &gt; const | [**Else**](#variable-else)  <br>_Else._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Enumerate &gt; const | [**Enumerate**](#variable-enumerate)  <br>_Enumerate sequence._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::EnvLoad &gt; const | [**EnvLoad**](#variable-envload)  <br>_Load value from the test environment using json pointer._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::EnvStore &gt; const | [**EnvStore**](#variable-envstore)  <br>_Store value in the test environment using json pointer._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::Eps &gt; const | [**Eps**](#variable-eps)  <br>_Machine epsilon._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Eq &gt; const | [**Eq**](#variable-eq)  <br>_Is equal._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Erf &gt; const | [**Erf**](#variable-erf)  <br>_Error function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Erfc &gt; const | [**Erfc**](#variable-erfc)  <br>_Error function complement._  |
|  [**lang::SignatureErr**](structzmbt_1_1lang_1_1SignatureErr.md) const | [**Err**](#variable-err)  <br>_Error object._  |
|  [**lang::SignatureErr**](structzmbt_1_1lang_1_1SignatureErr.md) const | [**Error**](#variable-error)  <br>_Alias for Err._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Eval &gt; const | [**Eval**](#variable-eval)  <br>_Flip designtime and run-time parameters, evaluating input as expression._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Exp &gt; const | [**Exp**](#variable-exp)  <br>_Exponential (e^x)_  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::False &gt; const | [**False**](#variable-false)  <br>_Logical false._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Not &gt; const | [**Falsy**](#variable-falsy)  <br>_Alias for Not._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Filter &gt; const | [**Filter**](#variable-filter)  <br>_Filter sequence by predicate param._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Find &gt; const | [**Find**](#variable-find)  <br>_Find the first element that satisfies given predicate._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::FindIdx &gt; const | [**FindIdx**](#variable-findidx)  <br>_Find index of the first element that satisfies given predicate._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::FindPtr &gt; const | [**FindPtr**](#variable-findptr)  <br>_Find json pointer of the first element that satisfies given predicate._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::First &gt; const | [**First**](#variable-first)  <br>_First item of sequence._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Flatten &gt; const | [**Flatten**](#variable-flatten)  <br>_Flatten nested list._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Flip &gt; const | [**Flip**](#variable-flip)  <br>_Flip design-time and eval-time parameters._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Floor &gt; const | [**Floor**](#variable-floor)  <br>_Floor._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Fmt &gt; const | [**Fmt**](#variable-fmt)  <br>_Format string with the given parameter list._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Fn &gt; const | [**Fn**](#variable-fn)  <br>_Symbolic binding of the inline function._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Fold &gt; const | [**Fold**](#variable-fold)  <br>_Reduce sequence with binary operator._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Fork &gt; const | [**Fork**](#variable-fork)  <br>_Pack results from enveloped functions into an array._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Fmt &gt; const | [**Format**](#variable-format)  <br>_Alias for Fmt._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Gamma &gt; const | [**Gamma**](#variable-gamma)  <br>_Gamma function._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Ge &gt; const | [**Ge**](#variable-ge)  <br>_Greater or equal._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Get &gt; const | [**Get**](#variable-get)  <br>_Load linked value (maybe a closure) or return null._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Gt &gt; const | [**Gt**](#variable-gt)  <br>_Greater than._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Id &gt; const | [**Id**](#variable-id)  <br>_Identity function._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::If &gt; const | [**If**](#variable-if)  <br>_Branching operator._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::In &gt; const | [**In**](#variable-in)  <br>_Element is in._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::Inf &gt; const | [**Inf**](#variable-inf)  <br>_Infinity._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Intersect &gt; const | [**Intersect**](#variable-intersect)  <br>_Set intersection._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::IsErr &gt; const | [**IsErr**](#variable-iserr)  <br>_Test the argument is err expression._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::IsErr &gt; const | [**Iserror**](#variable-iserror)  <br>_Alias for IsErr._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Items &gt; const | [**Items**](#variable-items)  <br>_Extract key-value pairs from object._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Keys &gt; const | [**Keys**](#variable-keys)  <br>_Extract keys from object._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Kwrd &gt; const | [**Kwrd**](#variable-kwrd)  <br>_Introspect expression keyword._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Last &gt; const | [**Last**](#variable-last)  <br>_Last item of sequence._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Le &gt; const | [**Le**](#variable-le)  <br>_Lesser or equal._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Link &gt; const | [**Link**](#variable-link)  <br>_Symbolic binding of the input value._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Log &gt; const | [**Log**](#variable-log)  <br>_Logarithm._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Lookup &gt; const | [**Lookup**](#variable-lookup)  <br>_Lookup table function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::LowerCase &gt; const | [**LowerCase**](#variable-lowercase)  <br>_Lower case string._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Lshift &gt; const | [**Lshift**](#variable-lshift)  <br>_Bitwise left shift._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Lt &gt; const | [**Lt**](#variable-lt)  <br>_Lesser than._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Map &gt; const | [**Map**](#variable-map)  <br>_Apply param expr to every element of sequence._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Max &gt; const | [**Max**](#variable-max)  <br>_Max value by key function._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Min &gt; const | [**Min**](#variable-min)  <br>_Min value by key function._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Mod &gt; const | [**Mod**](#variable-mod)  <br>_Modulo._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Mul &gt; const | [**Mul**](#variable-mul)  <br>_Multiplication._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::NaN &gt; const | [**NaN**](#variable-nan)  <br>_Not a number._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Ne &gt; const | [**Ne**](#variable-ne)  <br>_Not equal._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Near &gt; const | [**Near**](#variable-near)  <br>_Floating point approximately equal._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Neg &gt; const | [**Neg**](#variable-neg)  <br>_Negate._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Ni &gt; const | [**Ni**](#variable-ni)  <br>_Contains element._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Not &gt; const | [**Nil**](#variable-nil)  <br>_Alias for Not._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::Noop &gt; const | [**Noop**](#variable-noop)  <br>_No operation._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Not &gt; const | [**Not**](#variable-not)  <br>_Logical complement._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::NotIn &gt; const | [**NotIn**](#variable-notin)  <br>_Element is not in._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::NotNi &gt; const | [**NotNi**](#variable-notni)  <br>_Not contains element._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::Null &gt; const | [**Null**](#variable-null)  <br>_Null value._  |
|  [**lang::SignatureOp**](structzmbt_1_1lang_1_1SignatureOp.md) const | [**Op**](#variable-op)  <br>_Bind type-specific operator handler to function._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Or &gt; const | [**Or**](#variable-or)  <br>_Logical or._  |
|  [**lang::SignatureOp**](structzmbt_1_1lang_1_1SignatureOp.md) const | [**Overload**](#variable-overload)  <br>_Alias for Op._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::PSubset &gt; const | [**PSubset**](#variable-psubset)  <br>_Is proper subset._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::PSuperset &gt; const | [**PSuperset**](#variable-psuperset)  <br>_Is proper superset._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Prms &gt; const | [**Parameters**](#variable-parameters)  <br>_Alias for Prms._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Parse &gt; const | [**Parse**](#variable-parse)  <br>_Parse string as json._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::Pi &gt; const | [**Pi**](#variable-pi)  <br>_Pi constant._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Pipe &gt; const | [**Pipe**](#variable-pipe)  <br>_Pipe functions in left-to-right composition._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Pow &gt; const | [**Pow**](#variable-pow)  <br>_To power._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::PreProc &gt; const | [**PreProc**](#variable-preproc)  <br>_Preprocessing token._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Prms &gt; const | [**Prms**](#variable-prms)  <br>_Introspect expression parameters._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Prod &gt; const | [**Prod**](#variable-prod)  <br>_Multiplication reduction._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Push &gt; const | [**Push**](#variable-push)  <br>_Push element into a front of sequence._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Q &gt; const | [**Q**](#variable-q)  <br>_Quote parameter, similar to lisp quotation._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Quot &gt; const | [**Quot**](#variable-quot)  <br>_Quotient._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Rand &gt; const | [**Rand**](#variable-rand)  <br>_Uniformly distributed random number in the half-open interval [0.0, 1.0)_  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::RandInt &gt; const | [**RandInt**](#variable-randint)  <br>_Uniformly distributed random integer in the given range._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Re &gt; const | [**Re**](#variable-re)  <br>_Regular expression match._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Recur &gt; const | [**Recur**](#variable-recur)  <br>_Apply recursion to parameter expr and initial value._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Fold &gt; const | [**Reduce**](#variable-reduce)  <br>_Alias for Fold._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Re &gt; const | [**Regex**](#variable-regex)  <br>_Alias for Re._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Repeat &gt; const | [**Repeat**](#variable-repeat)  <br>_Repeat value in list._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Reverse &gt; const | [**Reverse**](#variable-reverse)  <br>_Reverse sequence._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Round &gt; const | [**Round**](#variable-round)  <br>_Round to nearest integer._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Rshift &gt; const | [**Rshift**](#variable-rshift)  <br>_Bitwise right shift._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Saturate &gt; const | [**Saturate**](#variable-saturate)  <br>_Saturate matches in order._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Sequence &gt; const | [**Seq**](#variable-seq)  <br>_Alias for Sequence._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Sequence &gt; const | [**Sequence**](#variable-sequence)  <br>_Produce sequence from parameter using arg as size._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Str &gt; const | [**Serialize**](#variable-serialize)  <br>_Alias for Str._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::SetEq &gt; const | [**SetEq**](#variable-seteq)  <br>_Equal as set._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Sign &gt; const | [**Sign**](#variable-sign)  <br>_Sign._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Sin &gt; const | [**Sin**](#variable-sin)  <br>_Sinus function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Sinh &gt; const | [**Sinh**](#variable-sinh)  <br>_Hyperbolic sin._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Size &gt; const | [**Size**](#variable-size)  <br>_Sequence size._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Slide &gt; const | [**Slide**](#variable-slide)  <br>_Sliding-window iteration._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Sort &gt; const | [**Sort**](#variable-sort)  <br>_Sort list by key function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Sqrt &gt; const | [**Sqrt**](#variable-sqrt)  <br>_Square root._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Str &gt; const | [**Str**](#variable-str)  <br>_Serialize json as string._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Stride &gt; const | [**Stride**](#variable-stride)  <br>_Striding iteration._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Sub &gt; const | [**Sub**](#variable-sub)  <br>_Subtraction._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Subset &gt; const | [**Subset**](#variable-subset)  <br>_Is subset._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Sum &gt; const | [**Sum**](#variable-sum)  <br>_Summation reduction._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Superset &gt; const | [**Superset**](#variable-superset)  <br>_Is superset._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Tan &gt; const | [**Tan**](#variable-tan)  <br>_Tangens function._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Tanh &gt; const | [**Tanh**](#variable-tanh)  <br>_Hyperbolic tan._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::Thread &gt; const | [**Thread**](#variable-thread)  <br>_Thread id._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::ToList &gt; const | [**ToList**](#variable-tolist)  <br>_Put argument into a list._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Trace &gt; const | [**Trace**](#variable-trace)  <br>_Same as id, but also prints identifier parameter to debug log._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Transp &gt; const | [**Transp**](#variable-transp)  <br>_Transpose multidimensional list, turning rows into columns._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::True &gt; const | [**True**](#variable-true)  <br>_Logical true._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Bool &gt; const | [**Truthy**](#variable-truthy)  <br>_Alias for Bool._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Try &gt; const | [**Try**](#variable-try)  <br>_Evaluate function and return result or null if it returns error._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Tuple &gt; const | [**Tuple**](#variable-tuple)  <br>_Pack expressions into an tuple without evaluation._  |
|  [**lang::SignatureUncast**](structzmbt_1_1lang_1_1SignatureUncast.md) const | [**Uncast**](#variable-uncast)  <br>_Reserialize decorator as decorated type._  |
|  [**lang::SignatureUncast**](structzmbt_1_1lang_1_1SignatureUncast.md) const | [**Undecorate**](#variable-undecorate)  <br>_Alias for Uncast._  |
|  [**lang::SignatureVariadic**](structzmbt_1_1lang_1_1SignatureVariadic.md)&lt;::zmbt::lang::Keyword::Unfold &gt; const | [**Unfold**](#variable-unfold)  <br>_Put results of recursive fn call on initial value into an array._  |
|  [**lang::SignatureBinary**](structzmbt_1_1lang_1_1SignatureBinary.md)&lt;::zmbt::lang::Keyword::Union &gt; const | [**Union**](#variable-union)  <br>_Set union._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Uniques &gt; const | [**Uniques**](#variable-uniques)  <br>_Filter unique elements._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::UpperCase &gt; const | [**UpperCase**](#variable-uppercase)  <br>_Upper case string._  |
|  [**lang::SignatureUnary**](structzmbt_1_1lang_1_1SignatureUnary.md)&lt;::zmbt::lang::Keyword::Values &gt; const | [**Values**](#variable-values)  <br>_Extract values from object._  |
|  [**lang::SignatureConst**](structzmbt_1_1lang_1_1SignatureConst.md)&lt;::zmbt::lang::Keyword::Noop &gt; const | [**\_**](#variable-_)  <br>_Alias for Noop._  |












































## Public Attributes Documentation




### variable Abs 

_Absolute value._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Abs> const zmbt::expr::Abs;
```




<hr>



### variable Acos 

_Arccos function._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Acos> const zmbt::expr::Acos;
```




<hr>



### variable Acosh 

_Hyperbolic arccos._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Acosh> const zmbt::expr::Acosh;
```




<hr>



### variable Add 

_Addition._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Add> const zmbt::expr::Add;
```




<hr>



### variable All 

_Match all predicates._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::All> const zmbt::expr::All;
```




<hr>



### variable And 

_Logical and._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::And> const zmbt::expr::And;
```



Generic behavior: if first operand is truthy, returns second operand, otherwise first 


        

<hr>



### variable Any 

_Match any predicate._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Any> const zmbt::expr::Any;
```




<hr>



### variable Approx 

_Alias for Near._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Near> const zmbt::expr::Approx;
```




<hr>



### variable Arange 

_Generate range of numbers._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Arange> const zmbt::expr::Arange;
```



Return evenly spaced values within a given interval.


Parameters:



* start: start value
* stop: stop value
* step: step value




Parameters dynamic evaluation:



* stop: int -&gt; [0, stop, 1]
* [start, stop] -&gt; [start, stop, 1]
* [start, stop, step] -&gt; [start, stop, step] 




        

<hr>



### variable Argmax 

_Max value index by key function._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Argmax> const zmbt::expr::Argmax;
```




<hr>



### variable Argmin 

_Min value index by key function._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Argmin> const zmbt::expr::Argmin;
```




<hr>



### variable Asin 

_Arcsin function._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Asin> const zmbt::expr::Asin;
```




<hr>



### variable Asinh 

_Hyperbolic arcsin._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Asinh> const zmbt::expr::Asinh;
```




<hr>



### variable Assert 

_Return argument if it holds assertion or error otherwise._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Assert> const zmbt::expr::Assert;
```




<hr>



### variable At 

```C++
lang::SignatureBinary<::zmbt::lang::Keyword::At> const zmbt::expr::At;
```



$


Structure index is evaluated as array index or as key-value pair index for objects on order-preserving backends.


Result is null if requested element not found. 


        

<hr>



### variable Atan 

_Arctan function._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Atan> const zmbt::expr::Atan;
```




<hr>



### variable Atanh 

_Hyperbolic arctan._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Atanh> const zmbt::expr::Atanh;
```




<hr>



### variable Avg 

_Arythmetic average._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Avg> const zmbt::expr::Avg;
```




<hr>



### variable Bind 

_Bind design-time parameters to function._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Bind> const zmbt::expr::Bind;
```




<hr>



### variable BitAnd 

_Bitwise and._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::BitAnd> const zmbt::expr::BitAnd;
```




<hr>



### variable BitNot 

_Bitwise not._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::BitNot> const zmbt::expr::BitNot;
```




<hr>



### variable BitOr 

_Bitwise or._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::BitOr> const zmbt::expr::BitOr;
```




<hr>



### variable BitXor 

_Bitwise xor._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::BitXor> const zmbt::expr::BitXor;
```




<hr>



### variable Bool 

_Predicate on boolean transform (aka truthy)_ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Bool> const zmbt::expr::Bool;
```




<hr>



### variable C 

_Alias for Q._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Q> const zmbt::expr::C;
```




<hr>



### variable Capitalize 

_Capitalize string._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Capitalize> const zmbt::expr::Capitalize;
```




<hr>



### variable Card 

_Set cardinality (uniques count)_ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Card> const zmbt::expr::Card;
```




<hr>



### variable Cartesian 

_Cartesian product._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Cartesian> const zmbt::expr::Cartesian;
```




<hr>



### variable Cast 

_Reserialize decorated type as decorator._ 
```C++
lang::SignatureCast const zmbt::expr::Cast;
```




<hr>



### variable Cat 

_Concatenate sequences._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Cat> const zmbt::expr::Cat;
```




<hr>



### variable Ceil 

_Ceil._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Ceil> const zmbt::expr::Ceil;
```




<hr>



### variable Chunks 

_Split into chunks of specified max width._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Chunks> const zmbt::expr::Chunks;
```



Similar to Stride, but includes the last subsequence smaller then step width. 


        

<hr>



### variable Concat 

_Alias for Cat._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Cat> const zmbt::expr::Concat;
```




<hr>



### variable Const 

_Alias for Q._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Q> const zmbt::expr::Const;
```




<hr>



### variable Contains 

_Alias for Ni._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Ni> const zmbt::expr::Contains;
```




<hr>



### variable Cos 

_Cosinus function._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Cos> const zmbt::expr::Cos;
```




<hr>



### variable Cosh 

_Hyperbolic cos._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Cosh> const zmbt::expr::Cosh;
```




<hr>



### variable Count 

_Count matches by predicate param._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Count> const zmbt::expr::Count;
```




<hr>



### variable D 

_Return x if not null, else return default value._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::D> const zmbt::expr::D;
```




<hr>



### variable Dbg 

_Evaluate function and print evaluation log to stderr._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Dbg> const zmbt::expr::Dbg;
```




<hr>



### variable Debug 

_Alias for Dbg._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Dbg> const zmbt::expr::Debug;
```




<hr>



### variable Decorate 

_Alias for Cast._ 
```C++
lang::SignatureCast const zmbt::expr::Decorate;
```




<hr>



### variable Default 

_Alias for D._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::D> const zmbt::expr::Default;
```




<hr>



### variable Del 

_Delete elements from structure by given query._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Del> const zmbt::expr::Del;
```



Possible queries:
* Structure index (negative resolves as reverse)
* JSON Pointer
* List of queries




Structure index is evaluated as array index or as key-value pair index for objects on order-preserving backends. When deleting an object element, resulting items order may change. 


        

<hr>



### variable Delete 

_Alias for Del._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Del> const zmbt::expr::Delete;
```




<hr>



### variable Diff 

_Set difference._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Diff> const zmbt::expr::Diff;
```




<hr>



### variable Div 

_Division._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Div> const zmbt::expr::Div;
```




* $[ ] \mapsto [x, y] \mapsto x / y$
* $[y] \mapsto [x] \mapsto x / y$ 




        

<hr>



### variable E 

_Euler's number._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::E> const zmbt::expr::E;
```




<hr>



### variable Each 

_Test predicate for each item in a sequence._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Each> const zmbt::expr::Each;
```



Equivalent to `Count(p | Not) |  Eq(0)` 


        

<hr>



### variable Elif 

_Else if._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Elif> const zmbt::expr::Elif;
```



Continuation operator in If-Elif-Else pipe. Will fail if not preceded by If. See If. 


        

<hr>



### variable Else 

_Else._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Else> const zmbt::expr::Else;
```



Resolving operator in If-Elif-Else pipe. Will fail if not preceded by If or Elif. See If. 


        

<hr>



### variable Enumerate 

_Enumerate sequence._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Enumerate> const zmbt::expr::Enumerate;
```



Enumerate sequence with index. 


        

<hr>



### variable EnvLoad 

_Load value from the test environment using json pointer._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::EnvLoad> const zmbt::expr::EnvLoad;
```



Load the the value from a global environment table with a given JSON Pointer. 


        

<hr>



### variable EnvStore 

_Store value in the test environment using json pointer._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::EnvStore> const zmbt::expr::EnvStore;
```



Capture the argument value and store it in a global environment table with a given JSON Pointer, passing the value further similarly to Link. 


        

<hr>



### variable Eps 

_Machine epsilon._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::Eps> const zmbt::expr::Eps;
```




<hr>



### variable Eq 

_Is equal._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Eq> const zmbt::expr::Eq;
```




<hr>



### variable Erf 

_Error function._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Erf> const zmbt::expr::Erf;
```




<hr>



### variable Erfc 

_Error function complement._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Erfc> const zmbt::expr::Erfc;
```




<hr>



### variable Err 

_Error object._ 
```C++
lang::SignatureErr const zmbt::expr::Err;
```



Error object handling the message and context info 


        

<hr>



### variable Error 

_Alias for Err._ 
```C++
lang::SignatureErr const zmbt::expr::Error;
```




<hr>



### variable Eval 

_Flip designtime and run-time parameters, evaluating input as expression._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Eval> const zmbt::expr::Eval;
```




<hr>



### variable Exp 

_Exponential (e^x)_ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Exp> const zmbt::expr::Exp;
```




<hr>



### variable False 

_Logical false._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::False> const zmbt::expr::False;
```




<hr>



### variable Falsy 

_Alias for Not._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Not> const zmbt::expr::Falsy;
```




<hr>



### variable Filter 

_Filter sequence by predicate param._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Filter> const zmbt::expr::Filter;
```




<hr>



### variable Find 

_Find the first element that satisfies given predicate._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Find> const zmbt::expr::Find;
```




<hr>



### variable FindIdx 

_Find index of the first element that satisfies given predicate._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::FindIdx> const zmbt::expr::FindIdx;
```



Similar to FindPtr, but will integer index or nullptr for non-indexable input. Objects are processed as list of key-value pairs. 


        

<hr>



### variable FindPtr 

_Find json pointer of the first element that satisfies given predicate._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::FindPtr> const zmbt::expr::FindPtr;
```




<hr>



### variable First 

_First item of sequence._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::First> const zmbt::expr::First;
```



Equivalent to [**At(0)**](namespacezmbt_1_1expr.md#variable-at) 


        

<hr>



### variable Flatten 

_Flatten nested list._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Flatten> const zmbt::expr::Flatten;
```




<hr>



### variable Flip 

_Flip design-time and eval-time parameters._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Flip> const zmbt::expr::Flip;
```



Useful for binding lhs operands to non-commutative operators. Unlike Haskell's flip, won't change the order or eval-time parameters - for that case use the Reverse keyword instead.


**Prefix operator form (tilde)**:


[**Flip(Div(1))**](namespacezmbt_1_1expr.md#variable-flip) ≡ ~Div(1) 


        

<hr>



### variable Floor 

_Floor._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Floor> const zmbt::expr::Floor;
```




<hr>



### variable Fmt 

_Format string with the given parameter list._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Fmt> const zmbt::expr::Fmt;
```



Constant expressions are supported for the token list, s.t. `"%s" |  Fmt(Pi)` produces "3.141592653589793E0" 


        

<hr>



### variable Fn 

_Symbolic binding of the inline function._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Fn> const zmbt::expr::Fn;
```



Expression `Fn(reference, expr)` creates a symbolic binding between the given reference and an expression, making the expression callable by name within the evaluation context.


The referenced expression is inlined at the call site and evaluated with the current input. The reference is available to the bound expression itself and to all its subexpressions, enabling arbitrary recursion.


Each invocation of a function bound with `Fn` establishes a local scope for argument bindings created via `Link`, forming a lexical closure over the surrounding bindings. Argument links from outer scopes are captured by the function and remain accessible unless shadowed by a local binding. Such captured values can be explicitly read using the `Get` expression


Function bindings are shared across the whole expression and are immutable: once a reference is bound with `Fn`, it cannot be redefined or reset.


**Infix operator form (left shift)**:


`"$f" << E` ≡ `Fn("$f", E)` 


        

<hr>



### variable Fold 

_Reduce sequence with binary operator._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Fold> const zmbt::expr::Fold;
```



To set a specific initial value, use composition with Push, e.g. `Push(0) | Fold(Add)`


For reverse operation, see Unfold 


        

<hr>



### variable Fork 

_Pack results from enveloped functions into an array._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Fork> const zmbt::expr::Fork;
```



Parallel composition operator:



```C++
x | Fork(f1, f2, ..., fn) ↦ [f1(x0), f2(x), ..., fn(x)]
```
 


        

<hr>



### variable Format 

_Alias for Fmt._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Fmt> const zmbt::expr::Format;
```




<hr>



### variable Gamma 

_Gamma function._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Gamma> const zmbt::expr::Gamma;
```




<hr>



### variable Ge 

_Greater or equal._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Ge> const zmbt::expr::Ge;
```




<hr>



### variable Get 

_Load linked value (maybe a closure) or return null._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Get> const zmbt::expr::Get;
```



Explicitly load the value bound to a symbolic reference without triggering capture semantics.


In contexts where a `$`-prefixed reference would otherwise attempt to initialize a new binding, `Get` forces a read of an existing binding from the nearest enclosing scope. If no such binding exists, `null` is returned.


This is particularly useful when working with immutable closures and recursive expressions, where it is necessary to distinguish between reading an upvalue and introducing a new local binding. 


        

<hr>



### variable Gt 

_Greater than._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Gt> const zmbt::expr::Gt;
```




<hr>



### variable Id 

_Identity function._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Id> const zmbt::expr::Id;
```




<hr>



### variable If 

_Branching operator._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::If> const zmbt::expr::If;
```



Branching operator can be used either in Lisp-like mode as `If(predicate, then_expr, else_expr)`, or in pipe mode with Elif or Else operators (see examples).


In pipe mode (without `else_expr` parameter), the chain will produce error if the following order is violated or interrupted: `If [ Elif ]* Else`


In both modes, `then_expr` and `else_expr` are lazy evaluated against run-time argument (which is also true for Elif and Else), making it possible to nest if-else expressions. 


        

<hr>



### variable In 

_Element is in._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::In> const zmbt::expr::In;
```




<hr>



### variable Inf 

_Infinity._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::Inf> const zmbt::expr::Inf;
```




<hr>



### variable Intersect 

_Set intersection._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Intersect> const zmbt::expr::Intersect;
```




<hr>



### variable IsErr 

_Test the argument is err expression._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::IsErr> const zmbt::expr::IsErr;
```




<hr>



### variable Iserror 

_Alias for IsErr._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::IsErr> const zmbt::expr::Iserror;
```




<hr>



### variable Items 

_Extract key-value pairs from object._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Items> const zmbt::expr::Items;
```




<hr>



### variable Keys 

_Extract keys from object._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Keys> const zmbt::expr::Keys;
```




<hr>



### variable Kwrd 

_Introspect expression keyword._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Kwrd> const zmbt::expr::Kwrd;
```




<hr>



### variable Last 

_Last item of sequence._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Last> const zmbt::expr::Last;
```



Equivalent to At(-1) 


        

<hr>



### variable Le 

_Lesser or equal._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Le> const zmbt::expr::Le;
```




<hr>



### variable Link 

_Symbolic binding of the input value._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Link> const zmbt::expr::Link;
```



Capture the current input value and associate it with a symbolic reference represented by a dollar-prefixed string, e.g. `"$x"`.


On its first evaluation, the reference stores the input value (similar to variable initialization) and passes the value further through the pipeline. On subsequent evaluations within the same scope, the stored value is returned, acting as an immutable constant.


A `Link` instance cannot be reset after its first access. However, it may be shadowed by another binding with the same reference name in a nested scope, such as a recursive call created with `Fn`.


The reference name following the `$` sign must not be enclosed in `[]`, `{}`, or `()`, as those formats are reserved for internal use. 


        

<hr>



### variable Log 

_Logarithm._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Log> const zmbt::expr::Log;
```



Logarithm with base b:



* $[ ] \mapsto [x, b] \mapsto log\_b(x)$
* $[b] \mapsto [x] \mapsto log\_b(x)$ 




        

<hr>



### variable Lookup 

_Lookup table function._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Lookup> const zmbt::expr::Lookup;
```



Parametrized at design time with fixed array or object, produces the value at corresponding At query given as eval-time argument. Equivalent to ~At(...) 


        

<hr>



### variable LowerCase 

_Lower case string._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::LowerCase> const zmbt::expr::LowerCase;
```




<hr>



### variable Lshift 

_Bitwise left shift._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Lshift> const zmbt::expr::Lshift;
```




* $[ ] \mapsto [x, s] \mapsto x \texttt{ &lt;&lt; } s$
* $[s] \mapsto [x] \mapsto x \texttt{ &lt;&lt; } s$ 




        

<hr>



### variable Lt 

_Lesser than._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Lt> const zmbt::expr::Lt;
```




<hr>



### variable Map 

_Apply param expr to every element of sequence._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Map> const zmbt::expr::Map;
```




<hr>



### variable Max 

_Max value by key function._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Max> const zmbt::expr::Max;
```




<hr>



### variable Min 

_Min value by key function._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Min> const zmbt::expr::Min;
```




<hr>



### variable Mod 

_Modulo._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Mod> const zmbt::expr::Mod;
```



Modulo of x:



* $[ ] \mapsto [x, m] \mapsto x % m$
* $[m] \mapsto [x] \mapsto x % m$ 




        

<hr>



### variable Mul 

_Multiplication._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Mul> const zmbt::expr::Mul;
```




<hr>



### variable NaN 

_Not a number._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::NaN> const zmbt::expr::NaN;
```




<hr>



### variable Ne 

_Not equal._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Ne> const zmbt::expr::Ne;
```




<hr>



### variable Near 

_Floating point approximately equal._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Near> const zmbt::expr::Near;
```



Based on numpy.isclose:


abs(x - ref) &lt;= (atol + rtol \* abs(ref))


Rhs parameters:


ref: reference value rtol: relative tolerance, default = 1e-05 atol: absolute tolerance, default = 1e-08


Rhs dynamic evaluation:



* ref -&gt; [ref, default, default]
* [ref] -&gt; [ref, default, default]
* [ref, rtol] -&gt; [ref, rtol , default]
* [ref, rtol, atol] -&gt; [ref, rtol , atol ] 




        

<hr>



### variable Neg 

_Negate._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Neg> const zmbt::expr::Neg;
```




<hr>



### variable Ni 

_Contains element._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Ni> const zmbt::expr::Ni;
```




<hr>



### variable Nil 

_Alias for Not._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Not> const zmbt::expr::Nil;
```




<hr>



### variable Noop 

_No operation._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::Noop> const zmbt::expr::Noop;
```



Returns true without input validation. Used in place of matchers for uninteresting signals. 


        

<hr>



### variable Not 

_Logical complement._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Not> const zmbt::expr::Not;
```




<hr>



### variable NotIn 

_Element is not in._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::NotIn> const zmbt::expr::NotIn;
```




<hr>



### variable NotNi 

_Not contains element._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::NotNi> const zmbt::expr::NotNi;
```




<hr>



### variable Null 

_Null value._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::Null> const zmbt::expr::Null;
```




<hr>



### variable Op 

_Bind type-specific operator handler to function._ 
```C++
lang::SignatureOp const zmbt::expr::Op;
```



Expression [**Op(op, f)**](namespacezmbt_1_1expr.md#variable-op) instructs f to use op operator on invocation instead of the default generic.


Operator parameter singleton can be referenced with a string key or constructed in place using type&lt;T&gt; tag.


This operator handler is propagated downstream to all terminal subexpression in `f`. The result of `f(x)` is not decorated as type&lt;T&gt;. 


        

<hr>



### variable Or 

_Logical or._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Or> const zmbt::expr::Or;
```



Generic behavior: if first operand is truthy, returns first operand, second otherwise 


        

<hr>



### variable Overload 

_Alias for Op._ 
```C++
lang::SignatureOp const zmbt::expr::Overload;
```




<hr>



### variable PSubset 

_Is proper subset._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::PSubset> const zmbt::expr::PSubset;
```




<hr>



### variable PSuperset 

_Is proper superset._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::PSuperset> const zmbt::expr::PSuperset;
```




<hr>



### variable Parameters 

_Alias for Prms._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Prms> const zmbt::expr::Parameters;
```




<hr>



### variable Parse 

_Parse string as json._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Parse> const zmbt::expr::Parse;
```




<hr>



### variable Pi 

_Pi constant._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::Pi> const zmbt::expr::Pi;
```




<hr>



### variable Pipe 

_Pipe functions in left-to-right composition._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Pipe> const zmbt::expr::Pipe;
```




<hr>



### variable Pow 

_To power._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Pow> const zmbt::expr::Pow;
```



X to power p
* $[ ] \mapsto [x, p] \mapsto x^p$
* $[p] \mapsto [x] \mapsto x^p$ 




        

<hr>



### variable PreProc 

_Preprocessing token._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::PreProc> const zmbt::expr::PreProc;
```



String token that can be substituted with arbitrary expression on expression preprocessing. 


        

<hr>



### variable Prms 

_Introspect expression parameters._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Prms> const zmbt::expr::Prms;
```




<hr>



### variable Prod 

_Multiplication reduction._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Prod> const zmbt::expr::Prod;
```



Equivalent to [**Reduce(Mul)**](namespacezmbt_1_1expr.md#variable-reduce) 


        

<hr>



### variable Push 

_Push element into a front of sequence._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Push> const zmbt::expr::Push;
```




<hr>



### variable Q 

_Quote parameter, similar to lisp quotation._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Q> const zmbt::expr::Q;
```



Quotation lifts any parameter to constant, s.t. produced expression will return the design-time parameter on evaluation, ignoring input. If evaluable expression is passed, it is returned unevaluated. Unlike plain literals which can be treated as predicate matchers in certain context, [**Q(x)**](namespacezmbt_1_1expr.md#variable-q) is always a constant expression discarding input. ~Q ([**Flip(Q)**](namespacezmbt_1_1expr.md#variable-flip)) is equivalent to Id. 


        

<hr>



### variable Quot 

_Quotient._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Quot> const zmbt::expr::Quot;
```



Quotient of x:



* $[ ] \mapsto [x, d] \mapsto x // d$
* $[d] \mapsto [x] \mapsto x // d$ 




        

<hr>



### variable Rand 

_Uniformly distributed random number in the half-open interval [0.0, 1.0)_ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Rand> const zmbt::expr::Rand;
```




<hr>



### variable RandInt 

_Uniformly distributed random integer in the given range._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::RandInt> const zmbt::expr::RandInt;
```



[**RandInt(x, y)**](namespacezmbt_1_1expr.md#variable-randint) : range is [x, y] [**RandInt(x)**](namespacezmbt_1_1expr.md#variable-randint) : range is [0, x] for positive x and [x, 0] for negative [**RandInt()**](namespacezmbt_1_1expr.md#variable-randint) : range is [0, RAND\_MAX] 


        

<hr>



### variable Re 

_Regular expression match._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Re> const zmbt::expr::Re;
```



If input is not a string, match it's serialized form. 


        

<hr>



### variable Recur 

_Apply recursion to parameter expr and initial value._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Recur> const zmbt::expr::Recur;
```



Inference rules:



* `n |  Recur(x, f)` $\mapsto ◯ⁿ f(x)$, or
* `Q(p) | Recur(x₀, f)` $\mapsto x\_k$, where
  * $x\_{i+1} = f(x\_i)$
  * $p(x\_{i}) = \top \quad \forall i \le k$
  * $p(x\_{i+1}) = \bot$ (exit condition) 






        

<hr>



### variable Reduce 

_Alias for Fold._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Fold> const zmbt::expr::Reduce;
```




<hr>



### variable Regex 

_Alias for Re._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Re> const zmbt::expr::Regex;
```




<hr>



### variable Repeat 

_Repeat value in list._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Repeat> const zmbt::expr::Repeat;
```




<hr>



### variable Reverse 

_Reverse sequence._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Reverse> const zmbt::expr::Reverse;
```




<hr>



### variable Round 

_Round to nearest integer._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Round> const zmbt::expr::Round;
```



Hint: To round to ndigits precision after the decimal point, use `Mul(ndigits) | Round | Div(ndigits)` combo. 


        

<hr>



### variable Rshift 

_Bitwise right shift._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Rshift> const zmbt::expr::Rshift;
```




* $[ ] ↦ [x, s] ↦ x \texttt{ &gt;&gt; } s$
* $[s] ↦ [x] ↦ x \texttt{ &gt;&gt; } s$ 




        

<hr>



### variable Saturate 

_Saturate matches in order._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Saturate> const zmbt::expr::Saturate;
```




<hr>



### variable Seq 

_Alias for Sequence._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Sequence> const zmbt::expr::Seq;
```




<hr>



### variable Sequence 

_Produce sequence from parameter using arg as size._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Sequence> const zmbt::expr::Sequence;
```



Behavior of `n |  Sequence(F)`is similar to n \| [**Flip(Repeat(F))**](namespacezmbt_1_1expr.md#variable-flip), with the main difference that the parameter is reevaluated for each step, making it possible to utilize side-effects, s.a. with Rand. 


        

<hr>



### variable Serialize 

_Alias for Str._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Str> const zmbt::expr::Serialize;
```




<hr>



### variable SetEq 

_Equal as set._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::SetEq> const zmbt::expr::SetEq;
```




<hr>



### variable Sign 

_Sign._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Sign> const zmbt::expr::Sign;
```




<hr>



### variable Sin 

_Sinus function._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Sin> const zmbt::expr::Sin;
```




<hr>



### variable Sinh 

_Hyperbolic sin._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Sinh> const zmbt::expr::Sinh;
```




<hr>



### variable Size 

_Sequence size._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Size> const zmbt::expr::Size;
```




<hr>



### variable Slide 

_Sliding-window iteration._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Slide> const zmbt::expr::Slide;
```



Sliding window iteration by specified window width. 


        

<hr>



### variable Sort 

_Sort list by key function._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Sort> const zmbt::expr::Sort;
```




<hr>



### variable Sqrt 

_Square root._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Sqrt> const zmbt::expr::Sqrt;
```




<hr>



### variable Str 

_Serialize json as string._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Str> const zmbt::expr::Str;
```




<hr>



### variable Stride 

_Striding iteration._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Stride> const zmbt::expr::Stride;
```



Striding iteration by specified step width. Reminder subsequence smaller then step width is discarded. 


        

<hr>



### variable Sub 

_Subtraction._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Sub> const zmbt::expr::Sub;
```




<hr>



### variable Subset 

_Is subset._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Subset> const zmbt::expr::Subset;
```




<hr>



### variable Sum 

_Summation reduction._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Sum> const zmbt::expr::Sum;
```



Equivalent to [**Reduce(Add)**](namespacezmbt_1_1expr.md#variable-reduce) 


        

<hr>



### variable Superset 

_Is superset._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Superset> const zmbt::expr::Superset;
```




<hr>



### variable Tan 

_Tangens function._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Tan> const zmbt::expr::Tan;
```




<hr>



### variable Tanh 

_Hyperbolic tan._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Tanh> const zmbt::expr::Tanh;
```




<hr>



### variable Thread 

_Thread id._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::Thread> const zmbt::expr::Thread;
```



Not really a constant, but useful for branching the test input conditions. 


        

<hr>



### variable ToList 

_Put argument into a list._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::ToList> const zmbt::expr::ToList;
```



Equivalent to At([""]) 


        

<hr>



### variable Trace 

_Same as id, but also prints identifier parameter to debug log._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Trace> const zmbt::expr::Trace;
```




<hr>



### variable Transp 

_Transpose multidimensional list, turning rows into columns._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Transp> const zmbt::expr::Transp;
```



May be used to zip sequences of equal length. 


        

<hr>



### variable True 

_Logical true._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::True> const zmbt::expr::True;
```




<hr>



### variable Truthy 

_Alias for Bool._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Bool> const zmbt::expr::Truthy;
```




<hr>



### variable Try 

_Evaluate function and return result or null if it returns error._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Try> const zmbt::expr::Try;
```




<hr>



### variable Tuple 

_Pack expressions into an tuple without evaluation._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Tuple> const zmbt::expr::Tuple;
```




<hr>



### variable Uncast 

_Reserialize decorator as decorated type._ 
```C++
lang::SignatureUncast const zmbt::expr::Uncast;
```




<hr>



### variable Undecorate 

_Alias for Uncast._ 
```C++
lang::SignatureUncast const zmbt::expr::Undecorate;
```




<hr>



### variable Unfold 

_Put results of recursive fn call on initial value into an array._ 
```C++
lang::SignatureVariadic<::zmbt::lang::Keyword::Unfold> const zmbt::expr::Unfold;
```



Inference rules:



* `n |  Unfold(x, f)`$\mapsto [x\_0, x\_1, ..., x\_n]$, or
* `Q(p) | Unfold(x₀, f)` $\mapsto [x\_0, x\_1, ..., x\_k]$, where
  * $x\_{i+1} = f(x\_i)$
  * $p(x\_{i}) = \top \quad \forall i \le k$
  * $p(x\_{i+1}) = \bot$ (exit condition) 






        

<hr>



### variable Union 

_Set union._ 
```C++
lang::SignatureBinary<::zmbt::lang::Keyword::Union> const zmbt::expr::Union;
```




<hr>



### variable Uniques 

_Filter unique elements._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Uniques> const zmbt::expr::Uniques;
```




<hr>



### variable UpperCase 

_Upper case string._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::UpperCase> const zmbt::expr::UpperCase;
```




<hr>



### variable Values 

_Extract values from object._ 
```C++
lang::SignatureUnary<::zmbt::lang::Keyword::Values> const zmbt::expr::Values;
```




<hr>



### variable \_ 

_Alias for Noop._ 
```C++
lang::SignatureConst<::zmbt::lang::Keyword::Noop> const zmbt::expr::_;
```




<hr>

------------------------------
The documentation for this class was generated from the following file `zmbt-framework/zmbt-framework/backends/cxx/include/zmbt/expr/api.hpp`

