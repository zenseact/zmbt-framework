/**
 * \file
 * \copyright (c) Copyright 2024 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * How to update:
 * 1. Update the template at `templates/expr/expression_keyword.cpp`
 * 2. Update the keyword data at `templates/expr/data.yaml`
 * 3. Regenerate file with `bazel run //templates/expr:expression_keyword_cpp > zmbt/src/model/expression_keyword.cpp`
 * 4. Commit changes
 */


#include <boost/spirit/include/qi.hpp>

#include "zmbt/reflect.hpp"
#include "zmbt/model/expression_keyword.hpp"
#include "zmbt/model/expression_grammar.hpp"


#ifndef ZMBT_KEYWORD_PREFIX
    #define ZMBT_KEYWORD_PREFIX ":"
#endif

namespace zmbt {
namespace reflect {
boost::json::value custom_serialization<ExpressionKeyword>::json_from(ExpressionKeyword const& kw)
{
    using Kw = ExpressionKeyword;

    switch(kw)
    {
    case Kw::Id: return ZMBT_KEYWORD_PREFIX "id";
    case Kw::Noop: return ZMBT_KEYWORD_PREFIX "noop";
    case Kw::True: return ZMBT_KEYWORD_PREFIX "true";
    case Kw::False: return ZMBT_KEYWORD_PREFIX "false";
    case Kw::Null: return ZMBT_KEYWORD_PREFIX "null";
    case Kw::Pi: return ZMBT_KEYWORD_PREFIX "pi";
    case Kw::E: return ZMBT_KEYWORD_PREFIX "e";
    case Kw::Inf: return ZMBT_KEYWORD_PREFIX "inf";
    case Kw::Eps: return ZMBT_KEYWORD_PREFIX "eps";
    case Kw::NaN: return ZMBT_KEYWORD_PREFIX "nan";
    case Kw::Bool: return ZMBT_KEYWORD_PREFIX "bool";
    case Kw::Nil: return ZMBT_KEYWORD_PREFIX "nil";
    case Kw::Not: return ZMBT_KEYWORD_PREFIX "not";
    case Kw::And: return ZMBT_KEYWORD_PREFIX "and";
    case Kw::Or: return ZMBT_KEYWORD_PREFIX "or";
    case Kw::Xor: return ZMBT_KEYWORD_PREFIX "xor";
    case Kw::Eq: return ZMBT_KEYWORD_PREFIX "eq";
    case Kw::Ne: return ZMBT_KEYWORD_PREFIX "ne";
    case Kw::Lt: return ZMBT_KEYWORD_PREFIX "lt";
    case Kw::Le: return ZMBT_KEYWORD_PREFIX "le";
    case Kw::Gt: return ZMBT_KEYWORD_PREFIX "gt";
    case Kw::Ge: return ZMBT_KEYWORD_PREFIX "ge";
    case Kw::Ni: return ZMBT_KEYWORD_PREFIX "ni";
    case Kw::NotNi: return ZMBT_KEYWORD_PREFIX "not-ni";
    case Kw::SetEq: return ZMBT_KEYWORD_PREFIX "set-eq";
    case Kw::Subset: return ZMBT_KEYWORD_PREFIX "subset";
    case Kw::Superset: return ZMBT_KEYWORD_PREFIX "superset";
    case Kw::ProperSubset: return ZMBT_KEYWORD_PREFIX "p-subset";
    case Kw::ProperSuperset: return ZMBT_KEYWORD_PREFIX "p-superset";
    case Kw::In: return ZMBT_KEYWORD_PREFIX "in";
    case Kw::NotIn: return ZMBT_KEYWORD_PREFIX "not-in";
    case Kw::Neg: return ZMBT_KEYWORD_PREFIX "neg";
    case Kw::Abs: return ZMBT_KEYWORD_PREFIX "abs";
    case Kw::Sign: return ZMBT_KEYWORD_PREFIX "sign";
    case Kw::Ceil: return ZMBT_KEYWORD_PREFIX "ceil";
    case Kw::Floor: return ZMBT_KEYWORD_PREFIX "floor";
    case Kw::Round: return ZMBT_KEYWORD_PREFIX "round";
    case Kw::Add: return ZMBT_KEYWORD_PREFIX "add";
    case Kw::Sub: return ZMBT_KEYWORD_PREFIX "sub";
    case Kw::Mul: return ZMBT_KEYWORD_PREFIX "mul";
    case Kw::Div: return ZMBT_KEYWORD_PREFIX "div";
    case Kw::Pow: return ZMBT_KEYWORD_PREFIX "pow";
    case Kw::Log: return ZMBT_KEYWORD_PREFIX "log";
    case Kw::Mod: return ZMBT_KEYWORD_PREFIX "mod";
    case Kw::Quot: return ZMBT_KEYWORD_PREFIX "quot";
    case Kw::Sqrt: return ZMBT_KEYWORD_PREFIX "sqrt";
    case Kw::Sin: return ZMBT_KEYWORD_PREFIX "sin";
    case Kw::Cos: return ZMBT_KEYWORD_PREFIX "cos";
    case Kw::Tan: return ZMBT_KEYWORD_PREFIX "tan";
    case Kw::Asin: return ZMBT_KEYWORD_PREFIX "asin";
    case Kw::Acos: return ZMBT_KEYWORD_PREFIX "acos";
    case Kw::Atan: return ZMBT_KEYWORD_PREFIX "atan";
    case Kw::Sinh: return ZMBT_KEYWORD_PREFIX "sinh";
    case Kw::Cosh: return ZMBT_KEYWORD_PREFIX "cosh";
    case Kw::Tanh: return ZMBT_KEYWORD_PREFIX "tanh";
    case Kw::Asinh: return ZMBT_KEYWORD_PREFIX "asinh";
    case Kw::Acosh: return ZMBT_KEYWORD_PREFIX "acosh";
    case Kw::Atanh: return ZMBT_KEYWORD_PREFIX "atanh";
    case Kw::Exp: return ZMBT_KEYWORD_PREFIX "exp";
    case Kw::Erf: return ZMBT_KEYWORD_PREFIX "erf";
    case Kw::Erfc: return ZMBT_KEYWORD_PREFIX "erfc";
    case Kw::Gamma: return ZMBT_KEYWORD_PREFIX "gamma";
    case Kw::BitNot: return ZMBT_KEYWORD_PREFIX "b-not";
    case Kw::BitAnd: return ZMBT_KEYWORD_PREFIX "b-and";
    case Kw::BitOr: return ZMBT_KEYWORD_PREFIX "b-or";
    case Kw::BitXor: return ZMBT_KEYWORD_PREFIX "b-xor";
    case Kw::BitLshift: return ZMBT_KEYWORD_PREFIX "b-lshift";
    case Kw::BitRshift: return ZMBT_KEYWORD_PREFIX "b-rshift";
    case Kw::Map: return ZMBT_KEYWORD_PREFIX "map";
    case Kw::Filter: return ZMBT_KEYWORD_PREFIX "filter";
    case Kw::Compose: return ZMBT_KEYWORD_PREFIX "compose";
    case Kw::Recur: return ZMBT_KEYWORD_PREFIX "recur";
    case Kw::Apply: return ZMBT_KEYWORD_PREFIX "apply";
    case Kw::Partial: return ZMBT_KEYWORD_PREFIX "partial";
    case Kw::Reduce: return ZMBT_KEYWORD_PREFIX "reduce";
    case Kw::Concat: return ZMBT_KEYWORD_PREFIX "concat";
    case Kw::Union: return ZMBT_KEYWORD_PREFIX "union";
    case Kw::Intersect: return ZMBT_KEYWORD_PREFIX "intersect";
    case Kw::Diff: return ZMBT_KEYWORD_PREFIX "set-diff";
    case Kw::Cartesian: return ZMBT_KEYWORD_PREFIX "cartesian";
    case Kw::Transp: return ZMBT_KEYWORD_PREFIX "transp";
    case Kw::Set: return ZMBT_KEYWORD_PREFIX "set";
    case Kw::List: return ZMBT_KEYWORD_PREFIX "list";
    case Kw::Slide: return ZMBT_KEYWORD_PREFIX "slide";
    case Kw::Stride: return ZMBT_KEYWORD_PREFIX "stride";
    case Kw::Slice: return ZMBT_KEYWORD_PREFIX "slice";
    case Kw::Sort: return ZMBT_KEYWORD_PREFIX "sort";
    case Kw::Repeat: return ZMBT_KEYWORD_PREFIX "repeat";
    case Kw::At: return ZMBT_KEYWORD_PREFIX "at";
    case Kw::Sum: return ZMBT_KEYWORD_PREFIX "sum";
    case Kw::Prod: return ZMBT_KEYWORD_PREFIX "prod";
    case Kw::Card: return ZMBT_KEYWORD_PREFIX "card";
    case Kw::Size: return ZMBT_KEYWORD_PREFIX "size";
    case Kw::Count: return ZMBT_KEYWORD_PREFIX "count";
    case Kw::Min: return ZMBT_KEYWORD_PREFIX "min";
    case Kw::Max: return ZMBT_KEYWORD_PREFIX "max";
    case Kw::Argmin: return ZMBT_KEYWORD_PREFIX "argmin";
    case Kw::Argmax: return ZMBT_KEYWORD_PREFIX "argmax";
    case Kw::Any: return ZMBT_KEYWORD_PREFIX "any";
    case Kw::All: return ZMBT_KEYWORD_PREFIX "all";
    case Kw::Saturate: return ZMBT_KEYWORD_PREFIX "saturate";
    case Kw::Re: return ZMBT_KEYWORD_PREFIX "re";
    case Kw::Approx: return ZMBT_KEYWORD_PREFIX "approx";
        // TODO: throw
        default: return ":undefined";
    }
}

ExpressionKeyword custom_serialization<ExpressionKeyword>::dejsonize(boost::json::value const& v)
{
    if (not v.is_string())
    {
        return ExpressionKeyword::Undefined;
    }

    static ExpressionKeywordGrammar const keyword_parser {};

    auto const& str = v.as_string();
    auto iter = str.cbegin();
    auto end = str.cend();
    ExpressionKeyword keyword_out {ExpressionKeyword::Undefined};
    static_cast<void>(boost::spirit::qi::parse(iter, end, keyword_parser, keyword_out));
    return keyword_out;
}
} // namespace reflect
} // namespace zmbt

