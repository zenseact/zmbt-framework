/**
 * \file
 * \copyright (c) Copyright 2024 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * How to update:
 * 1. Update the template at `templates/expr/expression_api.hpp`
 * 2. Update the keyword data at `templates/expr/data.yaml`
 * 3. Regenerate file with `bazel run //templates/expr:expression_api_hpp > zmbt/include/zmbt/model/expression_api.hpp`
 * 4. Commit changes
 */


#ifndef ZMBT_MODEL_EXPRESSION_API_HPP_
#define ZMBT_MODEL_EXPRESSION_API_HPP_

#include "expression_api_templates.hpp"


namespace zmbt {



namespace expr
{


    /// Identity function
    static ExprNoParams<ExpressionKeyword::Id> const Id{};

    /// No operation
    static ExprNoParams<ExpressionKeyword::Noop> const Noop{};

    /// logical constant true
    static ExprNoParams<ExpressionKeyword::True> const True{};

    /// logical constant false
    static ExprNoParams<ExpressionKeyword::False> const False{};

    /// constant null-value
    static ExprNoParams<ExpressionKeyword::Null> const Null{};

    /// Pi constant
    static ExprNoParams<ExpressionKeyword::Pi> const Pi{};

    /// Euler's number
    static ExprNoParams<ExpressionKeyword::E> const E{};

    /// Infinity
    static ExprNoParams<ExpressionKeyword::Inf> const Inf{};

    /// Machine epsilon
    static ExprNoParams<ExpressionKeyword::Eps> const Eps{};

    /// Not a number
    static ExprNoParams<ExpressionKeyword::NaN> const NaN{};

    /// Predicate on boolean transform (aka Truthy)
    static ExprNoParams<ExpressionKeyword::Bool> const Bool{};

    /// Predicate on boolean transform (aka Falsy)
    static ExprNoParams<ExpressionKeyword::Nil> const Nil{};

    /// Logical complement
    static ExprOneParam<ExpressionKeyword::Not> const Not{};

    /// Logical conjunction
    static ExprVariadicParam<ExpressionKeyword::And> const And{};

    /// Logical disjunction
    static ExprVariadicParam<ExpressionKeyword::Or> const Or{};

    /// Logical exclusive or
    static ExprTwoParam<ExpressionKeyword::Xor> const Xor{};

    /// Is equal
    static ExprOneParam<ExpressionKeyword::Eq> const Eq{};

    /// Not equal
    static ExprOneParam<ExpressionKeyword::Ne> const Ne{};

    /// Lesser than
    static ExprOneParam<ExpressionKeyword::Lt> const Lt{};

    /// Lesser or equal
    static ExprOneParam<ExpressionKeyword::Le> const Le{};

    /// Greater than
    static ExprOneParam<ExpressionKeyword::Gt> const Gt{};

    /// Greater or equal
    static ExprOneParam<ExpressionKeyword::Ge> const Ge{};

    /// Contains element
    static ExprOneParam<ExpressionKeyword::Ni> const Ni{};

    /// Not contains element
    static ExprOneParam<ExpressionKeyword::NotNi> const NotNi{};

    /// Equal as set
    static ExprSetParam<ExpressionKeyword::SetEq> const SetEq{};

    /// Is subset
    static ExprSetParam<ExpressionKeyword::Subset> const Subset{};

    /// is superset
    static ExprSetParam<ExpressionKeyword::Superset> const Superset{};

    /// Is proper subset
    static ExprSetParam<ExpressionKeyword::ProperSubset> const ProperSubset{};

    /// Is proper superset
    static ExprSetParam<ExpressionKeyword::ProperSuperset> const ProperSuperset{};

    /// Element is in
    static ExprSetParam<ExpressionKeyword::In> const In{};

    /// Element is not in
    static ExprSetParam<ExpressionKeyword::NotIn> const NotIn{};

    /// Negate
    static ExprNoParams<ExpressionKeyword::Neg> const Neg{};

    /// Absolute value
    static ExprNoParams<ExpressionKeyword::Abs> const Abs{};

    /// Sign
    static ExprNoParams<ExpressionKeyword::Sign> const Sign{};

    /// Ceil
    static ExprNoParams<ExpressionKeyword::Ceil> const Ceil{};

    /// Floor
    static ExprNoParams<ExpressionKeyword::Floor> const Floor{};

    /// Round
    static ExprNoParams<ExpressionKeyword::Round> const Round{};

    /// Add
    static ExprOneParam<ExpressionKeyword::Add> const Add{};

    /// Substract
    static ExprOneParam<ExpressionKeyword::Sub> const Sub{};

    /// Multiply
    static ExprOneParam<ExpressionKeyword::Mul> const Mul{};

    /// Divide
    static ExprOneParam<ExpressionKeyword::Div> const Div{};

    /// To power
    static ExprOneParam<ExpressionKeyword::Pow> const Pow{};

    /// Logarithm
    static ExprOneParam<ExpressionKeyword::Log> const Log{};

    /// Modulo
    static ExprOneParam<ExpressionKeyword::Mod> const Mod{};

    /// Quotient
    static ExprOneParam<ExpressionKeyword::Quot> const Quot{};

    /// Square root
    static ExprOneParam<ExpressionKeyword::Sqrt> const Sqrt{};

    /// Sinus
    static ExprOneParam<ExpressionKeyword::Sin> const Sin{};

    /// Cosinus
    static ExprOneParam<ExpressionKeyword::Cos> const Cos{};

    /// Tangens
    static ExprOneParam<ExpressionKeyword::Tan> const Tan{};

    /// Arcsin
    static ExprOneParam<ExpressionKeyword::Asin> const Asin{};

    /// Arccos
    static ExprOneParam<ExpressionKeyword::Acos> const Acos{};

    /// Arctan
    static ExprOneParam<ExpressionKeyword::Atan> const Atan{};

    /// Hyperbolic sin
    static ExprOneParam<ExpressionKeyword::Sinh> const Sinh{};

    /// Hyperbolic cos
    static ExprOneParam<ExpressionKeyword::Cosh> const Cosh{};

    /// Hyperbolic tan
    static ExprOneParam<ExpressionKeyword::Tanh> const Tanh{};

    /// Hyperbolic  arcsin
    static ExprOneParam<ExpressionKeyword::Asinh> const Asinh{};

    /// Hyperbolic arccos
    static ExprOneParam<ExpressionKeyword::Acosh> const Acosh{};

    /// Hyperbolic arctan
    static ExprOneParam<ExpressionKeyword::Atanh> const Atanh{};

    /// Exponential (e^x)
    static ExprOneParam<ExpressionKeyword::Exp> const Exp{};

    /// Error function
    static ExprOneParam<ExpressionKeyword::Erf> const Erf{};

    /// Error function complement
    static ExprOneParam<ExpressionKeyword::Erfc> const Erfc{};

    /// Gamma function
    static ExprOneParam<ExpressionKeyword::Gamma> const Gamma{};

    /// Bitwise not
    static ExprNoParams<ExpressionKeyword::BitNot> const BitNot{};

    /// Bitwise and
    static ExprOneParam<ExpressionKeyword::BitAnd> const BitAnd{};

    /// Bitwise or
    static ExprOneParam<ExpressionKeyword::BitOr> const BitOr{};

    /// Bitwise xor
    static ExprOneParam<ExpressionKeyword::BitXor> const BitXor{};

    /// Bitwise left shift
    static ExprOneParam<ExpressionKeyword::BitLshift> const BitLshift{};

    /// Bitwise right shift
    static ExprOneParam<ExpressionKeyword::BitRshift> const BitRshift{};

    /// Apply param fn to every element of sequence
    static ExprOneParam<ExpressionKeyword::Map> const Map{};

    /// Filter sequence by predicate param
    static ExprOneParam<ExpressionKeyword::Filter> const Filter{};

    /// Compose functions
    static ExprVariadicParam<ExpressionKeyword::Compose> const Compose{};

    /// apply recursion to parameter fn
    static ExprTwoParam<ExpressionKeyword::Recur> const Recur{};

    /// Apply fn to literal param
    static ExprTwoParam<ExpressionKeyword::Apply> const Apply{};

    /// Bind parameters
    static ExprTwoParam<ExpressionKeyword::Partial> const Partial{};

    static ExprOneOrTwoParam<ExpressionKeyword::Reduce> const Reduce{};

    /// Concatenate sequences
    static ExprNoParams<ExpressionKeyword::Concat> const Concat{};

    /// Set union
    static ExprNoParams<ExpressionKeyword::Union> const Union{};

    /// Set intersection
    static ExprNoParams<ExpressionKeyword::Intersect> const Intersect{};

    /// Set difference
    static ExprNoParams<ExpressionKeyword::Diff> const Diff{};

    /// Cartesian product
    static ExprNoParams<ExpressionKeyword::Cartesian> const Cartesian{};

    /// Transpose 2-d array, turning rows into columns
    static ExprNoParams<ExpressionKeyword::Transp> const Transp{};

    /// Sequence to set
    static ExprNoParams<ExpressionKeyword::Set> const Set{};

    /// Envelop value in array (equivalent to Repeat(1))
    static ExprNoParams<ExpressionKeyword::List> const List{};

    /// Sliding-window iteration
    static ExprOneParam<ExpressionKeyword::Slide> const Slide{};

    /// Striding iteration
    static ExprOneParam<ExpressionKeyword::Stride> const Stride{};

    /// Slice sequence by "start:stop:step"
    static ExprOneParam<ExpressionKeyword::Slice> const Slice{};

    /// Sort array by comparison parameter fn
    static ExprOneParam<ExpressionKeyword::Sort> const Sort{};

    /// Repeat value in array
    static ExprOneParam<ExpressionKeyword::Repeat> const Repeat{};

    /// Transform value with query pseudo-language
    /// 
    /// Evaluation rules:
    ///   1. int    q |-> x |-> array x at index q (negative -> reverse)
    ///   2. str    q |-> x |-> value x at JSON Pointer q
    ///   3. array  [q1, q2, ...] |-> x |-> [x at q1, x at q2, ...]
    ///   4. object {"key": q1, "$q2": q3, ...} |-> x |-> {"key1": x at q1, "$(x at q2)": x at q3, ...}
    /// 
    /// Optional second parameter - predicate P:
    ///   At(q, P) <==> Compose(P, At(q))
    /// 
    static ExprOneOrTwoParam<ExpressionKeyword::At> const At{};

    /// Summation reduction, real param - initial value
    /// 
    static ExprOneOrTwoParam<ExpressionKeyword::Sum> const Sum{};

    /// Multiplication reduction, real param - initial value
    static ExprOneOrTwoParam<ExpressionKeyword::Prod> const Prod{};

    /// Set cardinality (uniques count)
    static ExprOneOrTwoParam<ExpressionKeyword::Card> const Card{};

    /// Sequence size
    static ExprOneOrTwoParam<ExpressionKeyword::Size> const Size{};

    /// Count matches
    static ExprOneOrTwoParam<ExpressionKeyword::Count> const Count{};

    /// Min value
    static ExprOneOrTwoParam<ExpressionKeyword::Min> const Min{};

    /// Max value
    static ExprOneOrTwoParam<ExpressionKeyword::Max> const Max{};

    /// Min value index
    static ExprOneOrTwoParam<ExpressionKeyword::Argmin> const Argmin{};

    /// Max value index
    static ExprOneOrTwoParam<ExpressionKeyword::Argmax> const Argmax{};

    /// Match any predicate
    static ExprVariadicParam<ExpressionKeyword::Any> const Any{};

    /// Match all predicates
    static ExprVariadicParam<ExpressionKeyword::All> const All{};

    /// Saturate matches in order
    static ExprVariadicParam<ExpressionKeyword::Saturate> const Saturate{};

    /// Regular expression match
    static ExprOneParam<ExpressionKeyword::Re> const Re{};



/// Floating point approximate equal
/// Based on numpy.isclose: abs(a - b) <= (atol + rtol * abs(ref))
static struct Approx_ : public Expression
{
    Approx_() : Expression(Keyword::Approx)
    {}

    Expression operator()(double reference, double rtol, double atol = std::numeric_limits<double>::epsilon()) const
    {
        return Expression(Expression::Keyword::Approx, boost::json::array {reference, rtol, atol});
    }
} Approx;


// Aliases

static decltype(Noop) const _ = Noop;
static decltype(Ni) const Contains = Ni;
static decltype(Approx) const Near = Approx;
static decltype(Re) const Regex = Re;

}

} // namespace zmbt

#endif // ZMBT_MAPPING_EXPRESSION_HPP_

