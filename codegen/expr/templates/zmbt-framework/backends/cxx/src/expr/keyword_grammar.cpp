@require(data)
/**
 * \file
 * \copyright (c) Copyright 2024-2025 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * app: @appname
 * template: @template
 *
 * How to update:
 * 1. Update the template
 * 2. Run `python -m codegen` in the project root
 * 3. Commit changes
 */

#include <boost/spirit/include/qi.hpp>

#include "zmbt/expr/keyword.hpp"
#include "zmbt/expr/keyword_grammar.hpp"


namespace qi = boost::spirit::qi;

namespace zmbt {
namespace lang {


KeywordSymbol::KeywordSymbol()
{
    add
@for keyword in data.Keywords:
    ("@keyword.Name", Keyword::@keyword.Name)
    @if symbol := keyword.Symbol:
    ("@symbol", Keyword::@keyword.Name)
    @end
    @for alias in keyword.Aliases:
    ("@alias", Keyword::@keyword.Name)
    @end
@end
    ;
}


KeywordGrammar::KeywordGrammar()
    : KeywordGrammar::base_type(start)
{
    using boost::spirit::qi::eps;
    using boost::spirit::qi::_val;
    using boost::spirit::qi::_1;

    start = eps [_val = Keyword::Undefined] >>
        (
            +keyword_symbol [_val = _1]
        )
    ;
}


boost::json::string_view keyword_to_str(Keyword const& kw)
{
    switch(kw)
    {

@for keyword in data.Keywords:
    case Keyword::@keyword.Name: { return "@keyword.Name"; break; }
@end
    default:
        return "Undefined";
    }
}

void tag_invoke(boost::json::value_from_tag const&, boost::json::value& v, Keyword const& kw)
{
    v = keyword_to_str(kw);
}

Keyword tag_invoke(boost::json::value_to_tag<Keyword> const&, boost::json::value const& v)
{

    if (auto as_uint64 = v.if_uint64())
    {
        return *as_uint64 < static_cast<std::uint64_t>(Keyword::_count) ? static_cast<Keyword>(*as_uint64) : Keyword::Undefined;
    }

    if (not v.is_string())
    {
        return Keyword::Undefined;
    }

    static KeywordGrammar const keyword_parser {};

    auto const& str = v.as_string();
    auto iter = str.cbegin();
    auto end = str.cend();
    Keyword keyword_out {Keyword::Undefined};
    static_cast<void>(boost::spirit::qi::parse(iter, end, keyword_parser, keyword_out));
    return keyword_out;
}

} // namespace lang
} // namespace zmbt
