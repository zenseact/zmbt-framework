# (c) Copyright 2024-2025 Zenseact AB
# SPDX-License-Identifier: Apache-2.0

keyword_groups:

  Internal:
    defaults:
      internal: true
    keywords:
      - name: Literal
        brief: Literal value
        details: |-
          Literal value keyword with no expression API.
          in evaluation context works as Eq(x)
      - name: Void
        brief: empty value

  Constants:
    defaults:
      signature: Const
      domain: null
      codomain: real
      imports:
        cxx:
          - limits
          - boost/math/constants/constants.hpp
    keywords:
      - name: Noop
        brief: No operation
        details: |-
          Returns true without input validation.
          Used in place of matchers for uninteresting signals.
        domain: any
        codomain: any
        aliases: [ '_' ]
        codegen-value:
          cxx: 'true'

      - name: 'Null'
        brief: Null value
        domain: any
        codomain: any
        codegen-value:
          cxx: 'nullptr'

      - name: 'True'
        brief: Logical true
        symbol: T
        codomain: bool
        codegen-value:
          cxx: 'true'

      - name: 'False'
        brief: Logical false
        symbol: ⊥
        codomain: bool
        codegen-value:
          cxx: 'false'

      - name: Pi
        brief: Pi constant
        symbol: π
        codegen-value:
          cxx: boost::math::constants::pi<double>()

      - name: E
        brief: Euler's number
        codegen-value:
          cxx: boost::math::constants::e<double>()

      - name: Inf
        brief: Infinity
        codegen-value:
          cxx: std::numeric_limits<double>::infinity()

      - name: Eps
        brief: Machine epsilon
        codegen-value:
          cxx: std::numeric_limits<double>::epsilon()

      - name: NaN
        brief: Not a number
        codegen-value:
          cxx: std::numeric_limits<double>::quiet_NaN()

      - name: Thread
        brief: Thread id
        details: |-
          Not really a constant, but useful for
          branching the test input conditions.
        codegen-value:
          cxx: zmbt::get_tid().c_str()


  Math Functions:
    defaults:
      signature: Unary
      domain: real
      codomain: real
      imports:
        cxx:
          - cmath
          - complex
    keywords:

      - name: Sin
        brief: Sinus function
        codegen-value:
          cxx: json_from(std::sin(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Cos
        brief: Cosinus function
        codegen-value:
          cxx: json_from(std::cos(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Tan
        brief: Tangens function
        codegen-value:
          cxx: json_from(std::tan(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Asin
        brief: Arcsin function
        codegen-value:
          cxx: json_from(std::asin(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Acos
        brief: Arccos function
        codegen-value:
          cxx: json_from(std::acos(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Atan
        brief: Arctan function
        codegen-value:
          cxx: json_from(std::atan(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Sinh
        brief: Hyperbolic sin
        codegen-value:
          cxx: json_from(std::sinh(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Cosh
        brief: Hyperbolic cos
        codegen-value:
          cxx: json_from(std::cosh(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Tanh
        brief: Hyperbolic tan
        codegen-value:
          cxx: json_from(std::tanh(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Asinh
        brief: Hyperbolic arcsin
        codegen-value:
          cxx: json_from(std::asinh(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Acosh
        brief: Hyperbolic arccos
        codegen-value:
          cxx: json_from(std::acosh(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Atanh
        brief: Hyperbolic arctan
        codegen-value:
          cxx: json_from(std::atanh(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Exp
        brief: Exponential (e^x)
        codegen-value:
          cxx: json_from(std::exp(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Erf
        brief: Error function
        codegen-value:
          cxx: real_to_number(std::erf(dejsonize<double>( lhs().eval() )))

      - name: Erfc
        brief: Error function complement
        codegen-value:
          cxx: real_to_number(std::erfc(dejsonize<double>( lhs().eval() )))

      - name: Gamma
        brief: Gamma function
        codegen-value:
          cxx: real_to_number(std::tgamma(dejsonize<double>( lhs().eval() )))

      - name: Abs
        brief: Absolute value
        codegen-value:
          cxx: real_to_number(std::abs(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Ceil
        codegen-value:
          cxx: real_to_number(std::ceil(dejsonize<double>( lhs().eval() )))

      - name: Floor
        codegen-value:
          cxx: real_to_number(std::floor(dejsonize<double>( lhs().eval() )))

      - name: Round
        brief: Round to nearest integer
        details: |-
          Hint: To round to ndigits precision after the decimal point,
          use `Mul(ndigits) | Round | Div(ndigits)` combo.
        codegen-value:
          cxx: real_to_number(std::round(dejsonize<double>( lhs().eval() )))

      - name: Sqrt
        brief: Square root
        codegen-value:
          cxx: json_from(std::sqrt(dejsonize<std::complex<double>>( lhs().eval() )))

      - name: Sign
        domain: real
        codomain: int
        codegen-value:
          cxx: 'dejsonize<double>( lhs().eval() ) >= 0 ? 1 : -1'

  Arithmetic Operators:
    defaults:
      signature: Binary
      tags: [op]
      domain: [real, real]
      codomain: real
    keywords:
      - name: Neg
        signature: Unary
        brief: Negate
        domain: real
        codomain: real
        examples: |-
          42 | Neg ↦ -42

      - name: Add
        brief: Addition
        symbol: '+'
        examples: |-
          [2, -1] | Add ↦ 1
          2 | Add(-1) ↦ 1

      - name: Sub
        brief: Subtraction
        symbol: '-'
        examples: |-
          [2, 1] | Sub ↦ -1
          2 | Sub(1) ↦ 1

      - name: Mul
        brief: Multiplication
        symbol: '*'
        examples: |-
          [2, 3] | Mul ↦ 6
          2 | Mul(3) ↦ 6

      - name: Div
        brief: Division
        symbol: '/'
        details: |-
          1. $[ ] \mapsto [x, y] \mapsto x / y$
          2. $[y] \mapsto [x]    \mapsto x / y$
        examples: |-
          [6, 3] | Div ↦ 2
          6 | Div(3) ↦ 2

      - name: Pow
        brief: To power
        details: |-
          X to power p
            1. $[ ] \mapsto [x, p] \mapsto x^p$
            2. $[p] \mapsto [x]    \mapsto x^p$
        examples: |-
          [2, 3] | Pow ↦ 8
          2 | Pow(3) ↦ 8

      - name: Log
        brief: Logarithm
        details: |-
          Logarithm with base b:
            1. $[ ] \mapsto [x, b] \mapsto log_b(x)$
            2. $[b] \mapsto [x]    \mapsto log_b(x)$
        examples: |-
          [8, 2] | Log ↦ 3
          8 | Log(2) ↦ 3

      - name: Mod
        brief: Modulo
        symbol: '%'
        details: |-
          Modulo of x:
            1. $[ ] \mapsto [x, m] \mapsto x % m$
            2. $[m] \mapsto [x]    \mapsto x % m$
        examples: |-
          [7, 4] | Mod ↦ 3
          7 | Mod(4) ↦ 3

      - name: Quot
        brief: Quotient
        symbol: '//'
        details: |-
          Quotient of x:
            1. $[ ] \mapsto [x, d] \mapsto x // d$
            2. $[d] \mapsto [x]    \mapsto x // d$
        examples: |-
          [7, 4] | Quot ↦ 1
          7 | Quot(4) ↦ 1

      - name: BitNot
        signature: Unary
        brief: Bitwise not
        symbol: '~'
        domain: uint
        codomain: uint
        examples: |-
          0b1010 | BitNot ↦ 0b0101

      - name: BitAnd
        brief: Bitwise and
        domain: [uint, uint]
        codomain: uint
        examples: |-
          [0b1010, 0b1100] | BitAnd ↦ 0b1000

      - name: BitOr
        brief: Bitwise or
        symbol: '|'
        domain: [uint, uint]
        codomain: uint
        examples: |-
          [0b1010, 0b1100] | BitOr ↦ 0b1110

      - name: BitXor
        brief: Bitwise xor
        symbol: '^'
        domain: [uint, uint]
        codomain: uint
        examples: |-
          [0b1010, 0b1100] | BitXor ↦ 0b0110

      - name: Lshift
        brief: Bitwise left shift
        symbol: '<<'
        details: |-
          1. $[ ] \mapsto [x, s] \mapsto x \texttt{ << } s$
          2. $[s] \mapsto [x]    \mapsto x \texttt{ << } s$
        domain: [uint, uint]
        codomain: uint
        examples: |-
          [0b1010, 2] | Lshift ↦ 0b101000

      - name: Rshift
        brief: Bitwise right shift
        symbol: '>>'
        details: |-
          1. $[ ] ↦ [x, s] ↦ x \texttt{ >> } s$
          2. $[s] ↦ [x]    ↦ x \texttt{ >> } s$
        domain: [uint, uint]
        codomain: uint
        examples: |-
          [0b1010, 2] | Rshift ↦ 0b0010

  Relation Operators:
    defaults:
      signature: Binary
      domain: [any, any]
      codomain: bool
      tags: [op]
    keywords:

      - name: Eq
        brief: Is equal
        symbol: '='
        examples: |-
          [1, 1] | Eq ↦ true
          41 | Eq(42) ↦ false


      - name: Ne
        brief: Not equal
        symbol: '≠'
        examples: |-
          [1, 2] | Ne ↦ true
          42 | Ne(42) ↦ false

      - name: Lt
        brief: Lesser than
        symbol: '<'
        commutative-dual: ge
        examples: |-
          [1, 2] | Lt ↦ true
          41 | Lt(42) ↦ false

      - name: Le
        brief: Lesser or equal
        symbol: '≤'
        commutative-dual: gt
        examples: |-
          [1, 2] | Le ↦ true
          42 | Le(42) ↦ true

      - name: Gt
        brief: Greater than
        symbol: '>'
        commutative-dual: le
        examples: |-
          [2, 1] | Gt ↦ true
          43 | Gt(42) ↦ false

      - name: Ge
        brief: Greater or equal
        symbol: '≥'
        commutative-dual: lt
        examples: |-
          [2, 1] | Ge ↦ true
          42 | Ge(42) ↦ true

      - name: Near
        aliases: [ Approx ]
        brief: Floating point approximately equal
        details: |-
          Based on numpy.isclose:
            abs(x - ref) <= (atol + rtol * abs(ref))

          Rhs parameters:
            ref: reference value
            rtol: relative tolerance, default = 1e-05
            atol: absolute tolerance, default = 1e-08

          Rhs dynamic evaluation:
            1. ref                -> [ref, default, default]
            2. [ref]              -> [ref, default, default]
            3. [ref, rtol]        -> [ref, rtol   , default]
            4. [ref, rtol, atol]  -> [ref, rtol   , atol   ]

        domain: [real, list]
        codomain: bool
        commutative: false
        examples: |-
          [42, 42] | Approx ↦ true
          42 | Approx(42.0 + 1e-09) ↦ true
          42 | Approx(42.001) ↦ false

          Relative tolerance 1e-03
          pi | Approx([3.14, 0.001]) ↦ true
          Absolute tolerance 0.01
          pi | Approx([3.14, 0, 0.01]) ↦ true

  Set Operators:
    defaults:
      signature: Binary
      domain: [set, set]
      codomain: set
    keywords:

      - name: Union
        brief: Set union
        symbol: '∪'
        examples: |-
          [[1, 2], [2, 3]] | Union ↦ [1, 2, 3]
          [1, 2] | Union([2, 3]) ↦ [1, 2, 3]

      - name: Intersect
        brief: Set intersection
        symbol: '∩'
        examples: |-
          [[1, 2], [2, 3]] | Intersect ↦ [2]
          [1, 2] | Intersect([2, 3]) ↦ [2]

      - name: Diff
        brief: Set difference
        examples: |-
          [[1, 2], [2, 3]] | Diff ↦ [1]
          [1, 2] | Diff([2, 3]) ↦ [1]

  Set Relation Operators:
    defaults:
      signature: Binary
      tags: [op]
      domain: [set, set]
      codomain: bool
    keywords:

      - name: SetEq
        brief: Equal as set
        symbol: '≡'
        examples: |-
          [[1, 2], [2, 1]] | SetEq ↦ true
          [1, 2] | SetEq([2, 1]) ↦ true

      - name: Subset
        brief: Is subset
        symbol: '⊆'
        commutative-dual: p-superset
        examples: |-
          [[1, 2], [1, 2, 3]] | Subset ↦ true
          [1, 2] | Subset([1, 2, 3]) ↦ true

          [[1, 2, 3], [2, 3]] | Subset ↦ false
          [1, 2, 3] | Subset([2, 3]) ↦ false

          [[1, 2], []] | Subset ↦ true
          [[], []] | Subset ↦ true

      - name: Superset
        brief: is superset
        symbol: '⊇'
        commutative-dual: p-subset
        examples: |-
          [[1, 2, 3], [1, 2]] | Superset ↦ true
          [1, 2, 3] | Superset([1, 2]) ↦ true

          [[2, 3], [1, 2, 3]] | Superset ↦ false
          [2, 3] | Superset([1, 2, 3]) ↦ false

          [[], [1, 2]] | Superset ↦ true
          [[], []] | Superset ↦ true

      - name: PSubset
        brief: Is proper subset
        symbol: '⊂'
        commutative-dual: superset
        examples: |-
          [[1, 2], [1, 2, 3]] | PSubset ↦ true
          [1, 2] | PSubset([1, 2, 3]) ↦ true

          [[1, 2, 3], [2, 3]] | PSubset ↦ false
          [1, 2, 3] | PSubset([2, 3]) ↦ false

          [[1, 2], []] | PSubset ↦ true
          [[], []] | PSubset ↦ false

      - name: PSuperset
        brief: Is proper superset
        symbol: '⊃'
        commutative-dual: subset
        examples: |-
          [[1, 2, 3], [1, 2]] | PSuperset ↦ true
          [1, 2, 3] | PSuperset([1, 2]) ↦ true

          [[2, 3], [1, 2, 3]] | PSuperset ↦ false
          [2, 3] | PSuperset([1, 2, 3]) ↦ false

          [[], [1, 2]] | PSuperset ↦ true
          [[], []] | PSuperset ↦ false

      - name: In
        brief: Element is in
        symbol: '∈'
        domain: [any, set]
        commutative-dual: ni
        examples: |-
          [1, [1, 2]] | In ↦ true
          3 | In([1, 2]) ↦ false

      - name: NotIn
        brief: Element is not in
        symbol: '∉'
        domain: [any, set]
        commutative-dual: not-ni
        examples: |-
          [3, [1, 2]] | NotIn ↦ true
          1 | NotIn([1, 2]) ↦ false

      - name: Ni
        brief: Contains element
        symbol: '∋'
        aliases: [ Contains ]
        commutative-dual: in
        domain: [set, any]
        examples: |-
          [[1, 2], 1] | Ni ↦ true
          3 | Ni([1, 2]) ↦ false

      - name: NotNi
        brief: Not contains element
        symbol: '∌'
        commutative-dual: not-in
        domain: [set, any]
        examples: |-
          [[1, 2], 3] | NotNi ↦ true
          1 | NotNi([1, 2]) ↦ false

  Branching Operators:
    defaults:
      signature: Binary
      domain: [any, any]
      codomain: any
      tags: [op]
    keywords:

      - name: Bool
        signature: Unary
        brief: Predicate on boolean transform (aka Truthy)
        symbol: '?'
        domain: any
        codomain: bool
        aliases: [ Truthy ]
        examples: |-
          42 | Bool ↦ true
          0 | Bool ↦ false
          "false" | Bool ↦ true
          "" | Bool ↦ false
          [1] | Bool ↦ true
          [] | Bool ↦ false
          {} | Bool ↦ false
          null | Bool ↦ false

      - name: Not
        signature: Unary
        brief: Logical complement
        domain: any
        codomain: bool
        aliases: [ Falsy, Nil ]
        examples: |-
          42 | Nil ↦ false
          0 | Nil ↦ true

      - name: And
        brief: Logical and
        details: |-
          Generic behavior:
            if first operand is truthy,
            returns second operand, otherwise first
        symbol: ∧
        examples: |-
          [true, false] | And ↦ false
          [true, true] | And ↦ true

          **Generic behavior**:

          ["foo", [42, 43]] | And ↦ [42, 43]
          [""   , [42, 43]] | And ↦ ""

          13 | And(42) ↦ 42
          [] | And(42) ↦ []

          **If-Else using composition**:

          true | And(42) | Or(13) ↦ 42
          false | And(42) | Or(13) ↦ 13

      - name: Or
        brief: Logical or
        symbol: ∨
        details: |-
          Generic behavior:
            if first operand is truthy,
            returns first operand, second otherwise
        examples: |-
          [true, false] | Or ↦ true
          [false, false] | Or ↦ false

          **Generic behavior**:

          ["foo", [42, 43]] | Or ↦ "foo"
          [""   , [42, 43]] | Or ↦ [42, 43]

          13 | Or(42) ↦ 13
          [] | Or(42) ↦ 42

          **If-Else using composition**:

          true | And(42) | Or(13) ↦ 42
          false | And(42) | Or(13) ↦ 13


  Unary Structural transforms:
    defaults:
      signature: Unary
    keywords:
      - name: Id
        brief: Identity function
        domain: any
        codomain: any
        examples: |-
          42 | Id ↦ 42
        codegen-value:
          cxx: lhs()

      - name: Transp
        brief: Transpose multidimensional list, turning rows into columns
        details: |-
          May be used to zip sequences of equal length.
        domain: list[list]
        codomain: list[list]
        examples: |-
          [[1, 2, 3], [4, 5, 6]] | Transp ↦ [[1, 4], [2, 5], [3, 6]]

      - name: Cartesian
        brief: Cartesian product
        symbol: '×'
        domain: list[set]
        codomain: list[list]
        examples: |-
          [[1, 2], [3, 4]] | Cartesian ↦ [[1, 3], [1, 4], [2, 3], [2, 4]]

      - name: Reverse
        brief: Reverse sequence
        domain: list[set]
        codomain: list[list]
        examples: |-
          [1, 2, 3] | Reverse ↦ [3, 2, 1]

      - name: Uniques
        brief: Filter unique elements
        domain: list
        codomain: set
        examples: |-
          [1, 2, 1, 3, 2] | Uniques ↦ [1, 2, 3]

      - name: Items
        brief: Extract key-value pairs from object
        domain: object
        codomain: list[list]
        examples: |-
          {"a": 1, "b": 2} | Items ↦ [["a", 1], ["b", 2]]

      - name: Keys
        brief: Extract keys from object
        domain: object
        codomain: list
        examples: |-
          {"a": 1, "b": 2} | Keys ↦ ["a", "b"]

      - name: Values
        brief: Extract values from object
        domain: object
        codomain: list
        examples: |-
          {"a": 1, "b": 2} | Values ↦ [1, 2]

      - name: Enumerate
        brief: Enumerate sequence
        details: |-
          Enumerate sequence with index.
        domain: list
        codomain: list[list]
        examples: |-
          [1, 2, 3] | Enumerate ↦ [[0, 1], [1, 2], [2, 3]]

      - name: Flatten
        brief: Flatten nested list
        domain: list
        codomain: list
        examples: |-
          [[1, 2], [3, 4]] | Flatten ↦ [1, 2, 3, 4]

      - name: ToList
        brief: Put argument into a list
        details: Equivalent to At([""])
        domain: any
        codomain: list
        examples: |-
          42 | List ↦ [42]
        codegen-value:
          cxx: boost::json::array{ lhs().to_json() }


  Unary Generators:
    defaults:
      signature: Unary
    keywords:
      - name: Arange
        brief: Generate range of numbers
        details: |-
          Return evenly spaced values within a given interval.

          Parameters:
            1. start: start value
            2. stop: stop value
            3. step: step value

          Parameters dynamic evaluation:
            1. stop: int            -> [0, stop, 1]
            2. [start, stop]        -> [start, stop, 1]
            3. [start, stop, step]  -> [start, stop, step]
        domain: any
        codomain: list
        examples: |-
          6 | Arange ↦ [0,1,2,3,4,5]
          [2,6] | Arange ↦ [2,3,4,5]
          [1,9,2] | Arange ↦ [1,3,5,7]
          [5,1,-1] | Arange ↦ [5,4,3,2]

          "2:6" | Arange ↦ [2,3,4,5]
          "1:9:2" | Arange ↦ [1,3,5,7]
          "5:1:-1" | Arange ↦ [5,4,3,2]

  String Transforms:
    keywords:
      - name: Parse
        brief: Parse string as JSON
        signature: Unary
        domain: str
        codomain: any
        codegen-value:
          cxx: boost::json::parse( lhs().as_string())
        imports:
          cxx:
            - boost/json.hpp
        examples: |-
          '{"a": 42}' | Parse ↦ {"a": 42}

      - name: Str
        aliases: [ Serialize ]
        brief: Serialize JSON as string
        signature: Unary
        domain: any
        codomain: str
        codegen-value:
          cxx: lhs().prettify().c_str()
        imports:
          cxx:
            - boost/json.hpp
        examples: |-
          {"a": 42} | Serialize ↦ '{"a":42}'

      - name: Re
        aliases: [ Regex ]
        brief: Regular expression match
        signature: Binary
        details: If input is not a string, match it's serialized form.
        commutative: false
        domain: [any, str]
        codomain: bool
        params:
          - label: pattern
        examples: |-
          ["[0-9]+", "42"] | Re ↦ true
          "42" | Re("[0-9]+") ↦ true

      - name: Fmt
        aliases: [ Format ]
        brief: Format string with the given parameter list.
        details: |-
          Constant expressions are supported for the token list,
          s.t. "%s" | Fmt(Pi)  produces "3.141592653589793E0"
        signature: Variadic
        domain: [str, list]
        codomain: str
        examples: |-
          ["Hello, %s!", ["world"]] | Format ↦ "Hello, world!"
          "%d + %d = %d" | Format(2,2,4) ↦ "2 + 2 = 4"

  Structural properties:
    defaults:
      signature: Unary
    keywords:
      - name: Card
        brief: Set cardinality (uniques count)
        domain: union[list, object]
        codomain: uint
        examples: |-
          [1, 2, 1, 3, 2] | Card ↦ 3
          {"a": 1, "b": 2} | Card ↦ 2

      - name: Size
        brief: Sequence size
        domain: union[list, object]
        codomain: uint
        examples: |-
          [1, 1, 1] | Size ↦ 3
          {"a": 1, "b": 2} | Size ↦ 2

      - name: Sum
        brief: Summation reduction
        details: Equivalent to Reduce(Add)
        symbol: Σ
        domain: list
        codomain: any
        examples: |-
          [1, 2, 3] | Sum ↦ 6

      - name: Prod
        brief: Multiplication reduction
        details: Equivalent to Reduce(Mul)
        symbol: Π
        domain: list
        codomain: any
        examples: |-
          [1, 2, 3] | Prod ↦ 6

      - name: Avg
        brief: Arythmetic average
        domain: list
        codomain: any
        examples: |-
          [1, 2, 3] | Avg ↦ 2

  Binary Structural transforms:
    defaults:
      signature: Binary
    keywords:

      - name: Slide
        brief: Sliding-window iteration
        details: |-
          Sliding window iteration by specified window width.
        commutative: false
        domain: [list, int]
        codomain: list[list]
        params:
          - label: window width
        examples: |-
          [1,2,3,4,5] | Slide(3) ↦ [[1,2,3],[2,3,4],[3,4,5]]
          [1,2,3,4,5] | Slide(42) ↦ []

      - name: Stride
        brief: Striding iteration
        details: |-
          Striding iteration by specified step width.
          Reminder subsequence smaller then step width is discarded.
        commutative: false
        domain: [list, int]
        codomain: list[list]
        params:
          - label: step width
        examples: |-
          [1,2,3,4,5,6] | Stride(2) ↦ [[1,2],[3,4],[5,6]]
          [1,2,3,4,5] | Stride(3) ↦ [[1,2,3]]

      - name: Chunks
        brief: Split into chunks of specified max width
        details: |-
          Similar to Stride, but includes the last subsequence
          smaller then step width.
        commutative: false
        domain: [list, int]
        codomain: list[list]
        params:
          - label: step width
        examples: |-
          [1,2,3,4,5,6] | Chunks(2) ↦ [[1,2],[3,4],[5,6]]
          [1,2,3,4,5] | Chunks(3) ↦ [[1,2,3],[4,5]]


      - name: Repeat
        brief: Repeat value in list
        commutative: false
        domain: [any, int]
        codomain: list
        params:
          - label: count
        examples: |-
          42 | Repeat(3) ↦ [42, 42, 42]
          1 | Repeat(3) | Repeat(2) ↦ [[1,1,1],[1,1,1]]


      - name: Cat
        aliases: [ Concat ]
        brief: Concatenate sequences
        domain: [any, any]
        codomain: any
        examples: |-
          [[1, 2], [3, 4]] | Concat ↦ [1, 2, 3, 4]
          "Hello, " | Concat("World!") ↦ "Hello, World!"


      - name: Push
        brief: Push element into a front of sequence
        domain: [any, list]
        codomain: any
        examples: |-
          [[1, 2], 3] | Push ↦ [3, 1, 2]
          [1, 2] | Push(3) ↦ [3, 1, 2]

      - name: At
        brief: Transform JSON value with given query
        details: |-
          Query evaluation rules:

            1. Structure index (negative resolves as reverse): $q: int   \mapsto x: list  \mapsto x_q$
            2. Array slice: $q: slice \mapsto x: list  \mapsto x[start:stop:step]$
            3. JSON Pointer: $q: str   \mapsto x: any   \mapsto x_q$
            4. Array pack: $q: list  \mapsto x: any   \mapsto [x_{q_1}, x_{q_2}, ...]$
            5. Object pack:
              $\{key: q_1, \$q_2: q_3, ...\} \mapsto x: any \mapsto \{ key: x_{q_1}, q_2: x_{q_3}, ...\}$

            Structure index is evaluated as array index or as key-value pair index for objects
            on order-preserving backends.

            Result is null if requested element not found.
        commutative: false
        domain: [any, union: [int, str, list, object]]
        codomain: any
        params:
          - label: query
        examples: |-
          **Array index**:

          [1, 2, 3] | At(2) ↦ 3
          [1, 2, 3] | At(3) ↦ nullptr
          42 | At(0) ↦ nullptr

          **Array slice**:

          [1,2,3,4,5,6,7,8] | At("::2")     ↦ [1,3,5,7]
          [1,2,3,4,5,6,7,8] | At("4:")      ↦ [5,6,7,8]
          [1,2,3,4,5,6,7,8] | At("-1:0:-1") ↦ [8,7,6,5,4,3,2,1]

          **JSON Pointer**:

          "foo" | At("")   ↦ "foo"
          {"a": 42, "b": 13} | At("/a") ↦ 42

          **Array pack**:

          {"a": 42, "b": 13} | At(["/a", "/b"])  ↦ [42, 13]
          42 | At([""])          ↦  [42]

          **Object pack**:

          {"a": 42, "b": 13} | At({"f": "/a", "g": "/b"})  ↦ {"f": 42, "g": 13}
          {"a": 42, "b": 13} | At({"$/b": "/a"})           ↦ {"13": 42}

      - name: Del
        aliases: [ Delete ]
        brief: Delete elements from structure by given query
        details: |-
          Possible queries:
            1. Structure index (negative resolves as reverse)
            2. JSON Pointer
            3. List of queries

          Structure index is evaluated as array index or as key-value pair index for objects
            on order-preserving backends.
          When deleting an object element, resulting items order may change.
        domain: [any, any]
        codomain: any
        examples: |-
          [1,2,3,4,5] | Del(2) ↦ [1,2,4,5]
          [[1, 2], 3] | Del("/0/1") ↦ [[1], 3]
          {"a": {"b": [1,2,3]}} | Del({"/a/b/0", "/a/b/1"}) ↦ {"a": {"b": [3]}}

      - name: Lookup
        signature: Binary
        brief: Lookup table function
        commutative-dual: at
        details: |-
          Parametrized at design time with fixed array or object,
          produces the value at corresponding At query given
          as eval-time argument.
          Equivalent to Flip(At(...))

        domain: [union: [int, str, list, object], any]

        codomain: any
        examples: |-
          0 | Lookup([1,2,3]) ↦  1
          "/foo" | Lookup([1,2,3]) ↦  null

      - name: Cast
        aliases: [ Decorate ]
        signature: Special
        brief: Reserialize decorated type as decorator
        # details: |-
        domain: [any, any]
        codomain: any

      - name: Uncast
        aliases: [ Undecorate ]
        signature: Special
        brief: Reserialize decorator as decorated type
        # details: |-
        domain: [any, any]
        codomain: any


  High-Order:
    defaults: {}
    keywords:

      - name: Fold
        signature: Binary
        aliases: [ Reduce ]
        brief: Reduce sequence with binary operator
        details: |-
          To set a specific initial value, use composition with Push, e.g.
          `Push(0) | Fold(Add)`

          For reverse operation, see Unfold
        domain: [list, fn]
        codomain: any
        examples: |-
          [-1, 2, 3] | Fold(Add) ↦  4
          [-1, 2, 3] | Fold(Mul) ↦ -6

      - name: Map
        signature: Binary
        brief: Apply param expr to every element of sequence
        domain: [list, fn]
        codomain: list
        examples: |-
          [1, 2, 3] | Map(Add(1)) ↦ [2, 3, 4]


      - name: Filter
        signature: Binary
        brief: Filter sequence by predicate param
        literals-as-eq: true
        domain: [list, predicate]
        codomain: list
        examples: |-
          [1, 2, 3, 4] | Filter(Gt(2)) ↦ [3, 4]

      - name: Count
        signature: Binary
        brief: Count matches by predicate param
        domain: [list, predicate]
        literals-as-eq: true
        codomain: uint
        examples: |-
          [1, 2, 3, 4] | Count(Gt(2)) ↦ 2

      - name: Each
        signature: Binary
        brief: Test predicate for each item in a sequence
        details: Equivalent to `Count(p | Not) | Eq(0)`
        literals-as-eq: true
        domain: [list, predicate]
        codomain: bool
        examples: |-
          [1, 2, 3, 4] | Each(Gt(2)) ↦ false
          [1, 2, 3, 4] | Slide(2) | Each(Lt) ↦ true

      - name: Sort
        signature: Binary
        brief: 'Sort list by key function'
        domain: [list, fn]
        default: Id
        codomain: list
        examples: |-
          [3, 1, 2] | Sort ↦ [1, 2, 3]
          [3, 1, 2] | Sort(Id) ↦ [1, 2, 3]
          [-3, 1, -2] | Sort(Abs) ↦ [1, -2, -3]
          [3, 1, 2] | Sort | Reverse ↦ [3, 2, 1]

      - name: Find
        signature: Binary
        brief: Find the first element that satisfies given predicate
        detail: |-
          Objects are traversed breadth-first
        domain: [any, fn]
        codomain: any
        examples: |-
          [-3, 1, -2] | Find(Ge(2)) ↦  nullptr
          [-3, 1,  4] | Find(Ge(2)) ↦  4

      - name: FindPtr
        signature: Binary
        brief: Find JSON POinter of the first element that satisfies given predicate
        detail: |-
          Objects are traversed breadth-first.
        domain: [any, fn]
        codomain: any
        examples: |-
          [-3, 1, -2] | FindPtr(Ge(2)) ↦  nullptr
          [-3, 1,  4] | FindPtr(Ge(2)) ↦  "/2"

      - name: FindIdx
        signature: Binary
        brief: Find index of the first element that satisfies given predicate
        details: |-
          Similar to FindPtr, but will integer index or nullptr for non-indexable input.
          Objects are processed as list of key-value pairs.
        detail: |-
          find-ptr
        domain: [list, fn]
        codomain: any
        examples: |-
          [-3, 1, -2] | FindIdx(Ge(2)) ↦  nullptr
          [-3, 1,  4] | FindIdx(Ge(2)) ↦  2

      - name: Min
        signature: Binary
        brief: 'Min value by key function'
        domain: [list, fn]
        default: Id
        codomain: any
        examples: |-
          [-3, 1, -2] | Min      ↦  1
          [-3, 1, -2] | Min(Abs) ↦ -3

      - name: Max
        signature: Binary
        brief: 'Max value by key function'
        domain: [list, fn]
        default: Id
        codomain: any
        examples: |-
          [-3, 1, -2] | Max      ↦  1
          [-3, 1, -2] | Max(Abs) ↦ -3

      - name: Argmin
        signature: Binary
        brief: 'Min value index by key function'
        domain: [list, fn]
        default: Id
        codomain: uint
        examples: |-
          [-3, 1, -2] | Argmin      ↦ 0
          [-3, 1, -2] | Argmin(Abs) ↦ 1

      - name: Argmax
        signature: Binary
        brief: 'Max value index by key function'
        domain: [list, fn]
        default: Id
        codomain: uint
        examples: |-
          [-3, 1, -2] | Argmax      ↦ 1
          [-3, 1, -2] | Argmax(Abs) ↦ 0

      - name: Recur
        signature: Binary
        brief: Apply recursion to parameter expr and initial value
        details: |-
          Inference rules:

            - `n | Recur(x & f)` $\mapsto ◯ⁿ f(x)$, or
            - `Q(p) | Recur(x₀ & f)` $\mapsto x_k$, where

              - $x_{i+1} = f(x_i)$
              - $p(x_{i}) = \top \quad \forall i \le k$
              - $p(x_{i+1}) = \bot$ (exit condition)
        domain: [any, expr]
        codomain: any
        examples: |-
          0 | Recur(0 & Add(1))  ↦  3
          3 | Recur(1 & Mul(-1)) ↦ -1

      - name: Unfold
        signature: Binary
        brief: Put results of recursive fn call on initial value into an array
        details: |-

          Inference rules:

            - `n | Unfold(x & f)`$\mapsto [x_0, x_1, ...,  x_n]$, or
            - `Q(p) | Unfold(x₀ & f)` $\mapsto [x_0, x_1, ...,  x_k]$, where

              - $x_{i+1} = f(x_i)$
              - $p(x_{i}) = \top \quad \forall i \le k$
              - $p(x_{i+1}) = \bot$ (exit condition)

        domain: [any, expr]
        codomain: list
        examples: |-
          3 | Unfold(0 & Add(1)) ↦  [0, 1, 2, 3]
          3 | Unfold(1 & Mul(-1)) ↦  [1,-1, 1,-1]

      - name: Op
        aliases: [ Overload ]
        signature: Special
        brief: Bind type-specific operator handler to function
        details: |-
          Expression Op(op, f) instructs f to use op operator on
          invocation instead of the default generic.

          Operator parameter singleton can be referenced with string key
          or constructed in place using type<T> tag.

          This operator handler is propagated downstream to all terminal
          subexpression in `f`. Result of `f(x)` is also reserialized (undecorated)
          as operator type, unless f is constant or boolean expression.

        domain: any
        codomain: any
        params:
          - label: operator
          - type: fn
        examples: |-
          [0.5, 2] | Op("complex", Add(1)) ↦ [1.5, 2]

      - name: Bind
        signature: Binary
        brief: Bind design-time parameters to function.
        examples: |-
          42 & Q(Add) | Bind ↦ Add(42)
          42 | Bind(F) | Bind(G) | Bind(H) ↦  H(G(F(42)))
        domain: [any, expr]
        codomain: expr


      - name: Link
        signature: Binary
        brief: ...
        examples: |-
        domain: [any, expr]
        codomain: expr

      - name: Capture
        signature: Binary
        brief: Symbolic binding of the input value
        details: |-
          The capture is referenced by an arbitrary string preceded by dollar sign,
          e.g. "$x".

          On the first access it stores the input value in isolated expression context,
          and returns it on each subsequent call.
          It can't be reset after the first access.

          The string after $ sign shall not be enclosed in [], {}, or (),
          as those formats are reserved for internal usage.
        examples: |-
          42 | "$x" | Ge(0) | And("$x") | Or("$x" | Mul(-1)) ↦ 42
          -7 | "$x" | Ge(0) | And("$x") | Or("$x" | Mul(-1)) ↦ 7
        domain: [any, expr]
        codomain: expr

      - name: Refer
        signature: Binary
        brief: Return capture
        examples: |-
        domain: [any, expr]
        codomain: expr

      - name: Let
        signature: Binary
        brief: Store capture
        examples: |-
        domain: [any, expr]
        codomain: expr

      - name: Any
        signature: Variadic
        brief: Match any predicate
        domain: any
        codomain: bool
        literals-as-eq: true
        params:
          - label: predicates
            type: list[predicate]
        examples: |-
          3 | Any(Gt(2), Lt(0)) ↦ true
          0 | Any(Gt(2), Lt(0)) ↦ false

      - name: All
        signature: Variadic
        brief: Match all predicates
        domain: any
        codomain: bool
        literals-as-eq: true
        params:
          - label: predicates
            type: list[predicate]
        examples: |-
          3 | All(Gt(2), Lt(0)) ↦ false
          2.5 | All(Gt(2), Lt(3)) ↦ true

      - name: Saturate
        signature: Variadic
        brief: Saturate matches in order
        domain: list
        codomain: bool
        literals-as-eq: true
        params:
          - label: predicates
            type: list[predicate]
        examples: |-
          3 | Saturate(Gt(2), Lt(0)) ↦ true
          0 | Saturate(Gt(2), Lt(0)) ↦ false

          [2,4,8,42,1,2] | Saturate(42, Mod(2)|0) ↦ true
          [2,4,8,41,2] | Saturate(42, Mod(2)|0) ↦ false
          [2,4,8,42] | Saturate(42, Mod(2)|0) ↦ false

      - name: Pipe
        signature: Variadic
        brief: Pipe functions in left-to-right composition
        domain: any
        codomain: any
        literals-as-eq: true
        params:
          - label: functions
            type: list[expr]
        examples: |-
          3 | Pipe(Mul(2), Add(1)) ↦ 7
          4 | Pipe(Mul(2), Add(1)) ↦ 9

          **Infix operator form (pipe)**:

          Add(1) | Mul(2) ≡ Pipe(Add(1), Mul(2))
          3 | Add(1) | Mul(2) ↦ 8

      - name: Tuple
        signature: Variadic
        brief: Pack expressions into an tuple without evaluation
        domain: any
        codomain: list
        params:
          - label: functions
            type: list[expr]
        examples: |-
          null | Tuple(Reduce(Add), Size) ↦ [Reduce(Add), Size]

          **Infix operator form (plus):**

          Add(1) + Mul(2) ≡ Tuple(Add(1), Mul(2))

      - name: Fork
        signature: Variadic
        brief: Pack results from enveloped functions into an array
        details: |-
          Allows to combine different properties in a single expression.
          Parameter
        domain: any
        codomain: list
        params:
          - label: functions
            type: list[expr]
        examples: |-
          [1,2,3] | Fork(Reduce(Add), Size) ↦ [6,3]
          [1,2,3] | Fork(42, Card, Id) ↦ [42, 3, [1,2,3]]

          **Infix operator form (ampersand):**

          Add(1) & Mul(2) ≡ Fork(Add(1), Mul(2))
          [1,2,3] | Reduce(Add) & Size ↦ [6,3]
          [1,2,3] | Reduce(Add) & Size | Div ↦ 2

          Note that the Fork is not associative,
          therefore an infix operator chain is not unfolded
          as it is done for variadic Pipe or Tuple:
          a & b & c ≡ (a & b) & c ≡ Fork(Fork(a, b), c)

      - name: Flip
        signature: Binary
        brief: Flips design-time and eval-time parameters.
        details: |-
          Useful for binding lhs operands to non-commutative
          operators. Unlike Haskell's flip, won't change the
          order or eval-time parameters - for that case use
          the Reverse keyword instead.
        domain: [fn, any]
        codomain: any
        examples: |-
          2 | Div(1) ↦ 2
          2 | Flip(Div(1)) ↦ 0.5

      - name: Dbg
        signature: Binary
        aliases: [ Debug ]
        brief: Evaluate function and print evaluation log to stderr
        detail: |-
          To trace the origin in log add Trace to the enveloped expression.
        examples: |-
          42 | Dbg(Trace(ZMBT_CUR_LOC) | Add(2))
        params:
          - type: fn
          - label: identifier
        domain: any
        codomain: any

      - name: Eval
        signature: Binary
        brief: Flip designtime and run-time parameters, evaluating input as expression
        domain: [any, fn]

      - name: Try
        signature: Binary
        brief: Evaluate function and return result or null if it returns error
        domain: [fn, any]
        examples: |-
          42 | Try(Add(1)) ↦ 43
          "foo" | Try(Add(1)) ↦ null

      - name: Kwrd
        # aliases: [ Keyword ] FIXME: bad namespacing
        signature: Unary
        brief: Introspect Expression keyword.
        domain: any
        codomain: str
        examples: |-
          Q(Fold(Add)) | Kwrd ↦ "Fold"
          [1, 1, 1] | Kwrd ↦ "Literal"

      - name: Prms
        aliases: [ Parameters ]
        signature: Unary
        brief: Introspect Expression parameters.
        domain: any
        codomain: str
        examples: |-
          Q(Fold(Add)) | Prms ↦ Add
          [1, 1, 1] | Prms ↦ [1, 1, 1]

  Evaluation handlers:
    defaults:
      signature: Binary
      codomain: any

    keywords:

      - name: Q
        aliases: [ C, Const ]
        brief: Quote parameter, similar to Lisp quotation.
        details: |-
          Quotation lifts any parameter to constant, s.t.
          produced expression will return the design-time parameter
          on evaluation, ignoring input. If evaluable expression
          is passed, it is returned unevaluated.
          Unlike plain literals which can be treated
          as predicate matchers in certain context, Q(x) is always
          a constant expression discarding input.
          Flip(Q) is equivalent to Id.
        domain: [any, any]
        examples: |-
          null | C(42) ↦ 42
        codegen-value:
          cxx: rhs()

      - name: D
        aliases: [ Default ]
        brief: Return x if not null, else return default value
        domain: [any, any]
        codegen-value:
          # cxx: 'lhs().is_null() ? rhs() :  lhs()'
          cxx: '(lhs().is_literal() && lhs().is_null()) ? rhs().eval_e({}, curr_ctx()) : lhs()'
        examples: |-
          null | Default(42) ↦ 42
          13 | Default(42) ↦ 13

      - name: Err
        aliases: [ Error ]
        brief: Error object
        signature: Special
        details: |-
          Error object (work in progress)
        codegen-value:
          cxx: self()

      - name: Trace
        signature: Binary
        brief: Same as Id, but also prints identifier parameter to debug log.
        domain: [any, str]

      - name: PreProc
        brief: Preprocessing token
        details: |-
          String token that can be substituted with arbitrary expression
          on expression preprocessing.
        domain: [any, any]
        examples: |-
          null | C(42) ↦ 42
        codegen-value:
          cxx: self()
