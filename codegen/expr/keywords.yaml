# (c) Copyright 2024-2025 Zenseact AB
# SPDX-License-Identifier: Apache-2.0

keyword_groups:

  Internal:
    defaults:
      internal: true
    keywords:
      - name: literal
        brief: Literal value
        details: |-
          Literal value keyword with no expression API.
          in evaluation context works as Eq(x)
      - name: void
        brief: empty value

  Constants:
    defaults:
      signature: Const
      domain: null
      codomain: real
      imports:
        cxx:
          - limits
          - boost/math/constants/constants.hpp
    keywords:
      - name: noop
        brief: No operation
        details: |-
          Returns true without input validation.
          Used in place of matchers for uninteresting signals.
        domain: any
        codomain: any
        aliases: [ '_' ]
        codegen-value:
          cxx: 'true'

      - name: 'null'
        brief: Null value
        domain: any
        codomain: any
        codegen-value:
          cxx: 'nullptr'

      - name: 'true'
        brief: Logical true
        symbol: T
        codomain: bool
        codegen-value:
          cxx: 'true'

      - name: 'false'
        brief: Logical false
        symbol: ⊥
        codomain: bool
        codegen-value:
          cxx: 'false'

      - name: pi
        brief: Pi constant
        symbol: π
        codegen-value:
          cxx: boost::math::constants::pi<double>()

      - name: e
        brief: Euler's number
        codegen-value:
          cxx: boost::math::constants::e<double>()

      - name: inf
        brief: Infinity
        codegen-value:
          cxx: std::numeric_limits<double>::infinity()

      - name: eps
        brief: Machine epsilon
        codegen-value:
          cxx: std::numeric_limits<double>::epsilon()

      - name: nan
        enum: NaN
        brief: Not a number
        codegen-value:
          cxx: std::numeric_limits<double>::quiet_NaN()

  Math Functions:
    defaults:
      signature: Unary
      domain: real
      codomain: real
      imports:
        cxx:
          - cmath
    keywords:

      - name: sin
        brief: Sinus
        codegen-value:
          cxx: real_to_number(std::sin(boost::json::value_to<double>(x)))

      - name: cos
        brief: Cosinus
        codegen-value:
          cxx: real_to_number(std::cos(boost::json::value_to<double>(x)))

      - name: tan
        brief: Tangens
        codegen-value:
          cxx: real_to_number(std::tan(boost::json::value_to<double>(x)))

      - name: asin
        brief: Arcsin
        codegen-value:
          cxx: real_to_number(std::asin(boost::json::value_to<double>(x)))

      - name: acos
        brief: Arccos
        codegen-value:
          cxx: real_to_number(std::acos(boost::json::value_to<double>(x)))

      - name: atan
        brief: Arctan
        codegen-value:
          cxx: real_to_number(std::atan(boost::json::value_to<double>(x)))

      - name: sinh
        brief: Hyperbolic sin
        codegen-value:
          cxx: real_to_number(std::sinh(boost::json::value_to<double>(x)))

      - name: cosh
        brief: Hyperbolic cos
        codegen-value:
          cxx: real_to_number(std::cosh(boost::json::value_to<double>(x)))

      - name: tanh
        brief: Hyperbolic tan
        codegen-value:
          cxx: real_to_number(std::tanh(boost::json::value_to<double>(x)))

      - name: asinh
        brief: Hyperbolic arcsin
        codegen-value:
          cxx: real_to_number(std::asinh(boost::json::value_to<double>(x)))

      - name: acosh
        brief: Hyperbolic arccos
        codegen-value:
          cxx: real_to_number(std::acosh(boost::json::value_to<double>(x)))

      - name: atanh
        brief: Hyperbolic arctan
        codegen-value:
          cxx: real_to_number(std::atanh(boost::json::value_to<double>(x)))

      - name: exp
        brief: Exponential (e^x)
        codegen-value:
          cxx: real_to_number(std::exp(boost::json::value_to<double>(x)))

      - name: erf
        brief: Error function
        codegen-value:
          cxx: real_to_number(std::erf(boost::json::value_to<double>(x)))

      - name: erfc
        brief: Error function complement
        codegen-value:
          cxx: real_to_number(std::erfc(boost::json::value_to<double>(x)))

      - name: gamma
        brief: Gamma function
        codegen-value:
          cxx: real_to_number(std::tgamma(boost::json::value_to<double>(x)))

      - name: abs
        brief: Absolute value
        codegen-value:
          cxx: real_to_number(std::abs(boost::json::value_to<double>(x)))

      - name: ceil
        codegen-value:
          cxx: real_to_number(std::ceil(boost::json::value_to<double>(x)))

      - name: floor
        codegen-value:
          cxx: real_to_number(std::floor(boost::json::value_to<double>(x)))

      - name: round
        brief: Round to nearest integer
        details: |-
          Hint: To round to ndigits precision after the decimal point,
          use Mul(ndigits)|Round|Div(ndigits) combo.
        codegen-value:
          cxx: real_to_number(std::round(boost::json::value_to<double>(x)))

      - name: sqrt
        brief: Square root
        codegen-value:
          cxx: real_to_number(std::sqrt(boost::json::value_to<double>(x)))

      - name: sign
        domain: real
        codomain: int
        codegen-value:
          cxx: 'boost::json::value_to<double>(x) >= 0 ? 1 : -1'

  Arithmetic Operators:
    defaults:
      signature: Binary
      tags: [op]
      domain: [real, real]
      codomain: real
    keywords:
      - name: neg
        signature: Unary
        brief: Negate
        domain: real
        codomain: real
        examples: |-
          Neg >> 42 == -42

      - name: add
        brief: Addition
        symbol: '+'
        examples: |-
          Add >> [2, -1] == 1
          Add(-1) >> 2  == 1

      - name: sub
        brief: Subtraction
        symbol: '-'
        commutative-dual: sub-from
        examples: |-
          Sub >> [2, 1] == -1
          Sub(1) >> 2   == 1

      - name: sub-from
        brief: Reverse subtraction
        details: |-
          Subtraction with reverse arguments, i. e.
            1. [ ] |-> [y, x] |-> x - y
            2. [x] |-> [y]    |-> x - y
        commutative-dual: sub
        examples: |-
          SubFrom >> [2, 1] == -1
          SubFrom(1) >> 2   == -1

      - name: mul
        brief: Multiplication
        symbol: '*'
        examples: |-
          Mul >> [2, 3] == 6
          Mul(3) >> 2   == 6

      - name: div
        brief: Division
        symbol: '/'
        details: |-
          1. [ ] |-> [x, y] |-> x / y
          2. [y] |-> [x]    |-> x / y
        commutative-dual: div-from
        examples: |-
          Div >> [6, 3] == 2
          Div(3) >> 6   == 2

      - name: div-from
        brief: Reverse division
        details: |-
          Division with reverse arguments, i. e.
            1. [ ] |-> [y, x] |-> x / y
            2. [x] |-> [y]    |-> x / y
        commutative-dual: div
        examples: |-
          DivFrom >> [6, 3] == 0.5
          DivFrom(3) >> 6   == 0.5

      - name: pow
        brief: To power
        details: |-
          X to power p
            1. [ ] |-> [x, p] |-> x^p
            2. [p] |-> [x]    |-> x^p
        commutative-dual: pow-from
        examples: |-
          Pow >> [2, 3] == 8
          Pow(3) >> 2   == 8

      - name: pow-from
        brief: Reverse power
        details: |-
          Pow with reverse arguments, i. e.
            1. [ ] |-> [p, x] |-> x^p
            2. [x] |-> [p]    |-> x^p
        commutative-dual: pow
        examples: |-
          PowFrom >> [2, 3] == 9
          PowFrom(3) >> 2   == 9

      - name: log
        brief: Logarithm
        details: |-
          Logarithm with base b:
            1. [ ] |-> [x, b] |-> log_b(x)
            2. [b] |-> [x]    |-> log_b(x)
        commutative-dual: log-from
        examples: |-
          Log >> [8, 2] == 3
          Log(2) >> 8   == 3

      - name: log-from
        brief: Reverse logarithm
        details: |-
          Log with reverse arguments, i. e.
            1. [ ] |-> [b, x] |-> log_b(x)
            2. [b] |-> [b]    |-> log_b(x)
        commutative-dual: log
        examples: |-
          LogFrom >> [2, 8] == 3
          LogFrom(2) >> 8   == 3

      - name: mod
        brief: Modulo
        symbol: '%'
        details: |-
          Modulo of x:
            1. [ ] |-> [x, m] |-> x % m
            2. [m] |-> [x]    |-> x % m
        commutative-dual: mod-from
        examples: |-
          Mod >> [7, 4] == 3
          Mod(4) >> 7   == 3

      - name: mod-from
        brief: Reverse modulo
        details: |-
          Modulo with reverse arguments, i. e.
            1. [ ] |-> [b, x] |-> log_b(x)
            2. [b] |-> [b]    |-> log_b(x)
        commutative-dual: mod
        examples: |-
          ModFrom >> [4, 7] == 3
          ModFrom(4) >> 7   == 3

      - name: quot
        brief: Quotient
        symbol: '//'
        details: |-
          Quotient of x:
            1. [ ] |-> [x, d] |-> x // d
            2. [d] |-> [x]    |-> x // d
        commutative-dual: quot-from
        examples: |-
          Quot >> [7, 4] == 1
          Quot(4) >> 7   == 1

      - name: quot-from
        brief: Reverse quotient
        details: |-
          Quotient with reverse arguments, i. e.
            1. [ ] |-> [d, x] |-> x // d
            2. [x] |-> [d]    |-> x // d
        commutative-dual: quot
        examples: |-
          QuotFrom >> [4, 7] == 1
          QuotFrom(4) >> 7   == 1

      - name: b-not
        signature: Unary
        brief: Bitwise not
        enum: BitNot
        symbol: '~'
        domain: uint
        codomain: uint
        examples: |-
          BitNot >> 0b1010 == 0b0101

      - name: b-and
        brief: Bitwise and
        enum: BitAnd
        symbol: '&'
        domain: [uint, uint]
        codomain: uint
        examples: |-
          BitAnd >> [0b1010, 0b1100] == 0b1000

      - name: b-or
        brief: Bitwise or
        enum: BitOr
        symbol: '|'
        domain: [uint, uint]
        codomain: uint
        examples: |-
          BitOr >> [0b1010, 0b1100] == 0b1110

      - name: b-xor
        brief: Bitwise xor
        enum: BitXor
        symbol: '^'
        domain: [uint, uint]
        codomain: uint
        examples: |-
          BitXor >> [0b1010, 0b1100] == 0b0110

      - name: b-lshift
        brief: Bitwise left shift
        enum: BitLshift
        symbol: '<<'
        details: |-
          1. [ ] |-> [x, s] |-> x << s
          2. [s] |-> [x]    |-> x << s
        commutative-dual: b-lshift-from
        domain: [uint, uint]
        codomain: uint
        examples: |-
          BitLshift >> [0b1010, 2] == 0b101000

      - name: b-lshift-from
        brief: Reverse bitwise left shift
        enum: BitLshiftFrom
        details: |-
          Bitwise left shift with reverse arguments, i. e.
            1. [ ] |-> [s, x] |-> x << s
            2. [x] |-> [s]    |-> x << s
        commutative-dual: b-lshift
        domain: [uint, uint]
        codomain: uint
        examples: |-
          BitLshiftFrom >> [2, 0b1010] == 0b101000

      - name: b-rshift
        brief: Bitwise right shift
        enum: BitRshift
        symbol: '>>'
        details: |-
          1. [ ] |-> [x, s] |-> x >> s
          2. [s] |-> [x]    |-> x >> s
        commutative-dual: b-rshift-from
        domain: [uint, uint]
        codomain: uint
        examples: |-
          BitRshift >> [0b1010, 2] == 0b0010

      - name: b-rshift-from
        brief: Reverse bitwise right shift
        enum: BitRshiftFrom
        details: |-
          Bitwise right shift with reverse arguments, i. e.
            1. [ ] |-> [s, x] |-> x >> s
            2. [x] |-> [s]    |-> x >> s
        commutative-dual: b-rshift
        domain: [uint, uint]
        codomain: uint
        examples: |-
          BitRshiftFrom >> [2, 0b1010] == 0b0010

  Relation Operators:
    defaults:
      signature: Binary
      domain: [any, any]
      codomain: bool
      tags: [op]
    keywords:

      - name: eq
        brief: Is equal
        symbol: '='
        examples: |-
          Eq >> [1, 1] == true
          Eq(42) >> 41 == false


      - name: ne
        brief: Not equal
        symbol: '≠'
        examples: |-
          Ne >> [1, 2] == true
          Ne(42) >> 42 == false

      - name: lt
        brief: Lesser than
        symbol: '<'
        commutative-dual: ge
        examples: |-
          Lt >> [1, 2] == true
          Lt(42) >> 41 == false

      - name: le
        brief: Lesser or equal
        symbol: '≤'
        commutative-dual: gt
        examples: |-
          Le >> [1, 2] == true
          Le(42) >> 42 == true

      - name: gt
        brief: Greater than
        symbol: '>'
        commutative-dual: le
        examples: |-
          Gt >> [2, 1] == true
          Gt(42) >> 43 == false

      - name: ge
        brief: Greater or equal
        symbol: '≥'
        commutative-dual: lt
        examples: |-
          Ge >> [2, 1] == true
          Ge(42) >> 42 == true

      - name: approx
        brief: Floating point approximately equal
        details: |-
          Based on numpy.isclose: abs(x - ref) <= (atol + rtol * abs(ref))

          Rhs parameters:
            ref: reference value
            rtol: relative tolerance, default = 1e-05
            atol: absolute tolerance, default = 1e-08

          Rhs dynamic evaluation:
            1. ref                -> [ref, default, default]
            2. [ref]              -> [ref, default, default]
            3. [ref, rtol]        -> [ref, rtol   , default]
            4. [ref, rtol, atol]  -> [ref, rtol   , atol   ]

        aliases: [ 'near' ]
        domain: [real, list]
        codomain: bool
        commutative: false
        examples: |-
          Approx >> [42, 42] == true
          Approx(42.0 + 1e-09) >> 42 == true
          Approx(42.001) >> 42 == false

          Relative tolerance 1e-03
          Approx([3.14, 0.001]) >> pi == true
          Absolute tolerance 0.01
          Approx([3.14, 0, 0.01]) >> pi == true

  Set Operators:
    defaults:
      signature: Binary
      domain: [set, set]
      codomain: set
    keywords:

      - name: union
        brief: Set union
        symbol: '∪'
        examples: |-
          Union >> [[1, 2], [2, 3]] == [1, 2, 3]
          Union([2, 3]) >> [1, 2] == [1, 2, 3]

      - name: intersect
        brief: Set intersection
        symbol: '∩'
        examples: |-
          Intersect >> [[1, 2], [2, 3]] == [2]
          Intersect([2, 3]) >> [1, 2] == [2]

      - name: set-diff
        enum: Diff
        brief: Set difference
        commutative-dual: set-diff-from
        examples: |-
          Diff >> [[1, 2], [2, 3]] == [1]
          Diff([2, 3]) >> [1, 2] == [1]

      - name: set-diff-from
        enum: DiffFrom
        brief: Reverse set difference
        commutative-dual: set-diff
        examples: |-
          DiffFrom >> [[1, 2], [2, 3]] == [3]
          DiffFrom([2, 3]) >> [1, 2] == [3]

  Set Relation Operators:
    defaults:
      signature: Binary
      tags: [op]
      domain: [set, set]
      codomain: bool
    keywords:

      - name: set-eq
        enum: SetEq
        brief: Equal as set
        symbol: '≡'
        examples: |-
          SetEq >> [[1, 2], [2, 1]] == true
          SetEq([2, 1]) >> [1, 2] == true

      - name: subset
        brief: Is subset
        symbol: '⊆'
        commutative-dual: p-superset
        examples: |-
          Subset >> [[1, 2], [1, 2, 3]] == true
          Subset([1, 2, 3]) >> [1, 2] == true

          Subset >> [[1, 2, 3], [2, 3]] == false
          Subset([2, 3]) >> [1, 2, 3] == false

          Subset >> [[1, 2], []] == true
          Subset >> [[], []] == true

      - name: superset
        brief: is superset
        symbol: '⊇'
        commutative-dual: p-subset
        examples: |-
          Superset >> [[1, 2, 3], [1, 2]] == true
          Superset([1, 2]) >> [1, 2, 3] == true

          Superset >> [[2, 3], [1, 2, 3]] == false
          Superset([1, 2, 3]) >> [2, 3] == false

          Superset >> [[], [1, 2]] == true
          Superset >> [[], []] == true

      - name: p-subset
        enum: ProperSubset
        brief: Is proper subset
        symbol: '⊂'
        commutative-dual: superset
        examples: |-
          ProperSubset >> [[1, 2], [1, 2, 3]] == true
          ProperSubset([1, 2, 3]) >> [1, 2] == true

          ProperSubset >> [[1, 2, 3], [2, 3]] == false
          ProperSubset([2, 3]) >> [1, 2, 3] == false

          ProperSubset >> [[1, 2], []] == true
          ProperSubset >> [[], []] == false

      - name: p-superset
        enum: ProperSuperset
        brief: Is proper superset
        symbol: '⊃'
        commutative-dual: subset
        examples: |-
          ProperSuperset >> [[1, 2, 3], [1, 2]] == true
          ProperSuperset([1, 2]) >> [1, 2, 3] == true

          ProperSuperset >> [[2, 3], [1, 2, 3]] == false
          ProperSuperset([1, 2, 3]) >> [2, 3] == false

          ProperSuperset >> [[], [1, 2]] == true
          ProperSuperset >> [[], []] == false

      - name: in
        brief: Element is in
        symbol: '∈'
        domain: [any, set]
        commutative-dual: ni
        examples: |-
          In >> [1, [1, 2]] == true
          In([1, 2]) >> 3 == false

      - name: not-in
        enum: NotIn
        brief: Element is not in
        symbol: '∉'
        domain: [any, set]
        commutative-dual: not-ni
        examples: |-
          NotIn >> [3, [1, 2]] == true
          NotIn([1, 2]) >> 1 == false

      - name: ni
        brief: Contains element
        enum: Ni
        symbol: '∋'
        aliases: [ 'contains' ]
        commutative-dual: in
        domain: [set, any]
        examples: |-
          Ni >> [[1, 2], 1] == true
          Ni([1, 2]) >> 3 == false

      - name: not-ni
        brief: Not contains element
        enum: NotNi
        symbol: '∌'
        commutative-dual: not-in
        domain: [set, any]
        examples: |-
          NotNi >> [[1, 2], 3] == true
          NotNi([1, 2]) >> 1 == false

  Branching Operators:
    defaults:
      signature: Binary
      domain: [any, any]
      codomain: any
      tags: [op]
    keywords:

      - name: bool
        signature: Unary
        brief: Predicate on boolean transform (aka Truthy)
        symbol: '?'
        domain: any
        codomain: bool
        alias: [ 'truthy' ]
        examples: |-
          Bool >> 42 == true
          Bool >> 0 == false
          Bool >> "false" == true
          Bool >> "" == false
          Bool >> [1] == true
          Bool >> [] == false
          Bool >> {} == false
          Bool >> null == false

      - name: nil
        signature: Unary
        brief: Predicate on boolean transform (aka Falsy)
        domain: any
        codomain: bool
        alias: [ 'falsy' ]
        examples: |-
          Nil >> 42 == false
          Nil >> 0 == true

      - name: not
        signature: Unary
        brief: Logical complement
        domain: any
        codomain: bool
        symbol: ¬
        examples: |-
          Not >> true == false
          Not >> false == true

      - name: and
        brief: Logical and
        details: |-
          Generic behavior:
            if first operand is truthy, returns second operand, otherwise first
        symbol: ∧
        examples: |-
          And >> [true, false] == false
          And >> [true, true] == true

          Generic behavior:
          And >> ["foo", [42, 43]] == [42, 43]
          And >> [""   , [42, 43]] == ""

          And(42) >> 13 == 42
          And(42) >> [] == []

          If-Else using composition:
          And(42)|Or(13) >> true  == 42
          And(42)|Or(13) >> false == 13

      - name: or
        brief: Logical or
        symbol: ∨
        details: |-
          Generic behavior:
            if first operand is truthy, returns first operand, second otherwise
        examples: |-
          Or >> [true, false] == true
          Or >> [false, false] == false

          Generic behavior:
          Or >> ["foo", [42, 43]] == "foo"
          Or >> [""   , [42, 43]] == [42, 43]

          Or(42) >> 13 == 13
          Or(42) >> [] == 42

          If-Else using composition:
          And(42)|Or(13) >> true  == 42
          And(42)|Or(13) >> false == 13


  Unary Structural transforms:
    defaults:
      signature: Unary
    keywords:
      - name: id
        brief: Identity function
        domain: any
        codomain: any
        codegen-value:
          cxx: x
        examples: |-
          Id >> 42 == 42

      - name: transp
        brief: Transpose multidimensional list, turning rows into columns
        details: |-
          May be used to zip sequences of equal length.
        domain: list[list]
        codomain: list[list]
        examples: |-
          Transp >> [[1, 2, 3], [4, 5, 6]] == [[1, 4], [2, 5], [3, 6]]

      - name: cartesian
        brief: Cartesian product
        symbol: '×'
        domain: list[set]
        codomain: list[list]
        examples: |-
          Cartesian >> [[1, 2], [3, 4]] == [[1, 3], [1, 4], [2, 3], [2, 4]]

      - name: reverse
        brief: Reverse sequence
        domain: list[set]
        codomain: list[list]
        examples: |-
          Reverse >> [1, 2, 3] == [3, 2, 1]

      - name: uniques
        brief: Filter unique elements
        domain: list
        codomain: set
        examples: |-
          Uniques >> [1, 2, 1, 3, 2] == [1, 2, 3]

      - name: items
        brief: Extract key-value pairs from object
        domain: object
        codomain: list[list]
        examples: |-
          Items >> {"a": 1, "b": 2} == [["a", 1], ["b", 2]]

      - name: keys
        brief: Extract keys from object
        domain: object
        codomain: list
        examples: |-
          Keys >> {"a": 1, "b": 2} == ["a", "b"]

      - name: values
        brief: Extract values from object
        domain: object
        codomain: list
        examples: |-
          Values >> {"a": 1, "b": 2} == [1, 2]

      - name: enumerate
        brief: Enumerate sequence
        details: |-
          Enumerate sequence with index.
        domain: list
        codomain: list[list]
        examples: |-
          Enumerate >> [1, 2, 3] == [[0, 1], [1, 2], [2, 3]]

      - name: flatten
        brief: Flatten nested list
        domain: list
        codomain: list
        examples: |-
          Flatten >> [[1, 2], [3, 4]] == [1, 2, 3, 4]


  Unary Generators:
    defaults:
      signature: Unary
    keywords:
      - name: arange
        brief: Generate range of numbers
        details: |-
          Return evenly spaced values within a given interval.

          Parameters:
            1. start: start value
            2. stop: stop value
            3. step: step value

          Parameters dynamic evaluation:
            1. stop: int            -> [0, stop, 1]
            2. [start, stop]        -> [start, stop, 1]
            3. [start, stop, step]  -> [start, stop, step]
        domain: any
        codomain: list
        examples: |-
          Arange >> 6 == [0,1,2,3,4,5]
          Arange >> [2,6]     == [2,3,4,5]
          Arange >> [1,9,2]   == [1,3,5,7]
          Arange >> [5,1,-1]  == [5,4,3,2]

          Arange >> "2:6"     == [2,3,4,5]
          Arange >> "1:9:2"   == [1,3,5,7]
          Arange >> "5:1:-1"  == [5,4,3,2]

  String Transforms:
    keywords:
      - name: parse
        brief: Parse string as JSON
        signature: Unary
        domain: str
        codomain: any
        codegen-value:
          cxx: boost::json::parse(x.as_string())
        imports:
          cxx:
            - boost/json.hpp
        examples: |-
          Parse >> '{"a": 42}' == {"a": 42}

      - name: serialize
        aliases: [ str ]
        brief: Serialize JSON as string
        signature: Unary
        domain: any
        codomain: str
        codegen-value:
          cxx: '{boost::json::serialize(x)}'
        imports:
          cxx:
            - boost/json.hpp
        examples: |-
          Serialize >> {"a": 42} == '{"a":42}'

      - name: re
        brief: Regular expression match
        signature: Binary
        details: If input is not a string, match it's serialized form.
        aliases: [ 'regex' ]
        commutative: false
        domain: [any, str]
        codomain: bool
        params:
          - label: pattern
        examples: |-
          Re >> ["[0-9]+", "42"] == true
          Re("[0-9]+") >> "42" == true

      - name: format
        aliases: [ fmt ]
        brief: format string with given parameter list
        signature: Variadic
        domain: [str, list]
        codomain: str
        examples: |-
          Format >> ["Hello, %s!", ["world"]] == "Hello, world!"
          Format(2,2,4) >> "%d + %d = %d" == "2 + 2 = 4"

  Structural properties:
    defaults:
      signature: Unary
    keywords:
      - name: card
        brief: Set cardinality (uniques count)
        domain: union[list, object]
        codomain: uint
        examples: |-
          Card >> [1, 2, 1, 3, 2] == 3
          Card >> {"a": 1, "b": 2} == 2

      - name: size
        brief: Sequence size
        domain: union[list, object]
        codomain: uint
        examples: |-
          Size >> [1, 1, 1] == 3
          Size >> {"a": 1, "b": 2} == 2

      - name: sum
        brief: Summation reduction
        details: Equivalent to Reduce(Add)
        symbol: Σ
        domain: list
        codomain: any
        examples: |-
          Sum >> [1, 2, 3] == 6

      - name: prod
        brief: Multiplication reduction
        details: Equivalent to Reduce(Mul)
        symbol: Π
        domain: list
        codomain: any
        examples: |-
          Prod >> [1, 2, 3] == 6

      - name: avg
        brief: Arythmetic average
        domain: list
        codomain: any
        examples: |-
          Avg >> [1, 2, 3] == 2

  Binary Structural transforms:
    defaults:
      signature: Binary
    keywords:

      - name: slide
        brief: Sliding-window iteration
        details: |-
          Sliding window iteration by specified window width.
        commutative: false
        domain: [list, int]
        codomain: list[list]
        params:
          - label: window width
        examples: |-
          Slide(3) >> [1,2,3,4,5] == [[1,2,3],[2,3,4],[3,4,5]]

      - name: stride
        brief: Striding iteration
        details: |-
          Striding iteration by specified step width.
        commutative: false
        domain: [list, int]
        codomain: list[list]
        params:
          - label: step width
        examples: |-
          Stride(2) >> [1,2,3,4,5] == [[1,3,5],[2,4]]

      - name: repeat
        brief: Repeat value in list
        commutative: false
        domain: [any, int]
        codomain: list
        params:
          - label: count
        examples: |-
          Repeat(3) >> 42 == [42, 42, 42]
          Repeat(3)|Repeat(2) >> 1 == [[1,1,1],[1,1,1]]


      - name: concat
        brief: Concatenate sequences
        domain: [any, any]
        codomain: any
        examples: |-
          Concat >> [1, 2], [3, 4] == [1, 2, 3, 4]
          Concat("World!") >> "Hello, " == "Hello, World!"


      - name: push
        brief: Push element into a front of sequence
        domain: [any, list]
        codomain: any
        examples: |-
          Push >> [1, 2], 3 == [3, 1, 2]
          Push(3) >> [1, 2] == [3, 1, 2]

      - name: at
        brief: Transform JSON value with given query
        details: |-
          Query evaluation rules:
            1. q: int   |-> x: list  |-> x at index q (negative -> reverse)
            2. q: slice |-> x: list  |-> x[start:stop:step]
            3. q: str   |-> x: any   |-> x at JSON Pointer q
            4. q: list  |-> x: any   |-> [x at q1, x at q2, ...]
            5. {"key": q1, "$q2": q3, ...} |-> x: any |->
                { "key1": x at q1, "$(x at q2)": x at q3, ...}

        commutative: false
        domain: [any, union: [int, str, list, object]]
        codomain: any
        params:
          - label: query
        examples: |-
          • Index query:
          At(2) >> [1, 2, 3] == 3
          At(3) >> [1, 2, 3] == nullptr
          At(0) >> 42 == nullptr

          • JSON Pointer query:
          At("")   >> "foo" == "foo"
          At("/a") >> {"a": 42, "b": 13} == 42

          • List query:
          At(["/a", "/b"])  >> {"a": 42, "b": 13} == [42, 13]
          At([""])          >> 42 ==  [42]

          • Object query:
          At({"f": "/a", "g": "/b"})  >> {"a": 42, "b": 13} == {"f": 42, "g": 13}
          At({"$/b": "/a"})           >> {"a": 42, "b": 13} == {"13": 42}

          • Slice query:
          At("::2")     >> [1,2,3,4,5,6,7,8] == [1,3,5,7]
          At("4:")      >> [1,2,3,4,5,6,7,8] == [5,6,7,8]
          At("-1:0:-1") >> [1,2,3,4,5,6,7,8] == [8,7,6,5,4,3,2,1]

  High-Order:
    defaults: {}
    keywords:

      - name: reduce
        signature: Binary
        aliases: [ fold ]
        brief: Reduce sequence with binary operator
        details: |-
          To set specific initial value, use composition with Push, e.g.
          Push(0)|Reduce(Add)

          For reverse operatin, see Unfold
        domain: [list, fn]
        codomain: any
        examples: |-
          Reduce(Add) >> [-1, 2, 3] ==  4
          Reduce(Mul) >> [-1, 2, 3] == -6

      - name: map
        signature: Binary
        brief: Apply param expr to every element of sequence
        domain: [list, fn]
        codomain: list
        examples: |-
          Map(Add(1)) >> [1, 2, 3] == [2, 3, 4]

      - name: filter
        signature: Binary
        brief: Filter sequence by predicate param
        domain: [list, predicate]
        codomain: list
        examples: |-
          Filter(Gt(2)) >> [1, 2, 3, 4] == [3, 4]

      - name: count
        signature: Binary
        brief: Count matches by predicate param
        domain: [list, predicate]
        codomain: uint
        examples: |-
          Count(Gt(2)) >> [1, 2, 3, 4] == 2

      - name: sort
        signature: Binary
        brief: 'Sort list by key function'
        domain: [list, fn]
        default: Id
        codomain: list
        examples: |-
          Sort >> [3, 1, 2] == [1, 2, 3]
          Sort(Id) >> [3, 1, 2] == [1, 2, 3]
          Sort(Abs) >> [-3, 1, -2] == [1, -2, -3]
          Sort|Reverse >> [3, 1, 2] == [3, 2, 1]

      - name: min
        signature: Binary
        brief: 'Min value by key function'
        domain: [list, fn]
        default: Id
        codomain: any
        examples: |-
          Min      >> [-3, 1, -2] ==  1
          Min(Abs) >> [-3, 1, -2] == -3

      - name: max
        signature: Binary
        brief: 'Max value by key function'
        domain: [list, fn]
        default: Id
        codomain: any
        examples: |-
          Max      >> [-3, 1, -2] ==  1
          Max(Abs) >> [-3, 1, -2] == -3

      - name: argmin
        signature: Binary
        brief: 'Min value index by key function'
        domain: [list, fn]
        default: Id
        codomain: uint
        examples: |-
          Argmin      >> [-3, 1, -2] == 0
          Argmin(Abs) >> [-3, 1, -2] == 1

      - name: argmax
        signature: Binary
        brief: 'Max value index by key function'
        domain: [list, fn]
        default: Id
        codomain: uint
        examples: |-
          Argmax      >> [-3, 1, -2] == 1
          Argmax(Abs) >> [-3, 1, -2] == 0

      - name: apply
        signature: Ternary
        brief: Apply expr to literal param
        domain: null
        codomain: any
        params:
          - type: fn
          - label: argument
            type: any
        examples: |-
          Apply(Add(1), 42) >> null == 43

          • Infix operator form (left shift):
          (Add(1) << 42) ≡ Apply(Add(1), 42)

      - name: recur
        signature: Ternary
        brief: apply recursion to parameter expr
        domain: any
        codomain: any
        params:
          - type: fn
          - label: depth
            type: int
        examples: |-
          Recur(Add(1), 3)  >> 0 ==  3
          Recur(Mul(-1), 3) >> 1 == -1

      - name: unfold
        signature: Ternary
        brief: Put results of recursive fn call on initial value x into an array
        domain: any
        codomain: list
        params:
          - type: fn
          - label: depth
            type: int
        examples: |-
          Unfold(Add(1), 3)  >> 0 ==  [0, 1, 2, 3]
          Unfold(Mul(-1), 3) >> 1 ==  [1,-1, 1,-1]


      - name: bind
        signature: Variadic
        brief: '!NOT IMPLEMENTED! Bind design-time parameters'
        params:
          - type: fn
          - label: params
            type: object

      - name: any
        signature: Variadic
        brief: Match any predicate
        domain: any
        codomain: bool
        params:
          - label: predicates
            type: list[expr]
        examples: |-
          Any(Gt(2), Lt(0)) >> 3 == true
          Any(Gt(2), Lt(0)) >> 0 == false

      - name: all
        signature: Variadic
        brief: Match all predicates
        domain: any
        codomain: bool
        params:
          - label: predicates
            type: list[expr]
        examples: |-
          All(Gt(2), Lt(0)) >> 3 == false
          All(Gt(2), Lt(3)) >> 2.5 == true

      - name: saturate
        signature: Variadic
        brief: Saturate matches in order
        domain: list
        codomain: bool
        params:
          - label: predicates
            type: list[expr]
        examples: |-
          Saturate(Gt(2), Lt(0)) >> 3 == true
          Saturate(Gt(2), Lt(0)) >> 0 == false

          Saturate(42, Mod(2)|0) >> [2,4,8,42,1,2] == true
          Saturate(42, Mod(2)|0) >> [2,4,8,41,2]   == false
          Saturate(42, Mod(2)|0) >> [2,4,8,42]     == false

      - name: compose
        signature: Variadic
        brief: Compose functions
        domain: any
        codomain: any
        params:
          - label: functions
            type: list[expr]
        examples: |-
          Compose(Add(1), Mul(2)) >> 3 == 7
          Compose(Add(1), Mul(2)) >> 4 == 9

          • Infix operator form (pipe):
          Add(1)|Mul(2) ≡ Compose(Add(1), Mul(2))
          Add(1)|Mul(2) >> 3 == 7

      - name: pack
        signature: Variadic
        brief: Pack results from enveloped functions into an array
        details: |-
          Allows to combine different properties in a single expression
        domain: any
        codomain: list
        params:
          - label: functions
            type: list[expr]
        examples: |-
          Pack(Reduce(Add), Size) >> [1,2,3] == [6,3]

          • Infix operator form (ampersand):
          Reduce(Add) & Size >> [1,2,3] == [6,3]
          Reduce(Add) & Size | Div >> [1,2,3] == 2

  Evaluation handlers:
    defaults:
      signature: Binary
      codomain: any

    keywords:
      - name: default
        brief: Return x if not null, else return default value
        domain: [any, any]
        codegen-value:
          cxx: 'x.is_null() ? params() : x'
        examples: |-
          Default(42) >> null == 42
          Default(42) >> 13 == 13

      - name: try
        brief: Evaluate enveloped function and return result or null if it throws
        domain: [fn, any]
        examples: |-
          Try(Add(1)) >> 42    == 43
          Try(Add(1)) >> "foo" == null

      - name: try-catch
        brief: Evaluate enveloped function and return result or error info if it throws
        domain: [fn, any]
        examples: |-
          TryCatch(Div(0)) >> 42 == {
              "err": "zero division",
              "fn": ":div",
              "x": 42,
              "op":
              "zmbt::GenericSignalOperator"
          }

