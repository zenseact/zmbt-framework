/**
 * \file
 * \copyright (c) Copyright 2024-2025 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * app: codegen.expr
 * template: codegen/expr/templates/zmbt-framework/backends/cxx/src/expr/keyword_grammar.cpp
 *
 * How to update:
 * 1. Update the template
 * 2. Run `python -m codegen` in the project root
 * 3. Commit changes
 */

#include <boost/spirit/include/qi.hpp>

#include "zmbt/expr/keyword.hpp"
#include "zmbt/expr/keyword_grammar.hpp"


namespace qi = boost::spirit::qi;

namespace zmbt {
namespace lang {


KeywordSymbol::KeywordSymbol()
{
    add
    ("Literal", Keyword::Literal)
    ("Void", Keyword::Void)
    ("Noop", Keyword::Noop)
    ("_", Keyword::Noop)
    ("Null", Keyword::Null)
    ("True", Keyword::True)
    ("T", Keyword::True)
    ("False", Keyword::False)
    ("⊥", Keyword::False)
    ("Pi", Keyword::Pi)
    ("π", Keyword::Pi)
    ("E", Keyword::E)
    ("Inf", Keyword::Inf)
    ("Eps", Keyword::Eps)
    ("NaN", Keyword::NaN)
    ("Thread", Keyword::Thread)
    ("Sin", Keyword::Sin)
    ("Cos", Keyword::Cos)
    ("Tan", Keyword::Tan)
    ("Asin", Keyword::Asin)
    ("Acos", Keyword::Acos)
    ("Atan", Keyword::Atan)
    ("Sinh", Keyword::Sinh)
    ("Cosh", Keyword::Cosh)
    ("Tanh", Keyword::Tanh)
    ("Asinh", Keyword::Asinh)
    ("Acosh", Keyword::Acosh)
    ("Atanh", Keyword::Atanh)
    ("Exp", Keyword::Exp)
    ("Erf", Keyword::Erf)
    ("Erfc", Keyword::Erfc)
    ("Gamma", Keyword::Gamma)
    ("Abs", Keyword::Abs)
    ("Ceil", Keyword::Ceil)
    ("Floor", Keyword::Floor)
    ("Round", Keyword::Round)
    ("Sqrt", Keyword::Sqrt)
    ("Sign", Keyword::Sign)
    ("Neg", Keyword::Neg)
    ("Add", Keyword::Add)
    ("+", Keyword::Add)
    ("Sub", Keyword::Sub)
    ("-", Keyword::Sub)
    ("Mul", Keyword::Mul)
    ("*", Keyword::Mul)
    ("Div", Keyword::Div)
    ("/", Keyword::Div)
    ("Pow", Keyword::Pow)
    ("Log", Keyword::Log)
    ("Mod", Keyword::Mod)
    ("%", Keyword::Mod)
    ("Quot", Keyword::Quot)
    ("//", Keyword::Quot)
    ("BitNot", Keyword::BitNot)
    ("~", Keyword::BitNot)
    ("BitAnd", Keyword::BitAnd)
    ("BitOr", Keyword::BitOr)
    ("|", Keyword::BitOr)
    ("BitXor", Keyword::BitXor)
    ("^", Keyword::BitXor)
    ("Lshift", Keyword::Lshift)
    ("<<", Keyword::Lshift)
    ("Rshift", Keyword::Rshift)
    (">>", Keyword::Rshift)
    ("Eq", Keyword::Eq)
    ("=", Keyword::Eq)
    ("Ne", Keyword::Ne)
    ("≠", Keyword::Ne)
    ("Lt", Keyword::Lt)
    ("<", Keyword::Lt)
    ("Le", Keyword::Le)
    ("≤", Keyword::Le)
    ("Gt", Keyword::Gt)
    (">", Keyword::Gt)
    ("Ge", Keyword::Ge)
    ("≥", Keyword::Ge)
    ("Near", Keyword::Near)
    ("Approx", Keyword::Near)
    ("Union", Keyword::Union)
    ("∪", Keyword::Union)
    ("Intersect", Keyword::Intersect)
    ("∩", Keyword::Intersect)
    ("Diff", Keyword::Diff)
    ("SetEq", Keyword::SetEq)
    ("≡", Keyword::SetEq)
    ("Subset", Keyword::Subset)
    ("⊆", Keyword::Subset)
    ("Superset", Keyword::Superset)
    ("⊇", Keyword::Superset)
    ("PSubset", Keyword::PSubset)
    ("⊂", Keyword::PSubset)
    ("PSuperset", Keyword::PSuperset)
    ("⊃", Keyword::PSuperset)
    ("In", Keyword::In)
    ("∈", Keyword::In)
    ("NotIn", Keyword::NotIn)
    ("∉", Keyword::NotIn)
    ("Ni", Keyword::Ni)
    ("∋", Keyword::Ni)
    ("Contains", Keyword::Ni)
    ("NotNi", Keyword::NotNi)
    ("∌", Keyword::NotNi)
    ("Bool", Keyword::Bool)
    ("?", Keyword::Bool)
    ("Truthy", Keyword::Bool)
    ("Not", Keyword::Not)
    ("Falsy", Keyword::Not)
    ("Nil", Keyword::Not)
    ("And", Keyword::And)
    ("∧", Keyword::And)
    ("Or", Keyword::Or)
    ("∨", Keyword::Or)
    ("Id", Keyword::Id)
    ("Transp", Keyword::Transp)
    ("Cartesian", Keyword::Cartesian)
    ("×", Keyword::Cartesian)
    ("Reverse", Keyword::Reverse)
    ("Uniques", Keyword::Uniques)
    ("Items", Keyword::Items)
    ("Keys", Keyword::Keys)
    ("Values", Keyword::Values)
    ("Enumerate", Keyword::Enumerate)
    ("Flatten", Keyword::Flatten)
    ("ToList", Keyword::ToList)
    ("Arange", Keyword::Arange)
    ("Parse", Keyword::Parse)
    ("Str", Keyword::Str)
    ("Serialize", Keyword::Str)
    ("Re", Keyword::Re)
    ("Regex", Keyword::Re)
    ("Fmt", Keyword::Fmt)
    ("Format", Keyword::Fmt)
    ("Card", Keyword::Card)
    ("Size", Keyword::Size)
    ("Sum", Keyword::Sum)
    ("Σ", Keyword::Sum)
    ("Prod", Keyword::Prod)
    ("Π", Keyword::Prod)
    ("Avg", Keyword::Avg)
    ("Slide", Keyword::Slide)
    ("Stride", Keyword::Stride)
    ("Chunks", Keyword::Chunks)
    ("Repeat", Keyword::Repeat)
    ("Cat", Keyword::Cat)
    ("Concat", Keyword::Cat)
    ("Push", Keyword::Push)
    ("At", Keyword::At)
    ("Del", Keyword::Del)
    ("Delete", Keyword::Del)
    ("Lookup", Keyword::Lookup)
    ("Cast", Keyword::Cast)
    ("Decorate", Keyword::Cast)
    ("Uncast", Keyword::Uncast)
    ("Undecorate", Keyword::Uncast)
    ("Fold", Keyword::Fold)
    ("Reduce", Keyword::Fold)
    ("Map", Keyword::Map)
    ("Filter", Keyword::Filter)
    ("Count", Keyword::Count)
    ("Each", Keyword::Each)
    ("Sort", Keyword::Sort)
    ("Find", Keyword::Find)
    ("FindPtr", Keyword::FindPtr)
    ("FindIdx", Keyword::FindIdx)
    ("Min", Keyword::Min)
    ("Max", Keyword::Max)
    ("Argmin", Keyword::Argmin)
    ("Argmax", Keyword::Argmax)
    ("Recur", Keyword::Recur)
    ("Unfold", Keyword::Unfold)
    ("Op", Keyword::Op)
    ("Overload", Keyword::Op)
    ("Bind", Keyword::Bind)
    ("Link", Keyword::Link)
    ("Capture", Keyword::Capture)
    ("Refer", Keyword::Refer)
    ("Let", Keyword::Let)
    ("Any", Keyword::Any)
    ("All", Keyword::All)
    ("Saturate", Keyword::Saturate)
    ("Pipe", Keyword::Pipe)
    ("Tuple", Keyword::Tuple)
    ("Fork", Keyword::Fork)
    ("Flip", Keyword::Flip)
    ("Dbg", Keyword::Dbg)
    ("Debug", Keyword::Dbg)
    ("Eval", Keyword::Eval)
    ("Try", Keyword::Try)
    ("Kwrd", Keyword::Kwrd)
    ("Prms", Keyword::Prms)
    ("Parameters", Keyword::Prms)
    ("Q", Keyword::Q)
    ("C", Keyword::Q)
    ("Const", Keyword::Q)
    ("D", Keyword::D)
    ("Default", Keyword::D)
    ("Err", Keyword::Err)
    ("Error", Keyword::Err)
    ("Trace", Keyword::Trace)
    ("PreProc", Keyword::PreProc)
    ;
}


KeywordGrammar::KeywordGrammar()
    : KeywordGrammar::base_type(start)
{
    using boost::spirit::qi::eps;
    using boost::spirit::qi::_val;
    using boost::spirit::qi::_1;

    start = eps [_val = Keyword::Undefined] >>
        (
            +keyword_symbol [_val = _1]
        )
    ;
}


boost::json::string_view keyword_to_str(Keyword const& kw)
{
    switch(kw)
    {

    case Keyword::Literal: { return "Literal"; break; }
    case Keyword::Void: { return "Void"; break; }
    case Keyword::Noop: { return "Noop"; break; }
    case Keyword::Null: { return "Null"; break; }
    case Keyword::True: { return "True"; break; }
    case Keyword::False: { return "False"; break; }
    case Keyword::Pi: { return "Pi"; break; }
    case Keyword::E: { return "E"; break; }
    case Keyword::Inf: { return "Inf"; break; }
    case Keyword::Eps: { return "Eps"; break; }
    case Keyword::NaN: { return "NaN"; break; }
    case Keyword::Thread: { return "Thread"; break; }
    case Keyword::Sin: { return "Sin"; break; }
    case Keyword::Cos: { return "Cos"; break; }
    case Keyword::Tan: { return "Tan"; break; }
    case Keyword::Asin: { return "Asin"; break; }
    case Keyword::Acos: { return "Acos"; break; }
    case Keyword::Atan: { return "Atan"; break; }
    case Keyword::Sinh: { return "Sinh"; break; }
    case Keyword::Cosh: { return "Cosh"; break; }
    case Keyword::Tanh: { return "Tanh"; break; }
    case Keyword::Asinh: { return "Asinh"; break; }
    case Keyword::Acosh: { return "Acosh"; break; }
    case Keyword::Atanh: { return "Atanh"; break; }
    case Keyword::Exp: { return "Exp"; break; }
    case Keyword::Erf: { return "Erf"; break; }
    case Keyword::Erfc: { return "Erfc"; break; }
    case Keyword::Gamma: { return "Gamma"; break; }
    case Keyword::Abs: { return "Abs"; break; }
    case Keyword::Ceil: { return "Ceil"; break; }
    case Keyword::Floor: { return "Floor"; break; }
    case Keyword::Round: { return "Round"; break; }
    case Keyword::Sqrt: { return "Sqrt"; break; }
    case Keyword::Sign: { return "Sign"; break; }
    case Keyword::Neg: { return "Neg"; break; }
    case Keyword::Add: { return "Add"; break; }
    case Keyword::Sub: { return "Sub"; break; }
    case Keyword::Mul: { return "Mul"; break; }
    case Keyword::Div: { return "Div"; break; }
    case Keyword::Pow: { return "Pow"; break; }
    case Keyword::Log: { return "Log"; break; }
    case Keyword::Mod: { return "Mod"; break; }
    case Keyword::Quot: { return "Quot"; break; }
    case Keyword::BitNot: { return "BitNot"; break; }
    case Keyword::BitAnd: { return "BitAnd"; break; }
    case Keyword::BitOr: { return "BitOr"; break; }
    case Keyword::BitXor: { return "BitXor"; break; }
    case Keyword::Lshift: { return "Lshift"; break; }
    case Keyword::Rshift: { return "Rshift"; break; }
    case Keyword::Eq: { return "Eq"; break; }
    case Keyword::Ne: { return "Ne"; break; }
    case Keyword::Lt: { return "Lt"; break; }
    case Keyword::Le: { return "Le"; break; }
    case Keyword::Gt: { return "Gt"; break; }
    case Keyword::Ge: { return "Ge"; break; }
    case Keyword::Near: { return "Near"; break; }
    case Keyword::Union: { return "Union"; break; }
    case Keyword::Intersect: { return "Intersect"; break; }
    case Keyword::Diff: { return "Diff"; break; }
    case Keyword::SetEq: { return "SetEq"; break; }
    case Keyword::Subset: { return "Subset"; break; }
    case Keyword::Superset: { return "Superset"; break; }
    case Keyword::PSubset: { return "PSubset"; break; }
    case Keyword::PSuperset: { return "PSuperset"; break; }
    case Keyword::In: { return "In"; break; }
    case Keyword::NotIn: { return "NotIn"; break; }
    case Keyword::Ni: { return "Ni"; break; }
    case Keyword::NotNi: { return "NotNi"; break; }
    case Keyword::Bool: { return "Bool"; break; }
    case Keyword::Not: { return "Not"; break; }
    case Keyword::And: { return "And"; break; }
    case Keyword::Or: { return "Or"; break; }
    case Keyword::Id: { return "Id"; break; }
    case Keyword::Transp: { return "Transp"; break; }
    case Keyword::Cartesian: { return "Cartesian"; break; }
    case Keyword::Reverse: { return "Reverse"; break; }
    case Keyword::Uniques: { return "Uniques"; break; }
    case Keyword::Items: { return "Items"; break; }
    case Keyword::Keys: { return "Keys"; break; }
    case Keyword::Values: { return "Values"; break; }
    case Keyword::Enumerate: { return "Enumerate"; break; }
    case Keyword::Flatten: { return "Flatten"; break; }
    case Keyword::ToList: { return "ToList"; break; }
    case Keyword::Arange: { return "Arange"; break; }
    case Keyword::Parse: { return "Parse"; break; }
    case Keyword::Str: { return "Str"; break; }
    case Keyword::Re: { return "Re"; break; }
    case Keyword::Fmt: { return "Fmt"; break; }
    case Keyword::Card: { return "Card"; break; }
    case Keyword::Size: { return "Size"; break; }
    case Keyword::Sum: { return "Sum"; break; }
    case Keyword::Prod: { return "Prod"; break; }
    case Keyword::Avg: { return "Avg"; break; }
    case Keyword::Slide: { return "Slide"; break; }
    case Keyword::Stride: { return "Stride"; break; }
    case Keyword::Chunks: { return "Chunks"; break; }
    case Keyword::Repeat: { return "Repeat"; break; }
    case Keyword::Cat: { return "Cat"; break; }
    case Keyword::Push: { return "Push"; break; }
    case Keyword::At: { return "At"; break; }
    case Keyword::Del: { return "Del"; break; }
    case Keyword::Lookup: { return "Lookup"; break; }
    case Keyword::Cast: { return "Cast"; break; }
    case Keyword::Uncast: { return "Uncast"; break; }
    case Keyword::Fold: { return "Fold"; break; }
    case Keyword::Map: { return "Map"; break; }
    case Keyword::Filter: { return "Filter"; break; }
    case Keyword::Count: { return "Count"; break; }
    case Keyword::Each: { return "Each"; break; }
    case Keyword::Sort: { return "Sort"; break; }
    case Keyword::Find: { return "Find"; break; }
    case Keyword::FindPtr: { return "FindPtr"; break; }
    case Keyword::FindIdx: { return "FindIdx"; break; }
    case Keyword::Min: { return "Min"; break; }
    case Keyword::Max: { return "Max"; break; }
    case Keyword::Argmin: { return "Argmin"; break; }
    case Keyword::Argmax: { return "Argmax"; break; }
    case Keyword::Recur: { return "Recur"; break; }
    case Keyword::Unfold: { return "Unfold"; break; }
    case Keyword::Op: { return "Op"; break; }
    case Keyword::Bind: { return "Bind"; break; }
    case Keyword::Link: { return "Link"; break; }
    case Keyword::Capture: { return "Capture"; break; }
    case Keyword::Refer: { return "Refer"; break; }
    case Keyword::Let: { return "Let"; break; }
    case Keyword::Any: { return "Any"; break; }
    case Keyword::All: { return "All"; break; }
    case Keyword::Saturate: { return "Saturate"; break; }
    case Keyword::Pipe: { return "Pipe"; break; }
    case Keyword::Tuple: { return "Tuple"; break; }
    case Keyword::Fork: { return "Fork"; break; }
    case Keyword::Flip: { return "Flip"; break; }
    case Keyword::Dbg: { return "Dbg"; break; }
    case Keyword::Eval: { return "Eval"; break; }
    case Keyword::Try: { return "Try"; break; }
    case Keyword::Kwrd: { return "Kwrd"; break; }
    case Keyword::Prms: { return "Prms"; break; }
    case Keyword::Q: { return "Q"; break; }
    case Keyword::D: { return "D"; break; }
    case Keyword::Err: { return "Err"; break; }
    case Keyword::Trace: { return "Trace"; break; }
    case Keyword::PreProc: { return "PreProc"; break; }
    default:
        return "Undefined";
    }
}

void tag_invoke(boost::json::value_from_tag const&, boost::json::value& v, Keyword const& kw)
{
    v = keyword_to_str(kw);
}

Keyword tag_invoke(boost::json::value_to_tag<Keyword> const&, boost::json::value const& v)
{
    if (not v.is_string())
    {
        return Keyword::Undefined;
    }

    static KeywordGrammar const keyword_parser {};

    auto const& str = v.as_string();
    auto iter = str.cbegin();
    auto end = str.cend();
    Keyword keyword_out {Keyword::Undefined};
    static_cast<void>(boost::spirit::qi::parse(iter, end, keyword_parser, keyword_out));
    return keyword_out;
}

} // namespace lang
} // namespace zmbt
