/**
 * \file
 * \copyright (c) Copyright 2024-2025 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * app: codegen.expr
 * template: codegen/expr/templates/expression_api.hpp
 *
 * How to update:
 * 1. Update the template
 * 2. Run `python -m codegen` in the project root
 * 3. Commit changes
 */

#ifndef ZMBT_MODEL_EXPRESSION_API_HPP_
#define ZMBT_MODEL_EXPRESSION_API_HPP_

#include "expression_api_signatures.hpp"

namespace zmbt {
namespace api {


/// \brief No operation
extern expr::SignatureConst<::zmbt::expr::Keyword::Noop> const Noop;
/// \brief Alias for Noop
extern expr::SignatureConst<::zmbt::expr::Keyword::Noop> const _;

/// \brief Null value
extern expr::SignatureConst<::zmbt::expr::Keyword::Null> const Null;

/// \brief Logical true
extern expr::SignatureConst<::zmbt::expr::Keyword::True> const True;

/// \brief Logical false
extern expr::SignatureConst<::zmbt::expr::Keyword::False> const False;

/// \brief Pi constant
extern expr::SignatureConst<::zmbt::expr::Keyword::Pi> const Pi;

/// \brief Euler's number
extern expr::SignatureConst<::zmbt::expr::Keyword::E> const E;

/// \brief Infinity
extern expr::SignatureConst<::zmbt::expr::Keyword::Inf> const Inf;

/// \brief Machine epsilon
extern expr::SignatureConst<::zmbt::expr::Keyword::Eps> const Eps;

/// \brief Not a number
extern expr::SignatureConst<::zmbt::expr::Keyword::NaN> const NaN;

/// \brief Predicate on boolean transform (aka truthy)
extern expr::SignatureUnary<::zmbt::expr::Keyword::Bool> const Bool;

/// \brief Predicate on boolean transform (aka falsy)
extern expr::SignatureUnary<::zmbt::expr::Keyword::Nil> const Nil;

/// \brief Logical complement
extern expr::SignatureUnary<::zmbt::expr::Keyword::Not> const Not;

/// \brief Negate
extern expr::SignatureUnary<::zmbt::expr::Keyword::Neg> const Neg;

/// \brief Bitwise not
extern expr::SignatureUnary<::zmbt::expr::Keyword::BitNot> const BitNot;

/// \brief Square root
extern expr::SignatureUnary<::zmbt::expr::Keyword::Sqrt> const Sqrt;

/// \brief Sinus
extern expr::SignatureUnary<::zmbt::expr::Keyword::Sin> const Sin;

/// \brief Cosinus
extern expr::SignatureUnary<::zmbt::expr::Keyword::Cos> const Cos;

/// \brief Tangens
extern expr::SignatureUnary<::zmbt::expr::Keyword::Tan> const Tan;

/// \brief Arcsin
extern expr::SignatureUnary<::zmbt::expr::Keyword::Asin> const Asin;

/// \brief Arccos
extern expr::SignatureUnary<::zmbt::expr::Keyword::Acos> const Acos;

/// \brief Arctan
extern expr::SignatureUnary<::zmbt::expr::Keyword::Atan> const Atan;

/// \brief Hyperbolic sin
extern expr::SignatureUnary<::zmbt::expr::Keyword::Sinh> const Sinh;

/// \brief Hyperbolic cos
extern expr::SignatureUnary<::zmbt::expr::Keyword::Cosh> const Cosh;

/// \brief Hyperbolic tan
extern expr::SignatureUnary<::zmbt::expr::Keyword::Tanh> const Tanh;

/// \brief Hyperbolic arcsin
extern expr::SignatureUnary<::zmbt::expr::Keyword::Asinh> const Asinh;

/// \brief Hyperbolic arccos
extern expr::SignatureUnary<::zmbt::expr::Keyword::Acosh> const Acosh;

/// \brief Hyperbolic arctan
extern expr::SignatureUnary<::zmbt::expr::Keyword::Atanh> const Atanh;

/// \brief Exponential (e^x)
extern expr::SignatureUnary<::zmbt::expr::Keyword::Exp> const Exp;

/// \brief Error function
extern expr::SignatureUnary<::zmbt::expr::Keyword::Erf> const Erf;

/// \brief Error function complement
extern expr::SignatureUnary<::zmbt::expr::Keyword::Erfc> const Erfc;

/// \brief Gamma function
extern expr::SignatureUnary<::zmbt::expr::Keyword::Gamma> const Gamma;

/// \brief Absolute value
extern expr::SignatureUnary<::zmbt::expr::Keyword::Abs> const Abs;

/// \brief Ceil
extern expr::SignatureUnary<::zmbt::expr::Keyword::Ceil> const Ceil;

/// \brief Floor
extern expr::SignatureUnary<::zmbt::expr::Keyword::Floor> const Floor;

/// \brief Sign
extern expr::SignatureUnary<::zmbt::expr::Keyword::Sign> const Sign;

/// \brief Summation reduction, real param - initial value
/// \details
/// Equivalent to Reduce(Add, ...)
extern expr::SignatureUnaryParam<::zmbt::expr::Keyword::Sum> const Sum;

/// \brief Multiplication reduction, real param - initial value
/// \details
/// Equivalent to Reduce(Mul, ...)
extern expr::SignatureUnaryParam<::zmbt::expr::Keyword::Prod> const Prod;

/// \brief Round to nearest integer with optional precision
extern expr::SignatureUnaryParam<::zmbt::expr::Keyword::Round> const Round;

/// \brief Addition
extern expr::SignatureBinary<::zmbt::expr::Keyword::Add> const Add;

/// \brief Subtraction
extern expr::SignatureBinary<::zmbt::expr::Keyword::Sub> const Sub;

/// \brief Reverse subtraction
/// \details
/// Subtraction with reverse arguments, i. e.
///   1. [ ] |-> [y, x] |-> x - y
///   2. [x] |-> [y]    |-> x - y
extern expr::SignatureBinary<::zmbt::expr::Keyword::SubFrom> const SubFrom;

/// \brief Multiplication
extern expr::SignatureBinary<::zmbt::expr::Keyword::Mul> const Mul;

/// \brief Division
/// \details
/// 1. [ ] |-> [x, y] |-> x / y
/// 2. [y] |-> [x]    |-> x / y
extern expr::SignatureBinary<::zmbt::expr::Keyword::Div> const Div;

/// \brief Reverse division
/// \details
/// Division with reverse arguments, i. e.
///   1. [ ] |-> [y, x] |-> x / y
///   2. [x] |-> [y]    |-> x / y
extern expr::SignatureBinary<::zmbt::expr::Keyword::DivFrom> const DivFrom;

/// \brief To power
/// \details
/// X to power p
///   1. [ ] |-> [x, p] |-> x^p
///   2. [p] |-> [x]    |-> x^p
extern expr::SignatureBinary<::zmbt::expr::Keyword::Pow> const Pow;

/// \brief Reverse power
/// \details
/// Pow with reverse arguments, i. e.
///   1. [ ] |-> [p, x] |-> x^p
///   2. [x] |-> [p]    |-> x^p
extern expr::SignatureBinary<::zmbt::expr::Keyword::PowFrom> const PowFrom;

/// \brief Logarithm
/// \details
/// Logarithm with base b:
///   1. [ ] |-> [x, b] |-> log_b(x)
///   2. [b] |-> [x]    |-> log_b(x)
extern expr::SignatureBinary<::zmbt::expr::Keyword::Log> const Log;

/// \brief Reverse logarithm
/// \details
/// Log with reverse arguments, i. e.
///   1. [ ] |-> [b, x] |-> log_b(x)
///   2. [b] |-> [b]    |-> log_b(x)
extern expr::SignatureBinary<::zmbt::expr::Keyword::LogFrom> const LogFrom;

/// \brief Modulo
/// \details
/// Modulo of x:
///   1. [ ] |-> [x, m] |-> x % m
///   2. [m] |-> [x]    |-> x % m
extern expr::SignatureBinary<::zmbt::expr::Keyword::Mod> const Mod;

/// \brief Reverse modulo
/// \details
/// Modulo with reverse arguments, i. e.
///   1. [ ] |-> [b, x] |-> log_b(x)
///   2. [b] |-> [b]    |-> log_b(x)
extern expr::SignatureBinary<::zmbt::expr::Keyword::ModFrom> const ModFrom;

/// \brief Quotient
/// \details
/// Quotient of x:
///   1. [ ] |-> [x, d] |-> x // d
///   2. [d] |-> [x]    |-> x // d
extern expr::SignatureBinary<::zmbt::expr::Keyword::Quot> const Quot;

/// \brief Reverse quotient
/// \details
/// Quotient with reverse arguments, i. e.
///   1. [ ] |-> [d, x] |-> x // d
///   2. [x] |-> [d]    |-> x // d
extern expr::SignatureBinary<::zmbt::expr::Keyword::QuotFrom> const QuotFrom;

/// \brief Bitwise and
extern expr::SignatureBinary<::zmbt::expr::Keyword::BitAnd> const BitAnd;

/// \brief Bitwise or
extern expr::SignatureBinary<::zmbt::expr::Keyword::BitOr> const BitOr;

/// \brief Bitwise xor
extern expr::SignatureBinary<::zmbt::expr::Keyword::BitXor> const BitXor;

/// \brief Bitwise left shift
/// \details
/// 1. [ ] |-> [x, s] |-> x << s
/// 2. [s] |-> [x]    |-> x << s
extern expr::SignatureBinary<::zmbt::expr::Keyword::BitLshift> const BitLshift;

/// \brief Reverse bitwise left shift
/// \details
/// Bitwise left shift with reverse arguments, i. e.
///   1. [ ] |-> [s, x] |-> x << s
///   2. [x] |-> [s]    |-> x << s
extern expr::SignatureBinary<::zmbt::expr::Keyword::BitLshiftFrom> const BitLshiftFrom;

/// \brief Bitwise right shift
/// \details
/// 1. [ ] |-> [x, s] |-> x >> s
/// 2. [s] |-> [x]    |-> x >> s
extern expr::SignatureBinary<::zmbt::expr::Keyword::BitRshift> const BitRshift;

/// \brief Reverse bitwise right shift
/// \details
/// Bitwise right shift with reverse arguments, i. e.
///   1. [ ] |-> [s, x] |-> x >> s
///   2. [x] |-> [s]    |-> x >> s
extern expr::SignatureBinary<::zmbt::expr::Keyword::BitRshiftFrom> const BitRshiftFrom;

/// \brief Is equal
extern expr::SignatureBinary<::zmbt::expr::Keyword::Eq> const Eq;

/// \brief Not equal
extern expr::SignatureBinary<::zmbt::expr::Keyword::Ne> const Ne;

/// \brief Lesser than
extern expr::SignatureBinary<::zmbt::expr::Keyword::Lt> const Lt;

/// \brief Lesser or equal
extern expr::SignatureBinary<::zmbt::expr::Keyword::Le> const Le;

/// \brief Greater than
extern expr::SignatureBinary<::zmbt::expr::Keyword::Gt> const Gt;

/// \brief Greater or equal
extern expr::SignatureBinary<::zmbt::expr::Keyword::Ge> const Ge;

/// \brief Floating point approximately equal
/// \details
/// Based on numpy.isclose: abs(x - ref) <= (atol + rtol * abs(ref))
extern expr::SignatureApprox const Approx;
/// \brief Alias for Approx
extern expr::SignatureApprox const Near;

/// \brief Logical and
/// \details
/// Generic behavior:
///   if first operand is truthy, returns second operand, otherwise first
extern expr::SignatureBinary<::zmbt::expr::Keyword::And> const And;

/// \brief Logical or
/// \details
/// Generic behavior:
///   if first operand is truthy, returns first operand, second otherwise
extern expr::SignatureBinary<::zmbt::expr::Keyword::Or> const Or;

/// \brief Equal as set
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::SetEq> const SetEq;

/// \brief Is subset
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::Subset> const Subset;

/// \brief Is superset
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::Superset> const Superset;

/// \brief Is proper subset
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::ProperSubset> const ProperSubset;

/// \brief Is proper superset
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::ProperSuperset> const ProperSuperset;

/// \brief Element is in
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::In> const In;

/// \brief Element is not in
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::NotIn> const NotIn;

/// \brief Contains element
extern expr::SignatureBinary<::zmbt::expr::Keyword::Ni> const Ni;
/// \brief Alias for Ni
extern expr::SignatureBinary<::zmbt::expr::Keyword::Ni> const Contains;

/// \brief Not contains element
extern expr::SignatureBinary<::zmbt::expr::Keyword::NotNi> const NotNi;

/// \brief Set union
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::Union> const Union;

/// \brief Set intersection
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::Intersect> const Intersect;

/// \brief Set difference
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::Diff> const Diff;

/// \brief Reverse set difference
extern expr::SignatureBinarySetRhs<::zmbt::expr::Keyword::DiffFrom> const DiffFrom;

/// \brief Concatenate sequences
extern expr::SignatureVariadic<::zmbt::expr::Keyword::Concat> const Concat;

/// \brief Cartesian product
extern expr::SignatureVariadic<::zmbt::expr::Keyword::Cartesian> const Cartesian;

/// \brief Envelop zero or more parameters in list
extern expr::SignatureVariadic<::zmbt::expr::Keyword::List> const List;

/// \brief Transpose multidimensional list, turning rows into columns
/// \details
/// May be used to zip sequences of equal length.
/// Example:
///   [[1, 2, 3], [4, 5, 6]] -> [[1, 4], [2, 5], [3, 6]]
extern expr::SignatureUnary<::zmbt::expr::Keyword::Transp> const Transp;

/// \brief Filter unique elements
extern expr::SignatureUnary<::zmbt::expr::Keyword::Uniques> const Uniques;

/// \brief Identity function
extern expr::SignatureUnary<::zmbt::expr::Keyword::Id> const Id;

/// \brief Evaluate enveloped fn and return result or default value if result is null
extern expr::SignatureBinary<::zmbt::expr::Keyword::Default> const Default;

/// \brief Set cardinality (uniques count)
extern expr::SignatureUnary<::zmbt::expr::Keyword::Card> const Card;

/// \brief Sequence size
extern expr::SignatureUnary<::zmbt::expr::Keyword::Size> const Size;

/// \brief Sliding-window iteration
/// \details
/// Sliding window iteration by specified window width.
extern expr::SignatureBinary<::zmbt::expr::Keyword::Slide> const Slide;

/// \brief Striding iteration
/// \details
/// Striding iteration by specified step width.
extern expr::SignatureBinary<::zmbt::expr::Keyword::Stride> const Stride;

/// \brief Repeat value in list
extern expr::SignatureBinary<::zmbt::expr::Keyword::Repeat> const Repeat;

/// \brief Regular expression match
/// \details
/// If input is not a string, match it's serialized form.
extern expr::SignatureBinary<::zmbt::expr::Keyword::Re> const Re;
/// \brief Alias for Re
extern expr::SignatureBinary<::zmbt::expr::Keyword::Re> const Regex;

/// \brief Transform json value with given query
/// \details
/// Query evaluation rules:
/// ```
///   1. q: int  |-> x: list  |-> x at index q (negative -> reverse)
///   2. q: str  |-> x: any   |-> x at JSON Pointer q
///   3. q: list |-> x: any   |-> [x at q1, x at q2, ...]
///   4. {"key": q1, "$q2": q3, ...} |-> x: any |->
///       { "key1": x at q1, "$(x at q2)": x at q3, ...}
/// ```
extern expr::SignatureBinary<::zmbt::expr::Keyword::At> const At;

/// \brief Apply param expr to every element of sequence
extern expr::SignatureHiOrd<::zmbt::expr::Keyword::Map> const Map;

/// \brief Filter sequence by predicate param
extern expr::SignatureHiOrd<::zmbt::expr::Keyword::Filter> const Filter;

/// \brief Count matches by predicate param
extern expr::SignatureHiOrd<::zmbt::expr::Keyword::Count> const Count;

/// \brief Sort list by comparison parameter expr
extern expr::SignatureHiOrd<::zmbt::expr::Keyword::Sort> const Sort;

/// \brief Min value
extern expr::SignatureHiOrd<::zmbt::expr::Keyword::Min> const Min;

/// \brief Max value
extern expr::SignatureHiOrd<::zmbt::expr::Keyword::Max> const Max;

/// \brief Min value index
extern expr::SignatureHiOrd<::zmbt::expr::Keyword::Argmin> const Argmin;

/// \brief Max value index
extern expr::SignatureHiOrd<::zmbt::expr::Keyword::Argmax> const Argmax;

/// \brief Apply recursion to parameter expr
extern expr::SignatureHiOrdParam<::zmbt::expr::Keyword::Recur> const Recur;

/// \brief Apply expr to literal param
extern expr::SignatureHiOrdParam<::zmbt::expr::Keyword::Apply> const Apply;

/// \brief Bind parameters
extern expr::SignatureHiOrdParam<::zmbt::expr::Keyword::Bind> const Bind;

/// \brief Reduce sequence with binary operator and optional initial value
/// \details
/// If initial value is not provided, first element is used.
/// If sequence is empty and initial value is not provided, error is raised.
extern expr::SignatureHiOrdParamOpt<::zmbt::expr::Keyword::Reduce> const Reduce;

/// \brief Match any predicate
extern expr::SignatureVariadic<::zmbt::expr::Keyword::Any> const Any;

/// \brief Match all predicates
extern expr::SignatureVariadic<::zmbt::expr::Keyword::All> const All;

/// \brief Saturate matches in order
extern expr::SignatureVariadic<::zmbt::expr::Keyword::Saturate> const Saturate;

/// \brief Compose functions
extern expr::SignatureVariadic<::zmbt::expr::Keyword::Compose> const Compose;

} // namespace api
} // namespace zmbt

#endif // ZMBT_MAPPING_EXPRESSION_HPP_
