/**
 * \file
 * \copyright (c) Copyright 2024 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * How to update:
 * 1. Update the template at `templates/expr/expression_api.hpp`
 * 2. Update the keyword data at `templates/expr/data.yaml`
 * 3. Regenerate file with `bazel run //templates/expr:expression_api_hpp > zmbt-framework/backends/cxx/include/zmbt/model/expression_api.hpp`
 * 4. Commit changes
 */


#ifndef ZMBT_MODEL_EXPRESSION_API_HPP_
#define ZMBT_MODEL_EXPRESSION_API_HPP_

#include "expression_api_templates.hpp"


namespace zmbt {



namespace expr
{


/// \brief Identity function
static ExprNoParams<Keyword::Id> const Id{};

/// \brief No operation
static ExprNoParams<Keyword::Noop> const Noop{};

/// \brief Logical true
static ExprNoParams<Keyword::True> const True{};

/// \brief Logical false
static ExprNoParams<Keyword::False> const False{};

/// \brief Null value
static ExprNoParams<Keyword::Null> const Null{};

/// \brief Pi constant
static ExprNoParams<Keyword::Pi> const Pi{};

/// \brief Euler's number
static ExprNoParams<Keyword::E> const E{};

/// \brief Infinity
static ExprNoParams<Keyword::Inf> const Inf{};

/// \brief Machine epsilon
static ExprNoParams<Keyword::Eps> const Eps{};

/// \brief Not a number
static ExprNoParams<Keyword::NaN> const NaN{};

/// \brief Predicate on boolean transform (aka Truthy)
static ExprNoParams<Keyword::Bool> const Bool{};

/// \brief Predicate on boolean transform (aka Falsy)
static ExprNoParams<Keyword::Nil> const Nil{};

/// \brief Logical complement
static ExprOneParam<Keyword::Not> const Not{};

/// \brief Logical conjunction
static ExprVariadicParam<Keyword::And> const And{};

/// \brief Logical disjunction
static ExprVariadicParam<Keyword::Or> const Or{};

/// \brief Logical exclusive or
static ExprTwoParam<Keyword::Xor> const Xor{};

/// \brief Is equal
static ExprOneParam<Keyword::Eq> const Eq{};

/// \brief Not equal
static ExprOneParam<Keyword::Ne> const Ne{};

/// \brief Lesser than
static ExprOneParam<Keyword::Lt> const Lt{};

/// \brief Lesser or equal
static ExprOneParam<Keyword::Le> const Le{};

/// \brief Greater than
static ExprOneParam<Keyword::Gt> const Gt{};

/// \brief Greater or equal
static ExprOneParam<Keyword::Ge> const Ge{};

/// \brief Contains element
static ExprOneParam<Keyword::Ni> const Ni{};

/// \brief Not contains element
static ExprOneParam<Keyword::NotNi> const NotNi{};

/// \brief Equal as set
static ExprSetParam<Keyword::SetEq> const SetEq{};

/// \brief Is subset
static ExprSetParam<Keyword::Subset> const Subset{};

/// \brief is superset
static ExprSetParam<Keyword::Superset> const Superset{};

/// \brief Is proper subset
static ExprSetParam<Keyword::ProperSubset> const ProperSubset{};

/// \brief Is proper superset
static ExprSetParam<Keyword::ProperSuperset> const ProperSuperset{};

/// \brief Element is in
static ExprSetParam<Keyword::In> const In{};

/// \brief Element is not in
static ExprSetParam<Keyword::NotIn> const NotIn{};

/// \brief Negate
static ExprNoParams<Keyword::Neg> const Neg{};

/// \brief Absolute value
static ExprNoParams<Keyword::Abs> const Abs{};

/// \brief Sign
static ExprNoParams<Keyword::Sign> const Sign{};

/// \brief Ceil
static ExprNoParams<Keyword::Ceil> const Ceil{};

/// \brief Floor
static ExprNoParams<Keyword::Floor> const Floor{};

/// \brief Round
static ExprNoParams<Keyword::Round> const Round{};

/// \brief Add
static ExprOneParam<Keyword::Add> const Add{};

/// \brief Substract
static ExprOneParam<Keyword::Sub> const Sub{};

/// \brief Multiply
static ExprOneParam<Keyword::Mul> const Mul{};

/// \brief Divide
static ExprOneParam<Keyword::Div> const Div{};

/// \brief To power
static ExprOneParam<Keyword::Pow> const Pow{};

/// \brief Logarithm
static ExprOneParam<Keyword::Log> const Log{};

/// \brief Modulo
static ExprOneParam<Keyword::Mod> const Mod{};

/// \brief Quotient
static ExprOneParam<Keyword::Quot> const Quot{};

/// \brief Square root
static ExprOneParam<Keyword::Sqrt> const Sqrt{};

/// \brief Sinus
static ExprOneParam<Keyword::Sin> const Sin{};

/// \brief Cosinus
static ExprOneParam<Keyword::Cos> const Cos{};

/// \brief Tangens
static ExprOneParam<Keyword::Tan> const Tan{};

/// \brief Arcsin
static ExprOneParam<Keyword::Asin> const Asin{};

/// \brief Arccos
static ExprOneParam<Keyword::Acos> const Acos{};

/// \brief Arctan
static ExprOneParam<Keyword::Atan> const Atan{};

/// \brief Hyperbolic sin
static ExprOneParam<Keyword::Sinh> const Sinh{};

/// \brief Hyperbolic cos
static ExprOneParam<Keyword::Cosh> const Cosh{};

/// \brief Hyperbolic tan
static ExprOneParam<Keyword::Tanh> const Tanh{};

/// \brief Hyperbolic  arcsin
static ExprOneParam<Keyword::Asinh> const Asinh{};

/// \brief Hyperbolic arccos
static ExprOneParam<Keyword::Acosh> const Acosh{};

/// \brief Hyperbolic arctan
static ExprOneParam<Keyword::Atanh> const Atanh{};

/// \brief Exponential (e^x)
static ExprOneParam<Keyword::Exp> const Exp{};

/// \brief Error function
static ExprOneParam<Keyword::Erf> const Erf{};

/// \brief Error function complement
static ExprOneParam<Keyword::Erfc> const Erfc{};

/// \brief Gamma function
static ExprOneParam<Keyword::Gamma> const Gamma{};

/// \brief Bitwise not
static ExprNoParams<Keyword::BitNot> const BitNot{};

/// \brief Bitwise and
static ExprOneParam<Keyword::BitAnd> const BitAnd{};

/// \brief Bitwise or
static ExprOneParam<Keyword::BitOr> const BitOr{};

/// \brief Bitwise xor
static ExprOneParam<Keyword::BitXor> const BitXor{};

/// \brief Bitwise left shift
static ExprOneParam<Keyword::BitLshift> const BitLshift{};

/// \brief Bitwise right shift
static ExprOneParam<Keyword::BitRshift> const BitRshift{};

/// \brief Apply param fn to every element of sequence
static ExprOneParam<Keyword::Map> const Map{};

/// \brief Filter sequence by predicate param
static ExprOneParam<Keyword::Filter> const Filter{};

/// \brief Compose functions
static ExprVariadicParam<Keyword::Compose> const Compose{};

/// \brief apply recursion to parameter fn
static ExprTwoParam<Keyword::Recur> const Recur{};

/// \brief Apply fn to literal param
static ExprTwoParam<Keyword::Apply> const Apply{};

/// \brief Bind parameters
static ExprTwoParam<Keyword::Partial> const Partial{};

/// \brief Reduce
static ExprOneOrTwoParam<Keyword::Reduce> const Reduce{};

/// \brief Concatenate sequences
static ExprNoParams<Keyword::Concat> const Concat{};

/// \brief Set union
static ExprNoParams<Keyword::Union> const Union{};

/// \brief Set intersection
static ExprNoParams<Keyword::Intersect> const Intersect{};

/// \brief Set difference
static ExprNoParams<Keyword::Diff> const Diff{};

/// \brief Cartesian product
static ExprNoParams<Keyword::Cartesian> const Cartesian{};

/// \brief Transpose 2-d array, turning rows into columns
static ExprNoParams<Keyword::Transp> const Transp{};

/// \brief Sequence to set
static ExprNoParams<Keyword::Set> const Set{};

/// \brief Envelop value in array (equivalent to Repeat(1))
static ExprNoParams<Keyword::List> const List{};

/// \brief Sliding-window iteration
static ExprOneParam<Keyword::Slide> const Slide{};

/// \brief Striding iteration
static ExprOneParam<Keyword::Stride> const Stride{};

/// \brief Slice sequence by "start:stop:step"
static ExprOneParam<Keyword::Slice> const Slice{};

/// \brief Sort array by comparison parameter fn
static ExprOneParam<Keyword::Sort> const Sort{};

/// \brief Repeat value in array
static ExprOneParam<Keyword::Repeat> const Repeat{};

/// \brief Transform value with query pseudo-language
/// \details
/// Evaluation rules:
///   1. int    q |-> x |-> array x at index q (negative -> reverse)
///   2. str    q |-> x |-> value x at JSON Pointer q
///   3. array  [q1, q2, ...] |-> x |-> [x at q1, x at q2, ...]
///   4. object {"key": q1, "$q2": q3, ...} |-> x |-> {"key1": x at q1, "$(x at q2)": x at q3, ...}
/// 
/// Optional second parameter - predicate P:
///   At(q, P) <==> Compose(P, At(q))
static ExprOneOrTwoParam<Keyword::At> const At{};

/// \brief Summation reduction, real param - initial value
static ExprOneOrTwoParam<Keyword::Sum> const Sum{};

/// \brief Multiplication reduction, real param - initial value
static ExprOneOrTwoParam<Keyword::Prod> const Prod{};

/// \brief Set cardinality (uniques count)
static ExprOneOrTwoParam<Keyword::Card> const Card{};

/// \brief Sequence size
static ExprOneOrTwoParam<Keyword::Size> const Size{};

/// \brief Count matches
static ExprOneOrTwoParam<Keyword::Count> const Count{};

/// \brief Min value
static ExprOneOrTwoParam<Keyword::Min> const Min{};

/// \brief Max value
static ExprOneOrTwoParam<Keyword::Max> const Max{};

/// \brief Min value index
static ExprOneOrTwoParam<Keyword::Argmin> const Argmin{};

/// \brief Max value index
static ExprOneOrTwoParam<Keyword::Argmax> const Argmax{};

/// \brief Match any predicate
static ExprVariadicParam<Keyword::Any> const Any{};

/// \brief Match all predicates
static ExprVariadicParam<Keyword::All> const All{};

/// \brief Saturate matches in order
static ExprVariadicParam<Keyword::Saturate> const Saturate{};

/// \brief Regular expression match
static ExprOneParam<Keyword::Re> const Re{};




struct Approx_ : public Expression
{
    Approx_() : Expression(Keyword::Approx)
    {}

    Expression operator()(double reference, double rtol, double atol = std::numeric_limits<double>::epsilon()) const
    {
        return Expression(Keyword::Approx, boost::json::array {reference, rtol, atol});
    }
};

/// \brief Floating point approximate equal
/// \details Based on numpy.isclose: abs(a - b) <= (atol + rtol * abs(ref))
static Approx_ const Approx {};


// Aliases

/// Alias for expr::Noop
static decltype(Noop) const _ = Noop;
/// Alias for expr::Ni
static decltype(Ni) const Contains = Ni;
/// Alias for expr::Approx
static decltype(Approx) const Near = Approx;
/// Alias for expr::Re
static decltype(Re) const Regex = Re;

}

} // namespace zmbt

#endif // ZMBT_MAPPING_EXPRESSION_HPP_

