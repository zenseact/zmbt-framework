/**
 * \file
 * \copyright (c) Copyright 2024-2025 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * app: codegen.expr
 * template: codegen/expr/templates/zmbt-framework/backends/cxx/include/zmbt/model/expression_api.hpp
 *
 * How to update:
 * 1. Update the template
 * 2. Run `python -m codegen` in the project root
 * 3. Commit changes
 */

#ifndef ZMBT_MODEL_EXPRESSION_API_HPP_
#define ZMBT_MODEL_EXPRESSION_API_HPP_

#include "expression_api_signatures.hpp"

namespace zmbt {
namespace expr {


/// \brief No operation
/// \anchor expr-noop
/// \details
/// Returns true without input validation.
/// Used in place of matchers for uninteresting signals.\see \ref const-syntactic-forms "Const Syntatic Forms"
extern dsl::SignatureConst<::zmbt::dsl::Keyword::Noop> const Noop;
/// \brief Alias for Noop
extern dsl::SignatureConst<::zmbt::dsl::Keyword::Noop> const _;

/// \brief Null value
/// \anchor expr-null
/// \details
/// \see \ref const-syntactic-forms "Const Syntatic Forms"
extern dsl::SignatureConst<::zmbt::dsl::Keyword::Null> const Null;

/// \brief Logical true
/// \anchor expr-true
/// \details
/// \see \ref const-syntactic-forms "Const Syntatic Forms"
extern dsl::SignatureConst<::zmbt::dsl::Keyword::True> const True;

/// \brief Logical false
/// \anchor expr-false
/// \details
/// \see \ref const-syntactic-forms "Const Syntatic Forms"
extern dsl::SignatureConst<::zmbt::dsl::Keyword::False> const False;

/// \brief Pi constant
/// \anchor expr-pi
/// \details
/// \see \ref const-syntactic-forms "Const Syntatic Forms"
extern dsl::SignatureConst<::zmbt::dsl::Keyword::Pi> const Pi;

/// \brief Euler's number
/// \anchor expr-e
/// \details
/// \see \ref const-syntactic-forms "Const Syntatic Forms"
extern dsl::SignatureConst<::zmbt::dsl::Keyword::E> const E;

/// \brief Infinity
/// \anchor expr-inf
/// \details
/// \see \ref const-syntactic-forms "Const Syntatic Forms"
extern dsl::SignatureConst<::zmbt::dsl::Keyword::Inf> const Inf;

/// \brief Machine epsilon
/// \anchor expr-eps
/// \details
/// \see \ref const-syntactic-forms "Const Syntatic Forms"
extern dsl::SignatureConst<::zmbt::dsl::Keyword::Eps> const Eps;

/// \brief Not a number
/// \anchor expr-nan
/// \details
/// \see \ref const-syntactic-forms "Const Syntatic Forms"
extern dsl::SignatureConst<::zmbt::dsl::Keyword::NaN> const NaN;

/// \brief Sinus
/// \anchor expr-sin
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Sin> const Sin;

/// \brief Cosinus
/// \anchor expr-cos
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Cos> const Cos;

/// \brief Tangens
/// \anchor expr-tan
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Tan> const Tan;

/// \brief Arcsin
/// \anchor expr-asin
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Asin> const Asin;

/// \brief Arccos
/// \anchor expr-acos
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Acos> const Acos;

/// \brief Arctan
/// \anchor expr-atan
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Atan> const Atan;

/// \brief Hyperbolic sin
/// \anchor expr-sinh
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Sinh> const Sinh;

/// \brief Hyperbolic cos
/// \anchor expr-cosh
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Cosh> const Cosh;

/// \brief Hyperbolic tan
/// \anchor expr-tanh
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Tanh> const Tanh;

/// \brief Hyperbolic arcsin
/// \anchor expr-asinh
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Asinh> const Asinh;

/// \brief Hyperbolic arccos
/// \anchor expr-acosh
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Acosh> const Acosh;

/// \brief Hyperbolic arctan
/// \anchor expr-atanh
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Atanh> const Atanh;

/// \brief Exponential (e^x)
/// \anchor expr-exp
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Exp> const Exp;

/// \brief Error function
/// \anchor expr-erf
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Erf> const Erf;

/// \brief Error function complement
/// \anchor expr-erfc
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Erfc> const Erfc;

/// \brief Gamma function
/// \anchor expr-gamma
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Gamma> const Gamma;

/// \brief Absolute value
/// \anchor expr-abs
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Abs> const Abs;

/// \brief Ceil
/// \anchor expr-ceil
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Ceil> const Ceil;

/// \brief Floor
/// \anchor expr-floor
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Floor> const Floor;

/// \brief Round to nearest integer
/// \anchor expr-round
/// \details
/// Hint: To round to ndigits precision after the decimal point,
/// use Mul(ndigits)|Round|Div(ndigits) combo.\see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Round> const Round;

/// \brief Square root
/// \anchor expr-sqrt
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Sqrt> const Sqrt;

/// \brief Sign
/// \anchor expr-sign
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Sign> const Sign;

/// \brief Negate
/// \anchor expr-neg
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Neg> const Neg;

/// \brief Addition
/// \anchor expr-add
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Add> const Add;

/// \brief Subtraction
/// \anchor expr-sub
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Sub> const Sub;

/// \brief Multiplication
/// \anchor expr-mul
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Mul> const Mul;

/// \brief Division
/// \anchor expr-div
/// \details
/// 1. [ ] |-> [x, y] |-> x / y
/// 2. [y] |-> [x]    |-> x / y\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Div> const Div;

/// \brief To power
/// \anchor expr-pow
/// \details
/// X to power p
///   1. [ ] |-> [x, p] |-> x^p
///   2. [p] |-> [x]    |-> x^p\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Pow> const Pow;

/// \brief Logarithm
/// \anchor expr-log
/// \details
/// Logarithm with base b:
///   1. [ ] |-> [x, b] |-> log_b(x)
///   2. [b] |-> [x]    |-> log_b(x)\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Log> const Log;

/// \brief Modulo
/// \anchor expr-mod
/// \details
/// Modulo of x:
///   1. [ ] |-> [x, m] |-> x % m
///   2. [m] |-> [x]    |-> x % m\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Mod> const Mod;

/// \brief Quotient
/// \anchor expr-quot
/// \details
/// Quotient of x:
///   1. [ ] |-> [x, d] |-> x // d
///   2. [d] |-> [x]    |-> x // d\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Quot> const Quot;

/// \brief Bitwise not
/// \anchor expr-b-not
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::BitNot> const BitNot;

/// \brief Bitwise and
/// \anchor expr-b-and
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::BitAnd> const BitAnd;

/// \brief Bitwise or
/// \anchor expr-b-or
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::BitOr> const BitOr;

/// \brief Bitwise xor
/// \anchor expr-b-xor
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::BitXor> const BitXor;

/// \brief Bitwise left shift
/// \anchor expr-b-lshift
/// \details
/// 1. [ ] |-> [x, s] |-> x << s
/// 2. [s] |-> [x]    |-> x << s\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::BitLshift> const BitLshift;

/// \brief Bitwise right shift
/// \anchor expr-b-rshift
/// \details
/// 1. [ ] |-> [x, s] |-> x >> s
/// 2. [s] |-> [x]    |-> x >> s\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::BitRshift> const BitRshift;

/// \brief Is equal
/// \anchor expr-eq
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Eq> const Eq;

/// \brief Not equal
/// \anchor expr-ne
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Ne> const Ne;

/// \brief Lesser than
/// \anchor expr-lt
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Lt> const Lt;

/// \brief Lesser or equal
/// \anchor expr-le
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Le> const Le;

/// \brief Greater than
/// \anchor expr-gt
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Gt> const Gt;

/// \brief Greater or equal
/// \anchor expr-ge
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Ge> const Ge;

/// \brief Floating point approximately equal
/// \anchor expr-approx
/// \details
/// Based on numpy.isclose: abs(x - ref) <= (atol + rtol * abs(ref))
/// 
/// Rhs parameters:
///   ref: reference value
///   rtol: relative tolerance, default = 1e-05
///   atol: absolute tolerance, default = 1e-08
/// 
/// Rhs dynamic evaluation:
///   1. ref                -> [ref, default, default]
///   2. [ref]              -> [ref, default, default]
///   3. [ref, rtol]        -> [ref, rtol   , default]
///   4. [ref, rtol, atol]  -> [ref, rtol   , atol   ]\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Approx> const Approx;
/// \brief Alias for Approx
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Approx> const Near;

/// \brief Set union
/// \anchor expr-union
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Union> const Union;

/// \brief Set intersection
/// \anchor expr-intersect
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Intersect> const Intersect;

/// \brief Set difference
/// \anchor expr-set-diff
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Diff> const Diff;

/// \brief Equal as set
/// \anchor expr-set-eq
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::SetEq> const SetEq;

/// \brief Is subset
/// \anchor expr-subset
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Subset> const Subset;

/// \brief Is superset
/// \anchor expr-superset
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Superset> const Superset;

/// \brief Is proper subset
/// \anchor expr-p-subset
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::ProperSubset> const ProperSubset;

/// \brief Is proper superset
/// \anchor expr-p-superset
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::ProperSuperset> const ProperSuperset;

/// \brief Element is in
/// \anchor expr-in
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::In> const In;

/// \brief Element is not in
/// \anchor expr-not-in
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::NotIn> const NotIn;

/// \brief Contains element
/// \anchor expr-ni
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Ni> const Ni;
/// \brief Alias for Ni
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Ni> const Contains;

/// \brief Not contains element
/// \anchor expr-not-ni
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::NotNi> const NotNi;

/// \brief Predicate on boolean transform (aka truthy)
/// \anchor expr-bool
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Bool> const Bool;

/// \brief Predicate on boolean transform (aka falsy)
/// \anchor expr-nil
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Nil> const Nil;

/// \brief Logical complement
/// \anchor expr-not
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Not> const Not;

/// \brief Logical and
/// \anchor expr-and
/// \details
/// Generic behavior:
///   if first operand is truthy, returns second operand, otherwise first\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::And> const And;

/// \brief Logical or
/// \anchor expr-or
/// \details
/// Generic behavior:
///   if first operand is truthy, returns first operand, second otherwise\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Or> const Or;

/// \brief Identity function
/// \anchor expr-id
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Id> const Id;

/// \brief Transpose multidimensional list, turning rows into columns
/// \anchor expr-transp
/// \details
/// May be used to zip sequences of equal length.\see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Transp> const Transp;

/// \brief Cartesian product
/// \anchor expr-cartesian
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Cartesian> const Cartesian;

/// \brief Reverse sequence
/// \anchor expr-reverse
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Reverse> const Reverse;

/// \brief Filter unique elements
/// \anchor expr-uniques
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Uniques> const Uniques;

/// \brief Extract key-value pairs from object
/// \anchor expr-items
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Items> const Items;

/// \brief Extract keys from object
/// \anchor expr-keys
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Keys> const Keys;

/// \brief Extract values from object
/// \anchor expr-values
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Values> const Values;

/// \brief Enumerate sequence
/// \anchor expr-enumerate
/// \details
/// Enumerate sequence with index.\see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Enumerate> const Enumerate;

/// \brief Flatten nested list
/// \anchor expr-flatten
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Flatten> const Flatten;

/// \brief Put argument into a list
/// \anchor expr-to-list
/// \details
/// Equivalent to `At([""])`\see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::ToList> const ToList;

/// \brief Generate range of numbers
/// \anchor expr-arange
/// \details
/// Return evenly spaced values within a given interval.
/// 
/// Parameters:
///   1. start: start value
///   2. stop: stop value
///   3. step: step value
/// 
/// Parameters dynamic evaluation:
///   1. stop: int            -> [0, stop, 1]
///   2. [start, stop]        -> [start, stop, 1]
///   3. [start, stop, step]  -> [start, stop, step]\see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Arange> const Arange;

/// \brief Parse string as json
/// \anchor expr-parse
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Parse> const Parse;

/// \brief Serialize json as string
/// \anchor expr-serialize
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Serialize> const Serialize;
/// \brief Alias for Serialize
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Serialize> const Str;

/// \brief Regular expression match
/// \anchor expr-re
/// \details
/// If input is not a string, match it's serialized form.\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Re> const Re;
/// \brief Alias for Re
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Re> const Regex;

/// \brief Format string with given parameter list
/// \anchor expr-format
/// \details
/// \see \ref variadic-syntactic-forms "Variadic Syntatic Forms"
extern dsl::SignatureVariadic<::zmbt::dsl::Keyword::Format> const Format;
/// \brief Alias for Format
extern dsl::SignatureVariadic<::zmbt::dsl::Keyword::Format> const Fmt;

/// \brief Set cardinality (uniques count)
/// \anchor expr-card
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Card> const Card;

/// \brief Sequence size
/// \anchor expr-size
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Size> const Size;

/// \brief Summation reduction
/// \anchor expr-sum
/// \details
/// Equivalent to Reduce(Add)\see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Sum> const Sum;

/// \brief Multiplication reduction
/// \anchor expr-prod
/// \details
/// Equivalent to Reduce(Mul)\see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Prod> const Prod;

/// \brief Arythmetic average
/// \anchor expr-avg
/// \details
/// \see \ref unary-syntactic-forms "Unary Syntatic Forms"
extern dsl::SignatureUnary<::zmbt::dsl::Keyword::Avg> const Avg;

/// \brief Sliding-window iteration
/// \anchor expr-slide
/// \details
/// Sliding window iteration by specified window width.\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Slide> const Slide;

/// \brief Striding iteration
/// \anchor expr-stride
/// \details
/// Striding iteration by specified step width.\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Stride> const Stride;

/// \brief Repeat value in list
/// \anchor expr-repeat
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Repeat> const Repeat;

/// \brief Concatenate sequences
/// \anchor expr-concat
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Concat> const Concat;

/// \brief Push element into a front of sequence
/// \anchor expr-push
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Push> const Push;

/// \brief Transform json value with given query
/// \anchor expr-at
/// \details
/// Query evaluation rules:
///   1. q: int   |-> x: list  |-> x at index q (negative -> reverse)
///   2. q: slice |-> x: list  |-> x[start:stop:step]
///   3. q: str   |-> x: any   |-> x at JSON Pointer q
///   4. q: list  |-> x: any   |-> [x at q1, x at q2, ...]
///   5. {"key": q1, "$q2": q3, ...} |-> x: any |->
///       { "key1": x at q1, "$(x at q2)": x at q3, ...}\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::At> const At;

/// \brief Lookup table function
/// \anchor expr-lookup
/// \details
/// Parametrized at design time with fixed array or object,
/// produces the value at corresponding `At` query given
/// as eval-time argument.
/// Equivalent to `Flip(At(...))`\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Lookup> const Lookup;

/// \brief User-defined constant
/// \anchor expr-c
/// \details
/// Produced expression will return the design-time parameter
/// on evaluation, ignoring input.
/// C(x) is a shorthand for `Id << x` or `And(false)|Or(x)`\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::C> const C;
/// \brief Alias for C
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::C> const Let;

/// \brief Reduce sequence with binary operator
/// \anchor expr-reduce
/// \details
/// To set specific initial value, use composition with Push, e.g.
/// Push(0)|Reduce(Add)
/// 
/// For reverse operation, see Unfold\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Reduce> const Reduce;
/// \brief Alias for Reduce
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Reduce> const Fold;

/// \brief Apply param expr to every element of sequence
/// \anchor expr-map
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Map> const Map;

/// \brief Filter sequence by predicate param
/// \anchor expr-filter
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Filter> const Filter;

/// \brief Count matches by predicate param
/// \anchor expr-count
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Count> const Count;

/// \brief Sort list by key function
/// \anchor expr-sort
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Sort> const Sort;

/// \brief Min value by key function
/// \anchor expr-min
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Min> const Min;

/// \brief Max value by key function
/// \anchor expr-max
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Max> const Max;

/// \brief Min value index by key function
/// \anchor expr-argmin
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Argmin> const Argmin;

/// \brief Max value index by key function
/// \anchor expr-argmax
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Argmax> const Argmax;

/// \brief Apply expr to literal param
/// \anchor expr-apply
/// \details
/// \see \ref ternary-syntactic-forms "Ternary Syntatic Forms"
extern dsl::SignatureTernary<::zmbt::dsl::Keyword::Apply> const Apply;

/// \brief Apply recursion to parameter expr
/// \anchor expr-recur
/// \details
/// \see \ref ternary-syntactic-forms "Ternary Syntatic Forms"
extern dsl::SignatureTernary<::zmbt::dsl::Keyword::Recur> const Recur;

/// \brief Put results of recursive fn call on initial value x into an array
/// \anchor expr-unfold
/// \details
/// \see \ref ternary-syntactic-forms "Ternary Syntatic Forms"
extern dsl::SignatureTernary<::zmbt::dsl::Keyword::Unfold> const Unfold;

/// \brief !not implemented! bind design-time parameters
/// \anchor expr-bind
/// \details
/// \see \ref variadic-syntactic-forms "Variadic Syntatic Forms"
extern dsl::SignatureVariadic<::zmbt::dsl::Keyword::Bind> const Bind;

/// \brief Match any predicate
/// \anchor expr-any
/// \details
/// \see \ref variadic-syntactic-forms "Variadic Syntatic Forms"
extern dsl::SignatureVariadic<::zmbt::dsl::Keyword::Any> const Any;

/// \brief Match all predicates
/// \anchor expr-all
/// \details
/// \see \ref variadic-syntactic-forms "Variadic Syntatic Forms"
extern dsl::SignatureVariadic<::zmbt::dsl::Keyword::All> const All;

/// \brief Saturate matches in order
/// \anchor expr-saturate
/// \details
/// \see \ref variadic-syntactic-forms "Variadic Syntatic Forms"
extern dsl::SignatureVariadic<::zmbt::dsl::Keyword::Saturate> const Saturate;

/// \brief Compose functions
/// \anchor expr-compose
/// \details
/// \see \ref variadic-syntactic-forms "Variadic Syntatic Forms"
extern dsl::SignatureVariadic<::zmbt::dsl::Keyword::Compose> const Compose;

/// \brief Pack results from enveloped functions into an array
/// \anchor expr-pack
/// \details
/// Allows to combine different properties in a single expression\see \ref variadic-syntactic-forms "Variadic Syntatic Forms"
extern dsl::SignatureVariadic<::zmbt::dsl::Keyword::Pack> const Pack;

/// \brief Flips design-time and eval-time parameters for enveloped expression.
/// \anchor expr-flip
/// \details
/// Useful for binding lhs operands to non-commutative operators.
/// Unlike Haskell's flip, won't change the order or eval-time parameters
/// - for that case use the Reverse keyword instead.\see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Flip> const Flip;

/// \brief Return x if not null, else return default value
/// \anchor expr-default
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Default> const Default;

/// \brief Evaluate enveloped function and return result or null if it throws
/// \anchor expr-try
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::Try> const Try;

/// \brief Evaluate enveloped function and return result or error info if it throws
/// \anchor expr-try-catch
/// \details
/// \see \ref binary-syntactic-forms "Binary Syntatic Forms"
extern dsl::SignatureBinary<::zmbt::dsl::Keyword::TryCatch> const TryCatch;

} // namespace expr
} // namespace zmbt

#endif // ZMBT_MAPPING_EXPRESSION_HPP_
