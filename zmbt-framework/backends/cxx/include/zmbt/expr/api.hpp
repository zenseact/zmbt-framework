/**
 * \file
 * \copyright (c) Copyright 2024-2025 Zenseact AB
 * \license SPDX-License-Identifier: Apache-2.0
 *
 * \details Autogenerated file - do not change!
 *
 * app: codegen.expr
 * template: codegen/expr/templates/zmbt-framework/backends/cxx/include/zmbt/expr/api.hpp
 *
 * How to update:
 * 1. Update the template
 * 2. Run `python -m codegen` in the project root
 * 3. Commit changes
 */

#ifndef ZMBT_EXPR_EXPRESSION_API_HPP_
#define ZMBT_EXPR_EXPRESSION_API_HPP_

#include "api_signatures.hpp"

namespace zmbt {
namespace expr {


/// \brief No operation
/// \details
/// Returns true without input validation.
/// Used in place of matchers for uninteresting signals.
extern lang::SignatureConst<::zmbt::lang::Keyword::Noop> const Noop;
/// \brief Alias for Noop
extern lang::SignatureConst<::zmbt::lang::Keyword::Noop> const _;

/// \brief Null value
extern lang::SignatureConst<::zmbt::lang::Keyword::Null> const Null;

/// \brief Logical true
extern lang::SignatureConst<::zmbt::lang::Keyword::True> const True;

/// \brief Logical false
extern lang::SignatureConst<::zmbt::lang::Keyword::False> const False;

/// \brief Pi constant
extern lang::SignatureConst<::zmbt::lang::Keyword::Pi> const Pi;

/// \brief Euler's number
extern lang::SignatureConst<::zmbt::lang::Keyword::E> const E;

/// \brief Infinity
extern lang::SignatureConst<::zmbt::lang::Keyword::Inf> const Inf;

/// \brief Machine epsilon
extern lang::SignatureConst<::zmbt::lang::Keyword::Eps> const Eps;

/// \brief Not a number
extern lang::SignatureConst<::zmbt::lang::Keyword::NaN> const NaN;

/// \brief Thread id
/// \details
/// Not really a constant, but useful for
/// branching the test input conditions.
extern lang::SignatureConst<::zmbt::lang::Keyword::Thread> const Thread;

/// \brief Sinus function
extern lang::SignatureUnary<::zmbt::lang::Keyword::Sin> const Sin;

/// \brief Cosinus function
extern lang::SignatureUnary<::zmbt::lang::Keyword::Cos> const Cos;

/// \brief Tangens function
extern lang::SignatureUnary<::zmbt::lang::Keyword::Tan> const Tan;

/// \brief Arcsin function
extern lang::SignatureUnary<::zmbt::lang::Keyword::Asin> const Asin;

/// \brief Arccos function
extern lang::SignatureUnary<::zmbt::lang::Keyword::Acos> const Acos;

/// \brief Arctan function
extern lang::SignatureUnary<::zmbt::lang::Keyword::Atan> const Atan;

/// \brief Hyperbolic sin
extern lang::SignatureUnary<::zmbt::lang::Keyword::Sinh> const Sinh;

/// \brief Hyperbolic cos
extern lang::SignatureUnary<::zmbt::lang::Keyword::Cosh> const Cosh;

/// \brief Hyperbolic tan
extern lang::SignatureUnary<::zmbt::lang::Keyword::Tanh> const Tanh;

/// \brief Hyperbolic arcsin
extern lang::SignatureUnary<::zmbt::lang::Keyword::Asinh> const Asinh;

/// \brief Hyperbolic arccos
extern lang::SignatureUnary<::zmbt::lang::Keyword::Acosh> const Acosh;

/// \brief Hyperbolic arctan
extern lang::SignatureUnary<::zmbt::lang::Keyword::Atanh> const Atanh;

/// \brief Exponential (e^x)
extern lang::SignatureUnary<::zmbt::lang::Keyword::Exp> const Exp;

/// \brief Error function
extern lang::SignatureUnary<::zmbt::lang::Keyword::Erf> const Erf;

/// \brief Error function complement
extern lang::SignatureUnary<::zmbt::lang::Keyword::Erfc> const Erfc;

/// \brief Gamma function
extern lang::SignatureUnary<::zmbt::lang::Keyword::Gamma> const Gamma;

/// \brief Absolute value
extern lang::SignatureUnary<::zmbt::lang::Keyword::Abs> const Abs;

/// \brief Ceil
extern lang::SignatureUnary<::zmbt::lang::Keyword::Ceil> const Ceil;

/// \brief Floor
extern lang::SignatureUnary<::zmbt::lang::Keyword::Floor> const Floor;

/// \brief Round to nearest integer
/// \details
/// Hint: To round to ndigits precision after the decimal point,
/// use `Mul(ndigits) | Round | Div(ndigits)` combo.
extern lang::SignatureUnary<::zmbt::lang::Keyword::Round> const Round;

/// \brief Square root
extern lang::SignatureUnary<::zmbt::lang::Keyword::Sqrt> const Sqrt;

/// \brief Sign
extern lang::SignatureUnary<::zmbt::lang::Keyword::Sign> const Sign;

/// \brief Negate
extern lang::SignatureUnary<::zmbt::lang::Keyword::Neg> const Neg;

/// \brief Addition
extern lang::SignatureBinary<::zmbt::lang::Keyword::Add> const Add;

/// \brief Subtraction
extern lang::SignatureBinary<::zmbt::lang::Keyword::Sub> const Sub;

/// \brief Multiplication
extern lang::SignatureBinary<::zmbt::lang::Keyword::Mul> const Mul;

/// \brief Division
/// \details
/// 1. $[ ] \mapsto [x, y] \mapsto x / y$
/// 2. $[y] \mapsto [x]    \mapsto x / y$
extern lang::SignatureBinary<::zmbt::lang::Keyword::Div> const Div;

/// \brief To power
/// \details
/// X to power p
///   1. $[ ] \mapsto [x, p] \mapsto x^p$
///   2. $[p] \mapsto [x]    \mapsto x^p$
extern lang::SignatureBinary<::zmbt::lang::Keyword::Pow> const Pow;

/// \brief Logarithm
/// \details
/// Logarithm with base b:
///   1. $[ ] \mapsto [x, b] \mapsto log_b(x)$
///   2. $[b] \mapsto [x]    \mapsto log_b(x)$
extern lang::SignatureBinary<::zmbt::lang::Keyword::Log> const Log;

/// \brief Modulo
/// \details
/// Modulo of x:
///   1. $[ ] \mapsto [x, m] \mapsto x % m$
///   2. $[m] \mapsto [x]    \mapsto x % m$
extern lang::SignatureBinary<::zmbt::lang::Keyword::Mod> const Mod;

/// \brief Quotient
/// \details
/// Quotient of x:
///   1. $[ ] \mapsto [x, d] \mapsto x // d$
///   2. $[d] \mapsto [x]    \mapsto x // d$
extern lang::SignatureBinary<::zmbt::lang::Keyword::Quot> const Quot;

/// \brief Bitwise not
extern lang::SignatureUnary<::zmbt::lang::Keyword::BitNot> const BitNot;

/// \brief Bitwise and
extern lang::SignatureBinary<::zmbt::lang::Keyword::BitAnd> const BitAnd;

/// \brief Bitwise or
extern lang::SignatureBinary<::zmbt::lang::Keyword::BitOr> const BitOr;

/// \brief Bitwise xor
extern lang::SignatureBinary<::zmbt::lang::Keyword::BitXor> const BitXor;

/// \brief Bitwise left shift
/// \details
/// 1. $[ ] \mapsto [x, s] \mapsto x \texttt{ << } s$
/// 2. $[s] \mapsto [x]    \mapsto x \texttt{ << } s$
extern lang::SignatureBinary<::zmbt::lang::Keyword::Lshift> const Lshift;

/// \brief Bitwise right shift
/// \details
/// 1. $[ ] ↦ [x, s] ↦ x \texttt{ >> } s$
/// 2. $[s] ↦ [x]    ↦ x \texttt{ >> } s$
extern lang::SignatureBinary<::zmbt::lang::Keyword::Rshift> const Rshift;

/// \brief Is equal
extern lang::SignatureBinary<::zmbt::lang::Keyword::Eq> const Eq;

/// \brief Not equal
extern lang::SignatureBinary<::zmbt::lang::Keyword::Ne> const Ne;

/// \brief Lesser than
extern lang::SignatureBinary<::zmbt::lang::Keyword::Lt> const Lt;

/// \brief Lesser or equal
extern lang::SignatureBinary<::zmbt::lang::Keyword::Le> const Le;

/// \brief Greater than
extern lang::SignatureBinary<::zmbt::lang::Keyword::Gt> const Gt;

/// \brief Greater or equal
extern lang::SignatureBinary<::zmbt::lang::Keyword::Ge> const Ge;

/// \brief Floating point approximately equal
/// \details
/// Based on numpy.isclose:
///   abs(x - ref) <= (atol + rtol * abs(ref))
/// 
/// Rhs parameters:
///   ref: reference value
///   rtol: relative tolerance, default = 1e-05
///   atol: absolute tolerance, default = 1e-08
/// 
/// Rhs dynamic evaluation:
///   1. ref                -> [ref, default, default]
///   2. [ref]              -> [ref, default, default]
///   3. [ref, rtol]        -> [ref, rtol   , default]
///   4. [ref, rtol, atol]  -> [ref, rtol   , atol   ]
extern lang::SignatureBinary<::zmbt::lang::Keyword::Near> const Near;
/// \brief Alias for Near
extern lang::SignatureBinary<::zmbt::lang::Keyword::Near> const Approx;

/// \brief Set union
extern lang::SignatureBinary<::zmbt::lang::Keyword::Union> const Union;

/// \brief Set intersection
extern lang::SignatureBinary<::zmbt::lang::Keyword::Intersect> const Intersect;

/// \brief Set difference
extern lang::SignatureBinary<::zmbt::lang::Keyword::Diff> const Diff;

/// \brief Equal as set
extern lang::SignatureBinary<::zmbt::lang::Keyword::SetEq> const SetEq;

/// \brief Is subset
extern lang::SignatureBinary<::zmbt::lang::Keyword::Subset> const Subset;

/// \brief Is superset
extern lang::SignatureBinary<::zmbt::lang::Keyword::Superset> const Superset;

/// \brief Is proper subset
extern lang::SignatureBinary<::zmbt::lang::Keyword::PSubset> const PSubset;

/// \brief Is proper superset
extern lang::SignatureBinary<::zmbt::lang::Keyword::PSuperset> const PSuperset;

/// \brief Element is in
extern lang::SignatureBinary<::zmbt::lang::Keyword::In> const In;

/// \brief Element is not in
extern lang::SignatureBinary<::zmbt::lang::Keyword::NotIn> const NotIn;

/// \brief Contains element
extern lang::SignatureBinary<::zmbt::lang::Keyword::Ni> const Ni;
/// \brief Alias for Ni
extern lang::SignatureBinary<::zmbt::lang::Keyword::Ni> const Contains;

/// \brief Not contains element
extern lang::SignatureBinary<::zmbt::lang::Keyword::NotNi> const NotNi;

/// \brief Predicate on boolean transform (aka truthy)
extern lang::SignatureUnary<::zmbt::lang::Keyword::Bool> const Bool;
/// \brief Alias for Bool
extern lang::SignatureUnary<::zmbt::lang::Keyword::Bool> const Truthy;

/// \brief Logical complement
extern lang::SignatureUnary<::zmbt::lang::Keyword::Not> const Not;
/// \brief Alias for Not
extern lang::SignatureUnary<::zmbt::lang::Keyword::Not> const Falsy;
/// \brief Alias for Not
extern lang::SignatureUnary<::zmbt::lang::Keyword::Not> const Nil;

/// \brief Logical and
/// \details
/// Generic behavior:
///   if first operand is truthy,
///   returns second operand, otherwise first
extern lang::SignatureBinary<::zmbt::lang::Keyword::And> const And;

/// \brief Logical or
/// \details
/// Generic behavior:
///   if first operand is truthy,
///   returns first operand, second otherwise
extern lang::SignatureBinary<::zmbt::lang::Keyword::Or> const Or;

/// \brief Identity function
extern lang::SignatureUnary<::zmbt::lang::Keyword::Id> const Id;

/// \brief Transpose multidimensional list, turning rows into columns
/// \details
/// May be used to zip sequences of equal length.
extern lang::SignatureUnary<::zmbt::lang::Keyword::Transp> const Transp;

/// \brief Cartesian product
extern lang::SignatureUnary<::zmbt::lang::Keyword::Cartesian> const Cartesian;

/// \brief Reverse sequence
extern lang::SignatureUnary<::zmbt::lang::Keyword::Reverse> const Reverse;

/// \brief Filter unique elements
extern lang::SignatureUnary<::zmbt::lang::Keyword::Uniques> const Uniques;

/// \brief Extract key-value pairs from object
extern lang::SignatureUnary<::zmbt::lang::Keyword::Items> const Items;

/// \brief Extract keys from object
extern lang::SignatureUnary<::zmbt::lang::Keyword::Keys> const Keys;

/// \brief Extract values from object
extern lang::SignatureUnary<::zmbt::lang::Keyword::Values> const Values;

/// \brief Enumerate sequence
/// \details
/// Enumerate sequence with index.
extern lang::SignatureUnary<::zmbt::lang::Keyword::Enumerate> const Enumerate;

/// \brief Flatten nested list
extern lang::SignatureUnary<::zmbt::lang::Keyword::Flatten> const Flatten;

/// \brief Put argument into a list
/// \details
/// Equivalent to At([""])
extern lang::SignatureUnary<::zmbt::lang::Keyword::ToList> const ToList;

/// \brief Generate range of numbers
/// \details
/// Return evenly spaced values within a given interval.
/// 
/// Parameters:
///   1. start: start value
///   2. stop: stop value
///   3. step: step value
/// 
/// Parameters dynamic evaluation:
///   1. stop: int            -> [0, stop, 1]
///   2. [start, stop]        -> [start, stop, 1]
///   3. [start, stop, step]  -> [start, stop, step]
extern lang::SignatureUnary<::zmbt::lang::Keyword::Arange> const Arange;

/// \brief Parse string as json
extern lang::SignatureUnary<::zmbt::lang::Keyword::Parse> const Parse;

/// \brief Serialize json as string
extern lang::SignatureUnary<::zmbt::lang::Keyword::Str> const Str;
/// \brief Alias for Str
extern lang::SignatureUnary<::zmbt::lang::Keyword::Str> const Serialize;

/// \brief Regular expression match
/// \details
/// If input is not a string, match it's serialized form.
extern lang::SignatureBinary<::zmbt::lang::Keyword::Re> const Re;
/// \brief Alias for Re
extern lang::SignatureBinary<::zmbt::lang::Keyword::Re> const Regex;

/// \brief Format string with the given parameter list.
/// \details
/// Constant expressions are supported for the token list,
/// s.t. "%s" | Fmt(Pi)  produces "3.141592653589793E0"
extern lang::SignatureVariadic<::zmbt::lang::Keyword::Fmt> const Fmt;
/// \brief Alias for Fmt
extern lang::SignatureVariadic<::zmbt::lang::Keyword::Fmt> const Format;

/// \brief Set cardinality (uniques count)
extern lang::SignatureUnary<::zmbt::lang::Keyword::Card> const Card;

/// \brief Sequence size
extern lang::SignatureUnary<::zmbt::lang::Keyword::Size> const Size;

/// \brief Summation reduction
/// \details
/// Equivalent to Reduce(Add)
extern lang::SignatureUnary<::zmbt::lang::Keyword::Sum> const Sum;

/// \brief Multiplication reduction
/// \details
/// Equivalent to Reduce(Mul)
extern lang::SignatureUnary<::zmbt::lang::Keyword::Prod> const Prod;

/// \brief Arythmetic average
extern lang::SignatureUnary<::zmbt::lang::Keyword::Avg> const Avg;

/// \brief Sliding-window iteration
/// \details
/// Sliding window iteration by specified window width.
extern lang::SignatureBinary<::zmbt::lang::Keyword::Slide> const Slide;

/// \brief Striding iteration
/// \details
/// Striding iteration by specified step width.
/// Reminder subsequence smaller then step width is discarded.
extern lang::SignatureBinary<::zmbt::lang::Keyword::Stride> const Stride;

/// \brief Split into chunks of specified max width
/// \details
/// Similar to Stride, but includes the last subsequence
/// smaller then step width.
extern lang::SignatureBinary<::zmbt::lang::Keyword::Chunks> const Chunks;

/// \brief Repeat value in list
extern lang::SignatureBinary<::zmbt::lang::Keyword::Repeat> const Repeat;

/// \brief Concatenate sequences
extern lang::SignatureBinary<::zmbt::lang::Keyword::Cat> const Cat;
/// \brief Alias for Cat
extern lang::SignatureBinary<::zmbt::lang::Keyword::Cat> const Concat;

/// \brief Push element into a front of sequence
extern lang::SignatureBinary<::zmbt::lang::Keyword::Push> const Push;

/// \brief Transform json value with given query
/// \details
/// Query evaluation rules:
/// 
///   1. Structure index (negative resolves as reverse): $q: int   \mapsto x: list  \mapsto x_q$
///   2. Array slice: $q: slice \mapsto x: list  \mapsto x[start:stop:step]$
///   3. JSON Pointer: $q: str   \mapsto x: any   \mapsto x_q$
///   4. Array pack: $q: list  \mapsto x: any   \mapsto [x_{q_1}, x_{q_2}, ...]$
///   5. Object pack:
///     $\{key: q_1, \$q_2: q_3, ...\} \mapsto x: any \mapsto \{ key: x_{q_1}, q_2: x_{q_3}, ...\}$
/// 
///   Structure index is evaluated as array index or as key-value pair index for objects
///   on order-preserving backends.
/// 
///   Result is null if requested element not found.
extern lang::SignatureBinary<::zmbt::lang::Keyword::At> const At;

/// \brief Delete elements from structure by given query
/// \details
/// Possible queries:
///   1. Structure index (negative resolves as reverse)
///   2. JSON Pointer
///   3. List of queries
/// 
/// Structure index is evaluated as array index or as key-value pair index for objects
///   on order-preserving backends.
/// When deleting an object element, resulting items order may change.
extern lang::SignatureBinary<::zmbt::lang::Keyword::Del> const Del;
/// \brief Alias for Del
extern lang::SignatureBinary<::zmbt::lang::Keyword::Del> const Delete;

/// \brief Lookup table function
/// \details
/// Parametrized at design time with fixed array or object,
/// produces the value at corresponding At query given
/// as eval-time argument.
/// Equivalent to Flip(At(...))
extern lang::SignatureBinary<::zmbt::lang::Keyword::Lookup> const Lookup;

/// \brief Quote parameter, similar to lisp quotation.
/// \details
/// Quotation lifts any parameter to constant, s.t.
/// produced expression will return the design-time parameter
/// on evaluation, ignoring input. If evaluable expression
/// is passed, it is returned unevaluated.
/// Unlike plain literals which can be treated
/// as predicate matchers in certain context, Q(x) is always
/// a constant expression discarding input.
/// Flip(Q) is equivalent to Id.
extern lang::SignatureBinary<::zmbt::lang::Keyword::Q> const Q;
/// \brief Alias for Q
extern lang::SignatureBinary<::zmbt::lang::Keyword::Q> const C;
/// \brief Alias for Q
extern lang::SignatureBinary<::zmbt::lang::Keyword::Q> const Const;
/// \brief Alias for Q
extern lang::SignatureBinary<::zmbt::lang::Keyword::Q> const Let;
/// \brief Alias for Q
extern lang::SignatureBinary<::zmbt::lang::Keyword::Q> const Lift;

/// \brief Reserialize decorated type as decorator
extern lang::SignatureCast const Cast;
/// \brief Alias for Cast
extern lang::SignatureCast const Decorate;

/// \brief Reserialize decorator as decorated type
extern lang::SignatureUncast const Uncast;
/// \brief Alias for Uncast
extern lang::SignatureUncast const Undecorate;

/// \brief Reduce sequence with binary operator
/// \details
/// To set a specific initial value, use composition with Push, e.g.
/// `Push(0) | Fold(Add)`
/// 
/// For reverse operation, see Unfold
extern lang::SignatureBinary<::zmbt::lang::Keyword::Fold> const Fold;
/// \brief Alias for Fold
extern lang::SignatureBinary<::zmbt::lang::Keyword::Fold> const Reduce;

/// \brief Apply param expr to every element of sequence
extern lang::SignatureBinary<::zmbt::lang::Keyword::Map> const Map;

/// \brief Filter sequence by predicate param
extern lang::SignatureBinary<::zmbt::lang::Keyword::Filter> const Filter;

/// \brief Count matches by predicate param
extern lang::SignatureBinary<::zmbt::lang::Keyword::Count> const Count;

/// \brief Test predicate for each item in a sequence
/// \details
/// Equivalent to `Count(p | Not) | Eq(0)`
extern lang::SignatureBinary<::zmbt::lang::Keyword::Each> const Each;

/// \brief Sort list by key function
extern lang::SignatureBinary<::zmbt::lang::Keyword::Sort> const Sort;

/// \brief Find the first element that satisfies given predicate
extern lang::SignatureBinary<::zmbt::lang::Keyword::Find> const Find;

/// \brief Find json pointer of the first element that satisfies given predicate
extern lang::SignatureBinary<::zmbt::lang::Keyword::FindPtr> const FindPtr;

/// \brief Find index of the first element that satisfies given predicate
/// \details
/// Similar to FindPtr, but will integer index or nullptr for non-indexable input.
/// Objects are processed as list of key-value pairs.
extern lang::SignatureBinary<::zmbt::lang::Keyword::FindIdx> const FindIdx;

/// \brief Min value by key function
extern lang::SignatureBinary<::zmbt::lang::Keyword::Min> const Min;

/// \brief Max value by key function
extern lang::SignatureBinary<::zmbt::lang::Keyword::Max> const Max;

/// \brief Min value index by key function
extern lang::SignatureBinary<::zmbt::lang::Keyword::Argmin> const Argmin;

/// \brief Max value index by key function
extern lang::SignatureBinary<::zmbt::lang::Keyword::Argmax> const Argmax;

/// \brief Apply recursion to parameter expr and initial value
/// \details
/// Inference rules:
/// 
///   - `n | Recur(x & f)` $\mapsto ◯ⁿ f(x)$, or
///   - `Q(p) | Recur(x₀ & f)` $\mapsto x_k$, where
/// 
///     - $x_{i+1} = f(x_i)$
///     - $p(x_{i}) = \top \quad \forall i \le k$
///     - $p(x_{i+1}) = \bot$ (exit condition)
extern lang::SignatureBinary<::zmbt::lang::Keyword::Recur> const Recur;

/// \brief Put results of recursive fn call on initial value into an array
/// \details
/// 
/// Inference rules:
/// 
///   - `n | Unfold(x & f)`$\mapsto [x_0, x_1, ...,  x_n]$, or
///   - `Q(p) | Unfold(x₀ & f)` $\mapsto [x_0, x_1, ...,  x_k]$, where
/// 
///     - $x_{i+1} = f(x_i)$
///     - $p(x_{i}) = \top \quad \forall i \le k$
///     - $p(x_{i+1}) = \bot$ (exit condition)
extern lang::SignatureBinary<::zmbt::lang::Keyword::Unfold> const Unfold;

/// \brief Bind type-specific operator handler to function
/// \details
/// Expression Op(op, f) instructs f to use op operator on
/// invocation instead of the default generic.
/// 
/// Operator parameter singleton can be referenced with string key
/// or constructed in place using type<T> tag.
/// 
/// This operator handler is propagated downstream to all terminal
/// subexpression in `f`. Result of `f(x)` is also reserialized (undecorated)
/// as operator type, unless f is constant or boolean expression.
extern lang::SignatureOp const Op;
/// \brief Alias for Op
extern lang::SignatureOp const Overload;

/// \brief Bind design-time parameters to function.
extern lang::SignatureBinary<::zmbt::lang::Keyword::Bind> const Bind;

/// \brief Match any predicate
extern lang::SignatureVariadic<::zmbt::lang::Keyword::Any> const Any;

/// \brief Match all predicates
extern lang::SignatureVariadic<::zmbt::lang::Keyword::All> const All;

/// \brief Saturate matches in order
extern lang::SignatureVariadic<::zmbt::lang::Keyword::Saturate> const Saturate;

/// \brief Compose functions
extern lang::SignatureVariadic<::zmbt::lang::Keyword::Compose> const Compose;

/// \brief Pack results from enveloped functions into an array
/// \details
/// Allows to combine different properties in a single expression
extern lang::SignatureVariadic<::zmbt::lang::Keyword::Fork> const Fork;

/// \brief Flips design-time and eval-time parameters.
/// \details
/// Useful for binding lhs operands to non-commutative
/// operators. Unlike Haskell's flip, won't change the
/// order or eval-time parameters - for that case use
/// the Reverse keyword instead.
extern lang::SignatureBinary<::zmbt::lang::Keyword::Flip> const Flip;

/// \brief Evaluate function and print evaluation log to stderr
extern lang::SignatureDbg const Dbg;
/// \brief Alias for Dbg
extern lang::SignatureDbg const Debug;

/// \brief Flip designtime and run-time parameters, evaluating input as expression
extern lang::SignatureBinary<::zmbt::lang::Keyword::Eval> const Eval;

/// \brief Evaluate function and return result or null if it returns error
extern lang::SignatureBinary<::zmbt::lang::Keyword::Try> const Try;

/// \brief Introspect expression keyword.
extern lang::SignatureUnary<::zmbt::lang::Keyword::Kwrd> const Kwrd;

/// \brief Introspect expression parameters.
extern lang::SignatureUnary<::zmbt::lang::Keyword::Prms> const Prms;
/// \brief Alias for Prms
extern lang::SignatureUnary<::zmbt::lang::Keyword::Prms> const Parameters;

/// \brief Return x if not null, else return default value
extern lang::SignatureBinary<::zmbt::lang::Keyword::D> const D;
/// \brief Alias for D
extern lang::SignatureBinary<::zmbt::lang::Keyword::D> const Default;

/// \brief Error object
/// \details
/// Error object (work in progress)
extern lang::SignatureErr const Err;
/// \brief Alias for Err
extern lang::SignatureErr const Error;

} // namespace expr
} // namespace zmbt

#endif // ZMBT_MAPPING_EXPRESSION_HPP_
